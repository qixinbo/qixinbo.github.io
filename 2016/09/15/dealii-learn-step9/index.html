<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"qixinbo.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="引子 本例将要完成以下目标：   * 求解对流方程$\beta \cdot \nabla u &#x3D; f$  * 使用多线程求解  * 设计一个简单的细化准则  方程离散 对流方程中$\beta$是一个描述对流方向和速度的矢量场，可能与空间位置相关，$f$是源项，$u$是解。这个方程求解的物理过程可以是浓度u在给定流场下的传输，没有扩散过程，但有源。 明显地，在入流侧，上述方程需要在边界上获得补充：">
<meta property="og:type" content="article">
<meta property="og:title" content="求解偏微分方程开源有限元软件deal.II学习--Step 9">
<meta property="og:url" content="http://qixinbo.github.io/2016/09/15/dealii-learn-step9/index.html">
<meta property="og:site_name" content="数字旗手">
<meta property="og:description" content="引子 本例将要完成以下目标：   * 求解对流方程$\beta \cdot \nabla u &#x3D; f$  * 使用多线程求解  * 设计一个简单的细化准则  方程离散 对流方程中$\beta$是一个描述对流方向和速度的矢量场，可能与空间位置相关，$f$是源项，$u$是解。这个方程求解的物理过程可以是浓度u在给定流场下的传输，没有扩散过程，但有源。 明显地，在入流侧，上述方程需要在边界上获得补充：">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjk098ejhj30mb0m0aii.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjk0jwpe3j30qx0k5wkl.jpg">
<meta property="article:published_time" content="2016-09-14T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-26T06:51:29.651Z">
<meta property="article:author" content="Xin-Bo Qi(亓欣波)">
<meta property="article:tag" content="deal.II">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjk098ejhj30mb0m0aii.jpg">

<link rel="canonical" href="http://qixinbo.github.io/2016/09/15/dealii-learn-step9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>求解偏微分方程开源有限元软件deal.II学习--Step 9 | 数字旗手</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="数字旗手" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">数字旗手</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">电气化、自动化、数字化、智能化、智慧化</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-scholar">

    <a href="/scholar/" rel="section"><i class="fa fa-chart-bar fa-fw"></i>scholar</a>

  </li>
        <li class="menu-item menu-item-sources">

    <a href="/sources/" rel="section"><i class="fa fa-rss fa-fw"></i>sources</a>

  </li>
        <li class="menu-item menu-item-gallery">

    <a href="/gallery/" rel="section"><i class="fa fa-file-image fa-fw"></i>gallery</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404.html" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2016/09/15/dealii-learn-step9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Digitize everything to realize Digitalization!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="数字旗手">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          求解偏微分方程开源有限元软件deal.II学习--Step 9
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-09-15 00:00:00" itemprop="dateCreated datePublished" datetime="2016-09-15T00:00:00+08:00">2016-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-26 14:51:29" itemprop="dateModified" datetime="2021-03-26T14:51:29+08:00">2021-03-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/simulation/" itemprop="url" rel="index"><span itemprop="name">simulation</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2016/09/15/dealii-learn-step9/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/09/15/dealii-learn-step9/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>本例将要完成以下目标：</p>
<ul>
<li>求解对流方程$\beta \cdot \nabla u = f$</li>
<li>使用多线程求解</li>
<li>设计一个简单的细化准则</li>
</ul>
<h2 id="方程离散"><a href="#方程离散" class="headerlink" title="方程离散"></a>方程离散</h2><p>对流方程中$\beta$是一个描述对流方向和速度的矢量场，可能与空间位置相关，$f$是源项，$u$是解。这个方程求解的物理过程可以是浓度u在给定流场下的传输，没有扩散过程，但有源。<br>明显地，在入流侧，上述方程需要在边界上获得补充：</p>
<script type="math/tex; mode=display">
u = g \qquad\qquad \mathrm{on}\ \partial\Omega\_-,</script><p>其中，$\Omega_-$代表边界的入流部分，其定义为：</p>
<script type="math/tex; mode=display">
\partial\Omega_-=[{\mathbf x}\in\partial\Omega:\beta\cdot{\mathbf n}({\mathbf x}) < 0],</script><p>其中，${\mathbf n}({\mathbf x})$是点$x$上的外法线。这种定义方式是非常直观的：因为如果外法线是朝外的，那么在入流边界上流动方向就肯定是朝内的。而且，数学理论要求不能在外流边界上施加任何边界条件。在下面的弱形式中也可以看出，确实是没有对外流边界作任何处理。这里跟Fluent软件中的自由外流出口边界还不同，Fluent中默认其在出流界面上法线通量为0，即出流速度不影响前方的速度，其是由完全外推得到。但这里因为没有应用分部积分，所以也不需要处理外流边界上的速度值，只是在方程两侧显性地加上了入流条件。<br>注意：这个传输方程使用标准的有限元方法是不能稳定求解的。这里使用“流线扩散稳定方法”，测试函数的形式变成$v+\delta\beta\cdot v$，其中$\delta$是一个与局部网格间距$h$有关的参数，通常$\delta=0.1 h$。当网格尺寸为0时，测试函数就回归之前的形式。具体原理可以参见相关书籍和论文。<br>方程的弱形式为：</p>
<script type="math/tex; mode=display">
(\beta \cdot \nabla u\_h, v\_h + \delta \beta\cdot\nabla v\_h)\_\Omega - (\beta\cdot {\mathbf n} u\_h, v\_h)\_{\partial\Omega\_-} = (f, v\_h + \delta \beta\cdot\nabla v\_h)\_\Omega - (\beta\cdot {\mathbf n} g, v\_h)\_{\partial\Omega\_-}.</script><p>Attention！！上式已经加入了边界条件，即右端第二项。而为了满足等式，在左侧也加入了对应的积分项，所以，左侧边界积分项中是未知解，而右端项边界积分中是对应的边界值。<br>那么，其中的刚度矩阵就是：</p>
<script type="math/tex; mode=display">
a\_{ij} = (\beta \cdot \nabla \varphi\_i, \varphi\_j + \delta \beta\cdot\nabla \varphi\_j)\_\Omega - (\beta\cdot {\mathbf n} \varphi\_i, \varphi\_j)\_{\partial\Omega\_-},</script><p>但是这样的话就需要求解这样的方程：</p>
<script type="math/tex; mode=display">
{\mathbf u}^T A = {\mathbf f}^T,</script><p>实际求解时需要转置一下：</p>
<script type="math/tex; mode=display">
A^T{\mathbf u} = {\mathbf f},</script><p>此时如果$A^T=A$还好说，即A是对称矩阵，但此时的问题中的矩阵非对称，所以具体组装矩阵时就要注意元素的位置，为了防止出现需要计算转置这种问题，养成这样一种习惯：每次都把试探函数左乘，而不是右乘，则有：</p>
<script type="math/tex; mode=display">
(v\_h + \delta \beta\cdot\nabla v\_h, \beta \cdot \nabla u\_h)\_\Omega - (\beta\cdot {\mathbf n} v\_h, u\_h)\_{\partial\Omega\_-} = (v\_h + \delta \beta\cdot\nabla v\_h, f)\_\Omega - (\beta\cdot {\mathbf n} v\_h, g)\_{\partial\Omega\_-}</script><p>那么矩阵就变成：</p>
<script type="math/tex; mode=display">
a\_{ij} = (\varphi\_i + \delta \beta \cdot \nabla \varphi\_i, \beta\cdot\nabla \varphi\_j)\_\Omega - (\beta\cdot {\mathbf n} \varphi\_i, \varphi\_j)\_{\partial\Omega\_-},</script><p>对于方程的解，因为矩阵不再是对称正定的，CG算法不再适用，这里采用双共轭梯度稳定算法。<br>方程中的具体数值为：</p>
<script type="math/tex; mode=display">
\begin{equation}
\begin{split}
\Omega &=[-1,1]^d \\\ 
\beta({\mathbf x}) &=
\begin{bmatrix}
2 \\\ 
1+\frac{4}{5}\sin(8\pi x),
\end{bmatrix} \\\ 
f({\mathbf x}) &=
\begin{bmatrix}
\frac {1}{10 s^d} & \mathrm{for}\ |{\mathbf x}-{\mathbf x}\_0|<s, \\\
0                 & \mathrm{else},
\end{bmatrix}
\qquad\qquad {\mathbf x}\_0 = 
\begin{bmatrix}
-\frac{3}{4} \\\
-\frac{3}{4}
\end{bmatrix} \\\
g &=e^{5(1-|{\mathbf x}|^2)} \sin(16\pi|{\mathbf x}|^2)
\end{split}
\end{equation}</script><h2 id="基于任务task并行"><a href="#基于任务task并行" class="headerlink" title="基于任务task并行"></a>基于任务task并行</h2><p>传统的在共享内存机器上的并行是将程序分成多个线程，但这里先讲基于任务的并行。<br>“任务”是程序的独立部分，它们之间或者互相依赖，或者互相不依赖。如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> dof_handler.<span class="built_in">distribute_dofs</span> (fe);</span><br><span class="line"><span class="number">2</span> DoFTools::<span class="built_in">make_hanging_node_constraints</span> (dof_handler, hanging_node_constraints);</span><br><span class="line"><span class="number">3</span> DoFTools::<span class="built_in">make_sparsity_pattern</span> (dof_handler, sparsity_pattern);</span><br><span class="line"><span class="number">4</span> hanging_node_constraints.<span class="built_in">condense</span> (sparsity_pattern);</span><br></pre></td></tr></table></figure><br>上述4个操作每个都需要较大的计算量。但是注意并不是全部都互相依赖：明显地，操作1必须首先运行，操作4也必须最后运行，但2和3没有先后顺序。<br>Attention：这里如果用线程来表现2和3的独立性，就需要开两个线程，然后在每个线程上分别运行2和3。然后等待两个线程完成后，再将两者join起来：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dof_handler.<span class="built_in">distribute_dofs</span> (fe);</span><br><span class="line">Threads::Thread&lt;<span class="keyword">void</span>&gt;</span><br><span class="line">thread_1 = Threads::<span class="built_in">new_thread</span> (&amp;DoFTools::make_hanging_node_constraints,</span><br><span class="line">        dof_handler, hanging_node_constraints);</span><br><span class="line">Threads::Thread&lt;<span class="keyword">void</span>&gt;</span><br><span class="line">thread_2 = Threads::<span class="built_in">new_thread</span> (&amp;DoFTools::make_sparsity_pattern,</span><br><span class="line">        dof_handler, sparsity_pattern);</span><br><span class="line">thread_1.<span class="built_in">join</span>();</span><br><span class="line">thread_2.<span class="built_in">join</span>();</span><br><span class="line">hanging_node_constraints.<span class="built_in">condense</span> (sparsity_pattern);</span><br></pre></td></tr></table></figure><br>那么问题来了：如果只有一个处理器核心，或者有两个，但早就有程序的另外部分在用着？这些情况下，上面的代码仍然会开两个线程，但因为没有额外的计算资源，所以程序运行得不会更快，其实反而更慢，因为线程的创建和销毁需要时间，同时系统还需要调度线程给过载的计算资源。<br>一个更好的方法是：识别独立的任务，然后创建一个任务与计算资源相对应的调度程序scheduler，根据它来切换任务。这样，程序将会在每个核心上创建一个线程，然后开始计算，任务将会一直运行到结束，而不是都同时运行，防止突然打断的线程使计算切换到另一个线程上。在此例中，如果有两个核心，2和3将会同时运行，如果只有一个，调度程序将会先计算完2，然后再切换到3上，或者反过来。这种方法在有大量任务时会很有效率，见下面的WorkStream。<br>deal.II自己不建立调度程序，而是使用TBB库函数。<br>如果使用task来并行，则代码为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Threads::Task&lt;<span class="keyword">void</span>&gt;</span><br><span class="line">thread</span><br><span class="line">= Threads::<span class="built_in">new_task</span> (&amp;DoFTools::make_hanging_node_constraints,</span><br><span class="line">        dof_handler,</span><br><span class="line">        hanging_node_constraints);</span><br></pre></td></tr></table></figure><br>这里使用new_task来创建一个任务，跟之前的new_thread类似。<br>如果有很多tasks，得等它们都停下以后才能往后运行，这时每个都写join会很麻烦，可以把它们放进一个group中，一次等待所有的任务：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dof_handler.<span class="built_in">distribute_dofs</span> (fe);</span><br><span class="line">Threads::TaskGroup&lt;<span class="keyword">void</span>&gt; task_group;</span><br><span class="line">task_group += Threads::<span class="built_in">new_task</span> (&amp;DoFTools::make_hanging_node_constraints,</span><br><span class="line">        dof_handler, hanging_node_constraints);</span><br><span class="line">task_group += Threads::<span class="built_in">new_task</span> (&amp;DoFTools::make_sparsity_pattern,</span><br><span class="line">        dof_handler, sparsity_pattern);</span><br><span class="line">task_group.<span class="built_in">join_all</span> ();</span><br><span class="line">hanging_node_constraints.<span class="built_in">condense</span> (sparsity_pattern);</span><br></pre></td></tr></table></figure><br>至于如何调度任务，是在TBB库内部实现的。TBB的文档给出了如何将任务调度给线程，让其执行的详细过程，但没有明确说创建了多少线程。然而，合理猜测是TBB根据核数创建了相同数量的线程，这样就能充分使用整个系统，也没有过多的线程导致频繁的打断。TBB调度程序分配了任务，然后让线程运行它们，线程会充分运行，直到任务结束，而不会中途打断。这意味着缓存永远是时刻使用着的。<br>但是基于任务的并行也有缺点，CPU只在以下两者情况都满足的情况下才满负荷运转：一是有足够数目的任务；二是这些任务确实在做事。比如如果任务数目不够或数目够了但一些任务在闲着，比如等待写入硬盘或等待读入数据，都使CPU没有充分利用。其他情形还有任务在等待外部事件，比如与其他任务的同步等。上述情形下可以创建基于线程的并行，来充分利用CPU。</p>
<h3 id="工作流-Work-Streams"><a href="#工作流-Work-Streams" class="headerlink" title="工作流 Work Streams"></a>工作流 Work Streams</h3><p>在上面例子中，任务的数目大于或等于CPU的核数，以使它们满负荷运行，但也没有太多量，比如只有4个核却有百万个任务。然而也会有百万量级任务的情形，比如将单元上的贡献叠加到整体刚度矩阵中;估计每个单元上的误差指示子等。这些情形可以使用一种称为“WorkStream”的软件设计模式。<br>详情见相应的帮助文档。</p>
<h2 id="基于线程的并行"><a href="#基于线程的并行" class="headerlink" title="基于线程的并行"></a>基于线程的并行</h2><p>有时候基于任务的并行不能发挥CPU的百分百性能，这时可以使用基于线程的并行。比如下面的这个例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> MyClass&lt;dim&gt;::<span class="built_in">output_and_estimate_error</span> () <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    DataOut&lt;dim&gt; data_out;</span><br><span class="line">    data_out.<span class="built_in">attach_dof_handler</span> (dof_handler);</span><br><span class="line">    data_out.<span class="built_in">add_data_vector</span> (solution, <span class="string">&quot;solution&quot;</span>);</span><br><span class="line">    data_out.<span class="built_in">build_patches</span> ();</span><br><span class="line">    <span class="function">std::ofstream <span class="title">output</span> <span class="params">(<span class="string">&quot;solution.vtk&quot;</span>)</span></span>;</span><br><span class="line">    Threads::Thread&lt;<span class="keyword">void</span>&gt;</span><br><span class="line">        thread = Threads::<span class="built_in">new_thread</span> (&amp;DataOut&lt;dim&gt;::write_vtk, data_out, output);</span><br><span class="line">    <span class="function">Vector&lt;<span class="keyword">float</span>&gt; <span class="title">error_per_cell</span> <span class="params">(triangulation.n_active_cells())</span></span>;</span><br><span class="line">    KellyErrorEstimator&lt;dim&gt;::<span class="built_in">estimate</span> (dof_handler,</span><br><span class="line">            QGauss&lt;dim<span class="number">-1</span>&gt;(<span class="number">3</span>),</span><br><span class="line">            <span class="keyword">typename</span> FunctionMap&lt;dim&gt;::<span class="built_in">type</span>(),</span><br><span class="line">            solution,</span><br><span class="line">            estimated_error_per_cell);</span><br><span class="line">    thread.<span class="built_in">join</span> ();</span><br></pre></td></tr></table></figure><br>new_thread新开了一个线程用来输出图片，它跟后面的误差估计并行。这里用线程，是因为往硬盘中写数据不会使得CPU很忙，所以没必要把它做成一个任务。<br>正如上面所说，deal.II使用的是TBB来调度线程，TBB不建议明确地给定线程数目。但是有时候也需要明确指定线程数目，比如在有一个资源管理器的机器上或在获取某些计算资源很费劲的机器上，这时需要限制数目，防止TBB调用过多CPU。还有一种情况是有多个MPI并行任务时，每个任务也只能调用一个子集的计算资源。</p>
<h2 id="细化准则"><a href="#细化准则" class="headerlink" title="细化准则"></a>细化准则</h2><p>之前在有自适应网格的例子中，都是使用了Kelly等人提出的误差指示子，其实际使用的是类似解的二阶导数作为判据。所以应用这个指示子的前提是解有二阶导数。但在有些情况下，比如本例中，解甚至在某些地方没有一阶导数，所以Kelly指示子不再适用。这里提出一种判断梯度的公式。注意到给定两个单元和连结两个单元中心的向量，那么解的梯度可以近似表示为：</p>
<script type="math/tex; mode=display">
\frac{\mathbf y\_{KK'}^T}{|\mathbf y\_{KK'}|} \nabla u \approx \frac{u(K') - u(K)}{|\mathbf y\_{KK'}|},</script><p>那么：</p>
<script type="math/tex; mode=display">
\underbrace{ \left(\sum\_{K'} \frac{\mathbf y\_{KK'} \mathbf y\_{KK'}^T} {|\mathbf y\_{KK'}|^2}\right)}\_{=:Y} \nabla u \approx \sum\_{K'} \frac{\mathbf y\_{KK'}}{|\mathbf y\_{KK'}|} \frac{u(K') - u(K)}{|\mathbf y\_{KK'}|}.</script><p>再推导有：</p>
<script type="math/tex; mode=display">
\nabla u \approx Y^{-1} \left( \sum\_{K'} \frac{\mathbf y\_{KK'}}{|\mathbf y\_{KK'}|} \frac{u(K') - u(K)}{|\mathbf y\_{KK'}|} \right).</script><p>右端用$\nabla_h u(K)$来表示，细化准则则为：</p>
<script type="math/tex; mode=display">
\eta\_K = h^{1+d/2} |\nabla\_h u\_h(K)|,</script><h1 id="程序解析"><a href="#程序解析" class="headerlink" title="程序解析"></a>程序解析</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/quadrature_lib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/function.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/logstream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/vector.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/full_matrix.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/sparse_matrix.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/solver_bicgstab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/precondition.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/constraint_matrix.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/grid_generator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/grid_refinement.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria_accessor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria_iterator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_handler.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_accessor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_tools.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/fe/fe_values.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/vector_tools.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/matrix_tools.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/data_out.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/fe/fe_q.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/grid_out.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>以上是之前提过的一些头文件。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/work_stream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/multithread_info.h&gt;</span></span></span><br></pre></td></tr></table></figure><br>第一个头文件是WorkStream命名空间，包含并行计算时所用的函数和类。第二个头文件是获得电脑的处理器核数，从而确定并行时开多少线程。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/tensor_function.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/error_estimator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure><br>还有一个新头文件是TensorFunction，不同于之前的Function类，它返回的是个张量值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Step9</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> dealii;</span><br></pre></td></tr></table></figure><br>然后就开始具体问题的Step9命名空间定义。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdvectionProblem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">AdvectionProblem</span> ();</span><br><span class="line">        ~<span class="built_in">AdvectionProblem</span> ();</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setup_system</span> <span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><br>上面开始声明问题类。<br>然后开始组装矩阵：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AssemblyScratchData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">AssemblyScratchData</span> (<span class="keyword">const</span> FiniteElement&lt;dim&gt; &amp;fe);</span><br><span class="line">    <span class="built_in">AssemblyScratchData</span> (<span class="keyword">const</span> AssemblyScratchData &amp;scratch_data);</span><br><span class="line">    FEValues&lt;dim&gt; fe_values;</span><br><span class="line">    FEFaceValues&lt;dim&gt; fe_face_values;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AssemblyCopyData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    FullMatrix&lt;<span class="keyword">double</span>&gt; cell_matrix;</span><br><span class="line">    Vector&lt;<span class="keyword">double</span>&gt; cell_rhs;</span><br><span class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assemble_system</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">local_assemble_system</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator &amp;cell,</span></span></span><br><span class="line"><span class="function"><span class="params">        AssemblyScratchData &amp;scratch,</span></span></span><br><span class="line"><span class="function"><span class="params">        AssemblyCopyData &amp;copy_data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_local_to_global</span> <span class="params">(<span class="keyword">const</span> AssemblyCopyData &amp;copy_data)</span></span>;</span><br></pre></td></tr></table></figure><br>组装矩阵时可以很好地应用并行，因为单元矩阵运算可以自己进行，与其他单元无关，只需要在组装时同步就行。其中的ScratchData是临时数据。<br>然后就是之前的一些声明：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">refine_grid</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_results</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> cycle)</span> <span class="keyword">const</span></span>;</span><br><span class="line">Triangulation&lt;dim&gt; triangulation;</span><br><span class="line">DoFHandler&lt;dim&gt; dof_handler;</span><br><span class="line">FE_Q&lt;dim&gt; fe;</span><br><span class="line">ConstraintMatrix hanging_node_constraints;</span><br><span class="line">SparsityPattern sparsity_pattern;</span><br><span class="line">SparseMatrix&lt;<span class="keyword">double</span>&gt; system_matrix;</span><br><span class="line">Vector&lt;<span class="keyword">double</span>&gt; solution;</span><br><span class="line">Vector&lt;<span class="keyword">double</span>&gt; system_rhs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>下面就是声明一个对流场的类：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdvectionField</span> :</span> <span class="keyword">public</span> TensorFunction&lt;<span class="number">1</span>,dim&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">AdvectionField</span> () : TensorFunction&lt;<span class="number">1</span>,dim&gt; () &#123;&#125;</span><br><span class="line">        virtual Tensor&lt;1,dim&gt; value (const Point&lt;dim&gt; &amp;p) const;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">value_list</span> <span class="params">(<span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt; &gt; &amp;points,</span></span></span><br><span class="line"><span class="function"><span class="params">                std::vector&lt;Tensor&lt;<span class="number">1</span>,dim&gt; &gt; &amp;values)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="built_in">DeclException2</span> (ExcDimensionMismatch,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>,</span><br><span class="line">                &lt;&lt; <span class="string">&quot;The vector has size &quot;</span> &lt;&lt; arg1 &lt;&lt; <span class="string">&quot; but should have &quot;</span></span><br><span class="line">                &lt;&lt; arg2 &lt;&lt; <span class="string">&quot; elements.&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这个类明显是个矢量，因为有对应于空间维度数目的分量。可以像以前一样使用Function类，不过这里使用的是描述张量函数的TensorFunction类。这里面也设置了捕捉异常的函数，用来判断两个矢量的大小是否相同。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">Tensor&lt;<span class="number">1</span>,dim&gt;</span><br><span class="line">AdvectionField&lt;dim&gt;::<span class="built_in">value</span> (<span class="keyword">const</span> Point&lt;dim&gt; &amp;p) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Point&lt;dim&gt; value;</span><br><span class="line">    value[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">1</span>; i&lt;dim; ++i)</span><br><span class="line">        value[i] = <span class="number">1</span>+<span class="number">0.8</span>*std::<span class="built_in">sin</span>(<span class="number">8</span>*numbers::PI*p[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">AdvectionField&lt;dim&gt;::<span class="built_in">value_list</span> (<span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt; &gt; &amp;points,</span><br><span class="line">        std::vector&lt;Tensor&lt;<span class="number">1</span>,dim&gt; &gt; &amp;values) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Assert</span> (values.<span class="built_in">size</span>() == points.<span class="built_in">size</span>(),</span><br><span class="line">            <span class="built_in">ExcDimensionMismatch</span> (values.<span class="built_in">size</span>(), points.<span class="built_in">size</span>()));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;points.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        values[i] = AdvectionField&lt;dim&gt;::<span class="built_in">value</span> (points[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以上是value和value_list的具体实现。第二个函数中有矢量的尺寸大小判断，加上这么一个Assert语句能有效防止错误。<br>下面就是描述源项：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RightHandSide</span> :</span> <span class="keyword">public</span> Function&lt;dim&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">RightHandSide</span> () : Function&lt;dim&gt;() &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">value</span> <span class="params">(<span class="keyword">const</span> Point&lt;dim&gt; &amp;p,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">value_list</span> <span class="params">(<span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt; &gt; &amp;points,</span></span></span><br><span class="line"><span class="function"><span class="params">                std::vector&lt;<span class="keyword">double</span>&gt; &amp;values,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> Point&lt;dim&gt; center_point;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">const</span> Point&lt;<span class="number">1</span>&gt; RightHandSide&lt;<span class="number">1</span>&gt;::center_point = Point&lt;<span class="number">1</span>&gt; (<span class="number">-0.75</span>);</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">const</span> Point&lt;<span class="number">2</span>&gt; RightHandSide&lt;<span class="number">2</span>&gt;::center_point = Point&lt;<span class="number">2</span>&gt; (<span class="number">-0.75</span>, <span class="number">-0.75</span>);</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">const</span> Point&lt;<span class="number">3</span>&gt; RightHandSide&lt;<span class="number">3</span>&gt;::center_point = Point&lt;<span class="number">3</span>&gt; (<span class="number">-0.75</span>, <span class="number">-0.75</span>, <span class="number">-0.75</span>);</span><br></pre></td></tr></table></figure><br>从方程中可以看出，源项是围绕在某个源点附近，注意不是原点。这里定义了在不同维度下的源点。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">double</span></span><br><span class="line">RightHandSide&lt;dim&gt;::<span class="built_in">value</span> (<span class="keyword">const</span> Point&lt;dim&gt; &amp;p,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Assert</span> (component == <span class="number">0</span>, <span class="built_in">ExcIndexRange</span> (component, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> diameter = <span class="number">0.1</span>;</span><br><span class="line">    <span class="keyword">return</span> ( (p-center_point).<span class="built_in">norm_square</span>() &lt; diameter*diameter ?</span><br><span class="line">            <span class="number">.1</span>/std::<span class="built_in">pow</span>(diameter,dim) :</span><br><span class="line">            <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">RightHandSide&lt;dim&gt;::<span class="built_in">value_list</span> (<span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt; &gt; &amp;points,</span><br><span class="line">        std::vector&lt;<span class="keyword">double</span>&gt; &amp;values,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Assert</span> (values.<span class="built_in">size</span>() == points.<span class="built_in">size</span>(),</span><br><span class="line">            <span class="built_in">ExcDimensionMismatch</span> (values.<span class="built_in">size</span>(), points.<span class="built_in">size</span>()));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;points.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        values[i] = RightHandSide&lt;dim&gt;::<span class="built_in">value</span> (points[i], component);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以上是具体实现。这里也加入了尺寸判断。<br>然后就是边界值：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundaryValues</span> :</span> <span class="keyword">public</span> Function&lt;dim&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">BoundaryValues</span> () : Function&lt;dim&gt;() &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">value</span> <span class="params">(<span class="keyword">const</span> Point&lt;dim&gt; &amp;p,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">value_list</span> <span class="params">(<span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt; &gt; &amp;points,</span></span></span><br><span class="line"><span class="function"><span class="params">                std::vector&lt;<span class="keyword">double</span>&gt; &amp;values,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">double</span></span><br><span class="line">BoundaryValues&lt;dim&gt;::<span class="built_in">value</span> (<span class="keyword">const</span> Point&lt;dim&gt; &amp;p,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Assert</span> (component == <span class="number">0</span>, <span class="built_in">ExcIndexRange</span> (component, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> sine_term = std::<span class="built_in">sin</span>(<span class="number">16</span>*numbers::PI*std::<span class="built_in">sqrt</span>(p.<span class="built_in">norm_square</span>()));</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> weight = std::<span class="built_in">exp</span>(<span class="number">-5</span>*p.<span class="built_in">norm_square</span>()) / std::<span class="built_in">exp</span>(<span class="number">-5.</span>);</span><br><span class="line">    <span class="keyword">return</span> sine_term * weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">BoundaryValues&lt;dim&gt;::<span class="built_in">value_list</span> (<span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt; &gt; &amp;points,</span><br><span class="line">        std::vector&lt;<span class="keyword">double</span>&gt; &amp;values,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Assert</span> (values.<span class="built_in">size</span>() == points.<span class="built_in">size</span>(),</span><br><span class="line">            <span class="built_in">ExcDimensionMismatch</span> (values.<span class="built_in">size</span>(), points.<span class="built_in">size</span>()));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;points.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        values[i] = BoundaryValues&lt;dim&gt;::<span class="built_in">value</span> (points[i], component);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="梯度估计"><a href="#梯度估计" class="headerlink" title="梯度估计"></a>梯度估计</h2><p>下面开始计算单元上的梯度以及网格尺寸的乘方作为权重，就像引子中所示。这个类是DerivativeApproximation的简化版本，DerivativeApproximatio还能计算高阶的导数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GradientEstimation</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">            <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">estimate</span> <span class="params">(<span class="keyword">const</span> DoFHandler&lt;dim&gt; &amp;dof,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> Vector&lt;<span class="keyword">double</span>&gt; &amp;solution,</span></span></span><br><span class="line"><span class="function"><span class="params">                    Vector&lt;<span class="keyword">float</span>&gt; &amp;error_per_cell)</span></span>;</span><br><span class="line">        <span class="built_in">DeclException2</span> (ExcInvalidVectorLength,</span><br><span class="line">                <span class="keyword">int</span>, <span class="keyword">int</span>,</span><br><span class="line">                &lt;&lt; <span class="string">&quot;Vector has length &quot;</span> &lt;&lt; arg1 &lt;&lt; <span class="string">&quot;, but should have &quot;</span></span><br><span class="line">                &lt;&lt; arg2);</span><br><span class="line">        <span class="built_in">DeclException0</span> (ExcInsufficientDirections);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">EstimateScratchData</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                <span class="built_in">EstimateScratchData</span> (<span class="keyword">const</span> FiniteElement&lt;dim&gt; &amp;fe,</span><br><span class="line">                        <span class="keyword">const</span> Vector&lt;<span class="keyword">double</span>&gt; &amp;solution);</span><br><span class="line">                <span class="built_in">EstimateScratchData</span> (<span class="keyword">const</span> EstimateScratchData &amp;data);</span><br><span class="line">                FEValues&lt;dim&gt; fe_midpoint_value;</span><br><span class="line">                Vector&lt;<span class="keyword">double</span>&gt; solution;</span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">EstimateCopyData</span></span></span><br><span class="line"><span class="class">        &#123;</span>&#125;;</span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">            <span class="keyword">static</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">estimate_cell</span> <span class="params">(<span class="keyword">const</span> SynchronousIterators&lt;std_cxx11::tuple&lt;<span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator,</span></span></span><br><span class="line"><span class="function"><span class="params">                    Vector&lt;<span class="keyword">float</span>&gt;::iterator&gt; &gt; &amp;cell,</span></span></span><br><span class="line"><span class="function"><span class="params">                    EstimateScratchData&lt;dim&gt; &amp;scratch_data,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> EstimateCopyData &amp;copy_data)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这个类有一个静态Public函数estimate来计算误差指示子，还有几个Private函数来做具体的工作。还有两个异常捕获函数，用来捕捉没有相邻单元的单元以及尺寸不对的参数。<br>还有两个事情需要注意：一是该类没有非静态的成员函数或变量，所以它不是一个真正的类，而是命名空间的功能。这里选择类而不是命名空间是因为想要声明私有函数。这也可以同样使用命名空间来实现，但这涉及多文件，这里只有一个文件，所以在此例中不能隐藏函数。二是维度参数没有放在类中，而是放在了函数上，这样不用手动加上维度这个参数，而是编译器能够从DoF等上自动推导。<br>还要讲一下并行策略：之前主类中已经说了，并行时需要定义：一是定义临时和复制对象；二是在单元上进行局部计算；三是将局部对象复制到整体对象中的函数。但是这里做一点改变。具体改变见帮助文档。</p>
<h2 id="主类的实现"><a href="#主类的实现" class="headerlink" title="主类的实现"></a>主类的实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">AdvectionProblem&lt;dim&gt;::<span class="built_in">AdvectionProblem</span> ()</span><br><span class="line">    :</span><br><span class="line">        <span class="built_in">dof_handler</span> (triangulation),</span><br><span class="line">        <span class="built_in">fe</span>(<span class="number">1</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">AdvectionProblem&lt;dim&gt;::~<span class="built_in">AdvectionProblem</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    dof_handler.<span class="built_in">clear</span> ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> AdvectionProblem&lt;dim&gt;::<span class="built_in">setup_system</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    dof_handler.<span class="built_in">distribute_dofs</span> (fe);</span><br><span class="line">    hanging_node_constraints.<span class="built_in">clear</span> ();</span><br><span class="line">    DoFTools::<span class="built_in">make_hanging_node_constraints</span> (dof_handler,</span><br><span class="line">            hanging_node_constraints);</span><br><span class="line">    hanging_node_constraints.<span class="built_in">close</span> ();</span><br><span class="line">    <span class="function">DynamicSparsityPattern <span class="title">dsp</span><span class="params">(dof_handler.n_dofs(), dof_handler.n_dofs())</span></span>;</span><br><span class="line">    DoFTools::<span class="built_in">make_sparsity_pattern</span>(dof_handler,</span><br><span class="line">            dsp,</span><br><span class="line">            hanging_node_constraints,</span><br><span class="line">            / *keep_constrained_dofs = * / <span class="literal">true</span>);</span><br><span class="line">    sparsity_pattern.<span class="built_in">copy_from</span> (dsp);</span><br><span class="line">    system_matrix.<span class="built_in">reinit</span> (sparsity_pattern);</span><br><span class="line">    solution.<span class="built_in">reinit</span> (dof_handler.<span class="built_in">n_dofs</span>());</span><br><span class="line">    system_rhs.<span class="built_in">reinit</span> (dof_handler.<span class="built_in">n_dofs</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是主类的构造函数、析构函数和建立系统，不详述。<br>下面是组装系统的并行策略：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> AdvectionProblem&lt;dim&gt;::<span class="built_in">assemble_system</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    WorkStream::<span class="built_in">run</span>(dof_handler.<span class="built_in">begin_active</span>(),</span><br><span class="line">            dof_handler.<span class="built_in">end</span>(),</span><br><span class="line">            *<span class="keyword">this</span>,</span><br><span class="line">            &amp;AdvectionProblem::local_assemble_system,</span><br><span class="line">            &amp;AdvectionProblem::copy_local_to_global,</span><br><span class="line">            <span class="built_in">AssemblyScratchData</span>(fe),</span><br><span class="line">            <span class="built_in">AssemblyCopyData</span>());</span><br></pre></td></tr></table></figure><br>使用WorkStream来统一调度，能充分利用电脑的线程。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hanging_node_constraints.<span class="built_in">condense</span> (system_matrix);</span><br><span class="line">hanging_node_constraints.<span class="built_in">condense</span> (system_rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>同样也需要消除悬点限制。因为不能分开在单个线程上进行，所以需要统一进行。<br>Attention！！跟之前不同，这里没有施加边界条件，当然这是因为已经把边界条件加在了弱形式中。！<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">AdvectionProblem&lt;dim&gt;::AssemblyScratchData::</span><br><span class="line"><span class="built_in">AssemblyScratchData</span> (<span class="keyword">const</span> FiniteElement&lt;dim&gt; &amp;fe)</span><br><span class="line">    :</span><br><span class="line">        <span class="built_in">fe_values</span> (fe,</span><br><span class="line">                QGauss&lt;dim&gt;(<span class="number">2</span>),</span><br><span class="line">                update_values | update_gradients |</span><br><span class="line">                update_quadrature_points | update_JxW_values),</span><br><span class="line">        <span class="built_in">fe_face_values</span> (fe,</span><br><span class="line">                QGauss&lt;dim<span class="number">-1</span>&gt;(<span class="number">2</span>),</span><br><span class="line">                update_values | update_quadrature_points |</span><br><span class="line">                update_JxW_values | update_normal_vectors)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">AdvectionProblem&lt;dim&gt;::AssemblyScratchData::</span><br><span class="line"><span class="built_in">AssemblyScratchData</span> (<span class="keyword">const</span> AssemblyScratchData &amp;scratch_data)</span><br><span class="line">    :</span><br><span class="line">        <span class="built_in">fe_values</span> (scratch_data.fe_values.<span class="built_in">get_fe</span>(),</span><br><span class="line">                scratch_data.fe_values.<span class="built_in">get_quadrature</span>(),</span><br><span class="line">                update_values | update_gradients |</span><br><span class="line">                update_quadrature_points | update_JxW_values),</span><br><span class="line">        <span class="built_in">fe_face_values</span> (scratch_data.fe_face_values.<span class="built_in">get_fe</span>(),</span><br><span class="line">                scratch_data.fe_face_values.<span class="built_in">get_quadrature</span>(),</span><br><span class="line">                update_values | update_quadrature_points |</span><br><span class="line">                update_JxW_values | update_normal_vectors)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><br>这是并行时用到的临时对象。这些对象包含FEValues和FEFaceValues，其中的flag一定要传递全面。<br>下面就是具体要干的事了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">AdvectionProblem&lt;dim&gt;::</span><br><span class="line"><span class="built_in">local_assemble_system</span> (<span class="keyword">const</span> <span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator &amp;cell,</span><br><span class="line">        AssemblyScratchData &amp;scratch_data,</span><br><span class="line">        AssemblyCopyData &amp;copy_data)</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><br>帮助文档中关于这里有一大段关于效率的问题，没看明白，留坑待填。<br>首先创建描述边界值、右端项和对流场的对象，这里声明为const，以便让编译器进行优化：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AdvectionField&lt;dim&gt; advection_field;</span><br><span class="line"><span class="keyword">const</span> RightHandSide&lt;dim&gt; right_hand_side;</span><br><span class="line"><span class="keyword">const</span> BoundaryValues&lt;dim&gt; boundary_values;</span><br></pre></td></tr></table></figure><br>然后定义一些缩写，防止冗长的描述：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> dofs_per_cell = fe.dofs_per_cell;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> n_q_points = scratch_data.fe_values.<span class="built_in">get_quadrature</span>().<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> n_face_q_points = scratch_data.fe_face_values.<span class="built_in">get_quadrature</span>().<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure><br>初始化单元刚度矩阵和单元右端项和单元自由度的全局标识：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">copy_data.cell_matrix.<span class="built_in">reinit</span> (dofs_per_cell, dofs_per_cell);</span><br><span class="line">copy_data.cell_rhs.<span class="built_in">reinit</span> (dofs_per_cell);</span><br><span class="line">copy_data.local_dof_indices.<span class="built_in">resize</span>(dofs_per_cell);</span><br></pre></td></tr></table></figure><br>还有创建对象来存储单元和边界积分中要用到的右端项、对流方向和边界的值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="keyword">double</span>&gt; <span class="title">rhs_values</span> <span class="params">(n_q_points)</span></span>;</span><br><span class="line">std::vector&lt;Tensor&lt;1,dim&gt; &gt; <span class="built_in">advection_directions</span> (n_q_points);</span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">double</span>&gt; <span class="title">face_boundary_values</span> <span class="params">(n_face_q_points)</span></span>;</span><br><span class="line">std::vector&lt;Tensor&lt;1,dim&gt; &gt; <span class="built_in">face_advection_directions</span> (n_face_q_points);</span><br></pre></td></tr></table></figure><br>初始化FEValues对象：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scratch_data.fe_values.<span class="built_in">reinit</span> (cell);</span><br></pre></td></tr></table></figure><br>得到积分点上右端项和对流方向的值：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">advection_field.<span class="built_in">value_list</span> (scratch_data.fe_values.<span class="built_in">get_quadrature_points</span>(),</span><br><span class="line">        advection_directions);</span><br><span class="line">right_hand_side.<span class="built_in">value_list</span> (scratch_data.fe_values.<span class="built_in">get_quadrature_points</span>(),</span><br><span class="line">        rhs_values);</span><br></pre></td></tr></table></figure><br>设置流线扩散法中参数的值，参见引子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> delta = <span class="number">0.1</span> * cell-&gt;<span class="built_in">diameter</span> ();</span><br></pre></td></tr></table></figure><br>然后计算单元刚度矩阵和右端项：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> q_point=<span class="number">0</span>; q_point&lt;n_q_points; ++q_point)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dofs_per_cell; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j=<span class="number">0</span>; j&lt;dofs_per_cell; ++j)</span><br><span class="line">            copy_data.<span class="built_in">cell_matrix</span>(i,j) += ((advection_directions[q_point] *</span><br><span class="line">                        scratch_data.fe_values.<span class="built_in">shape_grad</span>(j,q_point) *</span><br><span class="line">                        (scratch_data.fe_values.<span class="built_in">shape_value</span>(i,q_point) +</span><br><span class="line">                         delta *</span><br><span class="line">                         (advection_directions[q_point] *</span><br><span class="line">                          scratch_data.fe_values.<span class="built_in">shape_grad</span>(i,q_point)))) *</span><br><span class="line">                    scratch_data.fe_values.<span class="built_in">JxW</span>(q_point));</span><br><span class="line">        copy_data.<span class="built_in">cell_rhs</span>(i) += ((scratch_data.fe_values.<span class="built_in">shape_value</span>(i,q_point) +</span><br><span class="line">                    delta *</span><br><span class="line">                    (advection_directions[q_point] *</span><br><span class="line">                     scratch_data.fe_values.<span class="built_in">shape_grad</span>(i,q_point)) ) *</span><br><span class="line">                rhs_values[q_point] *</span><br><span class="line">                scratch_data.fe_values.<span class="built_in">JxW</span> (q_point));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>Attention！！上面项中没有加入边界项。所以还要检查这个单元的边是否在入流边界上，如果是，那么必须把它的贡献也得叠加上去。注意仅仅是入流边界，所以还得知道积分点的绝对位置，及该点上的流动方向：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> face=<span class="number">0</span>; face&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</span><br><span class="line">    <span class="keyword">if</span> (cell-&gt;<span class="built_in">face</span>(face)-&gt;<span class="built_in">at_boundary</span>())</span><br><span class="line">    &#123;</span><br></pre></td></tr></table></figure><br>如果进入了上面的if，说明该单元的边是在边界上了，然而别忘了初始化FEFaceValues对象，然后获取入流函数的值和流动方向：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scratch_data.fe_face_values.<span class="built_in">reinit</span> (cell, face);</span><br><span class="line">boundary_values.<span class="built_in">value_list</span> (scratch_data.fe_face_values.<span class="built_in">get_quadrature_points</span>(),</span><br><span class="line">        face_boundary_values);</span><br><span class="line">advection_field.<span class="built_in">value_list</span> (scratch_data.fe_face_values.<span class="built_in">get_quadrature_points</span>(),</span><br><span class="line">        face_advection_directions);</span><br></pre></td></tr></table></figure><br>现在遍历所有积分点，判断是否入流边界：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> q_point=<span class="number">0</span>; q_point&lt;n_face_q_points; ++q_point)</span><br><span class="line">    <span class="keyword">if</span> (scratch_data.fe_face_values.<span class="built_in">normal_vector</span>(q_point) *</span><br><span class="line">            face_advection_directions[q_point]</span><br><span class="line">            &lt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><br>如果是入流边界，那么就计算这个边的贡献：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dofs_per_cell; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j=<span class="number">0</span>; j&lt;dofs_per_cell; ++j)</span><br><span class="line">        copy_data.<span class="built_in">cell_matrix</span>(i,j) -= (face_advection_directions[q_point] *</span><br><span class="line">                scratch_data.fe_face_values.<span class="built_in">normal_vector</span>(q_point) *</span><br><span class="line">                scratch_data.fe_face_values.<span class="built_in">shape_value</span>(i,q_point) *</span><br><span class="line">                scratch_data.fe_face_values.<span class="built_in">shape_value</span>(j,q_point) *</span><br><span class="line">                scratch_data.fe_face_values.<span class="built_in">JxW</span>(q_point));</span><br><span class="line">    copy_data.<span class="built_in">cell_rhs</span>(i) -= (face_advection_directions[q_point] *</span><br><span class="line">            scratch_data.fe_face_values.<span class="built_in">normal_vector</span>(q_point) *</span><br><span class="line">            face_boundary_values[q_point] *</span><br><span class="line">            scratch_data.fe_face_values.<span class="built_in">shape_value</span>(i,q_point) *</span><br><span class="line">            scratch_data.fe_face_values.<span class="built_in">JxW</span>(q_point));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>终于到组装了：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cell-&gt;<span class="built_in">get_dof_indices</span> (copy_data.local_dof_indices);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">AdvectionProblem&lt;dim&gt;::<span class="built_in">copy_local_to_global</span> (<span class="keyword">const</span> AssemblyCopyData &amp;copy_data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;copy_data.local_dof_indices.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j=<span class="number">0</span>; j&lt;copy_data.local_dof_indices.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            system_matrix.<span class="built_in">add</span> (copy_data.local_dof_indices[i],</span><br><span class="line">                    copy_data.local_dof_indices[j],</span><br><span class="line">                    copy_data.<span class="built_in">cell_matrix</span>(i,j));</span><br><span class="line">        <span class="built_in">system_rhs</span>(copy_data.local_dof_indices[i]) += copy_data.<span class="built_in">cell_rhs</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>跟之前的差不多。<br>然后就是求解：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> AdvectionProblem&lt;dim&gt;::<span class="built_in">solve</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">SolverControl <span class="title">solver_control</span> <span class="params">(<span class="number">1000</span>, <span class="number">1e-12</span>)</span></span>;</span><br><span class="line">    SolverBicgstab&lt;&gt; <span class="built_in">bicgstab</span> (solver_control);</span><br><span class="line">    PreconditionJacobi&lt;&gt; preconditioner;</span><br><span class="line">    preconditioner.<span class="built_in">initialize</span>(system_matrix, <span class="number">1.0</span>);</span><br><span class="line">    bicgstab.<span class="built_in">solve</span> (system_matrix, solution, system_rhs,</span><br><span class="line">            preconditioner);</span><br><span class="line">    hanging_node_constraints.<span class="built_in">distribute</span> (solution);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因为方程不再对称，所以使用了BICGStab算法。<br>然后就是细化网格：<br>template <int dim><br>void AdvectionProblem<dim>::refine_grid ()<br>{<br>    Vector<float> estimated_error_per_cell (triangulation.n_active_cells());<br>    GradientEstimation::estimate (dof_handler,<br>            solution,<br>            estimated_error_per_cell);<br>    GridRefinement::refine_and_coarsen_fixed_number (triangulation,<br>            estimated_error_per_cell,<br>            0.5, 0.03);<br>    triangulation.execute_coarsening_and_refinement ();<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">然后输出：</span><br><span class="line">&#96;&#96;&#96;cpp</span><br><span class="line">template &lt;int dim&gt;</span><br><span class="line">void AdvectionProblem&lt;dim&gt;::output_results (const unsigned int cycle) const</span><br><span class="line">&#123;</span><br><span class="line">    std::string filename &#x3D; &quot;grid-&quot;;</span><br><span class="line">    filename +&#x3D; (&#39;0&#39; + cycle);</span><br><span class="line">    Assert (cycle &lt; 10, ExcInternalError());</span><br><span class="line">    filename +&#x3D; &quot;.eps&quot;;</span><br><span class="line">    std::ofstream output (filename.c_str());</span><br><span class="line">    GridOut grid_out;</span><br><span class="line">    grid_out.write_eps (triangulation, output);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> AdvectionProblem&lt;dim&gt;::<span class="built_in">run</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> cycle=<span class="number">0</span>; cycle&lt;<span class="number">6</span>; ++cycle)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="string">&#x27;:&#x27;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (cycle == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GridGenerator::<span class="built_in">hyper_cube</span> (triangulation, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">            triangulation.<span class="built_in">refine_global</span> (<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">refine_grid</span> ();</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; Number of active cells: &quot;</span></span><br><span class="line">            &lt;&lt; triangulation.<span class="built_in">n_active_cells</span>()</span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">setup_system</span> ();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; Number of degrees of freedom: &quot;</span></span><br><span class="line">            &lt;&lt; dof_handler.<span class="built_in">n_dofs</span>()</span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">assemble_system</span> ();</span><br><span class="line">        <span class="built_in">solve</span> ();</span><br><span class="line">        <span class="built_in">output_results</span> (cycle);</span><br><span class="line">    &#125;</span><br><span class="line">    DataOut&lt;dim&gt; data_out;</span><br><span class="line">    data_out.<span class="built_in">attach_dof_handler</span> (dof_handler);</span><br><span class="line">    data_out.<span class="built_in">add_data_vector</span> (solution, <span class="string">&quot;solution&quot;</span>);</span><br><span class="line">    data_out.<span class="built_in">build_patches</span> ();</span><br><span class="line">    <span class="function">std::ofstream <span class="title">output</span> <span class="params">(<span class="string">&quot;final-solution.vtk&quot;</span>)</span></span>;</span><br><span class="line">    data_out.<span class="built_in">write_vtk</span> (output);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="梯度估计类的实现"><a href="#梯度估计类的实现" class="headerlink" title="梯度估计类的实现"></a>梯度估计类的实现</h2><p>先是构造函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">GradientEstimation::EstimateScratchData&lt;dim&gt;::</span><br><span class="line"><span class="built_in">EstimateScratchData</span> (<span class="keyword">const</span> FiniteElement&lt;dim&gt; &amp;fe,</span><br><span class="line">        <span class="keyword">const</span> Vector&lt;<span class="keyword">double</span>&gt; &amp;solution)</span><br><span class="line">    :</span><br><span class="line">        <span class="built_in">fe_midpoint_value</span>(fe,</span><br><span class="line">                QMidpoint&lt;dim&gt; (),</span><br><span class="line">                update_values | update_quadrature_points),</span><br><span class="line">        <span class="built_in">solution</span>(solution)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">GradientEstimation::EstimateScratchData&lt;dim&gt;::</span><br><span class="line"><span class="built_in">EstimateScratchData</span>(<span class="keyword">const</span> EstimateScratchData &amp;scratch_data)</span><br><span class="line">    :</span><br><span class="line">        <span class="built_in">fe_midpoint_value</span>(scratch_data.fe_midpoint_value.<span class="built_in">get_fe</span>(),</span><br><span class="line">                scratch_data.fe_midpoint_value.<span class="built_in">get_quadrature</span>(),</span><br><span class="line">                update_values | update_quadrature_points),</span><br><span class="line">        <span class="built_in">solution</span>(scratch_data.solution)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><br>然后就是estimate成员函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">GradientEstimation::<span class="built_in">estimate</span> (<span class="keyword">const</span> DoFHandler&lt;dim&gt; &amp;dof_handler,</span><br><span class="line">        <span class="keyword">const</span> Vector&lt;<span class="keyword">double</span>&gt; &amp;solution,</span><br><span class="line">        Vector&lt;<span class="keyword">float</span>&gt; &amp;error_per_cell)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Assert</span> (error_per_cell.<span class="built_in">size</span>() == dof_handler.<span class="built_in">get_triangulation</span>().<span class="built_in">n_active_cells</span>(),</span><br><span class="line">            <span class="built_in">ExcInvalidVectorLength</span> (error_per_cell.<span class="built_in">size</span>(),</span><br><span class="line">                dof_handler.<span class="built_in">get_triangulation</span>().<span class="built_in">n_active_cells</span>()));</span><br><span class="line">    <span class="keyword">typedef</span> std_cxx11::tuple&lt;<span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator,Vector&lt;<span class="keyword">float</span>&gt;::iterator&gt;</span><br><span class="line">        IteratorTuple;</span><br><span class="line">    SynchronousIterators&lt;IteratorTuple&gt;</span><br><span class="line">        <span class="built_in">begin_sync_it</span> (<span class="built_in">IteratorTuple</span> (dof_handler.<span class="built_in">begin_active</span>(),</span><br><span class="line">                    error_per_cell.<span class="built_in">begin</span>())),</span><br><span class="line">                      <span class="built_in">end_sync_it</span> (<span class="built_in">IteratorTuple</span> (dof_handler.<span class="built_in">end</span>(),</span><br><span class="line">                                  error_per_cell.<span class="built_in">end</span>()));</span><br><span class="line">    WorkStream::<span class="built_in">run</span> (begin_sync_it,</span><br><span class="line">            end_sync_it,</span><br><span class="line">            &amp;GradientEstimation::<span class="keyword">template</span> estimate_cell&lt;dim&gt;,</span><br><span class="line">            std_cxx11::function&lt;<span class="built_in"><span class="keyword">void</span></span> (<span class="keyword">const</span> EstimateCopyData &amp;)&gt; (),</span><br><span class="line">            EstimateScratchData&lt;dim&gt; (dof_handler.<span class="built_in">get_fe</span>(),</span><br><span class="line">                solution),</span><br><span class="line">            <span class="built_in">EstimateCopyData</span> ());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里也检查了矢量的尺寸是否正确，避免不易发现的错误。然后还设置了一些迭代器，没看明白。。<br>Attention！！然后计算梯度的有限差分近似：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std_cxx11::function&lt;<span class="built_in"><span class="keyword">void</span></span> (<span class="keyword">const</span> SynchronousIterators&lt;IteratorTuple&gt; &amp;,</span><br><span class="line">        EstimateScratchData&lt;dim&gt; &amp;,</span><br><span class="line">        EstimateCopyData &amp;)&gt;</span><br><span class="line">(std_cxx11::<span class="built_in">bind</span> (&amp;GradientEstimation::<span class="keyword">template</span> estimate_cell&lt;dim&gt;,</span><br><span class="line">                  std_cxx11::_1,</span><br><span class="line">                  std_cxx11::_2))</span><br></pre></td></tr></table></figure><br>整体思路是：首先计算当前单元的活跃邻居的列表，然后计算这些邻居单元上的量，参见引子。注意这里是活跃邻居单元，保证是在同一层级或更粗一级上。如果不活跃，还得看它的child。<br>具体为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">GradientEstimation::<span class="built_in">estimate</span> (<span class="keyword">const</span> DoFHandler&lt;dim&gt; &amp;dof_handler,</span><br><span class="line">        <span class="keyword">const</span> Vector&lt;<span class="keyword">double</span>&gt; &amp;solution,</span><br><span class="line">        Vector&lt;<span class="keyword">float</span>&gt; &amp;error_per_cell)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Assert</span> (error_per_cell.<span class="built_in">size</span>() == dof_handler.<span class="built_in">get_triangulation</span>().<span class="built_in">n_active_cells</span>(),</span><br><span class="line">            <span class="built_in">ExcInvalidVectorLength</span> (error_per_cell.<span class="built_in">size</span>(),</span><br><span class="line">                dof_handler.<span class="built_in">get_triangulation</span>().<span class="built_in">n_active_cells</span>()));</span><br><span class="line">    <span class="keyword">typedef</span> std_cxx11::tuple&lt;<span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator,Vector&lt;<span class="keyword">float</span>&gt;::iterator&gt;</span><br><span class="line">        IteratorTuple;</span><br><span class="line">    SynchronousIterators&lt;IteratorTuple&gt;</span><br><span class="line">        <span class="built_in">begin_sync_it</span> (<span class="built_in">IteratorTuple</span> (dof_handler.<span class="built_in">begin_active</span>(),</span><br><span class="line">                    error_per_cell.<span class="built_in">begin</span>())),</span><br><span class="line">                      <span class="built_in">end_sync_it</span> (<span class="built_in">IteratorTuple</span> (dof_handler.<span class="built_in">end</span>(),</span><br><span class="line">                                  error_per_cell.<span class="built_in">end</span>()));</span><br><span class="line">    WorkStream::<span class="built_in">run</span> (begin_sync_it,</span><br><span class="line">            end_sync_it,</span><br><span class="line">            &amp;GradientEstimation::<span class="keyword">template</span> estimate_cell&lt;dim&gt;,</span><br><span class="line">            std_cxx11::function&lt;<span class="built_in"><span class="keyword">void</span></span> (<span class="keyword">const</span> EstimateCopyData &amp;)&gt; (),</span><br><span class="line">            EstimateScratchData&lt;dim&gt; (dof_handler.<span class="built_in">get_fe</span>(),</span><br><span class="line">                solution),</span><br><span class="line">            <span class="built_in">EstimateCopyData</span> ());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">GradientEstimation::<span class="built_in">estimate_cell</span> (<span class="keyword">const</span> SynchronousIterators&lt;std_cxx11::tuple&lt;<span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator,</span><br><span class="line">        Vector&lt;<span class="keyword">float</span>&gt;::iterator&gt; &gt; &amp;cell,</span><br><span class="line">        EstimateScratchData&lt;dim&gt; &amp;scratch_data,</span><br><span class="line">        <span class="keyword">const</span> EstimateCopyData &amp;)</span><br><span class="line">&#123;</span><br><span class="line">    Tensor&lt;<span class="number">2</span>,dim&gt; Y;</span><br><span class="line">    std::vector&lt;<span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator&gt; active_neighbors;</span><br><span class="line">    active_neighbors.<span class="built_in">reserve</span> (GeometryInfo&lt;dim&gt;::faces_per_cell *</span><br><span class="line">            GeometryInfo&lt;dim&gt;::max_children_per_face);</span><br><span class="line">    <span class="keyword">typename</span> DoFHandler&lt;dim&gt;::<span class="function">active_cell_iterator <span class="title">cell_it</span><span class="params">(std_cxx11::get&lt;<span class="number">0</span>&gt;(cell.iterators))</span></span>;</span><br><span class="line">    scratch_data.fe_midpoint_value.<span class="built_in">reinit</span> (cell_it);</span><br><span class="line">    Tensor&lt;<span class="number">1</span>,dim&gt; projected_gradient;</span><br><span class="line">    active_neighbors.<span class="built_in">clear</span> ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> face_no=<span class="number">0</span>; face_no&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face_no)</span><br><span class="line">        <span class="keyword">if</span> (! std_cxx11::get&lt;<span class="number">0</span>&gt;(cell.iterators)-&gt;<span class="built_in">at_boundary</span>(face_no))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">typename</span> DoFHandler&lt;dim&gt;::face_iterator</span><br><span class="line">                face = std_cxx11::get&lt;<span class="number">0</span>&gt;(cell.iterators)-&gt;<span class="built_in">face</span>(face_no);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">typename</span> DoFHandler&lt;dim&gt;::cell_iterator</span><br><span class="line">                neighbor = std_cxx11::get&lt;<span class="number">0</span>&gt;(cell.iterators)-&gt;<span class="built_in">neighbor</span>(face_no);</span><br><span class="line">            <span class="keyword">if</span> (neighbor-&gt;<span class="built_in">active</span>())</span><br><span class="line">                active_neighbors.<span class="built_in">push_back</span> (neighbor);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (dim == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">typename</span> DoFHandler&lt;dim&gt;::cell_iterator</span><br><span class="line">                        neighbor_child = neighbor;</span><br><span class="line">                    <span class="keyword">while</span> (neighbor_child-&gt;<span class="built_in">has_children</span>())</span><br><span class="line">                        neighbor_child = neighbor_child-&gt;<span class="built_in">child</span> (face_no==<span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">                    <span class="built_in">Assert</span> (neighbor_child-&gt;<span class="built_in">neighbor</span>(face_no==<span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line">                            ==std_cxx11::get&lt;<span class="number">0</span>&gt;(cell.iterators),<span class="built_in">ExcInternalError</span>());</span><br><span class="line">                    active_neighbors.<span class="built_in">push_back</span> (neighbor_child);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> subface_no=<span class="number">0</span>; subface_no&lt;face-&gt;<span class="built_in">n_children</span>(); ++subface_no)</span><br><span class="line">                        active_neighbors.<span class="built_in">push_back</span> (</span><br><span class="line">                                std_cxx11::get&lt;<span class="number">0</span>&gt;(cell.iterators)-&gt;<span class="built_in">neighbor_child_on_subface</span>(face_no,subface_no));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">const</span> Point&lt;dim&gt; this_center = scratch_data.fe_midpoint_value.<span class="built_in">quadrature_point</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">double</span>&gt; <span class="title">this_midpoint_value</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    scratch_data.fe_midpoint_value.<span class="built_in">get_function_values</span> (scratch_data.solution, this_midpoint_value);</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">double</span>&gt; <span class="title">neighbor_midpoint_value</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">typename</span> std::vector&lt;<span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator&gt;::const_iterator</span><br><span class="line">        neighbor_ptr = active_neighbors.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (; neighbor_ptr!=active_neighbors.<span class="built_in">end</span>(); ++neighbor_ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator</span><br><span class="line">            neighbor = *neighbor_ptr;</span><br><span class="line">        scratch_data.fe_midpoint_value.<span class="built_in">reinit</span> (neighbor);</span><br><span class="line">        <span class="keyword">const</span> Point&lt;dim&gt; neighbor_center = scratch_data.fe_midpoint_value.<span class="built_in">quadrature_point</span>(<span class="number">0</span>);</span><br><span class="line">        scratch_data.fe_midpoint_value.<span class="built_in">get_function_values</span> (scratch_data.solution,</span><br><span class="line">                neighbor_midpoint_value);</span><br><span class="line">        Tensor&lt;<span class="number">1</span>,dim&gt; y = neighbor_center - this_center;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">double</span> distance = y.<span class="built_in">norm</span>();</span><br><span class="line">        y /= distance;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dim; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j=<span class="number">0</span>; j&lt;dim; ++j)</span><br><span class="line">                Y[i][j] += y[i] * y[j];</span><br><span class="line">        projected_gradient += (neighbor_midpoint_value[<span class="number">0</span>] -</span><br><span class="line">                this_midpoint_value[<span class="number">0</span>]) /</span><br><span class="line">            distance *</span><br><span class="line">            y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">AssertThrow</span> (<span class="built_in">determinant</span>(Y) != <span class="number">0</span>,</span><br><span class="line">            <span class="built_in">ExcInsufficientDirections</span>());</span><br><span class="line">    <span class="keyword">const</span> Tensor&lt;<span class="number">2</span>,dim&gt; Y_inverse = <span class="built_in">invert</span>(Y);</span><br><span class="line">    Tensor&lt;<span class="number">1</span>,dim&gt; gradient = Y_inverse * projected_gradient;</span><br><span class="line">    *(std_cxx11::get&lt;<span class="number">1</span>&gt;(cell.iterators)) = (std::<span class="built_in">pow</span>(std_cxx11::get&lt;<span class="number">0</span>&gt;(cell.iterators)-&gt;<span class="built_in">diameter</span>(),</span><br><span class="line">                <span class="number">1</span>+<span class="number">1.0</span>*dim/<span class="number">2</span>) *</span><br><span class="line">            std::<span class="built_in">sqrt</span>(gradient.<span class="built_in">norm_square</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>细节见帮助文档。简要说一下其中的几个特点：一是能判断单元是否活跃；二是能得到单元的子单元，甚至是它的左边子单元还是右边；三是能得到单元的中点上的函数值。<br>然后是main函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        ::MultithreadInfo::<span class="built_in">set_thread_limit</span>();</span><br><span class="line">        Step9::AdvectionProblem&lt;<span class="number">2</span>&gt; advection_problem_2d;</span><br><span class="line">        advection_problem_2d.<span class="built_in">run</span> ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (std::exception &amp;exc)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; exc.<span class="built_in">what</span>() &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>跟之前差不多，区别是使用MultithreadInfo来限制线程最大数目。</p>
<h1 id="计算结果"><a href="#计算结果" class="headerlink" title="计算结果"></a>计算结果</h1><p>自适应网格是：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjk098ejhj30mb0m0aii.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjk0jwpe3j30qx0k5wkl.jpg" alt=""></p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechat_reward.png" alt="Xin-Bo Qi(亓欣波) WeChat Pay">
        <p>WeChat Pay</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/deal-II/" rel="tag"># deal.II</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2016/09/06/dealii-learn-step8/" rel="prev" title="求解偏微分方程开源有限元软件deal.II学习--Step 8">
      <i class="fa fa-chevron-left"></i> 求解偏微分方程开源有限元软件deal.II学习--Step 8
    </a></div>
      <div class="post-nav-item">
    <a href="/2016/09/16/dealii-learn-step11/" rel="next" title="求解偏微分方程开源有限元软件deal.II学习--Step 11">
      求解偏微分方程开源有限元软件deal.II学习--Step 11 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%95%E5%AD%90"><span class="nav-number">1.</span> <span class="nav-text">引子</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E7%A8%8B%E7%A6%BB%E6%95%A3"><span class="nav-number">1.1.</span> <span class="nav-text">方程离散</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E4%BB%BB%E5%8A%A1task%E5%B9%B6%E8%A1%8C"><span class="nav-number">1.2.</span> <span class="nav-text">基于任务task并行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81-Work-Streams"><span class="nav-number">1.2.1.</span> <span class="nav-text">工作流 Work Streams</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E8%A1%8C"><span class="nav-number">1.3.</span> <span class="nav-text">基于线程的并行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%86%E5%8C%96%E5%87%86%E5%88%99"><span class="nav-number">1.4.</span> <span class="nav-text">细化准则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%A7%A3%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">程序解析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A2%AF%E5%BA%A6%E4%BC%B0%E8%AE%A1"><span class="nav-number">2.1.</span> <span class="nav-text">梯度估计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.</span> <span class="nav-text">主类的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A2%AF%E5%BA%A6%E4%BC%B0%E8%AE%A1%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.3.</span> <span class="nav-text">梯度估计类的实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C"><span class="nav-number">3.</span> <span class="nav-text">计算结果</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Xin-Bo Qi(亓欣波)"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Xin-Bo Qi(亓欣波)</p>
  <div class="site-description" itemprop="description">Digitize everything to realize Digitalization!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">129</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/qixinbo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;qixinbo" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:qixinbo@gmail.com" title="E-Mail → mailto:qixinbo@gmail.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/qixinbo" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;qixinbo" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fas fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.tsinghua.edu.cn/" title="https:&#x2F;&#x2F;www.tsinghua.edu.cn" rel="noopener" target="_blank">THU</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.imr.cas.cn/" title="http:&#x2F;&#x2F;www.imr.cas.cn" rel="noopener" target="_blank">IMR</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.sdu.edu.cn/" title="http:&#x2F;&#x2F;www.sdu.edu.cn" rel="noopener" target="_blank">SDU</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://liam0205.me/" title="http:&#x2F;&#x2F;liam0205.me&#x2F;" rel="noopener" target="_blank">黄晨成</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xin-Bo Qi(亓欣波)</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://qixinbo.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://qixinbo.github.io/2016/09/15/dealii-learn-step9/";
    this.page.identifier = "2016/09/15/dealii-learn-step9/";
    this.page.title = "求解偏微分方程开源有限元软件deal.II学习--Step 9";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://qixinbo.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
