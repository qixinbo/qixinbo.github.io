<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"qixinbo.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 2020-9-5 更新： 加入draw_image()和mix_img()方法的详解 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  前面系列文已经提到，ImagePy的画布Canvas类已经被抽象出来，可以被单独使用。 本节就对该类做一个详细解析：因为Canvas类又调用了同一路径下的boxutil和i">
<meta property="og:type" content="article">
<meta property="og:title" content="ImagePy解析：12 -- 画布Canvas类详解">
<meta property="og:url" content="http://qixinbo.github.io/2019/10/29/ImagePy_12/index.html">
<meta property="og:site_name" content="数字旗手">
<meta property="og:description" content="%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 2020-9-5 更新： 加入draw_image()和mix_img()方法的详解 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  前面系列文已经提到，ImagePy的画布Canvas类已经被抽象出来，可以被单独使用。 本节就对该类做一个详细解析：因为Canvas类又调用了同一路径下的boxutil和i">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://user-images.githubusercontent.com/6218739/69029568-54ff6680-0a10-11ea-879e-e1df857d0df2.jpg">
<meta property="article:published_time" content="2019-10-28T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-26T07:43:52.147Z">
<meta property="article:author" content="Xin-Bo Qi(亓欣波)">
<meta property="article:tag" content="ImagePy">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-images.githubusercontent.com/6218739/69029568-54ff6680-0a10-11ea-879e-e1df857d0df2.jpg">

<link rel="canonical" href="http://qixinbo.github.io/2019/10/29/ImagePy_12/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>ImagePy解析：12 -- 画布Canvas类详解 | 数字旗手</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="数字旗手" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">数字旗手</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">电气化、自动化、数字化、智能化、智慧化</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-scholar">

    <a href="/scholar/" rel="section"><i class="fa fa-chart-bar fa-fw"></i>scholar</a>

  </li>
        <li class="menu-item menu-item-sources">

    <a href="/sources/" rel="section"><i class="fa fa-rss fa-fw"></i>sources</a>

  </li>
        <li class="menu-item menu-item-gallery">

    <a href="/gallery/" rel="section"><i class="fa fa-file-image fa-fw"></i>gallery</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404.html" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2019/10/29/ImagePy_12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Digitize everything to realize Digitalization!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="数字旗手">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ImagePy解析：12 -- 画布Canvas类详解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-10-29 00:00:00" itemprop="dateCreated datePublished" datetime="2019-10-29T00:00:00+08:00">2019-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-26 15:43:52" itemprop="dateModified" datetime="2021-03-26T15:43:52+08:00">2021-03-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computer-vision/" itemprop="url" rel="index"><span itemprop="name">computer vision</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/10/29/ImagePy_12/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/10/29/ImagePy_12/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<br>2020-9-5 更新：<br>加入draw_image()和mix_img()方法的详解<br>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</p>
<p>前面系列文已经提到，ImagePy的画布Canvas类已经被抽象出来，可以被单独使用。<br>本节就对该类做一个详细解析：因为Canvas类又调用了同一路径下的boxutil和imutil，所以本文的思路是先整体介绍它的运行机理，然后具体到某一功能时可以再详细查看下方的详细解释，这样不至于迷失在代码中。。</p>
<p>该类的源码地址在<a target="_blank" rel="noopener" href="https://github.com/Image-Py/imagepy/tree/master/imagepy/ui/canvas">这里</a>。</p>
<h1 id="画布Canvas运行机理"><a href="#画布Canvas运行机理" class="headerlink" title="画布Canvas运行机理"></a>画布Canvas运行机理</h1><p>总体看一下它的调用代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    msk = np.zeros((<span class="number">512</span>,<span class="number">512</span>), dtype=np.uint8)</span><br><span class="line">    msk[<span class="number">100</span>:<span class="number">200</span>,<span class="number">100</span>:<span class="number">200</span>] = <span class="number">1</span></span><br><span class="line">    msk[<span class="number">200</span>:<span class="number">300</span>,<span class="number">200</span>:<span class="number">300</span>] = <span class="number">2</span></span><br><span class="line">    msk[<span class="number">300</span>:<span class="number">400</span>,<span class="number">300</span>:<span class="number">400</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    lut = np.array([(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>)], dtype=np.uint8)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> skimage.data <span class="keyword">import</span> astronaut, camera</span><br><span class="line">    app = wx.App()</span><br><span class="line">    frame = wx.Frame(<span class="literal">None</span>)</span><br><span class="line">    canvas = Canvas(frame)</span><br><span class="line">    canvas.set_img(msk)</span><br><span class="line">    canvas.set_lut(lut)</span><br><span class="line">    canvas.set_cn(<span class="number">0</span>)</span><br><span class="line">    canvas.set_back(astronaut())</span><br><span class="line">    canvas.set_cn(<span class="string">&#x27;rgb&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">    canvas.set_mode(<span class="string">&#x27;msk&#x27;</span>)</span><br><span class="line">    frame.Show(<span class="literal">True</span>)</span><br><span class="line">    app.MainLoop()</span><br></pre></td></tr></table></figure><br>这里是查看单独调用该画布时的用法，该画布也可以直接用在ImagePy框架中用。<br>然后分步看一下具体设置和运行。</p>
<h2 id="创建掩膜"><a href="#创建掩膜" class="headerlink" title="创建掩膜"></a>创建掩膜</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msk = np.zeros((<span class="number">512</span>,<span class="number">512</span>), dtype=np.uint8)</span><br><span class="line">msk[<span class="number">100</span>:<span class="number">200</span>,<span class="number">100</span>:<span class="number">200</span>] = <span class="number">1</span></span><br><span class="line">msk[<span class="number">200</span>:<span class="number">300</span>,<span class="number">200</span>:<span class="number">300</span>] = <span class="number">2</span></span><br><span class="line">msk[<span class="number">300</span>:<span class="number">400</span>,<span class="number">300</span>:<span class="number">400</span>] = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>这里的掩膜msk是一个512乘以512大小的黑色图像，然后将它的三个区域分别由0变为1、2或3。<br>掩膜之所以设置成512乘以512，是因为下面的astronaut()是这么个形状，所以一般掩膜应该是设置成与背景图像相同大小的黑色图像。（也可以任意设置掩膜大小，但那样只会显示原图的一部分，没有什么实际意义。）</p>
<h2 id="创建查找表"><a href="#创建查找表" class="headerlink" title="创建查找表"></a>创建查找表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lut = np.array([(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>)], dtype=np.uint8)</span><br></pre></td></tr></table></figure>
<p>这里的查找表lut是一个array数组，里面盛放了四种颜色。具体使用它的地方是imutil中lookup()方法，可以详细查看本文下面的说明。一言以蔽之，是使用了Numpy的Fancy Indexing，与上面的msk进行呼应，当msk中的像素值为1时，就取lut的(255, 0, 0)红色。</p>
<h2 id="创建并运行Canvas对象"><a href="#创建并运行Canvas对象" class="headerlink" title="创建并运行Canvas对象"></a>创建并运行Canvas对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app = wx.App()</span><br><span class="line">frame = wx.Frame(<span class="literal">None</span>)</span><br><span class="line">canvas = Canvas(frame)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">frame.Show(<span class="literal">True</span>)</span><br><span class="line">app.MainLoop()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面创建了Canvas的对象，并通过它所依赖的frame的Show()方法进行渲染展示。当Show()方法调用时，就会生成Canvas的窗口，然后就会触发它的窗口改变wx.EVT_SIZE事件，然后就执行一系列的绘图动作，具体做了啥见下方说明。</p>
<h2 id="配置Canvas：设置图像"><a href="#配置Canvas：设置图像" class="headerlink" title="配置Canvas：设置图像"></a>配置Canvas：设置图像</h2><p>上面创建了Canvas后，还要对其进行一番配置。这一步及下面的五步都是Canvas的核心配置步骤。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvas.set_img(msk)</span><br></pre></td></tr></table></figure><br>这一步是设置前景图（下面还有一个背景图），因为这个例子是有点特别，是用于标注，所以此时Canvas要显示的图像是掩膜msk与原图的在掩膜模式下的混合（看起来就像是前景可以任意涂抹，背景则不受影响）。<br>那么再重新理一下这几张图：在这个例子中，前景图是一张黑色图像（大部分像素值为0，但里面的一些像素值已被更改为非0），背景图是彩色原图，实际上画布Canvas显示的是一张图像，即两者的混合，根据不同的混合模式显示不同的混合图像。</p>
<p>还需要注意一点（感谢龙哥的语音指导）：<br>（1）在单纯这个Canvas显示中，前景图和背景图需要分辨清楚，因为它是用于标注，需要明确哪个在前哪个在后，而在其他混合模式下，如最大值、最小值混合，两者效果相同。<br>（2）如果将Canvas放入ImagePy中，两者也是要分辨清楚，因为前景永远指的是滤波器要处理的这一张图，而背景图仅用于衬托。</p>
<h2 id="配置Canvas：设置查找表"><a href="#配置Canvas：设置查找表" class="headerlink" title="配置Canvas：设置查找表"></a>配置Canvas：设置查找表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvas.set_lut(lut)</span><br></pre></td></tr></table></figure>
<p>这一步是设置查找表。这里因为只传递了lut，所以该方法的第二个参数用的是False，即这里设置的是self.lut属性，而self._lut保持默认值（即黑色到白色的渐变）不变。<br>这里也提前说明，不带下划线的属性（包括self.lut、self.rg和self.cn）都是与前景图相关，而带下划线的属性（包括self._lut、self._rg和self._cn）都是与背景图相关。</p>
<h2 id="配置Canvas：设置图像通道"><a href="#配置Canvas：设置图像通道" class="headerlink" title="配置Canvas：设置图像通道"></a>配置Canvas：设置图像通道</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvas.set_cn(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>这一步是设置图像通道，这里因为只传递了0，所以第二个参数用的是默认值False，即这里不是针对背景图设置的，而是针对前景图，即self.cn设为0。这里有两点需要注意：首先因为是cn，不带下划线，说明是对前景图的设置；再者一定要设置为0，这是通道标识，因为掩膜msk是一个灰度值，所以只有一个通道，那么它的标识就是0。</p>
<p>可以再往下看，后面又调用了set_cn()方法，传入的是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvas.set_cn(<span class="string">&#x27;rgb&#x27;</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><br>即此时将’rgb’赋给了self._cn，即对背景图的通道进行设置，即想让背景图以RGB彩色图的形式显示。</p>
<h2 id="配置Canvas：设置背景图像"><a href="#配置Canvas：设置背景图像" class="headerlink" title="配置Canvas：设置背景图像"></a>配置Canvas：设置背景图像</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvas.set_back(astronaut())</span><br></pre></td></tr></table></figure>
<p>这一步是设置背景图像，是将numpy数组形式的图像传入。</p>
<h2 id="配置Canvas：设置混合模式"><a href="#配置Canvas：设置混合模式" class="headerlink" title="配置Canvas：设置混合模式"></a>配置Canvas：设置混合模式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvas.set_mode(<span class="string">&#x27;msk&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这里将模式设为msk，即掩膜模式。<br>因为如前所述，该例子是为了标注，设置为掩膜模式后，画布上呈现的图就是掩膜不为0的地方的前景图与掩膜为0的地方的背景图的叠加。<br>关于mode的详述，见本文下面的set_mode()方法。</p>
<h1 id="Canvas类及其属性和方法"><a href="#Canvas类及其属性和方法" class="headerlink" title="Canvas类及其属性和方法"></a>Canvas类及其属性和方法</h1><h2 id="set-img-方法"><a href="#set-img-方法" class="headerlink" title="set_img()方法"></a>set_img()方法</h2><p>这一步就是指定前景图，再强调一下，这个前景图并不是画布呈现的图，画布呈现的是前景与背景的混合图像。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_img</span>(<span class="params">self, img</span>):</span></span><br><span class="line">    self.img = img</span><br><span class="line">    self.conbox = [<span class="number">0</span>, <span class="number">0</span>, *img.shape[<span class="number">1</span>::-<span class="number">1</span>]]</span><br><span class="line">    self.oribox = [<span class="number">0</span>, <span class="number">0</span>, *img.shape[<span class="number">1</span>::-<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><br>注意，这个地方用到了一个星号变量，是为了将shape由元组拆分为单个参数，具体用法可以看我转载的一篇讲星号变量的文章，那么这个地方的运算顺序实际是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.conbox = [<span class="number">0</span>, <span class="number">0</span>, *(img.shape[<span class="number">1</span>::-<span class="number">1</span>])]</span><br></pre></td></tr></table></figure><br>同时，注意对shape元组切片时的步长是-1，即它是反着切的，即只取第0个元素和第1个元素。<br>得到的conbox和oribox也是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conbox =  [<span class="number">0</span>, <span class="number">0</span>, <span class="number">512</span>, <span class="number">512</span>]</span><br></pre></td></tr></table></figure><br>通过设置前景图，给Canvas的img属性赋值，同时根据图像尺寸得到了Canvas的conbox和oribox。<br>这里面的几个box要明白它们的含义（因为这里没涉及旋转，oribox未作分析）：<br>（1）winbox：即盛放整个panel窗口的box；<br>（2）conbox：即承载图像的box；<br>（3）csbox：即上面两个box重叠的部分，也是真正绘图的画布box。<br>比如一张图像为[512, 1024]大小，呈现给用户的窗口是[1000, 1000]，那么conbox就是512乘以1024大小，winbox就是1000乘以1000大小，csbox大小则是512乘以1000，那么看起来就是整个窗口上，图像水平方向能全部显示，且左右都有空白填充，而垂直方向仅能显示大部分图像，没有空白填充。</p>
<h2 id="set-lut-方法"><a href="#set-lut-方法" class="headerlink" title="set_lut()方法"></a>set_lut()方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_lut</span>(<span class="params">self, lut, b=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> b: self._lut = lut</span><br><span class="line">    <span class="keyword">else</span>: self.lut = lut</span><br></pre></td></tr></table></figure>
<p>这一步是定义查找表，除了传入查找表数组，还传入一个旗标b（就是background），如果是False（即不是背景，可以把旗标b命名为isBackgroud，否则可能有点绕），就设置self.lut属性，如果是True（即是背景），就设置self._lut属性。</p>
<p>这两个属性默认值是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.lut = np.array([np.arange(<span class="number">256</span>)]*<span class="number">3</span>, dtype=np.uint8).T</span><br><span class="line">self._lut = np.array([np.arange(<span class="number">256</span>)]*<span class="number">3</span>, dtype=np.uint8).T</span><br></pre></td></tr></table></figure><br>即是从黑色到白色渐变的一个颜色索引（注意后面的转置）。</p>
<h2 id="set-cn-方法"><a href="#set-cn-方法" class="headerlink" title="set_cn()方法"></a>set_cn()方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_cn</span>(<span class="params">self, cn, b=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> b: self._cn = cn</span><br><span class="line">    <span class="keyword">else</span>: self.cn = cn</span><br></pre></td></tr></table></figure>
<p>这一步是设置图像通道，除了传入通道，还传入一个旗标b，如果是False（即不是背景），就设置self.cn，如果是True（即是背景），就设置self._cn。</p>
<p>这两个属性默认值都是0：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.cn = <span class="number">0</span></span><br><span class="line">self._cn = <span class="number">0</span></span><br></pre></td></tr></table></figure><br>这里传入的cn是通道标识，如果图像只有一个通道，一定要设置为0；如果有多个通道，比如RGB，若想显示彩图，则设置为RGB；若只想显示其中一个通道，则设置通道标识为0或1或2。</p>
<h2 id="set-back-方法"><a href="#set-back-方法" class="headerlink" title="set_back()方法"></a>set_back()方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_back</span>(<span class="params">self, back</span>):</span> self.back = back</span><br></pre></td></tr></table></figure>
<p>这一步是设置背景图像，为self.back属性赋值。</p>
<h2 id="set-mode-方法"><a href="#set-mode-方法" class="headerlink" title="set_mode()方法"></a>set_mode()方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_mode</span>(<span class="params">self, mode</span>):</span> self.mode = mode</span><br></pre></td></tr></table></figure>
<p>这一步是设置混合模式，为self.mode属性赋值。<br>该属性的默认值为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.mode = <span class="string">&#x27;set&#x27;</span></span><br></pre></td></tr></table></figure><br>有多种混合模式：<br>（1）set模式：默认模式，直接将图像设为要显示的图像（即不混合）<br>（2）min模式：逐个对比背景图和前景图两张图像中的像素，选择数值小的像素保存进混合图像<br>（3）max模式：逐个对比背景图和前景图两张图像中的像素，选择数值大的像素保存进混合图像<br>（4）msk模式：根据掩膜将背景图和前景图进行混合，在掩膜msk不为0的地方，将背景图设为0；在msk为0的地方，保留原值（因为对msk作了逻辑非操作，然后下面在元素相乘时，True为1，False为0）。然后将两图进行相加合成存入混合图像。<br>（5）按比例混合模式：mode可以是一个小数，即将背景图与1-mode相乘，前景图与mode相乘，然后两者相加合成存入混合图像。</p>
<h2 id="set-rg"><a href="#set-rg" class="headerlink" title="set_rg()"></a>set_rg()</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_rg</span>(<span class="params">self, rg, b=<span class="literal">False</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> b: self._rg = rg</span><br><span class="line">    <span class="keyword">else</span>: self.rg = rg</span><br></pre></td></tr></table></figure>
<p>这一步是设置像素值范围，默认两张图都是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.rg = (<span class="number">0</span>, <span class="number">255</span>)</span><br><span class="line">self._rg = (<span class="number">0</span>, <span class="number">255</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="initBuffer-方法"><a href="#initBuffer-方法" class="headerlink" title="initBuffer()方法"></a>initBuffer()方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initBuffer</span>(<span class="params">self</span>):</span></span><br><span class="line">    box = self.GetClientSize()</span><br><span class="line">    self.buffer = wx.Bitmap(*box)</span><br><span class="line">    self.winbox = [<span class="number">0</span>, <span class="number">0</span>, *box]</span><br></pre></td></tr></table></figure>
<p>可以看出来，初始化缓冲时就是先创建一个初始尺寸的wxPython的位图Bitmap，然后将它赋给self.buffer变量。<br>同时也将整个面板的大小self.winbox设定一下。</p>
<h2 id="update-方法"><a href="#update-方法" class="headerlink" title="update()方法"></a>update()方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self</span>):</span></span><br><span class="line">    start = time()</span><br><span class="line">    lay(self.winbox, self.conbox)</span><br><span class="line">    dc = wx.BufferedDC(wx.ClientDC(self), self.buffer)</span><br><span class="line">    dc.Clear()</span><br><span class="line">    self.draw_image(dc, self.img, self.back, <span class="number">0</span>)</span><br><span class="line">    dc.UnMask()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;frame rate:&#x27;</span>,<span class="built_in">int</span>(<span class="number">1</span>/<span class="built_in">max</span>(<span class="number">0.001</span>, time()-start)))</span><br></pre></td></tr></table></figure>
<p>首先通过lay()方法根据winbox的位置来更新conbox的位置（该方法的解析见本文下方），然后创建一个BufferedDC与用户交互，然后调用draw_image()方法。</p>
<h2 id="draw-image-方法"><a href="#draw-image-方法" class="headerlink" title="draw_image()方法"></a>draw_image()方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_image</span>(<span class="params">self, dc, img, back, mode</span>):</span></span><br><span class="line">    out, rgb = self.outimg, self.outrgb</span><br><span class="line">    csbox = cross(self.winbox, self.conbox)</span><br><span class="line">    shp = csbox[<span class="number">3</span>]-csbox[<span class="number">1</span>], csbox[<span class="number">2</span>]-csbox[<span class="number">0</span>]</span><br><span class="line">    o, m = mat(self.oribox, self.conbox, csbox)</span><br><span class="line">    shp = <span class="built_in">tuple</span>(np.array(shp).<span class="built_in">round</span>().astype(np.<span class="built_in">int</span>))</span><br><span class="line">    <span class="keyword">if</span> out <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> (out.shape, out.dtype) != (shp, img.dtype):</span><br><span class="line">        self.outimg = np.zeros(shp, dtype=img.dtype)</span><br><span class="line">    <span class="keyword">if</span> rgb <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> rgb.shape[:<span class="number">2</span>] != shp:</span><br><span class="line">        self.outrgb = np.zeros(shp+(<span class="number">3</span>,), dtype=np.uint8)</span><br><span class="line">        self.outint = np.zeros(shp, dtype=np.uint8)</span><br><span class="line">        buf = <span class="built_in">memoryview</span>(self.outrgb)</span><br><span class="line">        self.outbmp = wx.Bitmap.FromBuffer(*shp[::-<span class="number">1</span>], buf)</span><br><span class="line"></span><br><span class="line">    mix_img(back, m, o, shp, self.outimg,</span><br><span class="line">          self.outrgb, self.outint,</span><br><span class="line">          self._rg, self._lut, cns=self._cn, mode=<span class="string">&#x27;set&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">    mix_img(img, m, o, shp, self.outimg,</span><br><span class="line">          self.outrgb, self.outint,</span><br><span class="line">          self.rg, self.lut, cns=self.cn, mode=self.mode)</span><br><span class="line"></span><br><span class="line">    self.outbmp.CopyFromBuffer(<span class="built_in">memoryview</span>(self.outrgb))</span><br><span class="line">    dc.DrawBitmap(self.outbmp, *csbox[:<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p>首先通过cross()方法取得了winbox和conbox这两个矩形框重叠的部分csbox（仍然见下方解析），然后计算csbox的宽度和高度，形成shape这个元组，这个大小是真正要作图的区域，而不是winbox和conbox这两个的大小。<br>这里根据shape的大小，会创建几个变量：<br>self.outimg：大小为shape、值全为0、类型为img.dtype<br>self.outrgb：大小为shape+3通道（注意，是3通道）、值全为0、类型为np.uint8<br>self.outint：大小为shape（注意，是单通道）、值全为0、类型为np.uint8<br>然后就会调用两次图像混合。<br>通过mat()方法得到偏移量和缩放因子，这两个参数都是后面仿射变换的重要参数。<br>可以看出mix_img()方法调用了两次，分别是为了设置背景图和设置前景图。两者的顺序不能调换，因为第一次的调用返回的self.outrgb是作为背景图在第二次调用时进行图像混合。</p>
<h2 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bindEvents</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">for</span> event, handler <span class="keyword">in</span> [ \</span><br><span class="line">            (wx.EVT_SIZE, self.on_size),</span><br><span class="line">            (wx.EVT_MOUSE_EVENTS, self.on_mouseevent),</span><br><span class="line">            (wx.EVT_IDLE, self.on_idle),</span><br><span class="line">            (wx.EVT_CLOSE, self.on_close),</span><br><span class="line">            (wx.EVT_PAINT, self.on_paint)]:</span><br><span class="line">        self.Bind(event, handler)</span><br></pre></td></tr></table></figure>
<h3 id="窗口尺寸改变"><a href="#窗口尺寸改变" class="headerlink" title="窗口尺寸改变"></a>窗口尺寸改变</h3><p>这个事件就是wx.EVT_SIZE，即窗口尺寸变化时触发，比如用鼠标拖动窗口边界。<br>实际上，刚开始创建该窗口时也会触发该事件，即该事件实际就是该Canvas的入口函数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_size</span>(<span class="params">self, event</span>):</span></span><br><span class="line">    self.initBuffer()</span><br><span class="line">    self.update()</span><br></pre></td></tr></table></figure><br>可以看出，该事件处理函数就是调用初始化方法和更新方法。</p>
<h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><p>这个事件就是wx.EVT_MOUSE_EVENTS，包括鼠标按下和释放、鼠标移动、鼠标滚动等。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_mouseevent</span>(<span class="params">self, me</span>):</span></span><br><span class="line">    <span class="keyword">if</span> me.ButtonDown():</span><br><span class="line">       <span class="keyword">if</span> me.GetButton()==<span class="number">1</span>:</span><br><span class="line">            self.oldxy = me.GetX(), me.GetY()</span><br><span class="line">        <span class="keyword">if</span> me.GetButton()==<span class="number">3</span>:</span><br><span class="line">            self.fit()</span><br><span class="line">    wheel = np.sign(me.GetWheelRotation())</span><br><span class="line">    <span class="keyword">if</span> wheel!=<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> wheel == <span class="number">1</span>:</span><br><span class="line">            self.zoomout(me.GetX(), me.GetY())</span><br><span class="line">        <span class="keyword">if</span> wheel == -<span class="number">1</span>:</span><br><span class="line">            self.zoomin(me.GetX(), me.GetY())</span><br><span class="line">    <span class="keyword">if</span> me.Dragging():</span><br><span class="line">        x, y = self.oldxy</span><br><span class="line">        self.move(me.GetX()-x, me.GetY()-y)</span><br><span class="line">        self.oldxy = me.GetX(), me.GetY()</span><br></pre></td></tr></table></figure><br>可以看出，首先对鼠标按键按下做判断：1就是左键，3就是右键，2就是中键，如果想更清楚地表示的话，可以分别用wx.MOUSE_BTN_LEFT、wx.MOUSE_BTN_MIDDLE和wx.MOUSE_BTN_RIGHT来表示。<br>如果是左键按下，就要捕捉当前鼠标所在的像素坐标系（以图像左上角为原点）的坐标。然后下面如果接着出了Dragging()事件，则记录新的坐标点，同时根据新旧坐标点移动conbox，并重新绘图。<br>如果是右键按下，则会调用fit()方法，对比oribox与winbox的相对大小，然后寻找哪个收缩比例可以使得oribox小于winbox，然后调用zoom()，传给zoom()的是收缩因子以及中心点(0,0)，更新一下conbox。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scales = [<span class="number">0.03125</span>, <span class="number">0.0625</span>, <span class="number">0.125</span>, <span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>, <span class="number">1</span>, <span class="number">1.5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">50</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> self.scales[<span class="number">6</span>::-<span class="number">1</span>]:</span><br><span class="line">    <span class="keyword">if</span> oriw*i&lt;winw <span class="keyword">and</span> orih*i&lt;winh:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">self.scaidx = self.scales.index(i)</span><br></pre></td></tr></table></figure><br>scales属性本身存放了很多的缩放因子，fit()方法寻找收缩因子的时候，是从中间的比例1往前查找，找到第一个能使图像完整呈现的因子。<br>如果是鼠标滚轮动了，则：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> wheel == <span class="number">1</span>:</span><br><span class="line">    self.zoomout(me.GetX(), me.GetY())</span><br><span class="line"><span class="keyword">if</span> wheel == -<span class="number">1</span>:</span><br><span class="line">    self.zoomin(me.GetX(), me.GetY())</span><br></pre></td></tr></table></figure><br>判断到底是放大还是缩小，然后分别调用zoomout()和zoomin()，注意将当前鼠标的坐标点传入，这样就能够实现以当前鼠标点为中心进行缩放，妙~~~</p>
<h3 id="空闲事件"><a href="#空闲事件" class="headerlink" title="空闲事件"></a>空闲事件</h3><p>目前该事件处理函数是空的。</p>
<h3 id="绘图事件"><a href="#绘图事件" class="headerlink" title="绘图事件"></a>绘图事件</h3><p>这个事件就是wx.EVT_PAINT：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_paint</span>(<span class="params">self, event</span>):</span></span><br><span class="line">    wx.BufferedPaintDC(self, self.buffer)</span><br></pre></td></tr></table></figure><br>这个事件发生在拉动窗口边界时，此时创建一个临时的BufferedPaintDC，然后将当前的缓冲呈现出来。</p>
<h1 id="boxutil模块及其方法"><a href="#boxutil模块及其方法" class="headerlink" title="boxutil模块及其方法"></a>boxutil模块及其方法</h1><h2 id="cross-方法"><a href="#cross-方法" class="headerlink" title="cross()方法"></a>cross()方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cross</span>(<span class="params">winbox, conbox</span>):</span></span><br><span class="line">    two = np.array([winbox, conbox])</span><br><span class="line">    x1, y1 = two[:,:<span class="number">2</span>].<span class="built_in">max</span>(axis=<span class="number">0</span>)</span><br><span class="line">    x2, y2 = two[:,<span class="number">2</span>:].<span class="built_in">min</span>(axis=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> [x1, y1, x2, y2]</span><br></pre></td></tr></table></figure>
<p>cross()方法就是取winbox和conbox这两个矩形框交叠的部分。<br>比如，winbox是[0, 0, 520, 211]，conbox是[4.0, -2, 516.0, 510]，那么cross()返回的就是[4.0, 0.0, 516.0, 211.0]。</p>
<h2 id="lay-方法"><a href="#lay-方法" class="headerlink" title="lay()方法"></a>lay()方法</h2><p>lay()的功能就是根据图像与窗口之间的相对大小来设定conbox的大小。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">layx</span>(<span class="params">winbox, conbox</span>):</span></span><br><span class="line">    conw = conbox[<span class="number">2</span>]-conbox[<span class="number">0</span>]</span><br><span class="line">    winw = winbox[<span class="number">2</span>]-winbox[<span class="number">0</span>]  </span><br><span class="line">    <span class="keyword">if</span> conw&lt;winw:</span><br><span class="line">        mid = (winbox[<span class="number">0</span>]+winbox[<span class="number">2</span>])/<span class="number">2</span></span><br><span class="line">        conbox[<span class="number">0</span>] = mid-conw/<span class="number">2</span></span><br><span class="line">        conbox[<span class="number">2</span>] = mid+conw/<span class="number">2</span></span><br><span class="line">    <span class="keyword">elif</span> conbox[<span class="number">0</span>] &gt; winbox[<span class="number">0</span>]:</span><br><span class="line">        conbox[<span class="number">0</span>] = winbox[<span class="number">0</span>]</span><br><span class="line">        conbox[<span class="number">2</span>] = conbox[<span class="number">0</span>] + conw</span><br><span class="line">    <span class="keyword">elif</span> conbox[<span class="number">2</span>] &lt; winbox[<span class="number">2</span>]:</span><br><span class="line">        conbox[<span class="number">2</span>] = winbox[<span class="number">2</span>]</span><br><span class="line">        conbox[<span class="number">0</span>] = conbox[<span class="number">2</span>] - conw</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">layy</span>(<span class="params">winbox, conbox</span>):</span></span><br><span class="line">    winh = winbox[<span class="number">3</span>]-winbox[<span class="number">1</span>]</span><br><span class="line">    conh = conbox[<span class="number">3</span>]-conbox[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> conh&lt;winh:</span><br><span class="line">        mid = (winbox[<span class="number">1</span>]+winbox[<span class="number">3</span>])/<span class="number">2</span></span><br><span class="line">        conbox[<span class="number">1</span>] = mid-conh/<span class="number">2</span></span><br><span class="line">        conbox[<span class="number">3</span>] = mid+conh/<span class="number">2</span></span><br><span class="line">    <span class="keyword">elif</span> conbox[<span class="number">1</span>] &gt; winbox[<span class="number">1</span>]:</span><br><span class="line">        conbox[<span class="number">1</span>] = winbox[<span class="number">1</span>]</span><br><span class="line">        conbox[<span class="number">3</span>] = conbox[<span class="number">1</span>] + conh</span><br><span class="line">    <span class="keyword">elif</span> conbox[<span class="number">3</span>] &lt; winbox[<span class="number">3</span>]:</span><br><span class="line">        conbox[<span class="number">3</span>] = winbox[<span class="number">3</span>]</span><br><span class="line">        conbox[<span class="number">1</span>] = conbox[<span class="number">3</span>] - conh</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lay</span>(<span class="params">winbox, conbox</span>):</span></span><br><span class="line">    layx(winbox, conbox)</span><br><span class="line">    layy(winbox, conbox)</span><br></pre></td></tr></table></figure><br>可以分为以下几种情况，以x方向的大小为例（从layx和layy可以看出，两者代码是一致的），主要是判断宽度的相对大小、左端点和右端点的相对位置：<br>（1）如果conbox宽度小于winbox，即整张图像无法完全填充整个窗口，需要使用空白来填充窗口时，则：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> conw&lt;winw:</span><br><span class="line">    mid = (winbox[<span class="number">0</span>]+winbox[<span class="number">2</span>])/<span class="number">2</span></span><br><span class="line">    conbox[<span class="number">0</span>] = mid-conw/<span class="number">2</span></span><br><span class="line">    conbox[<span class="number">2</span>] = mid+conw/<span class="number">2</span></span><br></pre></td></tr></table></figure><br>即先得到winbox的中心mid，然后这个中心mid在左右分别减去和加上conbox的半宽，就得到新的conbox的位置，但保持其宽度不变。<br>（2）如果conbox宽度大于winbox，即conbox能覆盖住winbox，在此前提下，如果conbox的左侧端点大于winbox的左侧，即conbox相比于winbox太靠右了，则：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> conbox[<span class="number">0</span>] &gt; winbox[<span class="number">0</span>]:</span><br><span class="line">    conbox[<span class="number">0</span>] = winbox[<span class="number">0</span>]</span><br><span class="line">    conbox[<span class="number">2</span>] = conbox[<span class="number">0</span>] + conw</span><br></pre></td></tr></table></figure><br>即将conbox挪回到winbox的左侧，同时还要保证原来的宽度不变。<br>（3）另外，在conbox能覆盖住winbox前提下，如果conbox的右侧端点小于winbox的右侧，即conbox相比于winbox太靠左了，则：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> conbox[<span class="number">2</span>] &lt; winbox[<span class="number">2</span>]:</span><br><span class="line">    conbox[<span class="number">2</span>] = winbox[<span class="number">2</span>]</span><br><span class="line">    conbox[<span class="number">0</span>] = conbox[<span class="number">2</span>] - conw</span><br></pre></td></tr></table></figure><br>则将conbox挪回到winbox的右侧，同时还要保证原来的宽度不变。<br>后面这两种情形都与鼠标动作的拖动有关，即捕捉当前鼠标位置，拖动后再记录当前新位置，两者相减得到移动量，得到更新的conbox位置。</p>
<h2 id="mat-方法"><a href="#mat-方法" class="headerlink" title="mat()方法"></a>mat()方法</h2><p>mat()方法是为了得到图像conbox与绘图区域csbox的旋转缩放矩阵matrix及偏移量offset。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">o, m = mat(self.oribox, self.conbox, csbox)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mat</span>(<span class="params">ori, vir, cros</span>):</span></span><br><span class="line">    kx = (ori[<span class="number">2</span>]-ori[<span class="number">0</span>])/(vir[<span class="number">2</span>]-vir[<span class="number">0</span>])</span><br><span class="line">    ky = (ori[<span class="number">3</span>]-ori[<span class="number">1</span>])/(vir[<span class="number">3</span>]-vir[<span class="number">1</span>])</span><br><span class="line">    ox = (cros[<span class="number">1</span>]-vir[<span class="number">1</span>])*ky</span><br><span class="line">    oy = (cros[<span class="number">0</span>]-vir[<span class="number">0</span>])*kx</span><br><span class="line">    <span class="keyword">return</span> (ox, oy), (kx, ky)</span><br></pre></td></tr></table></figure><br>传入的分别是oribox（这里oribox一直没变）、conbox和csbox，然后返回偏移量和缩放因子。</p>
<h1 id="imutil模块及其方法"><a href="#imutil模块及其方法" class="headerlink" title="imutil模块及其方法"></a>imutil模块及其方法</h1><h2 id="stretch-方法"><a href="#stretch-方法" class="headerlink" title="stretch()方法"></a>stretch()方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stretch</span>(<span class="params">img, out, rg, rgb=<span class="literal">None</span>, mode=<span class="string">&#x27;set&#x27;</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> img.dtype==np.uint8 <span class="keyword">and</span> rg==(<span class="number">0</span>,<span class="number">255</span>):</span><br><span class="line">        out[:] = img</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        np.subtract(img, rg[<span class="number">0</span>], out=out, casting=<span class="string">&#x27;unsafe&#x27;</span>)</span><br><span class="line">        np.multiply(img, <span class="number">255.0</span>/np.ptp(rg), out=out, casting=<span class="string">&#x27;unsafe&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这一方法实际在这个canvas中只运行了if中的语句，else中的并没有执行，所以其实并没有深刻理解它干了啥。<br>目前看，if中实现了用img来填充out中的内容。注意这个赋值语句中，左边是out的切片，千万不能将这个切片去掉，否则img和out的地址是一样的，即out也指向了img，而如果使用了切片，out还是保留原来的地址指向，只是内容改成了img。知识点可以参见如下：<br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/10623302/how-assignment-works-with-python-list-slice">How assignment works with Python list slice?</a></p>
<h2 id="lookup-方法"><a href="#lookup-方法" class="headerlink" title="lookup()方法"></a>lookup()方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lookup</span>(<span class="params">img, lut, out, mode=<span class="string">&#x27;set&#x27;</span></span>):</span></span><br><span class="line">    blend(lut[img], out, img, mode)</span><br></pre></td></tr></table></figure>
<p>可以看出，lookup()方法实际是调用了下面的blend()方法，所以具体干了啥还要看一下blend()干了啥。<br>但这一步中有一个非常重要的操作，即：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lut[img]</span><br></pre></td></tr></table></figure><br>这一步就是将img作为参数传入了lut查找表中，其实是用到了Numpy的Fancy Indexing，具体知识点可以查看之前一篇博文。<br>值得注意的是，Fancy Indexing返回的数组的shape是索引的shape，所以这一步其实返回的是一个跟img相同shape的另一张图像。<br>所以，这一步的效果就是将图像按照查找表中的颜色进行了重新着色，即当img中的像素值为1时，那么就取lut中的(255, 0, 0)红色。</p>
<h2 id="blend-方法"><a href="#blend-方法" class="headerlink" title="blend()方法"></a>blend()方法</h2><p>blend()方法有很多种模式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">blend</span>(<span class="params">img, out, msk, mode</span>):</span></span><br><span class="line">    <span class="keyword">if</span> mode==<span class="string">&#x27;set&#x27;</span>: out[:] = img</span><br><span class="line">    <span class="keyword">if</span> mode==<span class="string">&#x27;min&#x27;</span>: np.minimum(out, img, out=out)</span><br><span class="line">    <span class="keyword">if</span> mode==<span class="string">&#x27;max&#x27;</span>: np.maximum(out, img, out=out)</span><br><span class="line">    <span class="keyword">if</span> mode==<span class="string">&#x27;msk&#x27;</span>:</span><br><span class="line">        msk = np.logical_not(msk)</span><br><span class="line">        out.T[:] *= msk.T</span><br><span class="line">        out += img</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(mode, <span class="built_in">float</span>):</span><br><span class="line">        np.multiply(out, <span class="number">1</span>-mode, out=out, casting=<span class="string">&#x27;unsafe&#x27;</span>)</span><br><span class="line">        np.multiply(img, mode, out=img, casting=<span class="string">&#x27;unsafe&#x27;</span>)</span><br><span class="line">        out += img</span><br></pre></td></tr></table></figure><br>最终目的就是看按哪一种方式将img和out混合起来：<br>（1）set模式：直接将out里的内容设为img<br>（2）min模式：逐个对比out和img两张图像中的像素，选择数值小的像素存入out<br>（3）max模式：逐个对比out和img两张图像中的像素，选择数值大的像素存入out<br>（4）msk模式：在掩膜msk不为0的地方，将out设为0；在msk为0的地方，保留原值（因为对msk作了逻辑非操作，然后下面主元素相乘时，True为1，False为0）。然后将img和out进行相加合成。<br>（5）按比例混合模式：mode可以是一个小数，即将out与1-mode相乘，img与mode相乘，然后两者相加合成。</p>
<h2 id="mix-img-方法"><a href="#mix-img-方法" class="headerlink" title="mix_img()方法"></a>mix_img()方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mix_img</span>(<span class="params">img, m, o, shp, buf, rgb, byt, rg=(<span class="params"><span class="number">0</span>,<span class="number">255</span></span>), lut=<span class="literal">None</span>, cns=<span class="number">0</span>, mode=<span class="string">&#x27;set&#x27;</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> img <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span></span><br><span class="line">    img = img.reshape((img.shape[<span class="number">0</span>], img.shape[<span class="number">1</span>], -<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(rg, <span class="built_in">tuple</span>): rg = [rg]*img.shape[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(cns, <span class="built_in">int</span>):</span><br><span class="line">        affine_transform(img[:,:,cns], m, o, shp, buf, <span class="number">0</span>, <span class="string">&#x27;nearest&#x27;</span>)</span><br><span class="line">        stretch(buf, byt, rg[cns])</span><br><span class="line">        <span class="keyword">return</span> lookup(byt, lut, rgb, mode)</span><br><span class="line"></span><br><span class="line">    irgb = [cns.index(i) <span class="keyword">if</span> i <span class="keyword">in</span> cns <span class="keyword">else</span> -<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&#x27;rgb&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">enumerate</span>(irgb):</span><br><span class="line">        <span class="keyword">if</span> v==-<span class="number">1</span>: rgb[:,:,i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> mode==<span class="string">&#x27;set&#x27;</span> <span class="keyword">and</span> buf.dtype==np.uint8 <span class="keyword">and</span> rg[v]==(<span class="number">0</span>,<span class="number">255</span>):</span><br><span class="line">            affine_transform(img[:,:,v], m, o, shp, rgb[:,:,v], <span class="number">0</span>, prefilter=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            affine_transform(img[:,:,v], m, o, shp, buf, <span class="number">0</span>, prefilter=<span class="literal">False</span>)</span><br><span class="line">            stretch(buf, byt, rg[v])</span><br><span class="line">            blend(byt, rgb[:,:,v], byt, mode)</span><br></pre></td></tr></table></figure>
<p>mix_img()方法接收的参数特别多：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mix_img</span>(<span class="params">img, m, o, shp, buf, rgb, byt, rg=(<span class="params"><span class="number">0</span>,<span class="number">255</span></span>), lut=<span class="literal">None</span>, cns=<span class="number">0</span>, mode=<span class="string">&#x27;set&#x27;</span></span>):</span></span><br></pre></td></tr></table></figure><br>第一个是img图像，从前面的调用可知，可以传入前景图或背景图；<br>第一个是m，旋转缩放矩阵；<br>第三个是shp，即最终要绘图的区域大小；<br>第四个是buf，其在显示某个通道（即单通道图像）时作为仿射变换后的图像；<br>第五个是rgb，其在显示RGB彩色图时作为仿射变换后的图像，在显示单通道图像时作为混合图像的背景；<br>第六个是byt，这张图像没分析出有什么作用。。；<br>第七个是rg，像素值范围，默认是(0, 255)；<br>第八个是lut，查找表；<br>第九个是cns，通道标识；<br>第十个是mode，混合模式。</p>
<p>具体看一下mix_img的操作：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mix_img</span>(<span class="params">img, m, o, shp, buf, rgb, byt, rg=(<span class="params"><span class="number">0</span>,<span class="number">255</span></span>), lut=<span class="literal">None</span>, log=<span class="literal">True</span>, cns=<span class="number">0</span>, mode=<span class="string">&#x27;set&#x27;</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> img <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span></span><br><span class="line">    img = img.reshape((img.shape[<span class="number">0</span>], img.shape[<span class="number">1</span>], -<span class="number">1</span>))</span><br></pre></td></tr></table></figure><br>首先是对img进行一下reshape，这里是将img的格式统一一下，将原来的两维或三维数组统一为三维数组。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">isinstance</span>(rg, <span class="built_in">tuple</span>): rg = [rg]*img.shape[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><br>这里也是对范围range进行一下统一，如果rg为元组，则将其转化为与img的通道数相匹配的形式，比如原来rg是(0, 255)，若图像是三通道的，则经过转换后，rg变为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="number">0</span>, <span class="number">255</span>), (<span class="number">0</span>, <span class="number">255</span>), (<span class="number">0</span>, <span class="number">255</span>)]</span><br></pre></td></tr></table></figure><br>接下来是对通道的处理：<br>如果cns是一个数，比如就选了一张彩色图中的一个通道显示，或者直接就是一张灰度图，那么：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">isinstance</span>(cns, <span class="built_in">int</span>):</span><br><span class="line">    <span class="keyword">if</span> np.iscomplexobj(buf):</span><br><span class="line">        affine_transform(img[:,:,<span class="number">0</span>].real, m, o, shp, buf.real, <span class="number">0</span>, prefilter=<span class="literal">False</span>)</span><br><span class="line">        affine_transform(img[:,:,<span class="number">0</span>].imag, m, o, shp, buf.imag, <span class="number">0</span>, prefilter=<span class="literal">False</span>)</span><br><span class="line">        buf = complex_norm(buf, buf.real, buf.imag, buf.real)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        affine_transform(img[:,:,cns], m, o, shp, buf, <span class="number">0</span>, prefilter=<span class="literal">False</span>)</span><br><span class="line">    stretch(buf, byt, rg[cns], log)</span><br><span class="line">    <span class="keyword">return</span> lookup(byt, lut, rgb, mode)</span><br></pre></td></tr></table></figure><br>（1）首先判断一下buf是不是复数，这里应该是支持傅里叶变换的图像显示，暂且不分析；<br>（2）否则，就对该图像（灰度图或彩图的某一通道）进行仿射变换，输出到buf中，接着通过stretch转移到byt中，然后再调用lookup，根据上面的分析，lookup实际调用了blend，只是中间转了一下，输入到blend中的是lut(byt)，即将原图用lut转一下，然后再图像混合到rgb，即此种情况下rgb中的颜色是原图在查找表lut中的值。</p>
<p>如果通道标识cns是一个元组形式传入的，则：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">enumerate</span>(cns):</span><br><span class="line">    <span class="keyword">if</span> v==-<span class="number">1</span>: rgb[:,:,i] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> mode==<span class="string">&#x27;set&#x27;</span> <span class="keyword">and</span> img.dtype==np.uint8 <span class="keyword">and</span> rg[v]==(<span class="number">0</span>,<span class="number">255</span>) <span class="keyword">and</span> <span class="keyword">not</span> log:</span><br><span class="line">        affine_transform(img[:,:,v], m, o, shp, rgb[:,:,i], <span class="number">0</span>, prefilter=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        affine_transform(img[:,:,v], m, o, shp, buf, <span class="number">0</span>, prefilter=<span class="literal">False</span>)</span><br><span class="line">        stretch(buf, byt, rg[v], log)</span><br><span class="line">        blend(byt, rgb[:,:,i], byt, mode)</span><br></pre></td></tr></table></figure><br>对通道标识cns进行遍历，这里有多个判断条件：<br>（1）如果某个标识为-1，则将rgb中的相应通道置为0，<br>（2）否则，如果mode为set，且满足dtype、rg的相应条件，则进行仿射变换，注意此时改变的是rgb的相应通道，即将img的相应通道的值经过放射变换赋值给rgb的相应通道。这种情况就是用来显示RGB彩色图；<br>（3）若上述条件都不满足，则进行以下操作，这种情形就是用来显示彩色图的某些通道，但又与单独显示某通道不同：<br>（3.1）仿射变换：注意这里的output是buf，因为buf是单一通道，所以这里直接就是对其本身进行作用；<br>（3.2）stretch：目前这里的测试效果就是将buf的值同样赋值给byt，即byt也是img的仿射变换<br>（3.3）blend：这里是混合模式的设置，注意这里是将byt和rgb的相应通道进行混合，改变的是rgb的值，注意，后面画布绘制出的也是基于self.rgb。</p>
<p>经过上面对于通道标识cns的分析，就可以知道以下两者的不同：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">image.cn = (<span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">image.cn = <span class="number">0</span></span><br></pre></td></tr></table></figure><br>假设图像是一张RGB彩色图，前者是将绿色通道和蓝色通道都置为0，红色通道照常处理，最终呈现的还是三者的综合；而后者是仅选了红色通道，即将红色通道单独摘出来作为一张灰度图显示。</p>
<p>mix_img()方法主要操作就是仿射变换和图像混合。关于仿射变换的具体细节见下面一小节。</p>
<p>以下面的代码为例，看看具体是怎么搞的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">image = Image()</span><br><span class="line">msk = np.zeros(astronaut().shape[:<span class="number">2</span>], dtype=np.uint8)</span><br><span class="line">msk[<span class="number">100</span>:<span class="number">200</span>,<span class="number">100</span>:<span class="number">200</span>] = <span class="number">1</span></span><br><span class="line">msk[<span class="number">200</span>:<span class="number">300</span>,<span class="number">200</span>:<span class="number">300</span>] = <span class="number">2</span></span><br><span class="line">msk[<span class="number">300</span>:<span class="number">400</span>,<span class="number">300</span>:<span class="number">400</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">image.img = msk</span><br><span class="line"> </span><br><span class="line">bak = Image([astronaut()])</span><br><span class="line">bak.cn = (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">image.back = bak</span><br><span class="line">image.mode = <span class="string">&#x27;msk&#x27;</span></span><br><span class="line"></span><br><span class="line">canvas.images.append(image)</span><br></pre></td></tr></table></figure><br>注意，前景图是一个有个别位置不为0的掩膜，背景图是宇航员图，前景图的混合模式是msk。</p>
<p>第一次调用“图像混合”方法时：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mix_img(back.img, m, o, shp, self.outbak,</span><br><span class="line">    self.outrgb, self.outint, back.rg, back.lut,</span><br><span class="line">    back.log, cns=back.cn, mode=<span class="string">&#x27;set&#x27;</span>)</span><br></pre></td></tr></table></figure><br>以宇航员astronaut()图像为例，传入的这些参数实际值是：<br>back.img的shape是(512, 512, 3)，<br>m是(4.0, 4.0)，这个值（包括下面的o和shp）不是固定的，与具体操作有关，这里不是绝对值，<br>o是(0.0, 0.0)，<br>shp是(128, 128)，<br>self.outbak对应形参中的buf，即缓冲，是shape为(128, 128)的全为0的数组，<br>self.outrgb对应形参中的rgb，即彩色图，是shape为(128, 128, 3)的全为0的数组，<br>self.outint对应形参中的byt，即灰度图，是shape为(128, 128)的全为0的数组，<br>back.rg是(0, 255)，即数值范围，<br>back.lut是查找表，这里默认的是shape为(256, 3)的数组，由以下语句构建：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default_lut = np.arange(<span class="number">256</span>*<span class="number">3</span>, dtype=np.uint8).reshape((<span class="number">3</span>,-<span class="number">1</span>)).T</span><br></pre></td></tr></table></figure><br>具体的值为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">array([[  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>],</span><br><span class="line">       [  <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>],</span><br><span class="line">       [  <span class="number">2</span>,   <span class="number">2</span>,   <span class="number">2</span>],</span><br><span class="line">       [  <span class="number">3</span>,   <span class="number">3</span>,   <span class="number">3</span>],</span><br><span class="line">…</span><br><span class="line">       [ <span class="number">254</span>,  <span class="number">254</span>,  <span class="number">254</span>],</span><br><span class="line">       [ <span class="number">255</span>,  <span class="number">255</span>,  <span class="number">255</span>],</span><br></pre></td></tr></table></figure><br>back.log是False，<br>back.cn是通道标识，这里是(0, 1, 2)，<br>mode为’set’。<br>经过这一步的mix_img，改变的只有self.outrgb，其大小仍是(128, 128, 3)，但数值已经变成了img经过仿射变换后的数值。</p>
<p>第二次调用“图像混合”方法时：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mix_img(img.img, m, o, shp, self.outimg,</span><br><span class="line">    self.outrgb, self.outint, img.rg, img.lut,</span><br><span class="line">    img.log, cns=img.cn, mode=img.mode)</span><br></pre></td></tr></table></figure><br>注意，这一次是基于img.img，即前景图，相应的buf、rg、lut、log也都是前景图的属性，值得注意的是这一次仍然调用了self.outrgb，它的值经过了前面背景图的处理，已经变成了背景图的仿射变换。<br>然后，这里因为是msk模式，先是将掩膜（再次强调掩膜是这里的前景图）仿射变换到buf，然后将buf和rgb进行混合，在掩膜不为0的地方，会将rgb的值置为掩膜的值，比如某些位置置为掩膜中的1，然后在显示时，就会去寻找lut中位置为1的颜色。</p>
<h2 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h2><p><a target="_blank" rel="noopener" href="https://sparkydogx.github.io/2018/09/03/affine-with-python/">使用python对2D坐标点进行仿射变换</a><br>仿射变换就是对原图进行缩放、旋转、平移等操作，其示意图如下图（取自上面的文献）：<br><img src="https://user-images.githubusercontent.com/6218739/69029568-54ff6680-0a10-11ea-879e-e1df857d0df2.jpg" alt=""><br>可以通过下面的代码进行探究：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.ndimage <span class="keyword">import</span> affine_transform</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">from</span> skimage.data <span class="keyword">import</span> astronaut</span><br><span class="line"> </span><br><span class="line">img = astronaut()</span><br><span class="line">matrix = (<span class="number">0.5</span>, <span class="number">0.1</span>)</span><br><span class="line"><span class="comment"># theta = np.pi/4</span></span><br><span class="line"><span class="comment"># matrix = ((np.cos(theta), np.sin(theta)), (-np.sin(theta), np.cos(theta)))</span></span><br><span class="line">offset = (<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">shape = img.shape</span><br><span class="line">output = np.zeros(shape, dtype=np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    affine_transform(img[:, :, i], matrix, offset, output.shape[<span class="number">0</span>:<span class="number">2</span>], output[:,:,i])</span><br><span class="line"></span><br><span class="line">io.imshow(output)</span><br><span class="line">io.show()</span><br></pre></td></tr></table></figure><br>对于图中的九种操作，可以按如下参数进行设定得到：<br>（1）no change:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matrix = (<span class="number">1.0</span>, <span class="number">1.0</span>)</span><br><span class="line">offset = <span class="number">0</span></span><br></pre></td></tr></table></figure><br>（2）Translate:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">matrix = (<span class="number">1.0</span>, <span class="number">1.0</span>)</span><br><span class="line">offset = (<span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line"><span class="comment"># or offset = 100</span></span><br></pre></td></tr></table></figure><br>这个地方可以单独为x、y设置偏移，也可以只设置一个数，表示x、y都偏移多少。注意，前面的是y偏移量。<br>（3）Scale about origin:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matrix = (<span class="number">0.5</span>, <span class="number">0.1</span>)</span><br><span class="line">offset = <span class="number">0</span></span><br></pre></td></tr></table></figure><br>小于1为放大倍数，大于1则为缩小倍数。<br>（4）Rotate about origin:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">theta = np.pi/<span class="number">4</span></span><br><span class="line">matrix = ((np.cos(theta), np.sin(theta)), (-np.sin(theta), np.cos(theta)))</span><br><span class="line">offset = <span class="number">0</span></span><br></pre></td></tr></table></figure><br>theta就是旋转角度。<br>（5）Shear in x direction：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">phi = np.pi/<span class="number">6</span></span><br><span class="line">matrix = ((<span class="number">1.0</span>, <span class="number">0.0</span>), (np.tan(phi), <span class="number">1.0</span>))</span><br><span class="line">offset = <span class="number">0</span></span><br></pre></td></tr></table></figure><br>（6）Shear in y direction:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">phi = np.pi/<span class="number">6</span></span><br><span class="line">matrix = ((<span class="number">1.0</span>, np.tan(phi)), (<span class="number">0.0</span>, <span class="number">1.0</span>))</span><br><span class="line">offset = <span class="number">0</span></span><br></pre></td></tr></table></figure><br>（7）Reflect about origin:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matrix = (-<span class="number">1.0</span>, -<span class="number">1.0</span>)</span><br><span class="line">offset = <span class="number">0</span></span><br></pre></td></tr></table></figure><br>实测这样操作后，因为还是显示的第一象限的数据，此时全是黑色。<br>其实可以通过：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">offset = img.shape[<span class="number">0</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure><br>将图像给挪到第一象限中，从而正确显示。<br>（8）Reflect about x-axis<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matrix = (<span class="number">1.0</span>, -<span class="number">1.0</span>)</span><br></pre></td></tr></table></figure><br>同样，通过平移将它挪到第一象限中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">offset = (<span class="number">0</span>, img.shape[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><br>（9）Reflect about y-axis<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matrix = (-<span class="number">1.0</span>, <span class="number">1.0</span>)</span><br></pre></td></tr></table></figure><br>同样，通过平移将它挪到第一象限中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">offset = (img.shape[<span class="number">0</span>], <span class="number">0</span>)</span><br></pre></td></tr></table></figure><br>另外，上面代码中的shape是取的跟原有图像一样的shape，这里可以任意设定大小，那么就可以得到特定形状的输出图像，比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shape = (<span class="number">100</span>, <span class="number">200</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><br>上述代码中img和output都是3通道，也可以output只有1通道，那么相应的输出shape也要改一下，即：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shape = (<span class="number">512</span>, <span class="number">512</span>)</span><br><span class="line">output = np.zeros(shape, dtype=np.uint8)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    affine_transform(img[:, :, i], matrix, offset, output.shape[<span class="number">0</span>:<span class="number">2</span>], output)</span><br></pre></td></tr></table></figure><br>此时虽然做了三次仿射变换，但只有img的第三个通道作用在了output上，它把前两个通道的作用给覆盖了。<br>即输入图像和输出图像可以不是一样的通道数，但affine_transform()的第四个参数shape和第五个参数output它俩一定要对应好。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechat_reward.png" alt="Xin-Bo Qi(亓欣波) WeChat Pay">
        <p>WeChat Pay</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/ImagePy/" rel="tag"># ImagePy</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/10/20/python-indexing/" rel="prev" title="Numpy的广播Broadcasting和奇妙索引Fancy Indexing">
      <i class="fa fa-chevron-left"></i> Numpy的广播Broadcasting和奇妙索引Fancy Indexing
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/11/04/ImagePy_13/" rel="next" title="ImagePy解析：13 -- Macros引擎及宏录制">
      ImagePy解析：13 -- Macros引擎及宏录制 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%BB%E5%B8%83Canvas%E8%BF%90%E8%A1%8C%E6%9C%BA%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">画布Canvas运行机理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%8E%A9%E8%86%9C"><span class="nav-number">1.1.</span> <span class="nav-text">创建掩膜</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%9F%A5%E6%89%BE%E8%A1%A8"><span class="nav-number">1.2.</span> <span class="nav-text">创建查找表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8CCanvas%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.3.</span> <span class="nav-text">创建并运行Canvas对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AECanvas%EF%BC%9A%E8%AE%BE%E7%BD%AE%E5%9B%BE%E5%83%8F"><span class="nav-number">1.4.</span> <span class="nav-text">配置Canvas：设置图像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AECanvas%EF%BC%9A%E8%AE%BE%E7%BD%AE%E6%9F%A5%E6%89%BE%E8%A1%A8"><span class="nav-number">1.5.</span> <span class="nav-text">配置Canvas：设置查找表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AECanvas%EF%BC%9A%E8%AE%BE%E7%BD%AE%E5%9B%BE%E5%83%8F%E9%80%9A%E9%81%93"><span class="nav-number">1.6.</span> <span class="nav-text">配置Canvas：设置图像通道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AECanvas%EF%BC%9A%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF%E5%9B%BE%E5%83%8F"><span class="nav-number">1.7.</span> <span class="nav-text">配置Canvas：设置背景图像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AECanvas%EF%BC%9A%E8%AE%BE%E7%BD%AE%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.8.</span> <span class="nav-text">配置Canvas：设置混合模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Canvas%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">Canvas类及其属性和方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#set-img-%E6%96%B9%E6%B3%95"><span class="nav-number">2.1.</span> <span class="nav-text">set_img()方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set-lut-%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.</span> <span class="nav-text">set_lut()方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set-cn-%E6%96%B9%E6%B3%95"><span class="nav-number">2.3.</span> <span class="nav-text">set_cn()方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set-back-%E6%96%B9%E6%B3%95"><span class="nav-number">2.4.</span> <span class="nav-text">set_back()方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set-mode-%E6%96%B9%E6%B3%95"><span class="nav-number">2.5.</span> <span class="nav-text">set_mode()方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set-rg"><span class="nav-number">2.6.</span> <span class="nav-text">set_rg()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#initBuffer-%E6%96%B9%E6%B3%95"><span class="nav-number">2.7.</span> <span class="nav-text">initBuffer()方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#update-%E6%96%B9%E6%B3%95"><span class="nav-number">2.8.</span> <span class="nav-text">update()方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#draw-image-%E6%96%B9%E6%B3%95"><span class="nav-number">2.9.</span> <span class="nav-text">draw_image()方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94"><span class="nav-number">2.10.</span> <span class="nav-text">事件响应</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E5%B0%BA%E5%AF%B8%E6%94%B9%E5%8F%98"><span class="nav-number">2.10.1.</span> <span class="nav-text">窗口尺寸改变</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6"><span class="nav-number">2.10.2.</span> <span class="nav-text">鼠标事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E4%BA%8B%E4%BB%B6"><span class="nav-number">2.10.3.</span> <span class="nav-text">空闲事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%98%E5%9B%BE%E4%BA%8B%E4%BB%B6"><span class="nav-number">2.10.4.</span> <span class="nav-text">绘图事件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#boxutil%E6%A8%A1%E5%9D%97%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">boxutil模块及其方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#cross-%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.</span> <span class="nav-text">cross()方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lay-%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">lay()方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mat-%E6%96%B9%E6%B3%95"><span class="nav-number">3.3.</span> <span class="nav-text">mat()方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#imutil%E6%A8%A1%E5%9D%97%E5%8F%8A%E5%85%B6%E6%96%B9%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">imutil模块及其方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#stretch-%E6%96%B9%E6%B3%95"><span class="nav-number">4.1.</span> <span class="nav-text">stretch()方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lookup-%E6%96%B9%E6%B3%95"><span class="nav-number">4.2.</span> <span class="nav-text">lookup()方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#blend-%E6%96%B9%E6%B3%95"><span class="nav-number">4.3.</span> <span class="nav-text">blend()方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mix-img-%E6%96%B9%E6%B3%95"><span class="nav-number">4.4.</span> <span class="nav-text">mix_img()方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2"><span class="nav-number">4.5.</span> <span class="nav-text">仿射变换</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Xin-Bo Qi(亓欣波)"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Xin-Bo Qi(亓欣波)</p>
  <div class="site-description" itemprop="description">Digitize everything to realize Digitalization!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">142</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/qixinbo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;qixinbo" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:qixinbo@gmail.com" title="E-Mail → mailto:qixinbo@gmail.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/qixinbo" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;qixinbo" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fas fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.tsinghua.edu.cn/" title="https:&#x2F;&#x2F;www.tsinghua.edu.cn" rel="noopener" target="_blank">THU</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.imr.cas.cn/" title="http:&#x2F;&#x2F;www.imr.cas.cn" rel="noopener" target="_blank">IMR</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.sdu.edu.cn/" title="http:&#x2F;&#x2F;www.sdu.edu.cn" rel="noopener" target="_blank">SDU</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://liam0205.me/" title="http:&#x2F;&#x2F;liam0205.me&#x2F;" rel="noopener" target="_blank">黄晨成</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xin-Bo Qi(亓欣波)</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://qixinbo.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://qixinbo.github.io/2019/10/29/ImagePy_12/";
    this.page.identifier = "2019/10/29/ImagePy_12/";
    this.page.title = "ImagePy解析：12 -- 画布Canvas类详解";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://qixinbo.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
