<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>数字旗手</title>
  
  <subtitle>电气化、自动化、数字化、智能化、智慧化</subtitle>
  <link href="http://qixinbo.github.io/atom.xml" rel="self"/>
  
  <link href="http://qixinbo.github.io/"/>
  <updated>2022-07-01T06:05:06.761Z</updated>
  <id>http://qixinbo.github.io/</id>
  
  <author>
    <name>Xin-Bo Qi(亓欣波)</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>轻量级PyTorch通用训练模板pytorch-accelerated解析：5 -- Trainer运行及案例赏析</title>
    <link href="http://qixinbo.github.io/2022/06/26/pytorch-accelerated_5/"/>
    <id>http://qixinbo.github.io/2022/06/26/pytorch-accelerated_5/</id>
    <published>2022-06-25T16:00:00.000Z</published>
    <updated>2022-07-01T06:05:06.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>首先对<code>pytorch-accelerated</code>的核心类<code>Trainer</code>进行逐行代码的注释理解，然后再以官方的几个例子进行注解说明。</p><h1 id="Trainer逐行代码注解"><a href="#Trainer逐行代码注解" class="headerlink" title="Trainer逐行代码注解"></a>Trainer逐行代码注解</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Copyright © 2021 Chris Hughes</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> <span class="type">Callable</span></span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> accelerate <span class="keyword">import</span> Accelerator, DistributedType</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="comment"># 导入内置的回调函数</span></span><br><span class="line"><span class="keyword">from</span> pytorch_accelerated.callbacks <span class="keyword">import</span> (</span><br><span class="line">    CallbackHandler,</span><br><span class="line">    LogMetricsCallback,</span><br><span class="line">    PrintProgressCallback,</span><br><span class="line">    TerminateOnNaNCallback,</span><br><span class="line">    StopTrainingError,</span><br><span class="line">    ProgressBarCallback,</span><br><span class="line">    MoveModulesToDeviceCallback,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> pytorch_accelerated.run_config <span class="keyword">import</span> TrainerRunConfig</span><br><span class="line"><span class="keyword">from</span> pytorch_accelerated.tracking <span class="keyword">import</span> RunHistory, InMemoryRunHistory, LossTracker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认使用的回调函数有如下5个：</span></span><br><span class="line">DEFAULT_CALLBACKS = (</span><br><span class="line">    <span class="comment"># 该回调在训练或评估开始时，将所有属于`torch.nn.Module`的实例（除了网络模型）的`trainer`属性移动到相应的设备上。</span></span><br><span class="line">    MoveModulesToDeviceCallback,</span><br><span class="line">    <span class="comment"># 该回调在训练时监测是否出现&#x27;NaN&#x27;损失值，从而及时终止训练</span></span><br><span class="line">    TerminateOnNaNCallback,</span><br><span class="line">    <span class="comment"># 打印进度</span></span><br><span class="line">    PrintProgressCallback,</span><br><span class="line">    <span class="comment"># 进度条</span></span><br><span class="line">    ProgressBarCallback,</span><br><span class="line">    <span class="comment"># 指标记录</span></span><br><span class="line">    LogMetricsCallback,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一些学习率调度器需要一些信息，比如在训练运行期间发生的总步数。</span></span><br><span class="line"><span class="comment"># 由于在创建训练数据加载器之前无法获得这些信息（它们是`Trainer.train`中产生的），在这种情况下可以使用一个占位符值，比如：</span></span><br><span class="line"><span class="comment"># from functools import Partial</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># from pytorch_accelerated import TrainerPlaceholderValues</span></span><br><span class="line"><span class="comment"># from torch.optim.lr_scheduler import OneCycleLR</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create_scheduler_fn = partial(</span></span><br><span class="line"><span class="comment">#             OneCycleLR,</span></span><br><span class="line"><span class="comment">#             max_lr=config.lr,</span></span><br><span class="line"><span class="comment">#             epochs=TrainerPlaceholderValues.NUM_EPOCHS,</span></span><br><span class="line"><span class="comment">#             steps_per_epoch=TrainerPlaceholderValues.NUM_UPDATE_STEPS_PER_EPOCH,</span></span><br><span class="line"><span class="comment">#         )</span></span><br><span class="line"><span class="comment"># 这些占位符将由trainer在训练期间使用正确的数值替换。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体实现原理如下。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先TrainerPlaceholderValues派生自Enum，关于该类的用法仔细阅读如下两篇：</span></span><br><span class="line"><span class="comment"># https://docs.python.org/3/library/enum.html</span></span><br><span class="line"><span class="comment"># https://www.pythontutorial.net/python-oop/python-enum-class/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrainerPlaceholderValues</span>(<span class="params">Enum</span>):</span></span><br><span class="line">    <span class="comment"># 这些枚举数值实际会调用trainer中的变量及配置</span></span><br><span class="line">    NUM_EPOCHS = <span class="string">&quot;trainer.run_config.num_epochs&quot;</span></span><br><span class="line">    NUM_UPDATE_STEPS_PER_EPOCH = <span class="string">&quot;trainer.run_config.num_update_steps_per_epoch&quot;</span></span><br><span class="line">    TRAIN_DATALOADER_LEN = <span class="string">&quot;len(trainer._train_dataloader)&quot;</span></span><br><span class="line">    EVAL_DATALOADER_LEN = <span class="string">&quot;len(trainer._eval_dataloader)&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类方法，教程参考：</span></span><br><span class="line">    <span class="comment"># https://www.jianshu.com/p/87608d92fafe</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">placeholder_set</span>(<span class="params">cls</span>):</span></span><br><span class="line">        <span class="keyword">return</span> &#123;placeholder.name <span class="keyword">for</span> placeholder <span class="keyword">in</span> cls&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__create_new_enum</span>(<span class="params">original_enum, other, operation</span>):</span></span><br><span class="line">        enum_members = &#123;k: v.value <span class="keyword">for</span> k, v <span class="keyword">in</span> original_enum._member_map_.items()&#125;</span><br><span class="line">        enum_members[</span><br><span class="line">            original_enum.name</span><br><span class="line">        ] = <span class="string">f&quot;<span class="subst">&#123;enum_members[original_enum.name]&#125;</span><span class="subst">&#123;operation&#125;</span><span class="subst">&#123;other&#125;</span>&quot;</span></span><br><span class="line">        new_enum = Enum(<span class="string">&quot;TrainerPlaceholderValues&quot;</span>, enum_members)</span><br><span class="line">        <span class="keyword">return</span> new_enum._member_map_[original_enum.name]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__create_new_enum(self, other, <span class="string">&quot;*&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__create_new_enum(self, other, <span class="string">&quot;+&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__sub__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> <span class="literal">NotImplemented</span>(</span><br><span class="line">            <span class="string">&quot;Subtraction is not supported, please re-write the expression in terms of addition&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果实例instance是一个偏函数对象，且包含了关键字，将替换它们，返回一个新的偏函数对象</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replace_trainer_placeholder_values</span>(<span class="params">trainer, instance</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(instance, partial):</span><br><span class="line">        placeholders = TrainerPlaceholderValues.placeholder_set()</span><br><span class="line">        keywords = <span class="built_in">list</span>(instance.keywords.items())</span><br><span class="line"></span><br><span class="line">        new_keywords = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> keyword, value <span class="keyword">in</span> keywords:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">hasattr</span>(value, <span class="string">&quot;name&quot;</span>):</span><br><span class="line">                <span class="comment"># 如果value有name属性，且在TrainerPlaceholderValues的占位符集合中</span></span><br><span class="line">                <span class="keyword">if</span> value.name <span class="keyword">in</span> placeholders:</span><br><span class="line">                    <span class="comment"># 则马上计算该占位符（即枚举值）的表达式，教程见：</span></span><br><span class="line">                    <span class="comment"># https://www.runoob.com/python/python-func-eval.html</span></span><br><span class="line">                    new_keywords[keyword] = <span class="built_in">eval</span>(value.value)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    new_keywords[keyword] = value</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                new_keywords[keyword] = value</span><br><span class="line"></span><br><span class="line">        instance = partial(instance.func, *instance.args, **new_keywords)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trainer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        self,</span></span></span><br><span class="line"><span class="function"><span class="params">        model,</span></span></span><br><span class="line"><span class="function"><span class="params">        loss_func,</span></span></span><br><span class="line"><span class="function"><span class="params">        optimizer,</span></span></span><br><span class="line"><span class="function"><span class="params">        callbacks=DEFAULT_CALLBACKS,</span></span></span><br><span class="line"><span class="function"><span class="params">        run_history=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>):</span></span><br><span class="line">        <span class="comment"># 传入模型，后面会被替换成被accelerate封装后的模型</span></span><br><span class="line">        self.model = model</span><br><span class="line">        <span class="comment"># 传入损失函数</span></span><br><span class="line">        self.loss_func = loss_func</span><br><span class="line">        <span class="comment"># 传入优化器，后面会被替换成被accelerate封装后的优化器</span></span><br><span class="line">        self.optimizer = optimizer</span><br><span class="line">        <span class="comment"># 将回调事件列表作为参数传入“回调函数句柄”</span></span><br><span class="line">        <span class="comment"># 该句柄的call_event()方法有如下形式：</span></span><br><span class="line">        <span class="comment"># def call_event(self, event, *args, **kwargs):</span></span><br><span class="line">        <span class="comment"># 即传入一个event事件及参数列表，然后该方法会判断该event在哪些回调函数中存在（即存在该成员函数或成员变量）</span></span><br><span class="line">        self.callback_handler = CallbackHandler(</span><br><span class="line">            callbacks,</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 传入运行历史，该运行历史应该是RunHistory类型</span></span><br><span class="line">        <span class="comment"># 如果是None的话，就使用默认实现的InMemoryRunHistory()</span></span><br><span class="line">        <span class="comment"># 也可以自己手写基于基类RunHistory的实现</span></span><br><span class="line">        self.run_history: RunHistory = (</span><br><span class="line">            run_history <span class="keyword">if</span> run_history <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> InMemoryRunHistory()</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 创建一个accelerate.Accelerator的实例，用于管理训练过程</span></span><br><span class="line">        self._accelerator = self._create_accelerator()</span><br><span class="line">        <span class="comment"># 创建一个损失追踪器</span></span><br><span class="line">        self._loss_tracker = LossTracker()</span><br><span class="line">        <span class="comment"># 下面是一些内部变量，它们的值会在训练过程中被设置</span></span><br><span class="line">        self.create_scheduler_fn = <span class="literal">None</span></span><br><span class="line">        self.scheduler = <span class="literal">None</span></span><br><span class="line">        self.collate_fn = <span class="literal">None</span></span><br><span class="line">        self.train_dataset = <span class="literal">None</span></span><br><span class="line">        self.eval_dataset = <span class="literal">None</span></span><br><span class="line">        self._train_dataloader = <span class="literal">None</span></span><br><span class="line">        self._train_dl_kwargs = <span class="literal">None</span></span><br><span class="line">        self._eval_dl_kwargs = <span class="literal">None</span></span><br><span class="line">        self._eval_dataloader = <span class="literal">None</span></span><br><span class="line">        self.run_config: TrainerRunConfig = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化Trainer的末尾会调用一下`on_init_end`事件</span></span><br><span class="line">        <span class="comment"># 目前来看这几个内置的回调函数都没有该属性</span></span><br><span class="line">        self.callback_handler.call_event(<span class="string">&quot;on_init_end&quot;</span>, self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_create_accelerator</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Create an instance of :class:`accelerate.Accelerator` which will be used to manage training.</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> Accelerator()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建训练集的dataloader</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_train_dataloader</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        self, batch_size: <span class="built_in">int</span>, train_dl_kwargs: <span class="built_in">dict</span> = <span class="literal">None</span></span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) -&gt; Iterable:</span></span><br><span class="line">        <span class="comment"># 首先获得默认的训练集dataloader的参数，包括&quot;shuffle&quot;、&quot;pin_memory&quot;、&quot;batch_size&quot;和&quot;num_workers&quot;配置</span></span><br><span class="line">        default_train_dl_kwargs = self.get_default_train_dl_kwargs(batch_size)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果明确指定了参数字典，则对默认的字典进行更新，用 update 更新字典 a，会有两种情况：</span></span><br><span class="line">        <span class="comment"># （1）有相同的键时：会使用最新的字典 b 中 该 key 对应的 value 值。</span></span><br><span class="line">        <span class="comment"># （2）有新的键时：会直接把字典 b 中的 key、value 加入到 a 中。</span></span><br><span class="line">        <span class="keyword">if</span> train_dl_kwargs <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            default_train_dl_kwargs.update(train_dl_kwargs)</span><br><span class="line"></span><br><span class="line">        self._train_dl_kwargs = default_train_dl_kwargs</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 最终是调用torch原生的DataLoader来创建数据加载器</span></span><br><span class="line">        <span class="keyword">return</span> DataLoader(</span><br><span class="line">            dataset=self.train_dataset,</span><br><span class="line">            collate_fn=self.collate_fn,</span><br><span class="line">            **self._train_dl_kwargs,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_eval_dataloader</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        self, batch_size: <span class="built_in">int</span>, eval_dl_kwargs: <span class="built_in">dict</span> = <span class="literal">None</span></span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) -&gt; Iterable:</span></span><br><span class="line">        <span class="comment"># 首先获得默认的验证集dataloader的参数，包括&quot;shuffle&quot;、&quot;pin_memory&quot;、&quot;batch_size&quot;和&quot;num_workers&quot;配置</span></span><br><span class="line">        <span class="comment"># 与训练集不同的是，验证集的shuffle是False</span></span><br><span class="line">        default_eval_dl_kwargs = self.get_default_eval_dl_kwargs(batch_size)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> eval_dl_kwargs <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            default_eval_dl_kwargs.update(eval_dl_kwargs)</span><br><span class="line"></span><br><span class="line">        self._eval_dl_kwargs = default_eval_dl_kwargs</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> DataLoader(</span><br><span class="line">            dataset=self.eval_dataset,</span><br><span class="line">            collate_fn=self.collate_fn,</span><br><span class="line">            **self._eval_dl_kwargs,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 基于之前传递给Trainer的工厂函数创建一个学习率调度器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_scheduler</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 该工厂函数是个偏函数对象，它里面的关键词参数如果用到了占位符，会被实时结果所更新替代</span></span><br><span class="line">        scheduler_type = replace_trainer_placeholder_values(</span><br><span class="line">            self, self.create_scheduler_fn</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 该工厂函数再接收优化器参数，从而返回调度器实例</span></span><br><span class="line">        <span class="keyword">return</span> scheduler_type(self.optimizer)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">training_run_start</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        This method is called at the start of a training run.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每一训练epoch开始时的动作</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train_epoch_start</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 默认行为是将模型设置成train模式，教程见：</span></span><br><span class="line">        <span class="comment"># https://zhuanlan.zhihu.com/p/494060986</span></span><br><span class="line">        self.model.train()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算训练时的损失</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate_train_batch_loss</span>(<span class="params">self, batch</span>) -&gt; <span class="built_in">dict</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Calculates the training loss and return this along with the batch size and model outputs.</span></span><br><span class="line"><span class="string">        Any additional values returned will be available in the :meth:`~callbacks.TrainerCallback.on_train_step_end` callback method.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param batch: the output of the train dataloader</span></span><br><span class="line"><span class="string">        :return: A dictionary containing the training loss, model outputs and batch size. Can include any keys, but must include the keys &#x27;loss&#x27;, &#x27;model_outputs&#x27; and &#x27;batch_size&#x27;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 获得x和y</span></span><br><span class="line">        xb, yb = batch[<span class="number">0</span>], batch[<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># 将x输入模型，获得预测值</span></span><br><span class="line">        model_outputs = self.model(xb)</span><br><span class="line">        <span class="comment"># 计算损失值</span></span><br><span class="line">        loss = self.loss_func(model_outputs, yb)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回值包括损失、模型输出值和batch size</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">&quot;loss&quot;</span>: loss,</span><br><span class="line">            <span class="string">&quot;model_outputs&quot;</span>: model_outputs,</span><br><span class="line">            <span class="string">&quot;batch_size&quot;</span>: yb.size(<span class="number">0</span>),</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward_step</span>(<span class="params">self, loss</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Use the accelerator to perform the backward pass on the calculated value of the loss returned by :meth:`~Trainer.calculate_train_batch_loss`.</span></span><br><span class="line"><span class="string">        If gradient accumulation is enabled, this loss has been scaled by 1 / accumulation steps.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param loss: The loss tensor returned by :meth:`~Trainer.calculate_train_batch_loss`.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self._accelerator.backward(loss)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">optimizer_step</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Performs a single optimization step and updates the parameters which have been passed to ``self.optimizer``.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.optimizer.step()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scheduler_step</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Performs a single scheduler step if ``self.scheduler`` has been assigned.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.scheduler <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.scheduler.step()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">optimizer_zero_grad</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Sets the gradients of all optimized ``torch.Tensor`` s to zero.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train_epoch_end</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        This method is called at the end of each training epoch.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eval_epoch_start</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        This method is called at the start of an evaluation epoch.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        The default behaviour of this method is to call ``self.model.eval()``</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate_eval_batch_loss</span>(<span class="params">self, batch</span>) -&gt; <span class="built_in">dict</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Calculates the evaluation loss and return this along with the batch size and model outputs.</span></span><br><span class="line"><span class="string">        Any additional values returned will be available in the :meth:`~callbacks.TrainerCallback.on_eval_step_end` callback.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param batch: the output of the eval dataloader</span></span><br><span class="line"><span class="string">        :return: A dictionary containing the evaluation loss, model outputs and batch size. Can include any keys, but must include the keys ``loss``, ``model_outputs`` and ``batch_size``</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            xb, yb = batch[<span class="number">0</span>], batch[<span class="number">1</span>]</span><br><span class="line">            model_outputs = self.model(xb)</span><br><span class="line">            val_loss = self.loss_func(model_outputs, yb)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">&quot;loss&quot;</span>: val_loss,</span><br><span class="line">            <span class="string">&quot;model_outputs&quot;</span>: model_outputs,</span><br><span class="line">            <span class="string">&quot;batch_size&quot;</span>: yb.size(<span class="number">0</span>),</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eval_epoch_end</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        This method is called at the end of an evaluation epoch.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">training_run_epoch_end</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        This method is called during a training run after both training and evaluation epochs have been completed.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">training_run_end</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        This method is called at the end of a training run.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evaluation_run_start</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        This method is called at the start of an evaluation run.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evaluation_run_end</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        This method is called at the end of an evaluation run.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># train是Trainer的入口函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        self,</span></span></span><br><span class="line"><span class="function"><span class="params">        train_dataset,</span></span></span><br><span class="line"><span class="function"><span class="params">        num_epochs,</span></span></span><br><span class="line"><span class="function"><span class="params">        eval_dataset=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        per_device_batch_size=<span class="number">8</span>, <span class="comment"># 默认每个设备上的batch size是8</span></span></span></span><br><span class="line"><span class="function"><span class="params">        max_num_train_steps=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        gradient_accumulation_steps=<span class="number">1</span>, <span class="comment"># 默认梯度累加步数为1</span></span></span></span><br><span class="line"><span class="function"><span class="params">        gradient_clip_value=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        create_scheduler_fn: <span class="type">Callable</span> = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        train_dataloader_kwargs: <span class="built_in">dict</span> = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        eval_dataloader_kwargs: <span class="built_in">dict</span> = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        reset_run_history=<span class="literal">True</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        collate_fn=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>):</span></span><br><span class="line">        <span class="comment"># 传入训练集</span></span><br><span class="line">        self.train_dataset = train_dataset</span><br><span class="line">        <span class="comment"># 传入验证集，默认为None</span></span><br><span class="line">        self.eval_dataset = eval_dataset</span><br><span class="line">        <span class="comment"># 传入调度器，默认为None</span></span><br><span class="line">        <span class="comment"># 注意，这里不是传递一个学习率调度器的实例，而是传递一个能返回这样的实例的工厂函数。</span></span><br><span class="line">        self.create_scheduler_fn = create_scheduler_fn</span><br><span class="line">        <span class="comment"># 传入数据加载器所使用的collate函数，该函数指定如何整理样本以形成一个mini-batch的样本，默认为None，即使用默认的整理方法</span></span><br><span class="line">        <span class="comment"># https://zhuanlan.zhihu.com/p/361830892</span></span><br><span class="line">        self.collate_fn = collate_fn</span><br><span class="line">        <span class="comment"># 如果指定重置运行历史，则调用run_history的reset方法</span></span><br><span class="line">        <span class="comment"># 对于默认的InMemoryRunHistory()，具体就是做了：</span></span><br><span class="line">        <span class="comment"># （1）_current_epoch设为1，</span></span><br><span class="line">        <span class="comment"># （2）_metrics设为defaultdict(list)，这里用了defaultdict，是怕字典里没有key时报错，</span></span><br><span class="line">        <span class="comment"># 教程见：https://www.jianshu.com/p/bbd258f99fd3</span></span><br><span class="line">        <span class="keyword">if</span> reset_run_history:</span><br><span class="line">            self.run_history.reset()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 传入batch_size及训练集数据加载器的参数，创建训练集dataloader</span></span><br><span class="line">        <span class="comment"># 接下来会被替换成被accelerate封装后的加载器</span></span><br><span class="line">        self._train_dataloader = self.create_train_dataloader(</span><br><span class="line">            batch_size=per_device_batch_size, train_dl_kwargs=train_dataloader_kwargs</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果明确指定了验证集后，则以与上面训练集dataloader同样的方式创建验证集的dataloader</span></span><br><span class="line">        <span class="comment"># 两者区别是验证集的默认的shuffle是False</span></span><br><span class="line">        <span class="keyword">if</span> self.eval_dataset <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 接下来它也会被替换成被accelerate封装后的加载器</span></span><br><span class="line">            self._eval_dataloader = self.create_eval_dataloader(</span><br><span class="line">                batch_size=per_device_batch_size, eval_dl_kwargs=eval_dataloader_kwargs</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将模型、优化器和dataloader放到accelerate上</span></span><br><span class="line">        self._prepare_model_optimizer_and_dataloaders()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 封装运行配置</span></span><br><span class="line">        self.run_config = self._create_run_config(</span><br><span class="line">            num_epochs=num_epochs,</span><br><span class="line">            gradient_accumulation_steps=gradient_accumulation_steps,</span><br><span class="line">            max_num_train_steps=max_num_train_steps,</span><br><span class="line">            per_device_batch_size=per_device_batch_size,</span><br><span class="line">            gradient_clip_value=gradient_clip_value,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建调度器实例</span></span><br><span class="line">        <span class="keyword">if</span> self.create_scheduler_fn <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.scheduler = self.create_scheduler()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 开始训练</span></span><br><span class="line">        self._run_training()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evaluate</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        self,</span></span></span><br><span class="line"><span class="function"><span class="params">        dataset=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        per_device_batch_size=<span class="number">8</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        dataloader_kwargs: <span class="built_in">dict</span> = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        collate_fn=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Start an evaluation run.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        .. Note:: Starting an evaluation run will reset the :class:`Trainer`&#x27;s run history.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        .. Note:: During distributed evaluation, if the `per_device_batch_size` * the number of processes used does not exactly divide the dataset, and `drop_last=False` has not been passed as a dataloader kwarg, the dataloader will repeat from the start in processes that run out of batches. This should be taken into consideration when calculating metrics.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param dataset: the dataset to use during evaluation</span></span><br><span class="line"><span class="string">        :param per_device_batch_size: the batch size to use per device</span></span><br><span class="line"><span class="string">        :param dataloader_kwargs: a dictionary of keyword arguments to pass to the dataloader constructor, for details see :class:`torch.utils.data.DataLoader`</span></span><br><span class="line"><span class="string">        :param collate_fn: the collate function to be used by the dataloader</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.eval_dataset = dataset</span><br><span class="line">        self.collate_fn = collate_fn</span><br><span class="line"></span><br><span class="line">        self.run_history.reset()</span><br><span class="line"></span><br><span class="line">        self._train_dataloader = <span class="literal">None</span></span><br><span class="line">        self._eval_dataloader = self.create_eval_dataloader(</span><br><span class="line">            batch_size=per_device_batch_size, eval_dl_kwargs=dataloader_kwargs</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self._prepare_model_optimizer_and_dataloaders()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.run_config <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.run_config = self._create_run_config(</span><br><span class="line">                num_epochs=<span class="number">1</span>,</span><br><span class="line">                gradient_accumulation_steps=<span class="number">0</span>,</span><br><span class="line">                max_num_train_steps=<span class="literal">None</span>,</span><br><span class="line">                per_device_batch_size=per_device_batch_size,</span><br><span class="line">                gradient_clip_value=<span class="literal">None</span>,</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        self._run_evaluation()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_default_train_dl_kwargs</span>(<span class="params">self, batch_size</span>) -&gt; <span class="built_in">dict</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Return the default arguments that will be used by the training dataloader.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param batch_size: the batch size to use during training</span></span><br><span class="line"><span class="string">        :return: a dictionary containing the default arguments for the training dataloader</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">&quot;shuffle&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">            <span class="string">&quot;pin_memory&quot;</span>: <span class="literal">True</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="literal">False</span>,</span><br><span class="line">            <span class="string">&quot;batch_size&quot;</span>: batch_size,</span><br><span class="line">            <span class="string">&quot;num_workers&quot;</span>: <span class="built_in">max</span>(</span><br><span class="line">                os.cpu_count() // torch.cuda.device_count()</span><br><span class="line">                <span class="keyword">if</span> torch.cuda.is_available()</span><br><span class="line">                <span class="keyword">else</span> os.cpu_count(),</span><br><span class="line">                <span class="number">1</span>,</span><br><span class="line">            ),</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_default_eval_dl_kwargs</span>(<span class="params">self, batch_size</span>) -&gt; <span class="built_in">dict</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Return the default arguments that will be used by the evaluation dataloader.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param batch_size: the batch size to use during evaluation</span></span><br><span class="line"><span class="string">        :return: a dictionary containing the default arguments for the evaluation dataloader</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">&quot;shuffle&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">            <span class="string">&quot;pin_memory&quot;</span>: <span class="literal">True</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="literal">False</span>,</span><br><span class="line">            <span class="string">&quot;batch_size&quot;</span>: batch_size,</span><br><span class="line">            <span class="string">&quot;num_workers&quot;</span>: <span class="built_in">max</span>(</span><br><span class="line">                os.cpu_count() // torch.cuda.device_count()</span><br><span class="line">                <span class="keyword">if</span> torch.cuda.is_available()</span><br><span class="line">                <span class="keyword">else</span> os.cpu_count(),</span><br><span class="line">                <span class="number">1</span>,</span><br><span class="line">            ),</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">device</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Use the internal instance of :class:`accelerate.Accelerator` to get the appropriate device</span></span><br><span class="line"><span class="string">        :return: an instance of `torch.device`</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._accelerator.device</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_prepare_model_optimizer_and_dataloaders</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        使用`accelerate.Accelerator`将模型、优化器和数据加载器包裹在任何训练所需的包装器中，并确保参数被放置在适当的设备上。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self._accelerator.free_memory()</span><br><span class="line">        self._accelerator = self._create_accelerator()</span><br><span class="line"></span><br><span class="line">        components = [self.model, self.optimizer]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self._train_dataloader <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            components.append(self._train_dataloader)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self._eval_dataloader <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            components.append(self._eval_dataloader)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 准备与训练相关的对象（优化器、模型、训练集dataloader、验证集dataloader）</span></span><br><span class="line">        <span class="comment"># 这使得这些东西做好训练的准备</span></span><br><span class="line">        prepared_components = self._accelerator.prepare(*components)</span><br><span class="line"></span><br><span class="line">        self.model = prepared_components[<span class="number">0</span>]</span><br><span class="line">        self.optimizer = prepared_components[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这个if和elif会区分是训练阶段还是测试阶段</span></span><br><span class="line">        <span class="comment"># 训练数据加载器将在所有可用的GPU/TPU核中上进行分片，以便每个核看到训练数据集的不同部分。此外，所有进程的随机状态将在每次迭代开始时在dataloader中进行同步，以确保数据以相同的方式被打乱（如果决定使用shuffle=True或任何种类的随机采样器）。</span></span><br><span class="line">        <span class="comment"># 训练的实际批次大小将是所使用的设备数量乘以在脚本中设置的批次大小：例如，在4个GPU上训练，在创建训练数据加载器时设置的批次大小为16，则实际训练的批次大小为64。另外，可以在创建Accelerator时使用split_batches=True选项，在这种情况下，无论在1、2、4还是64个GPU上运行脚本，批次大小都会保持一致。</span></span><br><span class="line">        <span class="keyword">if</span> self._train_dataloader <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self._train_dataloader = prepared_components[<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">if</span> self._eval_dataloader <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                self._eval_dataloader = prepared_components[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> self._eval_dataloader <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self._eval_dataloader = prepared_components[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建运行配置</span></span><br><span class="line">    <span class="comment"># 将运行配置集合在一个地方</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_create_run_config</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        self,</span></span></span><br><span class="line"><span class="function"><span class="params">        per_device_batch_size,</span></span></span><br><span class="line"><span class="function"><span class="params">        num_epochs,</span></span></span><br><span class="line"><span class="function"><span class="params">        gradient_accumulation_steps,</span></span></span><br><span class="line"><span class="function"><span class="params">        max_num_train_steps,</span></span></span><br><span class="line"><span class="function"><span class="params">        gradient_clip_value,</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) -&gt; TrainerRunConfig:</span></span><br><span class="line">        <span class="comment"># 获得train_per_device_batch_size配置</span></span><br><span class="line">        <span class="keyword">if</span> self._train_dl_kwargs <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># get()方法返回指定键的值，如果键不在字典中返回默认值 None 或者设置的默认值。</span></span><br><span class="line">            train_per_device_batch_size = self._train_dl_kwargs.get(</span><br><span class="line">                <span class="string">&quot;batch_size&quot;</span>, per_device_batch_size</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            train_per_device_batch_size = per_device_batch_size</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获得eval_per_device_batch_size配置</span></span><br><span class="line">        <span class="keyword">if</span> self._eval_dl_kwargs <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            eval_per_device_batch_size = self._eval_dl_kwargs.get(</span><br><span class="line">                <span class="string">&quot;batch_size&quot;</span>, train_per_device_batch_size</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            eval_per_device_batch_size = train_per_device_batch_size</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获得num_update_steps_per_epoch配置</span></span><br><span class="line">        <span class="keyword">if</span> self._train_dataloader <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 这个地方涉及梯度累加步数，关于梯度累加，一些参考教程见：</span></span><br><span class="line">            <span class="comment"># https://blog.kamino.link/2021/10/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A2%AF%E5%BA%A6%E7%B4%AF%E5%8A%A0Pytorch%E5%AE%9E%E7%8E%B0/</span></span><br><span class="line">            <span class="comment"># https://www.cnblogs.com/lart/p/11628696.html</span></span><br><span class="line">            <span class="comment"># https://zhuanlan.zhihu.com/p/351999133</span></span><br><span class="line"></span><br><span class="line">            num_update_steps_per_epoch = math.ceil(</span><br><span class="line">                <span class="built_in">len</span>(self._train_dataloader) / gradient_accumulation_steps</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            num_update_steps_per_epoch = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获得max_num_train_steps配置</span></span><br><span class="line">        <span class="comment"># 如果未明确配置它，则根据其他参数计算</span></span><br><span class="line">        <span class="keyword">if</span> max_num_train_steps <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            max_num_train_steps = num_epochs * num_update_steps_per_epoch</span><br><span class="line">        <span class="comment"># 如果明确配置它了，则对num_epochs这个参数重新计算一下</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            num_epochs = math.ceil(max_num_train_steps / num_update_steps_per_epoch)</span><br><span class="line"></span><br><span class="line">        config = &#123;</span><br><span class="line">            <span class="string">&quot;num_epochs&quot;</span>: num_epochs,</span><br><span class="line">            <span class="string">&quot;train_per_device_batch_size&quot;</span>: train_per_device_batch_size,</span><br><span class="line">            <span class="string">&quot;train_dl_kwargs&quot;</span>: self._train_dl_kwargs,</span><br><span class="line">            <span class="string">&quot;eval_per_device_batch_size&quot;</span>: eval_per_device_batch_size,</span><br><span class="line">            <span class="string">&quot;eval_dl_kwargs&quot;</span>: self._eval_dl_kwargs,</span><br><span class="line">            <span class="string">&quot;gradient_accumulation_steps&quot;</span>: gradient_accumulation_steps,</span><br><span class="line">            <span class="string">&quot;train_total_batch_size&quot;</span>: train_per_device_batch_size</span><br><span class="line">            * self._accelerator.num_processes</span><br><span class="line">            * gradient_accumulation_steps,</span><br><span class="line">            <span class="string">&quot;eval_total_batch_size&quot;</span>: eval_per_device_batch_size</span><br><span class="line">            * self._accelerator.num_processes,</span><br><span class="line">            <span class="string">&quot;num_update_steps_per_epoch&quot;</span>: num_update_steps_per_epoch,</span><br><span class="line">            <span class="string">&quot;max_num_train_steps&quot;</span>: max_num_train_steps,</span><br><span class="line">            <span class="string">&quot;is_local_process_zero&quot;</span>: self._accelerator.is_local_main_process,</span><br><span class="line">            <span class="string">&quot;is_world_process_zero&quot;</span>: self._accelerator.is_main_process,</span><br><span class="line">            <span class="string">&quot;is_distributed&quot;</span>: <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> self._accelerator.distributed_type != DistributedType.NO</span><br><span class="line">            <span class="keyword">else</span> <span class="literal">False</span>,</span><br><span class="line">            <span class="string">&quot;mixed_precision&quot;</span>: self._accelerator.mixed_precision,</span><br><span class="line">            <span class="string">&quot;gradient_clip_value&quot;</span>: gradient_clip_value,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将所有配置封装进TrainerRunConfig类型中</span></span><br><span class="line">        <span class="keyword">return</span> TrainerRunConfig(**config)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始训练</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_run_training</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 开始训练时调用一次该成员函数，当前该函数是空的</span></span><br><span class="line">        self.training_run_start()</span><br><span class="line">        <span class="comment"># 触发&quot;on_training_run_start&quot;这一回调事件</span></span><br><span class="line">        <span class="comment"># 比如MoveModulesToDeviceCallback、PrintProgressCallback这两个回调就拥有该事件属性</span></span><br><span class="line">        <span class="comment"># 从而能够在训练一开始就做一些事情</span></span><br><span class="line">        self.callback_handler.call_event(</span><br><span class="line">            <span class="string">&quot;on_training_run_start&quot;</span>,</span><br><span class="line">            self,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对epoch进行循环</span></span><br><span class="line">        <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(self.run_config.num_epochs):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 每一个训练epoch期间运行所做的事情</span></span><br><span class="line">                self._run_train_epoch(self._train_dataloader)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果指定了验证集，则运行验证epoch</span></span><br><span class="line">                <span class="comment"># 其基本流程与train epoch类似，但少了训练过程</span></span><br><span class="line">                <span class="keyword">if</span> self.eval_dataset <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    self._run_eval_epoch(self._eval_dataloader)</span><br><span class="line">                <span class="comment"># 对epoch进行步进</span></span><br><span class="line">                self.run_history._increment_epoch()</span><br><span class="line">                <span class="comment"># 每个epoch结束后调用</span></span><br><span class="line">                self.training_run_epoch_end()</span><br><span class="line">                <span class="comment"># 每个epoch结束后触发on_training_run_epoch_end事件</span></span><br><span class="line">                <span class="comment"># 默认的回调中没有该事件</span></span><br><span class="line">                <span class="comment"># 不过该事件非常重要，在SaveBestModelCallback中有使用，用来保存最佳模型；以及在EarlyStoppingCallback中使用，用来提前终止训练</span></span><br><span class="line">                self.callback_handler.call_event(</span><br><span class="line">                    <span class="string">&quot;on_training_run_epoch_end&quot;</span>,</span><br><span class="line">                    self,</span><br><span class="line">                )</span><br><span class="line">            <span class="keyword">except</span> StopTrainingError <span class="keyword">as</span> e:</span><br><span class="line">                self._accelerator.<span class="built_in">print</span>(e)</span><br><span class="line">                self.callback_handler.call_event(</span><br><span class="line">                    <span class="string">&quot;on_stop_training_error&quot;</span>,</span><br><span class="line">                    self,</span><br><span class="line">                )</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 整个训练结束后调用</span></span><br><span class="line">        self.training_run_end()</span><br><span class="line">        <span class="comment"># 整个训练结束后触发on_training_run_end事件</span></span><br><span class="line">        <span class="comment"># 默认的回调中，PrintProgressCallback有该事件属性，会打印出训练结束的字符串。</span></span><br><span class="line">        self.callback_handler.call_event(</span><br><span class="line">            <span class="string">&quot;on_training_run_end&quot;</span>,</span><br><span class="line">            self,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_run_evaluation</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        The method responsible for the orchestration of the high level steps which will be executed during an evaluation run.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.evaluation_run_start()</span><br><span class="line">        self.callback_handler.call_event(</span><br><span class="line">            <span class="string">&quot;on_evaluation_run_start&quot;</span>,</span><br><span class="line">            self,</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._run_eval_epoch(self._eval_dataloader, is_training=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">except</span> StopTrainingError <span class="keyword">as</span> e:</span><br><span class="line">            self._accelerator.<span class="built_in">print</span>(e)</span><br><span class="line">            self.callback_handler.call_event(</span><br><span class="line">                <span class="string">&quot;on_stop_training_error&quot;</span>,</span><br><span class="line">                self,</span><br><span class="line">            )</span><br><span class="line">        self.evaluation_run_end()</span><br><span class="line">        self.callback_handler.call_event(</span><br><span class="line">            <span class="string">&quot;on_evaluation_run_end&quot;</span>,</span><br><span class="line">            self,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每一个训练epoch期间运行所做的事情</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_run_train_epoch</span>(<span class="params">self, train_dl</span>):</span></span><br><span class="line">        <span class="comment"># 将网络模型设置成train模式</span></span><br><span class="line">        self.train_epoch_start()</span><br><span class="line">        <span class="comment"># 将损失追踪器重置一下，即设置当前epoch为1，指标列表为空。</span></span><br><span class="line">        self._loss_tracker.reset()</span><br><span class="line">        <span class="comment"># 触发&quot;on_train_epoch_start&quot;事件</span></span><br><span class="line">        <span class="comment"># 默认的回调函数中有如下几个有该事件属性，比如：</span></span><br><span class="line">        <span class="comment"># PrintProgressCallback：每个epoch开始都输出一下当前epoch是多少</span></span><br><span class="line">        <span class="comment"># ProgressBarCallback：每个epoch开始时初始化一个进度条</span></span><br><span class="line">        self.callback_handler.call_event(</span><br><span class="line">            <span class="string">&quot;on_train_epoch_start&quot;</span>,</span><br><span class="line">            self,</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 进入对batch的循环，对每个batch的运行称为一个step</span></span><br><span class="line">        <span class="keyword">for</span> step, batch <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_dl):</span><br><span class="line">            <span class="comment"># 每一步开始之前触发on_train_step_start事件，默认的回调中没有该事件的定义</span></span><br><span class="line">            self.callback_handler.call_event(</span><br><span class="line">                <span class="string">&quot;on_train_step_start&quot;</span>,</span><br><span class="line">                self,</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判断是否达到了梯度累加的步数，或者到了数据集的最后</span></span><br><span class="line">            perform_gradient_update = (</span><br><span class="line">                (step + <span class="number">1</span>) % self.run_config.gradient_accumulation_steps == <span class="number">0</span></span><br><span class="line">            ) <span class="keyword">or</span> (step + <span class="number">1</span> == <span class="built_in">len</span>(train_dl))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果没有达到梯度累加的步数</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> perform_gradient_update:</span><br><span class="line">                <span class="comment"># 那么就在不同的进程中关闭梯度同步</span></span><br><span class="line">                <span class="keyword">with</span> self._accelerator.no_sync(self.model):</span><br><span class="line">                    self._perform_forward_and_backward_passes(batch)</span><br><span class="line">            <span class="comment"># 如果达到梯度累加的步数，则会进行梯度同步</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self._perform_forward_and_backward_passes(batch)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果设定了梯度裁剪阈值，则进行梯度裁剪</span></span><br><span class="line">            <span class="keyword">if</span> self.run_config.gradient_clip_value <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                self._clip_gradients()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果达到了梯度累加</span></span><br><span class="line">            <span class="keyword">if</span> perform_gradient_update:</span><br><span class="line">                <span class="comment"># 优化器更新参数</span></span><br><span class="line">                self.optimizer_step()</span><br><span class="line">                <span class="comment"># 如果设定了学习率调度器，则调用调度器一次</span></span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    self.scheduler <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">                    <span class="keyword">and</span> <span class="keyword">not</span> self._accelerator.optimizer_step_was_skipped</span><br><span class="line">                ):</span><br><span class="line">                    self.scheduler_step()</span><br><span class="line">                <span class="comment"># 梯度清零</span></span><br><span class="line">                self.optimizer_zero_grad()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 每个epoch结束后调用如下方法，当前其为空</span></span><br><span class="line">        self.train_epoch_end()</span><br><span class="line">        <span class="comment"># 使用损失追踪器中的平均损失来更新运行历史中的指标</span></span><br><span class="line">        self.run_history.update_metric(<span class="string">&quot;train_loss_epoch&quot;</span>, self._loss_tracker.average)</span><br><span class="line">        <span class="comment"># 每个epoch结束后触发on_train_epoch_end事件</span></span><br><span class="line">        <span class="comment"># 默认的回调中，有如下拥有该事件属性：</span></span><br><span class="line">        <span class="comment"># ProgressBarCallback：用来关闭进度条</span></span><br><span class="line">        <span class="comment"># LogMetricsCallback：输出训练损失</span></span><br><span class="line">        self.callback_handler.call_event(</span><br><span class="line">            <span class="string">&quot;on_train_epoch_end&quot;</span>,</span><br><span class="line">            self,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算前向传播和反向传播</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_perform_forward_and_backward_passes</span>(<span class="params">self, batch</span>):</span></span><br><span class="line">        <span class="comment"># 计算训练损失</span></span><br><span class="line">        batch_output = self.calculate_train_batch_loss(batch)</span><br><span class="line">        <span class="comment"># 如果梯度累加步数大于1，进行损失标准化，教程参见上面的梯度累加的参考文献</span></span><br><span class="line">        <span class="keyword">if</span> self.run_config.gradient_accumulation_steps &gt; <span class="number">1</span>:</span><br><span class="line">            batch_output[<span class="string">&quot;loss&quot;</span>] /= self.run_config.gradient_accumulation_steps</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 通过聚合所有进程上的损失值，更新损失追踪器，</span></span><br><span class="line">        <span class="comment"># 包括当前batch上的损失、总损失、已运行的总样本数、平均损失</span></span><br><span class="line">        self._loss_tracker.update(</span><br><span class="line">            self.gather(batch_output[<span class="string">&quot;loss&quot;</span>]).detach().mean().item(),</span><br><span class="line">            batch_output[<span class="string">&quot;batch_size&quot;</span>],</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在每一步结束时触发on_train_step_end事件</span></span><br><span class="line">        <span class="comment"># 默认的回调中ProgressBarCallback有该事件属性，做的动作是更新进度条</span></span><br><span class="line">        self.callback_handler.call_event(</span><br><span class="line">            <span class="string">&quot;on_train_step_end&quot;</span>, self, batch_output=batch_output, batch=batch</span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 进行反向传播</span></span><br><span class="line">        self.backward_step(batch_output[<span class="string">&quot;loss&quot;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_clip_gradients</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Clip the gradients of the model&#x27;s parameters that fall outside of the threshold specified in :meth:`~Trainer.train`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        By default, this clips the gradients using :meth:`accelerate.Accelerator.clip_grad_value_`</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self._accelerator.clip_grad_value_(</span><br><span class="line">            self.model.parameters(), clip_value=self.run_config.gradient_clip_value</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_run_eval_epoch</span>(<span class="params">self, valid_dl, is_training: <span class="built_in">bool</span> = <span class="literal">True</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        The method responsible for the behaviour of each evaluation epoch.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param valid_dl: the dataloader to be used during evaluation</span></span><br><span class="line"><span class="string">        :param is_training: signals whether the evaluation is being run as part of a training run</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.eval_epoch_start()</span><br><span class="line">        self._loss_tracker.reset()</span><br><span class="line">        self.callback_handler.call_event(</span><br><span class="line">            <span class="string">&quot;on_eval_epoch_start&quot;</span>,</span><br><span class="line">            self,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> batch <span class="keyword">in</span> valid_dl:</span><br><span class="line">            self.callback_handler.call_event(</span><br><span class="line">                <span class="string">&quot;on_eval_step_start&quot;</span>,</span><br><span class="line">                self,</span><br><span class="line">            )</span><br><span class="line">            batch_output = self.calculate_eval_batch_loss(batch)</span><br><span class="line">            self._loss_tracker.update(</span><br><span class="line">                self.gather(batch_output[<span class="string">&quot;loss&quot;</span>]).detach().mean().item(),</span><br><span class="line">                batch_output[<span class="string">&quot;batch_size&quot;</span>],</span><br><span class="line">            )</span><br><span class="line">            self.callback_handler.call_event(</span><br><span class="line">                <span class="string">&quot;on_eval_step_end&quot;</span>, self, batch_output=batch_output, batch=batch</span><br><span class="line">            )</span><br><span class="line">        self.eval_epoch_end()</span><br><span class="line">        metric_name = <span class="string">&quot;eval_loss_epoch&quot;</span> <span class="keyword">if</span> is_training <span class="keyword">else</span> <span class="string">&quot;evaluation_loss&quot;</span></span><br><span class="line">        self.run_history.update_metric(metric_name, self._loss_tracker.average)</span><br><span class="line">        self.callback_handler.call_event(</span><br><span class="line">            <span class="string">&quot;on_eval_epoch_end&quot;</span>,</span><br><span class="line">            self,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对在不同进程上的tensor进行聚合</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gather</span>(<span class="params">self, tensor</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Gather the values in `tensor` across all processes and concatenate them on the first dimension. This can be</span></span><br><span class="line"><span class="string">        useful to regroup the predictions from all processes when doing evaluation.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        .. Note:: This gather happens in all processes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param tensor: (:obj:`torch.Tensor`, or a nested tuple/list/dictionary of :obj:`torch.Tensor`) The tensors to gather across all processes.</span></span><br><span class="line"><span class="string">        :return: The gathered tensor(s) (:obj:`torch.Tensor`, or a nested tuple/list/dictionary of :obj:`torch.Tensor`). The first dimension of the result is `num_processes` multiplied by the first dimension of the input tensors.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._accelerator.gather(tensor)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Use in replacement of ``print()`` to only print once per node.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self._accelerator <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self._accelerator.<span class="built_in">print</span>(*args, **kwargs)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save_checkpoint</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        self, save_path, checkpoint_kwargs=<span class="literal">None</span>, save_optimizer=<span class="literal">True</span>, save_per_node=<span class="literal">True</span></span></span></span><br><span class="line"><span class="function"><span class="params">    </span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Save the model, optimizer and specified args as a checkpoint file.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param save_path: the path where to save the checkpoint, this should end in &#x27;.pt&#x27;</span></span><br><span class="line"><span class="string">        :param checkpoint_kwargs: additional objects to include in the checkpoint</span></span><br><span class="line"><span class="string">        :param save_optimizer: flag to indicate whether to include the optimizer in the checkpoint</span></span><br><span class="line"><span class="string">        :param save_per_node: flag to indicate whether to save the checkpoint once per machine, if False, the checkpoint will only be saved from the world process zero. This is True by default.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> add save method for run history?</span></span><br><span class="line"></span><br><span class="line">        checkpoint = &#123;</span><br><span class="line">            <span class="string">&quot;model_state_dict&quot;</span>: self._accelerator.unwrap_model(self.model).state_dict(),</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> save_optimizer:</span><br><span class="line">            checkpoint[<span class="string">&quot;optimizer_state_dict&quot;</span>] = self.optimizer.state_dict()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> checkpoint_kwargs <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            checkpoint.update(checkpoint_kwargs)</span><br><span class="line"></span><br><span class="line">        self._accelerator.wait_for_everyone()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> save_per_node:</span><br><span class="line"></span><br><span class="line">            self._accelerator.save(</span><br><span class="line">                checkpoint,</span><br><span class="line">                save_path,</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.run_config.is_world_process_zero:</span><br><span class="line">                self._accelerator.save(</span><br><span class="line">                    checkpoint,</span><br><span class="line">                    save_path,</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_checkpoint</span>(<span class="params">self, checkpoint_path, load_optimizer=<span class="literal">True</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Load the model and optimizer from a checkpoint file.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param checkpoint_path: the path of the checkpoint file to load</span></span><br><span class="line"><span class="string">        :param load_optimizer: flag to indicate whether to load the optimizer if it is included in the checkpoint</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self._accelerator.wait_for_everyone()</span><br><span class="line">        checkpoint = torch.load(checkpoint_path, map_location=<span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">        self._accelerator.unwrap_model(self.model).load_state_dict(</span><br><span class="line">            checkpoint[<span class="string">&quot;model_state_dict&quot;</span>]</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> load_optimizer <span class="keyword">and</span> <span class="string">&quot;optimizer_state_dict&quot;</span> <span class="keyword">in</span> checkpoint:</span><br><span class="line">            <span class="keyword">if</span> self.optimizer <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(</span><br><span class="line">                    <span class="string">&quot;You are trying to load an optimizer from a checkpoint, but no optimizer&quot;</span></span><br><span class="line">                    <span class="string">&quot;has been set in the Trainer. Either pass the correct optimizer instance when&quot;</span></span><br><span class="line">                    <span class="string">&quot;creating the trainer, or specify load_optimizer=False when loading the checkpoint.&quot;</span></span><br><span class="line">                )</span><br><span class="line">            self.optimizer.load_state_dict(checkpoint[<span class="string">&quot;optimizer_state_dict&quot;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrainerWithTimmScheduler</span>(<span class="params">Trainer</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Subclass of the :class:`Trainer` that works with `timm schedulers &lt;https://fastai.github.io/timmdocs/schedulers&gt;`_ instead</span></span><br><span class="line"><span class="string">    of standard PyTorch learning rate schedulers</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(*args, **kwargs)</span><br><span class="line">        self.num_updates = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">train_epoch_start</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().train_epoch_start()</span><br><span class="line">        self.num_updates = self.run_history.current_epoch * <span class="built_in">len</span>(self._train_dataloader)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eval_epoch_end</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.scheduler <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.scheduler.step(self.run_history.current_epoch + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scheduler_step</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.num_updates += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.scheduler <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.scheduler.step_update(num_updates=self.num_updates)</span><br></pre></td></tr></table></figure><h1 id="对PyTorch迁移学习案例的加速改造"><a href="#对PyTorch迁移学习案例的加速改造" class="headerlink" title="对PyTorch迁移学习案例的加速改造"></a>对PyTorch迁移学习案例的加速改造</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Modifications Copyright © 2021 Chris Hughes</span></span><br><span class="line"><span class="comment">########################################################################</span></span><br><span class="line"><span class="comment"># 这个例子是PyTorch迁移学习的官方教程&quot;Transfer Learning for Computer Vision Tutorial&quot;（作者Sasank Chilamkurthy）的&quot;加速&quot;版本，原文在这里:</span></span><br><span class="line"><span class="comment"># https://pytorch.org/tutorials/beginner/transfer_learning_tutorial.html</span></span><br><span class="line"><span class="comment">########################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令行参数模块，参考教程见：</span></span><br><span class="line"><span class="comment"># https://docs.python.org/zh-cn/3/howto/argparse.html</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 偏函数，用来固定参数的默认值，参考教程见：</span></span><br><span class="line"><span class="comment"># https://www.liaoxuefeng.com/wiki/1016959663602400/1017454145929440</span></span><br><span class="line"><span class="comment"># https://zhuanlan.zhihu.com/p/47124891</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="comment"># torch原生的神经网络模块和优化器</span></span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn, optim</span><br><span class="line"><span class="comment"># torch原生的学习率调度器</span></span><br><span class="line"><span class="keyword">from</span> torch.optim <span class="keyword">import</span> lr_scheduler</span><br><span class="line"><span class="comment"># 使用torchvision的变换、数据集和模型</span></span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms, datasets, models</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.insert(<span class="number">0</span>, <span class="string">&#x27;../../../&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pytorch-accelerated的训练器</span></span><br><span class="line"><span class="keyword">from</span> pytorch_accelerated.trainer <span class="keyword">import</span> Trainer, TrainerPlaceholderValues</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">data_dir</span>):</span></span><br><span class="line">    <span class="comment"># 数据变换</span></span><br><span class="line">    data_transforms = &#123;</span><br><span class="line">        <span class="comment"># 对于训练集，使用随机裁剪、翻转等数据增强和标准化</span></span><br><span class="line">        <span class="string">&quot;train&quot;</span>: transforms.Compose(</span><br><span class="line">            [</span><br><span class="line">                transforms.RandomResizedCrop(<span class="number">224</span>),</span><br><span class="line">                transforms.RandomHorizontalFlip(),</span><br><span class="line">                transforms.ToTensor(),</span><br><span class="line">                transforms.Normalize([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>], [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>]),</span><br><span class="line">            ]</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment"># 对于训练集，仅使用标准化</span></span><br><span class="line">        <span class="string">&quot;val&quot;</span>: transforms.Compose(</span><br><span class="line">            [</span><br><span class="line">                transforms.Resize(<span class="number">256</span>),</span><br><span class="line">                transforms.CenterCrop(<span class="number">224</span>),</span><br><span class="line">                transforms.ToTensor(),</span><br><span class="line">                transforms.Normalize([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>], [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>]),</span><br><span class="line">            ]</span><br><span class="line">        ),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建数据集</span></span><br><span class="line">    <span class="comment"># 采用的是torchvision的datasets.ImageFolder</span></span><br><span class="line">    <span class="comment"># 字典推导式语法，参考教程见：https://www.runoob.com/python3/python-comprehensions.html</span></span><br><span class="line">    <span class="comment"># 使用的数据集是hymenoptera_data，下载地址在：</span></span><br><span class="line">    <span class="comment"># https://download.pytorch.org/tutorial/hymenoptera_data.zip</span></span><br><span class="line">    image_datasets = &#123;</span><br><span class="line">        x: datasets.ImageFolder(os.path.join(data_dir, x), data_transforms[x])</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">&quot;train&quot;</span>, <span class="string">&quot;val&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 创建模型</span></span><br><span class="line">    <span class="comment"># 采用的是torchvision的models，以及下载预训练权重</span></span><br><span class="line">    model = models.resnet18(pretrained=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 将模型的分类器修改一下，适用于本例</span></span><br><span class="line">    model.fc = nn.Linear(model.fc.in_features, <span class="built_in">len</span>(image_datasets[<span class="string">&quot;train&quot;</span>].classes))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义损失函数</span></span><br><span class="line">    loss_func = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用torch自己的优化器</span></span><br><span class="line">    optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对于学习率调度器，仍然采用torch原生的调度器</span></span><br><span class="line">    <span class="comment"># 但这里将它用在pytorch-accelerated的Trainer时要经过修改</span></span><br><span class="line">    <span class="comment"># Trainer是在step级别（即对batch进行循环）上调用调度器，而不是torch原生的StepLR那样在epoch级别上调用</span></span><br><span class="line">    <span class="comment"># 比如，torch原生的StepLR是这样调用的：</span></span><br><span class="line">    <span class="comment"># &gt;&gt;&gt; # Assuming optimizer uses lr = 0.05 for all groups</span></span><br><span class="line">    <span class="comment"># &gt;&gt;&gt; # lr = 0.05     if epoch &lt; 30</span></span><br><span class="line">    <span class="comment"># &gt;&gt;&gt; # lr = 0.005    if 30 &lt;= epoch &lt; 60</span></span><br><span class="line">    <span class="comment"># &gt;&gt;&gt; # lr = 0.0005   if 60 &lt;= epoch &lt; 90</span></span><br><span class="line">    <span class="comment"># &gt;&gt;&gt; # ...</span></span><br><span class="line">    <span class="comment"># &gt;&gt;&gt; scheduler = StepLR(optimizer, step_size=30, gamma=0.1)</span></span><br><span class="line">    <span class="comment"># &gt;&gt;&gt; for epoch in range(100):</span></span><br><span class="line">    <span class="comment"># &gt;&gt;&gt;     train(...)</span></span><br><span class="line">    <span class="comment"># &gt;&gt;&gt;     validate(...)</span></span><br><span class="line">    <span class="comment"># &gt;&gt;&gt;     scheduler.step()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 但是，在pytorch-accelerated中，看源码的话就会发现，它的scheduler.step()是在如下地方：</span></span><br><span class="line">    <span class="comment">#     # 进入对batch的循环，对每个batch的运行称为一个step</span></span><br><span class="line">    <span class="comment">#     for step, batch in enumerate(train_dl):</span></span><br><span class="line">    <span class="comment">#         .....</span></span><br><span class="line">    <span class="comment">#         # 如果达到了梯度累加</span></span><br><span class="line">    <span class="comment">#         if perform_gradient_update:</span></span><br><span class="line">    <span class="comment">#             .......</span></span><br><span class="line">    <span class="comment">#             # 如果设定了学习率调度器，则调用调度器一次</span></span><br><span class="line">    <span class="comment">#             if (</span></span><br><span class="line">    <span class="comment">#                 self.scheduler is not None</span></span><br><span class="line">    <span class="comment">#                 and not self._accelerator.optimizer_step_was_skipped</span></span><br><span class="line">    <span class="comment">#             ):</span></span><br><span class="line">    <span class="comment">#                 self.scheduler_step()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 所以，原来的step_size在epoch层级假设为30个epoch，那么此时在step层级的step_size就要变为30*steps_per_epoch，才能得到同样的调用效果。（这是对于Pytorch原生的调度器，其他的调度器则要看具体情况）</span></span><br><span class="line">    <span class="comment"># 推测是这样调用的：对于原来的epoch层级的调用，在epoch层级进行循环，每个epoch都会调用它一次，此时step_size设为30，它内部会计数，当进行30次epoch循环后，就会更新一次；对于pytorch-accelerated的step层级的调用（假设每个epoch有5个batch，即5个step），首先是对于epoch进行循环，然后在每个epoch内部，再对step进行循环，每个step都会调用它一次，先假设step_size仍然是30，因为它内部会计数，那么当进行了6个epoch后它就会更新，这显然是错误的，所以为了达到以前的每30次epoch更新一次，step_size就不能再是30，而是变成30*5，即steps_per_epoch*原来的step_size。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 具体原理实现：exp_lr_schedular是一个partial实例，它会在replace_trainer_placeholder_values中被处理，它的参数，比如step_size会被TrainerPlaceholderValues中的占位符的实际计算值所赋值</span></span><br><span class="line">    <span class="comment"># 从而实现了实时更新。</span></span><br><span class="line">    exp_lr_scheduler = partial(</span><br><span class="line">        lr_scheduler.StepLR,</span><br><span class="line">        step_size=TrainerPlaceholderValues.NUM_UPDATE_STEPS_PER_EPOCH * <span class="number">7</span>,</span><br><span class="line">        gamma=<span class="number">0.1</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将模型、损失函数、优化器传入Trainer即可</span></span><br><span class="line">    trainer = Trainer(</span><br><span class="line">        model,</span><br><span class="line">        loss_func=loss_func,</span><br><span class="line">        optimizer=optimizer,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用train函数，设置训练集、验证集、epoch数、batch size和学习率调度器</span></span><br><span class="line">    trainer.train(</span><br><span class="line">        train_dataset=image_datasets[<span class="string">&quot;train&quot;</span>],</span><br><span class="line">        eval_dataset=image_datasets[<span class="string">&quot;val&quot;</span>],</span><br><span class="line">        num_epochs=<span class="number">1</span>,</span><br><span class="line">        per_device_batch_size=<span class="number">4</span>,</span><br><span class="line">        create_scheduler_fn=exp_lr_scheduler,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&quot;Simple example of training script.&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--data_dir&quot;</span>, required=<span class="literal">True</span>, <span class="built_in">help</span>=<span class="string">&quot;The data folder on disk.&quot;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    main(args.data_dir)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="渐进式调整大小的案例"><a href="#渐进式调整大小的案例" class="headerlink" title="渐进式调整大小的案例"></a>渐进式调整大小的案例</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Copyright © 2021 Chris Hughes</span></span><br><span class="line"><span class="comment">########################################################################</span></span><br><span class="line"><span class="comment"># This example trains a ResNet50d on the Imagenette Dataset using progressive resizing</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Note: this example requires installing the torchmetrics and timm packages</span></span><br><span class="line"><span class="comment">########################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个例子使用了渐进式大小调整progressive resizing</span></span><br><span class="line"><span class="comment"># 该技术的一个讲解可以参考该例子：https://www.yanxishe.com/TextTranslation/1614</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># python的具名元组，见：https://www.runoob.com/note/25726</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> timm <span class="keyword">import</span> create_model</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="comment"># 使用torch原生的OneCycleLR，该调度器介绍参考：https://zhuanlan.zhihu.com/p/387162205</span></span><br><span class="line"><span class="keyword">from</span> torch.optim.lr_scheduler <span class="keyword">import</span> OneCycleLR</span><br><span class="line"><span class="comment"># 额外添加精度这一指标</span></span><br><span class="line"><span class="keyword">from</span> torchmetrics <span class="keyword">import</span> Accuracy</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms, datasets</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入内置的回调事件</span></span><br><span class="line"><span class="keyword">from</span> pytorch_accelerated.callbacks <span class="keyword">import</span> (</span><br><span class="line">    TerminateOnNaNCallback,</span><br><span class="line">    LogMetricsCallback,</span><br><span class="line">    PrintProgressCallback,</span><br><span class="line">    EarlyStoppingCallback,</span><br><span class="line">    SaveBestModelCallback,</span><br><span class="line">    TrainerCallback,</span><br><span class="line">    ProgressBarCallback,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pytorch_accelerated.trainer <span class="keyword">import</span> Trainer, TrainerPlaceholderValues</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个新的回调来计算精度</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccuracyCallback</span>(<span class="params">TrainerCallback</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_classes</span>):</span></span><br><span class="line">        self.accuracy = Accuracy(num_classes=num_classes)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在训练触发时将精度变量放到正确的设备上</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_training_run_start</span>(<span class="params">self, trainer, **kwargs</span>):</span></span><br><span class="line">        self.accuracy.to(trainer._eval_dataloader.device)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在每一个验证步结束时更新精度</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_eval_step_end</span>(<span class="params">self, trainer, batch, batch_output, **kwargs</span>):</span></span><br><span class="line">        preds = batch_output[<span class="string">&quot;model_outputs&quot;</span>].argmax(dim=-<span class="number">1</span>)</span><br><span class="line">        self.accuracy.update(preds, batch[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在每一个验证epoch结束时更新精度指标，并重置</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_eval_epoch_end</span>(<span class="params">self, trainer, **kwargs</span>):</span></span><br><span class="line">        trainer.run_history.update_metric(<span class="string">&quot;accuracy&quot;</span>, self.accuracy.compute().item())</span><br><span class="line">        self.accuracy.reset()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_transforms</span>(<span class="params">train_image_size=<span class="number">224</span>, val_image_size=<span class="number">224</span></span>):</span></span><br><span class="line">    <span class="comment"># Data augmentation and normalization for training</span></span><br><span class="line">    <span class="comment"># Just normalization for validation</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;train&quot;</span>: transforms.Compose(</span><br><span class="line">            [</span><br><span class="line">                transforms.RandomResizedCrop(train_image_size),</span><br><span class="line">                transforms.RandomHorizontalFlip(),</span><br><span class="line">                transforms.ToTensor(),</span><br><span class="line">                transforms.Normalize([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>], [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>]),</span><br><span class="line">            ]</span><br><span class="line">        ),</span><br><span class="line">        <span class="string">&quot;val&quot;</span>: transforms.Compose(</span><br><span class="line">            [</span><br><span class="line">                transforms.Resize(<span class="built_in">int</span>(<span class="built_in">round</span>(<span class="number">1.15</span> * val_image_size))),</span><br><span class="line">                transforms.CenterCrop(val_image_size),</span><br><span class="line">                transforms.ToTensor(),</span><br><span class="line">                transforms.Normalize([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>], [<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>]),</span><br><span class="line">            ]</span><br><span class="line">        ),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">data_dir</span>):</span></span><br><span class="line"></span><br><span class="line">    data_dir = Path(data_dir)</span><br><span class="line">    num_classes = <span class="built_in">len</span>(<span class="built_in">list</span>((data_dir / <span class="string">&quot;train&quot;</span>).iterdir()))</span><br><span class="line"></span><br><span class="line">    model = create_model(<span class="string">&quot;resnet50d&quot;</span>, pretrained=<span class="literal">False</span>, num_classes=num_classes)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Define loss function</span></span><br><span class="line">    loss_func = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Define optimizer</span></span><br><span class="line">    optimizer = torch.optim.Adam(params=model.parameters(), lr=<span class="number">0.01</span> / <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">    trainer = Trainer(</span><br><span class="line">        model,</span><br><span class="line">        loss_func=loss_func,</span><br><span class="line">        optimizer=optimizer,</span><br><span class="line">        callbacks=(</span><br><span class="line">            TerminateOnNaNCallback,</span><br><span class="line">            AccuracyCallback(num_classes=num_classes),</span><br><span class="line">            PrintProgressCallback,</span><br><span class="line">            ProgressBarCallback,</span><br><span class="line">            LogMetricsCallback,</span><br><span class="line">            EarlyStoppingCallback(early_stopping_patience=<span class="number">2</span>),</span><br><span class="line">            SaveBestModelCallback(watch_metric=<span class="string">&quot;accuracy&quot;</span>, greater_is_better=<span class="literal">True</span>),</span><br><span class="line">        ),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    EpochConfig = namedtuple(</span><br><span class="line">        <span class="string">&quot;EpochConfig&quot;</span>, [<span class="string">&quot;num_epochs&quot;</span>, <span class="string">&quot;train_image_size&quot;</span>, <span class="string">&quot;eval_image_size&quot;</span>, <span class="string">&quot;lr&quot;</span>]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置不同的图像尺寸</span></span><br><span class="line">    epoch_configs = [</span><br><span class="line">        EpochConfig(num_epochs=<span class="number">2</span>, train_image_size=<span class="number">64</span>, eval_image_size=<span class="number">64</span>, lr=<span class="number">0.01</span>),</span><br><span class="line">        EpochConfig(num_epochs=<span class="number">3</span>, train_image_size=<span class="number">128</span>, eval_image_size=<span class="number">128</span>, lr=<span class="number">0.01</span>),</span><br><span class="line">        EpochConfig(num_epochs=<span class="number">6</span>, train_image_size=<span class="number">224</span>, eval_image_size=<span class="number">224</span>, lr=<span class="number">0.001</span>),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 渐进式调整图像大小</span></span><br><span class="line">    <span class="keyword">for</span> e_config <span class="keyword">in</span> epoch_configs:</span><br><span class="line">        trainer.<span class="built_in">print</span>(<span class="string">f&quot;Training with image size: <span class="subst">&#123;e_config.train_image_size&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        image_datasets = &#123;</span><br><span class="line">            x: datasets.ImageFolder(</span><br><span class="line">                os.path.join(data_dir, x),</span><br><span class="line">                create_transforms(</span><br><span class="line">                    train_image_size=e_config.train_image_size,</span><br><span class="line">                    val_image_size=e_config.eval_image_size,</span><br><span class="line">                )[x],</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">&quot;train&quot;</span>, <span class="string">&quot;val&quot;</span>]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Here we use placeholders for the number of epochs and number of steps per epoch, so that the</span></span><br><span class="line">        <span class="comment"># trainer can inject those values later. This is especially key for the number of update steps</span></span><br><span class="line">        <span class="comment"># which will change depending on whether training is distributed or not</span></span><br><span class="line">        lr_scheduler = partial(</span><br><span class="line">            OneCycleLR,</span><br><span class="line">            max_lr=e_config.lr,</span><br><span class="line">            epochs=TrainerPlaceholderValues.NUM_EPOCHS,</span><br><span class="line">            steps_per_epoch=TrainerPlaceholderValues.NUM_UPDATE_STEPS_PER_EPOCH,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        trainer.train(</span><br><span class="line">            train_dataset=image_datasets[<span class="string">&quot;train&quot;</span>],</span><br><span class="line">            eval_dataset=image_datasets[<span class="string">&quot;val&quot;</span>],</span><br><span class="line">            num_epochs=e_config.num_epochs,</span><br><span class="line">            create_scheduler_fn=lr_scheduler,</span><br><span class="line">            per_device_batch_size=<span class="number">32</span>,</span><br><span class="line">            reset_run_history=<span class="literal">False</span>,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&quot;Simple example of training script.&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--data_dir&quot;</span>, required=<span class="literal">True</span>, <span class="built_in">help</span>=<span class="string">&quot;The data folder on disk.&quot;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    main(args.data_dir)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">简介
首先对pytorch-accelerated的核心类Trainer进行逐行代码的注释理解，然后再以官方的几个例子进行注解说明。

Trainer逐行代码注解
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76</summary>
    
    
    
    <category term="machine learning" scheme="http://qixinbo.github.io/categories/machine-learning/"/>
    
    
    <category term="PyTorch" scheme="http://qixinbo.github.io/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch图像模型库timm解析</title>
    <link href="http://qixinbo.github.io/2022/06/25/timm/"/>
    <id>http://qixinbo.github.io/2022/06/25/timm/</id>
    <published>2022-06-24T16:00:00.000Z</published>
    <updated>2022-06-24T15:38:18.294Z</updated>
    
    <content type="html"><![CDATA[<p>参考文档：<a href="https://towardsdatascience.com/getting-started-with-pytorch-image-models-timm-a-practitioners-guide-4e77b4bf9055">0</a>、<a href="https://timm.fast.ai/">1</a>、<a href="https://rwightman.github.io/pytorch-image-models/">2</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://github.com/rwightman/pytorch-image-models"><code>PyTorch Image Models (timm)</code></a>是<a href="https://twitter.com/wightmanr"><code>Ross Wightman</code></a>创建的深度学习库，是一个大型集合，包括了<code>SOTA</code>计算机视觉模型、神经网络层、实用函数、优化器、调度器、数据加载器、数据增强器以及训练/验证脚本等。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install timm</span><br></pre></td></tr></table></figure><h2 id="示例数据集（可选）"><a href="#示例数据集（可选）" class="headerlink" title="示例数据集（可选）"></a>示例数据集（可选）</h2><p>在演示之前，先下载一些流行的数据集作为示范。在这里，<a href="https://medium.com/@chris.p.hughes10">Chris Hughes</a>使用了两个数据集：</p><ul><li><a href="https://www.robots.ox.ac.uk/~vgg/data/pets/">牛津大学<code>IIIT</code>宠物数据集</a>，该数据集有<code>37</code>个类别，每个类别大约有<code>200</code>张图片</li><li><a href="https://github.com/fastai/imagenette"><code>Imagenette</code></a>，这是<code>Imagenet</code>中<code>10</code>个容易分类的类别的一个子集。</li></ul><p>(1)<code>IIIT</code>宠物数据集<br>下载并解压：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.robots.ox.ac.uk/~vgg/data/pets/data/images.tar.gz -P pets</span><br><span class="line">tar zxf pets/images.tar.gz -C pets</span><br></pre></td></tr></table></figure></p><p>（2）<code>Imagenette</code>数据集<br>下载并解压：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://s3.amazonaws.com/fast-ai-imageclas/imagenette2-<span class="number">320.</span>tgz -P imagenette</span><br><span class="line">tar zxf imagenette/imagenette2-<span class="number">320.</span>tgz -C imagenette</span><br><span class="line">gzip -d imagenette/imagenette2-<span class="number">320.</span>tgz</span><br></pre></td></tr></table></figure></p><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p><code>timm</code>最受欢迎的功能之一是其庞大且不断增长的模型架构集合。其中大部分模型包含预训练的权重——这些权重要么是在<code>PyTorch</code>中原生训练的，要么是从<code>Jax</code>和<code>TensorFlow</code>等其他库中移植的——可以轻松下载和使用。</p><h2 id="列出可用模型"><a href="#列出可用模型" class="headerlink" title="列出可用模型"></a>列出可用模型</h2><p>列出所有可用模型：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timm</span><br><span class="line">timm.list_models()</span><br></pre></td></tr></table></figure><br>列出所有可用的预训练模型：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timm.list_models(pretrained=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><br>通过通配符搜索特定模型：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_densenet_models = timm.list_models(<span class="string">&#x27;*densenet*&#x27;</span>)</span><br></pre></td></tr></table></figure><br><code>timm</code>中有几百个模型，且该数字还在不断增长，如果你觉得选择困难的话，可以参考<code>Papers with code</code>上的<a href="https://paperswithcode.com/lib/timm">总结页</a>，它包含了<code>timm</code>中许多模型的基准和原始论文的链接。</p><h2 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h2><h3 id="常规用法"><a href="#常规用法" class="headerlink" title="常规用法"></a>常规用法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timm </span><br><span class="line">model = timm.create_model(<span class="string">&#x27;resnet34&#x27;</span>)</span><br></pre></td></tr></table></figure><p>使用<code>timm</code>创建模型非常简单。<code>create_model</code>是一个用来可以创建超过<code>300</code>个模型的工厂函数。<br>创建一个预训练模型，则仅需额外传递一个参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = timm.create_model(<span class="string">&#x27;resnet34&#x27;</span>, pretrained=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><br>为了进一步了解如何使用这个模型，可以访问它的配置：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.default_cfg</span><br></pre></td></tr></table></figure><br>其中包含的信息有：应该用来归一化输入数据的统计数据<code>mean</code>和<code>std</code>、输出类别的数目<code>num_classes</code>和网络中分类器的名称<code>classifier</code>等信息。<br>也可以直接打印出整个模型的架构：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(model)</span><br></pre></td></tr></table></figure></p><h3 id="创建可变输入通道数目的图像的预训练模型"><a href="#创建可变输入通道数目的图像的预训练模型" class="headerlink" title="创建可变输入通道数目的图像的预训练模型"></a>创建可变输入通道数目的图像的预训练模型</h3><p><code>timm</code>模型有一个不太为人所知、但却非常有用的特点，那就是它们能够处理具有不同通道数的输入图像，这对大多数其他库来说都是一个问题；<a href="https://timm.fast.ai/models#So-how-is-timm-able-to-load-these-weights?">这里</a>给出了一个关于这个工作原理的出色解释。直观地说，<code>timm</code>通过对少于3个通道的初始卷积层的权重进行求和，或者智能地将这些权重复制到所需的通道数上，来实现这一目的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = timm.create_model(<span class="string">&#x27;resnet34&#x27;</span>, pretrained=<span class="literal">True</span>, in_chans=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><br>值得注意的是，虽然这使我们能够使用一个预训练的模型，但输入的图像与模型训练所基于的图像有很大的不同。正因为如此，我们不应该期待同样的性能水平，在将模型用于任务之前，应该在新的数据集上对其进行微调。</p><h2 id="定制化模型"><a href="#定制化模型" class="headerlink" title="定制化模型"></a>定制化模型</h2><p>除了用现有架构创建模型外，<code>create_model</code>还支持一些参数，使我们能够为特定的任务定制一个模型。<br>不过需要注意的是，支持的参数可能取决于底层的模型架构。</p><ul><li>一些参数，如<code>global_pool</code>就是与具体模型相关，该参会决定全局池化的类型，它在类<code>ResNet</code>的模型中是有效的，但就不适用于比如<code>ViT</code>这样的模型，因为<code>ViT</code>不使用平均池化。</li><li>另一些参数，如丢弃率<code>drop_rate</code>和输出类别数<code>num_classes</code>就适用于大多数模型。</li></ul><p>所以提前查看当前模型的默认架构是非常有必要的。</p><p>以之前的<code>resnet34</code>为例，看如何定制模型：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = timm.create_model(<span class="string">&#x27;resnet34&#x27;</span>, pretrained=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><br>其默认配置为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">model.default_cfg</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;https://github.com/rwightman/pytorch-image-models/releases/download/v0.1-weights/resnet34-43635321.pth&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;num_classes&#x27;</span>: <span class="number">1000</span>,</span><br><span class="line"> <span class="string">&#x27;input_size&#x27;</span>: (<span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>),</span><br><span class="line"> <span class="string">&#x27;pool_size&#x27;</span>: (<span class="number">7</span>, <span class="number">7</span>),</span><br><span class="line"> <span class="string">&#x27;crop_pct&#x27;</span>: <span class="number">0.875</span>,</span><br><span class="line"> <span class="string">&#x27;interpolation&#x27;</span>: <span class="string">&#x27;bilinear&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;mean&#x27;</span>: (<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>),</span><br><span class="line"> <span class="string">&#x27;std&#x27;</span>: (<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>),</span><br><span class="line"> <span class="string">&#x27;first_conv&#x27;</span>: <span class="string">&#x27;conv1&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;classifier&#x27;</span>: <span class="string">&#x27;fc&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;architecture&#x27;</span>: <span class="string">&#x27;resnet34&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></p><h3 id="改变输出类别数量"><a href="#改变输出类别数量" class="headerlink" title="改变输出类别数量"></a>改变输出类别数量</h3><p>由上面的模型配置可以看出，网络的分类器名字是<code>fc</code>。可以用它来直接访问相应的模块：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model.fc</span><br><span class="line"></span><br><span class="line">Linear(in_features=<span class="number">512</span>, out_features=<span class="number">1000</span>, bias=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><br>然而，这个名字很可能会根据使用的模型架构而改变。为了给不同的模型提供一个一致的接口，<code>timm</code>模型有<code>get_classifier</code>方法，我们可以用它来获得分类器，而不需要查询模块名称：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.get_classifier()</span><br></pre></td></tr></table></figure><br>由于这个模型是在<code>ImageNet</code>上预训练的，我们可以看到最后一层输出<code>1000</code>个类。可以通过<code>num_classes</code>参数来改变这一点。<br>创建一个自定义类别数目的模型，仅需额外传递一个参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = timm.create_model(<span class="string">&#x27;resnet34&#x27;</span>, num_classes=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><br>此时查看该模型的分类器，可以看到，<code>timm</code>已经用一个新的、未经训练的、具有所需类别数的线性层替换了最后一层；然后就可以在自己的数据集上进行微调。</p><p>如果想完全避免创建最后一层，可以将类的数量设置为<code>0</code>，这将创建一个以<code>Identity()</code>恒等函数为最后一层的模型；这对检查倒数第二层的输出很有用。</p><h3 id="全局池化"><a href="#全局池化" class="headerlink" title="全局池化"></a>全局池化</h3><p>依然从上面的模型配置中可以看到<code>pool_size</code>参数，表明在分类器之前由一个全局池化层。可以通过如下命令查看：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model.global_pool</span><br><span class="line"></span><br><span class="line">SelectAdaptivePool2d (pool_type=avg, flatten=Flatten(start_dim=<span class="number">1</span>, end_dim=-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><br>可以看到，返回了一个<code>SelectAdaptivePool2d</code>实例， 这是一个由<code>timm</code>提供的自定义层，支持不同的池化和压平配置，包括：</p><ul><li><code>avg</code>：平均池化</li><li><code>max</code>：最大池化</li><li><code>avgmax</code>：平均池化和最大池化的和，然后<code>0.5</code>倍缩放</li><li><code>catavgmax</code>：沿着特征维度将平均池化和最大池化的输出连接起来。注意，这将使特征维度增加一倍。</li><li><code>&#39;&#39;</code>：不使用池化，池化层倍一个<code>Indentity</code>恒等函数所替代</li></ul><p>通过以下代码查看一下不同池化选项的效果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pool_types = [<span class="string">&#x27;avg&#x27;</span>, <span class="string">&#x27;max&#x27;</span>, <span class="string">&#x27;avgmax&#x27;</span>, <span class="string">&#x27;catavgmax&#x27;</span>, <span class="string">&#x27;&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pool <span class="keyword">in</span> pool_types:</span><br><span class="line">    <span class="comment"># 这里一定要设置num_classes=0，</span></span><br><span class="line">    <span class="comment"># 否则在catavgmax和&#x27;&#x27;两种情形下都会报错，因为它改变了原来模型架构，无法与分类器正确连接</span></span><br><span class="line">    <span class="comment"># 这里设置了num_classes=0，实际就是查看倒数第二层（即全局池化层）的输出形状</span></span><br><span class="line">    model = timm.create_model(<span class="string">&#x27;resnet34&#x27;</span>, pretrained=<span class="literal">True</span>, num_classes=<span class="number">0</span>, global_pool=pool)</span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    feature_output = model(torch.randn(<span class="number">1</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>))</span><br><span class="line">    <span class="built_in">print</span>(feature_output.shape)</span><br></pre></td></tr></table></figure></p><h3 id="修改已有模型"><a href="#修改已有模型" class="headerlink" title="修改已有模型"></a>修改已有模型</h3><p>可以通过<code>reset_classifier</code>方法来修改已有模型：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">model = timm.create_model(<span class="string">&#x27;resnet34&#x27;</span>, pretrained=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Original pooling: <span class="subst">&#123;model.global_pool&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Original classifier: <span class="subst">&#123;model.get_classifier()&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;--------------&#x27;</span>)</span><br><span class="line">model.reset_classifier(<span class="number">10</span>, <span class="string">&#x27;max&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Modified pooling: <span class="subst">&#123;model.global_pool&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Modified classifier: <span class="subst">&#123;model.get_classifier()&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Original pooling: SelectAdaptivePool2d (pool_type=avg, flatten=Flatten(start_dim=<span class="number">1</span>, end_dim=-<span class="number">1</span>))</span><br><span class="line">Original classifier: Linear(in_features=<span class="number">512</span>, out_features=<span class="number">1000</span>, bias=<span class="literal">True</span>)</span><br><span class="line">--------------</span><br><span class="line">Modified pooling: SelectAdaptivePool2d (pool_type=<span class="built_in">max</span>, flatten=Flatten(start_dim=<span class="number">1</span>, end_dim=-<span class="number">1</span>))</span><br><span class="line">Modified classifier: Linear(in_features=<span class="number">512</span>, out_features=<span class="number">10</span>, bias=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p><h3 id="创建新的分类器"><a href="#创建新的分类器" class="headerlink" title="创建新的分类器"></a>创建新的分类器</h3><p>虽然已经证明使用单一的线性层作为分类器足以取得良好的效果，但在下游任务上微调模型时，<a href="https://medium.com/@chris.p.hughes10">Chris Hughes</a>发现使用一个稍大的头可以导致性能的提高。<br>接下来探讨一下如何进一步修改之前的<code>ResNet</code>模型。<br>首先，以前一样创建<code>ResNet</code>模型，指定需要<code>10</code>个输出类别。由于使用的是一个较大的头，这里使用<code>catavgmax</code>来进行池化，这样就可以提供更多的信息作为分类器的输入。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = timm.create_model(<span class="string">&#x27;resnet34&#x27;</span>, pretrained=<span class="literal">True</span>, num_classes=<span class="number">10</span>, global_pool=<span class="string">&#x27;catavgmax&#x27;</span>)</span><br></pre></td></tr></table></figure><br>对于该模型的已有分类器，看一下它的输入特征：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num_in_features = model.get_classifier().in_features</span><br><span class="line">num_in_features</span><br><span class="line"></span><br><span class="line"><span class="number">1024</span></span><br></pre></td></tr></table></figure><br>下面用一个自定义的分类器来直接替换原来的分类器：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line">model.fc = nn.Sequential(</span><br><span class="line">    nn.BatchNorm1d(num_in_features),</span><br><span class="line">    nn.Linear(in_features=num_in_features, out_features=<span class="number">512</span>, bias=<span class="literal">False</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.BatchNorm1d(<span class="number">512</span>),</span><br><span class="line">    nn.Dropout(<span class="number">0.4</span>),</span><br><span class="line">    nn.Linear(in_features=<span class="number">512</span>, out_features=<span class="number">10</span>, bias=<span class="literal">False</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>使用一个模拟数据来测试一下新分类器的输出：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line">model(torch.randn(<span class="number">1</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>)).shape</span><br><span class="line"></span><br><span class="line">torch.Size([<span class="number">1</span>, <span class="number">10</span>])</span><br></pre></td></tr></table></figure><br>可以看出，结果符合预期，经过修改后的模型可以用来训练了。</p><h2 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h2><p><code>timm</code>模型有一套统一的机制来获得各种类型的中间特征，这对于将一个架构作为下游任务的特征提取器是非常有用的。<br>这一部分使用宠物数据集中的图像作为一个例子。<br>在程序中加载<code>IIIT</code>宠物数据集：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line">pets_path = Path(<span class="string">&#x27;pets/images&#x27;</span>)</span><br><span class="line">pets_image_paths = <span class="built_in">list</span>(pets_path.iterdir())</span><br></pre></td></tr></table></figure><br>选取其中一张图像，并转为<code>PyTorch</code>期望的数据格式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">image = Image.<span class="built_in">open</span>(pets_image_paths[<span class="number">1</span>])</span><br><span class="line">image = torch.as_tensor(np.array(image, dtype=np.float32)).transpose(<span class="number">2</span>, <span class="number">0</span>)[<span class="literal">None</span>]</span><br><span class="line"></span><br><span class="line">image.shape</span><br><span class="line">torch.Size([<span class="number">1</span>, <span class="number">3</span>, <span class="number">500</span>, <span class="number">375</span>])</span><br></pre></td></tr></table></figure><br>使用<code>timm</code>常规用法创建一个模型（这里换成了<code>resnet50d</code>）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">model = timm.create_model(<span class="string">&#x27;resnet50d&#x27;</span>, pretrained=<span class="literal">True</span>)</span><br><span class="line">model.default_cfg</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&#x27;url&#x27;</span>: <span class="string">&#x27;https://github.com/rwightman/pytorch-image-models/releases/download/v0.1-weights/resnet50d_ra2-464e36ba.pth&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;num_classes&#x27;</span>: <span class="number">1000</span>,</span><br><span class="line"> <span class="string">&#x27;input_size&#x27;</span>: (<span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>),</span><br><span class="line"> <span class="string">&#x27;pool_size&#x27;</span>: (<span class="number">7</span>, <span class="number">7</span>),</span><br><span class="line"> <span class="string">&#x27;crop_pct&#x27;</span>: <span class="number">0.875</span>,</span><br><span class="line"> <span class="string">&#x27;interpolation&#x27;</span>: <span class="string">&#x27;bicubic&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;mean&#x27;</span>: (<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>),</span><br><span class="line"> <span class="string">&#x27;std&#x27;</span>: (<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>),</span><br><span class="line"> <span class="string">&#x27;first_conv&#x27;</span>: <span class="string">&#x27;conv1.0&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;classifier&#x27;</span>: <span class="string">&#x27;fc&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;architecture&#x27;</span>: <span class="string">&#x27;resnet50d&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><br>如果我们只对最终的特征图感兴趣——也就是本例中池化之前的最终卷积层的输出——可以使用<code>forward_features</code>方法来绕过全局池化和分类层：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feature_output = model.forward_features(image)</span><br></pre></td></tr></table></figure><br>可以对它可视化一下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visualize_feature_output</span>(<span class="params">t</span>):</span></span><br><span class="line">    plt.imshow(feature_output[<span class="number">0</span>].transpose(<span class="number">0</span>, <span class="number">2</span>).<span class="built_in">sum</span>(-<span class="number">1</span>).detach().numpy())</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">visualize_feature_output(feature_output)</span><br></pre></td></tr></table></figure></p><h3 id="多个特征输出"><a href="#多个特征输出" class="headerlink" title="多个特征输出"></a>多个特征输出</h3><p>虽然<code>forward_features</code>方法可以方便地获得最终的特征图，但<code>timm</code>也提供了一些功能，使得可以将模型作为特征骨干，输出选定层次的特征图。<br>先看一个之前模型中的特征信息：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">model.feature_info</span><br><span class="line"></span><br><span class="line">[&#123;<span class="string">&#x27;num_chs&#x27;</span>: <span class="number">64</span>, <span class="string">&#x27;reduction&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;module&#x27;</span>: <span class="string">&#x27;act1&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;num_chs&#x27;</span>: <span class="number">64</span>, <span class="string">&#x27;reduction&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;module&#x27;</span>: <span class="string">&#x27;layer1&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;num_chs&#x27;</span>: <span class="number">128</span>, <span class="string">&#x27;reduction&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;module&#x27;</span>: <span class="string">&#x27;layer2&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;num_chs&#x27;</span>: <span class="number">256</span>, <span class="string">&#x27;reduction&#x27;</span>: <span class="number">16</span>, <span class="string">&#x27;module&#x27;</span>: <span class="string">&#x27;layer3&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;num_chs&#x27;</span>: <span class="number">512</span>, <span class="string">&#x27;reduction&#x27;</span>: <span class="number">32</span>, <span class="string">&#x27;module&#x27;</span>: <span class="string">&#x27;layer4&#x27;</span>&#125;]</span><br></pre></td></tr></table></figure><br>以上是常规创建的模型的输出信息。<br>实际上，在创建模型时，可以添加参数<code>features_only=True</code>来指定所使用模型作为特征骨干，即：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">model = timm.create_model(<span class="string">&#x27;resnet50d&#x27;</span>, pretrained=<span class="literal">True</span>, features_only=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">model</span><br><span class="line"></span><br><span class="line">FeatureListNet(</span><br><span class="line">  (conv1): Sequential(</span><br><span class="line">    (<span class="number">0</span>): Conv2d(<span class="number">3</span>, <span class="number">32</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), stride=(<span class="number">2</span>, <span class="number">2</span>), padding=(<span class="number">1</span>, <span class="number">1</span>), bias=<span class="literal">False</span>)</span><br><span class="line">    (<span class="number">1</span>): BatchNorm2d(<span class="number">32</span>, eps=<span class="number">1e-05</span>, momentum=<span class="number">0.1</span>, affine=<span class="literal">True</span>, track_running_stats=<span class="literal">True</span>)</span><br><span class="line">    (<span class="number">2</span>): ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">    (<span class="number">3</span>): Conv2d(<span class="number">32</span>, <span class="number">32</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), stride=(<span class="number">1</span>, <span class="number">1</span>), padding=(<span class="number">1</span>, <span class="number">1</span>), bias=<span class="literal">False</span>)</span><br><span class="line">    (<span class="number">4</span>): BatchNorm2d(<span class="number">32</span>, eps=<span class="number">1e-05</span>, momentum=<span class="number">0.1</span>, affine=<span class="literal">True</span>, track_running_stats=<span class="literal">True</span>)</span><br><span class="line">    (<span class="number">5</span>): ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">    (<span class="number">6</span>): Conv2d(<span class="number">32</span>, <span class="number">64</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), stride=(<span class="number">1</span>, <span class="number">1</span>), padding=(<span class="number">1</span>, <span class="number">1</span>), bias=<span class="literal">False</span>)</span><br><span class="line">  )</span><br><span class="line">..............</span><br></pre></td></tr></table></figure><br>此时生成的模型是<code>FeatureListNet</code>类型。<br>如下所示，可以得到更多关于返回的特征的信息，如具体的模块名称，特征的减少量和通道的数量：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">model.feature_info.module_name()</span><br><span class="line">[<span class="string">&#x27;act1&#x27;</span>, <span class="string">&#x27;layer1&#x27;</span>, <span class="string">&#x27;layer2&#x27;</span>, <span class="string">&#x27;layer3&#x27;</span>, <span class="string">&#x27;layer4&#x27;</span>]</span><br><span class="line"></span><br><span class="line">model.feature_info.reduction()</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>]</span><br><span class="line"></span><br><span class="line">model.feature_info.channels()</span><br><span class="line">[<span class="number">64</span>, <span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>, <span class="number">2048</span>]</span><br></pre></td></tr></table></figure><br>默认情况下，大多数模型将输出<code>5</code>层（并非所有模型都有这么多步长），第一层从<code>2</code>开始（但有些从<code>1</code>或<code>4</code>开始）。<br>可以使用<code>out_indices</code>和<code>output_stride</code>参数来修改特征层的索引和数量，如<a href="https://rwightman.github.io/pytorch-image-models/feature_extraction/#multi-scale-feature-maps-feature-pyramid">文档</a>中所示。<br>将图像传入该特征提取模型中，看一下它的输出：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">out = model(image)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> o <span class="keyword">in</span> out:</span><br><span class="line">    <span class="built_in">print</span>(o.shape)</span><br><span class="line"></span><br><span class="line">torch.Size([<span class="number">1</span>, <span class="number">64</span>, <span class="number">250</span>, <span class="number">188</span>])</span><br><span class="line">torch.Size([<span class="number">1</span>, <span class="number">256</span>, <span class="number">125</span>, <span class="number">94</span>])</span><br><span class="line">torch.Size([<span class="number">1</span>, <span class="number">512</span>, <span class="number">63</span>, <span class="number">47</span>])</span><br><span class="line">torch.Size([<span class="number">1</span>, <span class="number">1024</span>, <span class="number">32</span>, <span class="number">24</span>])</span><br><span class="line">torch.Size([<span class="number">1</span>, <span class="number">2048</span>, <span class="number">16</span>, <span class="number">12</span>])</span><br></pre></td></tr></table></figure><br>可以看出，能返回<code>5</code>个特征图，以及形状和通道数都符合预期。<br>还可以具体可视化一下特征图：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> o <span class="keyword">in</span> out:</span><br><span class="line">    plt.imshow(o[<span class="number">0</span>].transpose(<span class="number">0</span>, <span class="number">2</span>).<span class="built_in">sum</span>(-<span class="number">1</span>).detach().numpy())</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></p><h3 id="使用Torch-FX"><a href="#使用Torch-FX" class="headerlink" title="使用Torch FX"></a>使用Torch FX</h3><p><code>TorchVision</code>最近发布了一个名为<code>FX</code>的新工具，它可以更容易地访问<code>PyTorch Module</code>正向传递过程中的输入的中间转换。具体是通过符号性地运行前向方法来产生一个图<code>graph</code>，其中每个节点代表一个操作。由于节点被赋予了人类可读的名称，所以很容易准确地指定我们要访问的节点。<code>FX</code>在<a href="https://pytorch.org/docs/stable/fx.html#module-torch.fx">这篇文档</a>和<a href="https://pytorch.org/blog/FX-feature-extraction-torchvision/">这篇博文</a>中有更详细的描述。<br>注意：<code>Chris Hughes</code>在撰写<a href="https://towardsdatascience.com/getting-started-with-pytorch-image-models-timm-a-practitioners-guide-4e77b4bf9055#0583">本教程</a>时，使用<code>FX</code>时，动态控制流还不能用静态图来表示。<br>由于<code>timm</code>中几乎所有的模型都可以用符号追踪，我们可以用<code>FX</code>来操作这些模型。<br>下面来探讨一下如何使用<code>FX</code>从<code>timm</code>模型中提取特征。<br>（1）获取节点：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入fx必要的包</span></span><br><span class="line"><span class="keyword">from</span> torchvision.models.feature_extraction <span class="keyword">import</span> get_graph_node_names, create_feature_extractor</span><br><span class="line"><span class="comment"># 在创建模型时指定exportable参数，使得模型可被追踪</span></span><br><span class="line">model = timm.create_model(<span class="string">&#x27;resnet50d&#x27;</span>, pretrained=<span class="literal">True</span>, exportable=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 获得节点</span></span><br><span class="line"><span class="comment"># 因为模型分别以train和evel模式都执行一次，所以两种模式下的节点名称都会返回。</span></span><br><span class="line">nodes, _ = get_graph_node_names(model)</span><br><span class="line"></span><br><span class="line">nodes</span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;x&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;conv1.0&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;conv1.1&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;conv1.2&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;conv1.3&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;conv1.4&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;conv1.5&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;conv1.6&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;bn1&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;act1&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;maxpool&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;layer1.0.conv1&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;layer1.0.bn1&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;layer1.0.act1&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;layer1.0.conv2&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;layer1.0.bn2&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;layer1.0.act2&#x27;</span>,</span><br><span class="line"> ............</span><br></pre></td></tr></table></figure><br>（2）特征提取器：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用FX可以很容易地获得任意节点的输出</span></span><br><span class="line"><span class="comment"># 这里以选择layer1的第二个激活函数为例</span></span><br><span class="line">features = &#123;<span class="string">&#x27;layer1.0.act2&#x27;</span>: <span class="string">&#x27;out&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用create_feature_extractor可以在这个点上切断整个模型</span></span><br><span class="line">feature_extractor = create_feature_extractor(model, return_nodes=features)</span><br><span class="line"><span class="comment"># 切断后的模型如下</span></span><br><span class="line">feature_extractor</span><br><span class="line"></span><br><span class="line">ResNet(</span><br><span class="line">  (conv1): Module(</span><br><span class="line">    (<span class="number">0</span>): Conv2d(<span class="number">3</span>, <span class="number">32</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), stride=(<span class="number">2</span>, <span class="number">2</span>), padding=(<span class="number">1</span>, <span class="number">1</span>), bias=<span class="literal">False</span>)</span><br><span class="line">    (<span class="number">1</span>): BatchNorm2d(<span class="number">32</span>, eps=<span class="number">1e-05</span>, momentum=<span class="number">0.1</span>, affine=<span class="literal">True</span>, track_running_stats=<span class="literal">True</span>)</span><br><span class="line">    (<span class="number">2</span>): ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">    (<span class="number">3</span>): Conv2d(<span class="number">32</span>, <span class="number">32</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), stride=(<span class="number">1</span>, <span class="number">1</span>), padding=(<span class="number">1</span>, <span class="number">1</span>), bias=<span class="literal">False</span>)</span><br><span class="line">    (<span class="number">4</span>): BatchNorm2d(<span class="number">32</span>, eps=<span class="number">1e-05</span>, momentum=<span class="number">0.1</span>, affine=<span class="literal">True</span>, track_running_stats=<span class="literal">True</span>)</span><br><span class="line">    (<span class="number">5</span>): ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">    (<span class="number">6</span>): Conv2d(<span class="number">32</span>, <span class="number">64</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), stride=(<span class="number">1</span>, <span class="number">1</span>), padding=(<span class="number">1</span>, <span class="number">1</span>), bias=<span class="literal">False</span>)</span><br><span class="line">  )</span><br><span class="line">  (bn1): BatchNorm2d(<span class="number">64</span>, eps=<span class="number">1e-05</span>, momentum=<span class="number">0.1</span>, affine=<span class="literal">True</span>, track_running_stats=<span class="literal">True</span>)</span><br><span class="line">  (act1): ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">  (maxpool): MaxPool2d(kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>, dilation=<span class="number">1</span>, ceil_mode=<span class="literal">False</span>)</span><br><span class="line">  (layer1): Module(</span><br><span class="line">    (<span class="number">0</span>): Module(</span><br><span class="line">      (conv1): Conv2d(<span class="number">64</span>, <span class="number">64</span>, kernel_size=(<span class="number">1</span>, <span class="number">1</span>), stride=(<span class="number">1</span>, <span class="number">1</span>), bias=<span class="literal">False</span>)</span><br><span class="line">      (bn1): BatchNorm2d(<span class="number">64</span>, eps=<span class="number">1e-05</span>, momentum=<span class="number">0.1</span>, affine=<span class="literal">True</span>, track_running_stats=<span class="literal">True</span>)</span><br><span class="line">      (act1): ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">      (conv2): Conv2d(<span class="number">64</span>, <span class="number">64</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), stride=(<span class="number">1</span>, <span class="number">1</span>), padding=(<span class="number">1</span>, <span class="number">1</span>), bias=<span class="literal">False</span>)</span><br><span class="line">      (bn2): BatchNorm2d(<span class="number">64</span>, eps=<span class="number">1e-05</span>, momentum=<span class="number">0.1</span>, affine=<span class="literal">True</span>, track_running_stats=<span class="literal">True</span>)</span><br><span class="line">      (act2): ReLU(inplace=<span class="literal">True</span>)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>（3）提取特征：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入图像，返回特征</span></span><br><span class="line">out = feature_extractor(image)</span><br><span class="line"><span class="comment"># 可视化一下</span></span><br><span class="line">plt.imshow(out[<span class="string">&#x27;out&#x27;</span>][<span class="number">0</span>].transpose(<span class="number">0</span>, <span class="number">2</span>).<span class="built_in">sum</span>(-<span class="number">1</span>).detach().numpy())</span><br></pre></td></tr></table></figure></p><h2 id="模型导出"><a href="#模型导出" class="headerlink" title="模型导出"></a>模型导出</h2><p>训练结束后，通常建议将模型导出为优化的格式，以便进行推理；<code>PyTorch</code>有多种导出选项可以做到这一点。由于几乎所有的<code>timm</code>模型都是可编写脚本和可追踪的，因此可以利用这些格式。</p><h3 id="导出为TorchScript"><a href="#导出为TorchScript" class="headerlink" title="导出为TorchScript"></a>导出为TorchScript</h3><p><code>TorchScript</code>是一种从<code>PyTorch</code>代码中创建可序列化和可优化的模型的方法；任何<code>TorchScript</code>程序都可以从<code>Python</code>进程中保存，并在没有<code>Python</code>依赖性的进程中加载。<br>可以通过两种不同的方式将一个模型转换为<code>TorchScript</code>。</p><ul><li>追踪：运行代码，记录发生的操作，并构造一个包含这些操作的<code>ScriptModule</code>。控制流或动态行为（如<code>if/else</code>语句）会被抹去。</li><li>脚本化：使用脚本编译器对<code>Python</code>源代码进行直接分析，将其转化为<code>TorchScript</code>。这保留了动态控制流，对不同大小的输入都有效。</li></ul><p>关于<code>TorchScript</code>的更多信息可以在<a href="https://pytorch.org/docs/stable/jit.html">该文档</a>和<a href="https://pytorch.org/tutorials/beginner/Intro_to_TorchScript_tutorial.html">该教程</a>中看到。<br>由于大多数<code>timm</code>模型是可编写脚本的，这里使用脚本来导出上面的<code>ResNet-D</code>模型。可以在创建模型时使用<code>scriptable</code>参数来使模型是<code>jit</code>可脚本化。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = timm.create_model(<span class="string">&#x27;resnet50d&#x27;</span>, pretrained=<span class="literal">True</span>, scriptable=<span class="literal">True</span>)</span><br><span class="line">model.<span class="built_in">eval</span>()</span><br></pre></td></tr></table></figure><br>在导出模型之前调用<code>model.eval()</code>是非常重要的，这样可以使模型进入推理模式，因为诸如<code>dropout</code>和<code>batchnorm</code>这样的运算符在不同的模式下表现不同。<br>确认一下可以脚本化模型：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">scripted_model = torch.jit.script(model)</span><br><span class="line"></span><br><span class="line">scripted_model</span><br><span class="line"></span><br><span class="line">RecursiveScriptModule(</span><br><span class="line">  original_name=ResNet</span><br><span class="line">  (conv1): RecursiveScriptModule(</span><br><span class="line">    original_name=Sequential</span><br><span class="line">    (<span class="number">0</span>): RecursiveScriptModule(original_name=Conv2d)</span><br><span class="line">    (<span class="number">1</span>): RecursiveScriptModule(original_name=BatchNorm2d)</span><br><span class="line">    (<span class="number">2</span>): RecursiveScriptModule(original_name=ReLU)</span><br><span class="line">    (<span class="number">3</span>): RecursiveScriptModule(original_name=Conv2d)</span><br><span class="line">    (<span class="number">4</span>): RecursiveScriptModule(original_name=BatchNorm2d)</span><br><span class="line">    (<span class="number">5</span>): RecursiveScriptModule(original_name=ReLU)</span><br><span class="line">    (<span class="number">6</span>): RecursiveScriptModule(original_name=Conv2d)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><br>同时模型也能正常使用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scripted_model(torch.rand(<span class="number">8</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>)).shape</span><br><span class="line"></span><br><span class="line">torch.Size([<span class="number">8</span>, <span class="number">1000</span>])</span><br></pre></td></tr></table></figure></p><h3 id="导出为ONNX"><a href="#导出为ONNX" class="headerlink" title="导出为ONNX"></a>导出为ONNX</h3><p><a href="https://onnx.ai/"><code>Open Neural Network eXchange(ONNX)</code></a>是一种表示机器学习模型的开放标准格式。<br>可以使用<code>torch.onnx</code>模块将<code>timm</code>模型导出到<code>ONNX</code>，使它们能够被任何支持<code>ONNX</code>的运行时<code>runtimes</code>所使用。如果调用<code>torch.onnx.export()</code>的模块不是<code>ScriptModule</code>，它首先会做相当于<code>torch.jit.trace()</code>的工作；用给定的<code>args</code>执行一次模型，并记录执行期间发生的所有操作。这意味着，如果模型是动态的，例如，根据输入数据改变行为，导出的模型将不能捕捉到这种动态行为。同样，跟踪可能只对特定的输入尺寸有效。<br>关于<code>ONNX</code>的更多细节可以在<a href="https://pytorch.org/docs/master/onnx.html">该文档</a>中找到。<br>为了能够以<code>ONNX</code>格式导出一个<code>timm</code>模型，可以在创建模型时使用<code>exportable</code>参数，以确保模型是可追踪的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = timm.create_model(<span class="string">&#x27;resnet50d&#x27;</span>, pretrained=<span class="literal">True</span>, exportable=<span class="literal">True</span>)</span><br><span class="line">model.<span class="built_in">eval</span>()</span><br></pre></td></tr></table></figure><br>然后使用<code>torch.onnx.export</code>来追踪和导出模型：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">x = torch.randn(<span class="number">2</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">torch_out = model(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Export the model</span></span><br><span class="line">torch.onnx.export(model,                                       <span class="comment"># model being run</span></span><br><span class="line">                  x,                                           <span class="comment"># model input (or a tuple for multiple inputs)</span></span><br><span class="line">                  <span class="string">&quot;resnet50d.onnx&quot;</span>,                            <span class="comment"># where to save the model (can be a file or file-like object)</span></span><br><span class="line">                  export_params=<span class="literal">True</span>,                          <span class="comment"># store the trained parameter weights inside the model file</span></span><br><span class="line">                  opset_version=<span class="number">10</span>,                            <span class="comment"># the ONNX version to export the model to</span></span><br><span class="line">                  do_constant_folding=<span class="literal">True</span>,                    <span class="comment"># whether to execute constant folding for optimization</span></span><br><span class="line">                  input_names = [<span class="string">&#x27;input&#x27;</span>],                     <span class="comment"># the model&#x27;s input names</span></span><br><span class="line">                  output_names = [<span class="string">&#x27;output&#x27;</span>],                   <span class="comment"># the model&#x27;s output names</span></span><br><span class="line">                  dynamic_axes=&#123;<span class="string">&#x27;input&#x27;</span> : &#123;<span class="number">0</span> : <span class="string">&#x27;batch_size&#x27;</span>&#125;,  <span class="comment"># variable length axes</span></span><br><span class="line">                                <span class="string">&#x27;output&#x27;</span>: &#123;<span class="number">0</span> : <span class="string">&#x27;batch_size&#x27;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><br>使用<code>check_model</code>验证一下模型是否有效：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> onnx</span><br><span class="line"></span><br><span class="line">onnx_model = onnx.load(<span class="string">&quot;resnet50d.onnx&quot;</span>)</span><br><span class="line">onnx.checker.check_model(onnx_model)</span><br></pre></td></tr></table></figure><br>由于已经指定模型应该是可追踪的，也可以手动进行追踪，如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">traced_model = torch.jit.trace(model, torch.rand(<span class="number">8</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>))</span><br><span class="line">traced_model(torch.rand(<span class="number">8</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>)).shape</span><br></pre></td></tr></table></figure></p><h1 id="数据增强"><a href="#数据增强" class="headerlink" title="数据增强"></a>数据增强</h1><p><code>timm</code>包括很多数据增强变换，它们可以被串联起来组成增强管道；与<code>TorchVision</code>类似，这些管道需要一个<code>PIL</code>图像作为输入。<br>最简单的方法是使用<code>create_transform</code>工厂函数，下面探索如何使用它。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> timm.data.transforms_factory <span class="keyword">import</span> create_transform</span><br><span class="line"></span><br><span class="line">create_transform(<span class="number">224</span>,)</span><br><span class="line"></span><br><span class="line">Compose(</span><br><span class="line">    Resize(size=<span class="number">256</span>, interpolation=bilinear, max_size=<span class="literal">None</span>, antialias=<span class="literal">None</span>)</span><br><span class="line">    CenterCrop(size=(<span class="number">224</span>, <span class="number">224</span>))</span><br><span class="line">    ToTensor()</span><br><span class="line">    Normalize(mean=tensor([<span class="number">0.4850</span>, <span class="number">0.4560</span>, <span class="number">0.4060</span>]), std=tensor([<span class="number">0.2290</span>, <span class="number">0.2240</span>, <span class="number">0.2250</span>]))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>可以看到，<code>create_transform</code>已经创建了一些基本的增强管道，包括调整大小、归一化和将图像转换为张量。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create_transform(<span class="number">224</span>, is_training=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">Compose(</span><br><span class="line">    RandomResizedCropAndInterpolation(size=(<span class="number">224</span>, <span class="number">224</span>), scale=(<span class="number">0.08</span>, <span class="number">1.0</span>), ratio=(<span class="number">0.75</span>, <span class="number">1.3333</span>), interpolation=bilinear)</span><br><span class="line">    RandomHorizontalFlip(p=<span class="number">0.5</span>)</span><br><span class="line">    ColorJitter(brightness=[<span class="number">0.6</span>, <span class="number">1.4</span>], contrast=[<span class="number">0.6</span>, <span class="number">1.4</span>], saturation=[<span class="number">0.6</span>, <span class="number">1.4</span>], hue=<span class="literal">None</span>)</span><br><span class="line">    ToTensor()</span><br><span class="line">    Normalize(mean=tensor([<span class="number">0.4850</span>, <span class="number">0.4560</span>, <span class="number">0.4060</span>]), std=tensor([<span class="number">0.2290</span>, <span class="number">0.2240</span>, <span class="number">0.2250</span>]))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>正如所期望的那样，可以看到，当设置<code>is_training=True</code>时，额外的转换，如水平翻转和颜色抖动，也包括在内。这些增强方式的数值大小可以通过参数<code>hflip</code>、<code>vflip</code>和<code>color_jitter</code>来控制。<br>还可以看到，用于调整图像大小的方法也因是否是模型训练而不同。在验证期间使用标准的<code>Resize</code>和<code>CenterCrop</code>，而在训练期间则使用<code>RandomResizedCropAndInterpolation</code>。<br>通过下面的代码可以看看<code>RandomResizedCropAndInterpolation</code>具体干了什么。由于<code>timm</code>中这个变换的实现使我们能够设置不同的图像插值方法；在这里我们选择插值是<code>random</code>，即随机选择。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">image = Image.<span class="built_in">open</span>(pets_image_paths[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> timm.data.transforms <span class="keyword">import</span> RandomResizedCropAndInterpolation</span><br><span class="line">tfm = RandomResizedCropAndInterpolation(size=<span class="number">350</span>, interpolation=<span class="string">&#x27;random&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">fig, ax = plt.subplots(<span class="number">2</span>, <span class="number">4</span>, figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line"><span class="keyword">for</span> idx, im <span class="keyword">in</span> <span class="built_in">enumerate</span>([tfm(image) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]):</span><br><span class="line">    ax[<span class="number">0</span>, idx].imshow(im)   </span><br><span class="line"><span class="keyword">for</span> idx, im <span class="keyword">in</span> <span class="built_in">enumerate</span>([tfm(image) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]):</span><br><span class="line">    ax[<span class="number">1</span>, idx].imshow(im)</span><br><span class="line">fig.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br>多次运行该转换，可以观察到对图像进行了不同的剪裁。虽然这在训练过程中是有益的，但在评估过程中可能会增加任务的难度。根据图片的类型，这种类型的转换可能会导致图片的主体被裁剪掉。如果这种情况不常发生，这应该不是一个大问题，可以通过调整比例参数来避免这种情况。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tfm = RandomResizedCropAndInterpolation(size=<span class="number">224</span>, scale=(<span class="number">0.8</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure></p><h2 id="RandAugment"><a href="#RandAugment" class="headerlink" title="RandAugment"></a>RandAugment</h2><p>当开始一个新的任务时，可能很难知道要使用哪些增强，以及以何种顺序使用；由于现在有大量的增强，组合的数量是巨大的。<br>通常，一个好的开始是使用一个在其他任务上表现出良好性能的增强管道。<code>RandAugment</code>就是这样一个策略，它是一种自动化的数据增强方法，从一组增强中统一采样操作——如均衡化、旋转、过曝、颜色抖动、海报化、改变对比度、改变亮度、改变锐度、剪切和平移——并按顺序应用其中的一些；更多信息请参见<a href="https://arxiv.org/abs/1909.13719">原始论文</a>。<br>然而，在<code>timm</code>中提供的实现有几个关键的区别，这些区别由<code>timm</code>的创造者<code>Ross Wightman</code>在<a href="https://arxiv.org/pdf/2110.00476v1.pdf"><code>ResNets Strike Back</code></a>论文的附录中做了最好的描述，将其转述如下：</p><blockquote><p>原始的<code>RandAugment</code>规范有两个超参数，即<code>M</code>和<code>N</code>；其中<code>M</code>是变换幅度，<code>N</code>是每幅图像统一采样和应用的变换数量。<code>RandAugment</code>的目标是，<code>M</code>和<code>N</code>都是人类可以解释的。<br>然而，[在最初的实施中]M的情况最终并非如此。一些增强随着数值变大却是倒退的，或者在范围内不是单调增加的，因此增加<code>M</code>并不能增加所有增强的效果。<br><code>timm</code>的实现试图通过增加一个<code>increasing</code>模式（默认启用）来改善这种情况，在这种模式下，所有的增强的效果都会随着幅度的增加而增加。<br>此外，<code>timm</code>增加了一个<code>MSTD</code>参数，它在每个变换的<code>M</code>值中增加了具有指定标准偏差的高斯噪声。如果<code>MSTD</code>被设置为<code>&#39;-inf&#39;</code>，则每次变换时，<code>M</code>会从<code>0-M</code>中均匀地取样。<br><code>timm</code>的<code>RandAugment</code>会注意减少对图像平均值的影响，归一化参数可以作为一个参数传递，这样所有可能引入边界像素的增强可以使用指定的平均值，而不是像其他实现那样默认为<code>0</code>或一个硬编码的元组。<br>最后，默认情况下不包括<code>Cutout</code>，以支持单独使用<code>timm</code>的随机擦除实现，这对平均数和标准偏差的影响较小。</p></blockquote><p>随机擦除的实现可以查看<a href="https://timm.fast.ai/RandomErase">该文章</a>。<br>现在了解了什么是<code>RandAugment</code>，再看看如何在增强管道中使用它。<br>在<code>timm</code>中，通过使用配置字符串来定义<code>RandAugment</code>策略的参数；它由多个部分组成，以破折号（<code>-</code>）分隔：第一个部分定义了<code>RandAugment</code>的具体变体（目前只支持<code>Rand</code>），其余部分可以按任何顺序排列，它们是：</p><ul><li><code>m</code>：整型，增强的强度</li><li><code>n</code>：整型，每张图像选择的变换的数目，可选，默认设置为<code>2</code></li><li><code>mstd</code>：浮点型，施加的幅度噪声的标准差</li><li><code>mmax</code>：整型，设置幅度的上限，默认为<code>10</code></li><li><code>w</code>：整型，概率权重指数（影响操作选择的一组权重的指数）</li><li><code>inc</code>：布尔型，是否使用随幅度增加而增加的增强，这是可选的，默认为<code>0</code></li></ul><p>比如：</p><ul><li><code>rand-m9-n3-mstd0.5</code>：幅度为<code>9</code>、每张图像有<code>3</code>个增强操作、噪声标准差为<code>0.5</code>的随机增强</li><li><code>rand-mstd1-w0</code>：噪声标准差<code>1.0</code>、概率权重指数<code>0</code>、默认强度最大值为<code>10</code>、每张图像有<code>2</code>个增强操作</li></ul><p>向<code>create_transform</code>传递一个配置字符串，如下可以看到这是由<code>RandAugment</code>对象处理，而且可以看到所有可用的操作的名称：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">create_transform(<span class="number">224</span>, is_training=<span class="literal">True</span>, auto_augment=<span class="string">&#x27;rand-m9-mstd0.5&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Compose(</span><br><span class="line">    RandomResizedCropAndInterpolation(size=(<span class="number">224</span>, <span class="number">224</span>), scale=(<span class="number">0.08</span>, <span class="number">1.0</span>), ratio=(<span class="number">0.75</span>, <span class="number">1.3333</span>), interpolation=bilinear)</span><br><span class="line">    RandomHorizontalFlip(p=<span class="number">0.5</span>)</span><br><span class="line">    RandAugment(n=<span class="number">2</span>, ops=</span><br><span class="line">    AugmentOp(name=AutoContrast, p=<span class="number">0.5</span>, m=<span class="number">9</span>, mstd=<span class="number">0.5</span>)</span><br><span class="line">    AugmentOp(name=Equalize, p=<span class="number">0.5</span>, m=<span class="number">9</span>, mstd=<span class="number">0.5</span>)</span><br><span class="line">    AugmentOp(name=Invert, p=<span class="number">0.5</span>, m=<span class="number">9</span>, mstd=<span class="number">0.5</span>)</span><br><span class="line">    AugmentOp(name=Rotate, p=<span class="number">0.5</span>, m=<span class="number">9</span>, mstd=<span class="number">0.5</span>)</span><br><span class="line">    AugmentOp(name=Posterize, p=<span class="number">0.5</span>, m=<span class="number">9</span>, mstd=<span class="number">0.5</span>)</span><br><span class="line">    AugmentOp(name=Solarize, p=<span class="number">0.5</span>, m=<span class="number">9</span>, mstd=<span class="number">0.5</span>)</span><br><span class="line">    AugmentOp(name=SolarizeAdd, p=<span class="number">0.5</span>, m=<span class="number">9</span>, mstd=<span class="number">0.5</span>)</span><br><span class="line">    AugmentOp(name=Color, p=<span class="number">0.5</span>, m=<span class="number">9</span>, mstd=<span class="number">0.5</span>)</span><br><span class="line">    AugmentOp(name=Contrast, p=<span class="number">0.5</span>, m=<span class="number">9</span>, mstd=<span class="number">0.5</span>)</span><br><span class="line">    AugmentOp(name=Brightness, p=<span class="number">0.5</span>, m=<span class="number">9</span>, mstd=<span class="number">0.5</span>)</span><br><span class="line">    AugmentOp(name=Sharpness, p=<span class="number">0.5</span>, m=<span class="number">9</span>, mstd=<span class="number">0.5</span>)</span><br><span class="line">    AugmentOp(name=ShearX, p=<span class="number">0.5</span>, m=<span class="number">9</span>, mstd=<span class="number">0.5</span>)</span><br><span class="line">    AugmentOp(name=ShearY, p=<span class="number">0.5</span>, m=<span class="number">9</span>, mstd=<span class="number">0.5</span>)</span><br><span class="line">    AugmentOp(name=TranslateXRel, p=<span class="number">0.5</span>, m=<span class="number">9</span>, mstd=<span class="number">0.5</span>)</span><br><span class="line">    AugmentOp(name=TranslateYRel, p=<span class="number">0.5</span>, m=<span class="number">9</span>, mstd=<span class="number">0.5</span>))</span><br><span class="line">    ToTensor()</span><br><span class="line">    Normalize(mean=tensor([<span class="number">0.4850</span>, <span class="number">0.4560</span>, <span class="number">0.4060</span>]), std=tensor([<span class="number">0.2290</span>, <span class="number">0.2240</span>, <span class="number">0.2250</span>]))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>还可以直接通过使用<code>rand_augment_transform</code>函数来创建这个<code>RandAugment</code>对象：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> timm.data.auto_augment <span class="keyword">import</span> rand_augment_transform</span><br><span class="line"></span><br><span class="line">tfm = rand_augment_transform(</span><br><span class="line">    config_str=<span class="string">&#x27;rand-m9-mstd0.5&#x27;</span>, </span><br><span class="line">    hparams=&#123;<span class="string">&#x27;img_mean&#x27;</span>: (<span class="number">124</span>, <span class="number">116</span>, <span class="number">104</span>)&#125;</span><br><span class="line">)</span><br><span class="line">tfm</span><br><span class="line"></span><br><span class="line">RandAugment(n=<span class="number">2</span>, ops=</span><br><span class="line">    AugmentOp(name=AutoContrast, p=<span class="number">0.5</span>, m=<span class="number">9</span>, mstd=<span class="number">0.5</span>)</span><br><span class="line">    AugmentOp(name=Equalize, p=<span class="number">0.5</span>, m=<span class="number">9</span>, mstd=<span class="number">0.5</span>)</span><br><span class="line">    AugmentOp(name=Invert, p=<span class="number">0.5</span>, m=<span class="number">9</span>, mstd=<span class="number">0.5</span>)</span><br><span class="line">    AugmentOp(name=Rotate, p=<span class="number">0.5</span>, m=<span class="number">9</span>, mstd=<span class="number">0.5</span>)</span><br><span class="line">    AugmentOp(name=Posterize, p=<span class="number">0.5</span>, m=<span class="number">9</span>, mstd=<span class="number">0.5</span>)</span><br><span class="line">    AugmentOp(name=Solarize, p=<span class="number">0.5</span>, m=<span class="number">9</span>, mstd=<span class="number">0.5</span>)</span><br><span class="line">    AugmentOp(name=SolarizeAdd, p=<span class="number">0.5</span>, m=<span class="number">9</span>, mstd=<span class="number">0.5</span>)</span><br><span class="line">    AugmentOp(name=Color, p=<span class="number">0.5</span>, m=<span class="number">9</span>, mstd=<span class="number">0.5</span>)</span><br><span class="line">    AugmentOp(name=Contrast, p=<span class="number">0.5</span>, m=<span class="number">9</span>, mstd=<span class="number">0.5</span>)</span><br><span class="line">    AugmentOp(name=Brightness, p=<span class="number">0.5</span>, m=<span class="number">9</span>, mstd=<span class="number">0.5</span>)</span><br><span class="line">    AugmentOp(name=Sharpness, p=<span class="number">0.5</span>, m=<span class="number">9</span>, mstd=<span class="number">0.5</span>)</span><br><span class="line">    AugmentOp(name=ShearX, p=<span class="number">0.5</span>, m=<span class="number">9</span>, mstd=<span class="number">0.5</span>)</span><br><span class="line">    AugmentOp(name=ShearY, p=<span class="number">0.5</span>, m=<span class="number">9</span>, mstd=<span class="number">0.5</span>)</span><br><span class="line">    AugmentOp(name=TranslateXRel, p=<span class="number">0.5</span>, m=<span class="number">9</span>, mstd=<span class="number">0.5</span>)</span><br><span class="line">    AugmentOp(name=TranslateYRel, p=<span class="number">0.5</span>, m=<span class="number">9</span>, mstd=<span class="number">0.5</span>))</span><br></pre></td></tr></table></figure><br>可以将该增强策略应用到图像上，看看其效果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(<span class="number">2</span>, <span class="number">4</span>, figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx, im <span class="keyword">in</span> <span class="built_in">enumerate</span>([tfm(image) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]):</span><br><span class="line">    ax[<span class="number">0</span>, idx].imshow(im)</span><br><span class="line"><span class="keyword">for</span> idx, im <span class="keyword">in</span> <span class="built_in">enumerate</span>([tfm(image) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]):</span><br><span class="line">    ax[<span class="number">1</span>, idx].imshow(im)</span><br><span class="line"></span><br><span class="line">fig.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><h2 id="CutMix和Mixup"><a href="#CutMix和Mixup" class="headerlink" title="CutMix和Mixup"></a>CutMix和Mixup</h2><p><code>timm</code>使用它的<code>Mixup</code>类为<a href="https://arxiv.org/abs/1905.04899"><code>CutMix</code></a>和<a href="https://arxiv.org/abs/1710.09412"><code>Mixup</code></a>增强功能提供了一个灵活的实现，它可以处理这两种增强功能并提供在它们之间切换的选项。<br>通过使用<code>Mixup</code>，可以从各种不同的混合策略中进行选择：</p><ul><li><code>batch</code>：在每个批次上进行<code>CutMix</code>与<code>Mixup</code>的选择、<code>lambda</code>和<code>CutMix</code>区域采样</li><li><code>pair</code>：在一个批次内的取样对上进行混合、<code>lambda</code>和区域取样。</li><li><code>elem</code>：在批次内的每个图像上进行混合、<code>lambda</code>和区域取样。</li><li><code>half</code>：与<code>elementwise</code>相同，但每个混合对中的一个被丢弃，这样每个样本在每个<code>epoch</code>中被看到一次</li></ul><p>下面看一下具体是怎样工作的。<br>首先得需要创建一个数据加载器、迭代器，然后才能将这些增强施加到<code>batch</code>上。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> timm.data <span class="keyword">import</span> ImageDataset</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_dataloader_iterator</span>():</span></span><br><span class="line">    dataset = ImageDataset(<span class="string">&#x27;pets/images&#x27;</span>, transform=create_transform(<span class="number">224</span>))</span><br><span class="line">    dl = <span class="built_in">iter</span>(DataLoader(dataset, batch_size=<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> dl</span><br><span class="line"></span><br><span class="line">dataloader = create_dataloader_iterator()</span><br><span class="line">inputs, classes = <span class="built_in">next</span>(dataloader)</span><br></pre></td></tr></table></figure><br>这里再创建一个可视化函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Taken from timmdocs https://fastai.github.io/timmdocs/mixup_cutmix</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">imshow</span>(<span class="params">inp, title=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Imshow for Tensor.&quot;&quot;&quot;</span></span><br><span class="line">    inp = inp.cpu().numpy().transpose((<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>))</span><br><span class="line">    mean = np.array([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>])</span><br><span class="line">    std = np.array([<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">    inp = std * inp + mean</span><br><span class="line">    inp = np.clip(inp, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    plt.imshow(inp)</span><br><span class="line">    <span class="keyword">if</span> title <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        plt.title(title)</span><br><span class="line">    plt.pause(<span class="number">0.001</span>)  <span class="comment"># pause a bit so that plots are updated</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line">out = torchvision.utils.make_grid(inputs)</span><br><span class="line">imshow(out, title=[x.item() <span class="keyword">for</span> x <span class="keyword">in</span> classes])</span><br></pre></td></tr></table></figure><br>下面创建<code>Mixup</code>变换，其支持如下参数：</p><ul><li><code>mixup_alpha</code>：浮点型，<code>mixup</code>的<code>alpha</code>值，如果大于<code>0</code>，<code>mixup</code>将被激活（默认为<code>1</code>）</li><li><code>cutmix_alpha</code>：浮点型，<code>cutmix</code>的<code>alpha</code>值，如果大于<code>0</code>，则<code>cutmix</code>激活（默认是<code>0</code>）。</li><li><code>cutmix_minmax</code>：<code>List[float])</code>型，<code>cutmix</code>的最小/最大图像比例，如果不是<code>None</code>，<code>cutmix</code>将被激活并使用这个与<code>alpha</code>的比值。</li><li><code>prob</code>：<code>float</code>型， 每个批次或元素应用<code>mixup</code>或<code>cutmix</code>的概率（默认是<code>1</code>）。</li><li><code>switch_prob</code>：<code>float</code>型，当两者都激活时，切换到<code>cutmix</code>而不是<code>mixup</code>的概率（默认是<code>0.5</code>）。</li><li><code>mode</code>：<code>str</code>型， 如何应用<code>mixup/cutmix</code>参数（默认是<code>batch</code>）</li><li><code>label_smoothing</code>：浮点型，应用于混合目标张量的标签平滑量（默认是<code>0.1</code>）</li><li><code>num_classes</code>：<code>int</code>型，目标变量的类别数量。</li></ul><p>创建一个<code>Mixup</code>变换：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> timm.data.mixup <span class="keyword">import</span> Mixup</span><br><span class="line"></span><br><span class="line">mixup_args = &#123;</span><br><span class="line">    <span class="string">&#x27;mixup_alpha&#x27;</span>: <span class="number">1.</span>,</span><br><span class="line">    <span class="string">&#x27;cutmix_alpha&#x27;</span>: <span class="number">1.</span>,</span><br><span class="line">    <span class="string">&#x27;prob&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;switch_prob&#x27;</span>: <span class="number">0.5</span>,</span><br><span class="line">    <span class="string">&#x27;mode&#x27;</span>: <span class="string">&#x27;batch&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;label_smoothing&#x27;</span>: <span class="number">0.1</span>,</span><br><span class="line">    <span class="string">&#x27;num_classes&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">mixup_fn = Mixup(**mixup_args)</span><br></pre></td></tr></table></figure><br>由于<code>mixup</code>和<code>cutmix</code>是在一批次图像上进行的，可以在应用增强之前将这批图像放在<code>GPU</code>上，以加快进度：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mixed_inputs, mixed_classes = mixup_fn(inputs.to(torch.device(<span class="string">&#x27;cuda:0&#x27;</span>)), classes.to(torch.device(<span class="string">&#x27;cuda:0&#x27;</span>)))</span><br><span class="line">out = torchvision.utils.make_grid(mixed_inputs)</span><br><span class="line">imshow(out, title=mixed_classes)</span><br></pre></td></tr></table></figure></p><h1 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h1><p><code>timm</code>提供了许多有用的工具来处理不同类型的数据集。最简单的入门方法是使用<code>create_dataset</code>函数，它将为我们创建一个合适的数据集。<br><code>create_dataset</code>需要有两个参数：</p><ul><li><code>name</code>：要加载的数据集的名称</li><li><code>root</code>：数据集在本地文件系统中的根文件夹。</li></ul><p>也可以有额外的关键字参数用于指定选项，如是否要加载训练集或验证集。<br>还可以使用<code>create_dataset</code>来加载来自不同地方的数据：</p><ul><li><a href="https://pytorch.org/vision/main/datasets.html"><code>TorchVision</code></a>数据集</li><li><a href="https://www.tensorflow.org/datasets"><code>TensorFlow</code></a>数据集</li><li>存储在本地文件夹中的数据集</li></ul><h2 id="加载TorchVision数据集"><a href="#加载TorchVision数据集" class="headerlink" title="加载TorchVision数据集"></a>加载TorchVision数据集</h2><p>要加载<code>TorchVision</code>包含的数据集，只需在希望加载的数据集的名称前指定前缀<code>torch/</code>。如果数据在文件系统中不存在，可以通过设置<code>download=True</code>来下载这些数据。此外，还可以使用<code>split</code>参数来指定加载训练数据集。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> timm.data <span class="keyword">import</span> create_dataset</span><br><span class="line">ds = create_dataset(<span class="string">&#x27;torch/cifar10&#x27;</span>, <span class="string">&#x27;cifar10&#x27;</span>, download=<span class="literal">True</span>, split=<span class="string">&#x27;train&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h2 id="加载TensorFlow数据集"><a href="#加载TensorFlow数据集" class="headerlink" title="加载TensorFlow数据集"></a>加载TensorFlow数据集</h2><p><code>timm</code>还可以使得从<code>TensorFlow</code>数据集中下载和使用数据集；同时封装了底层的<code>tfds</code>对象。<br>当加载<code>TensorFlow</code>数据集时，在数据集的名称前加上<code>tfds/</code>。此时建议设置几个额外的参数，这些参数对于本地或<code>TorchVision</code>数据集来说是不需要的。</p><ul><li><code>batch_size</code>：这是用来确保在分布式训练过程中，样本总数划分到所有节点上能整除批处理大小。</li><li><code>is_training</code>：如果设置了，数据集将被打乱。注意，这与设置<code>split</code>是不同的。</li></ul><p>虽然这个封装从<code>TFDS</code>数据集中返回解压缩的图像示例，但需要的任何增强和批处理仍然由<code>PyTorch</code>处理。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ds = create_dataset(<span class="string">&#x27;tfds/beans&#x27;</span>, <span class="string">&#x27;beans&#x27;</span>, download=<span class="literal">True</span>, split=<span class="string">&#x27;train[:10%]&#x27;</span>, batch_size=<span class="number">2</span>, is_training=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p><h2 id="加载本地数据"><a href="#加载本地数据" class="headerlink" title="加载本地数据"></a>加载本地数据</h2><p>也可以从本地文件夹加载数据，在这种情况下，只需使用一个空字符串（<code>&#39;&#39;</code>）作为数据集名称。<br>除了能够从<code>ImageNet</code>风格的文件夹层次中加载数据外，<code>create_dataset</code>还可以让我们从一个或多个<code>tar</code>档案中提取数据；可以用它来避免解开档案的麻烦。<br>作为一个例子，可以在<code>Imagenette</code>数据集上试试这个方法。<br>此外，到目前为止，一直在加载原始图像，所以这里也使用变换参数来应用一些变换：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ds = create_dataset(name=<span class="string">&#x27;&#x27;</span>, root=<span class="string">&#x27;imagenette/imagenette2-320.tar&#x27;</span>, transform=create_transform(<span class="number">224</span>))</span><br></pre></td></tr></table></figure></p><h2 id="ImageDataset类"><a href="#ImageDataset类" class="headerlink" title="ImageDataset类"></a>ImageDataset类</h2><p>如上所述，<code>create_dataset</code>函数为处理不同类型的数据提供了很多选择。<code>timm</code>之所以能够提供这样的灵活性，是通过尽可能地使用<code>TorchVision</code>中提供的现有数据集类，以及提供一些额外的实现——<code>ImageDataset</code>和<code>IterableImageDataset</code>，它们可用于广泛的场景。<br>从本质上讲，<code>create_dataset</code>通过选择一个合适的类为我们简化了这个过程，但有时我们可能希望直接与底层组件一起工作。<br><code>Chris Hughes</code>最常使用的实现是<code>ImageDataset</code>，它类似于<code>torchvision.datasets.ImageFolder</code>，但有一些附加功能。<br>下面探讨一下如何使用它来加载之前解压缩的<code>imagenette</code>数据集：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> timm.data <span class="keyword">import</span> ImageDataset</span><br><span class="line">imagenette_ds = ImageDataset(<span class="string">&#x27;imagenette/imagenette2-320/train&#x27;</span>)</span><br></pre></td></tr></table></figure><br><code>ImageDataset</code>的灵活性的关键在于，它索引和加载样本的方式被抽象成一个解析器对象<code>parser</code>。<br><code>timm</code>中包含了多个解析器，包括从文件夹、<code>tar</code>文件和<code>tensorflow</code>数据集读取图像的解析器。解析器可以作为一个参数传递给数据集，可以直接访问解析器。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">imagenette_ds.parser</span><br><span class="line"></span><br><span class="line">&lt;timm.data.parsers.parser_image_folder.ParserImageFolder at <span class="number">0x7f66e8146ee0</span>&gt;</span><br></pre></td></tr></table></figure><br>可以看到，默认的解析器是<code>ParserImageFolder</code>的一个实例。解析器还包含有用的信息，比如类别查找，如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">imagenette_ds.parser.class_to_idx</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&#x27;n01440764&#x27;</span>: <span class="number">0</span>,</span><br><span class="line"> <span class="string">&#x27;n02102040&#x27;</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="string">&#x27;n02979186&#x27;</span>: <span class="number">2</span>,</span><br><span class="line"> <span class="string">&#x27;n03000684&#x27;</span>: <span class="number">3</span>,</span><br><span class="line"> <span class="string">&#x27;n03028079&#x27;</span>: <span class="number">4</span>,</span><br><span class="line"> <span class="string">&#x27;n03394916&#x27;</span>: <span class="number">5</span>,</span><br><span class="line"> <span class="string">&#x27;n03417042&#x27;</span>: <span class="number">6</span>,</span><br><span class="line"> <span class="string">&#x27;n03425413&#x27;</span>: <span class="number">7</span>,</span><br><span class="line"> <span class="string">&#x27;n03445777&#x27;</span>: <span class="number">8</span>,</span><br><span class="line"> <span class="string">&#x27;n03888257&#x27;</span>: <span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure></p><h3 id="手动选择解析器——以tar包为例"><a href="#手动选择解析器——以tar包为例" class="headerlink" title="手动选择解析器——以tar包为例"></a>手动选择解析器——以tar包为例</h3><p>因此，除了选择一个合适的数据集类之外，<code>create_dataset</code>还负责选择正确的解析器。<br>再次考虑压缩的<code>Imagenette</code>数据集，可以通过手动选择<code>ParserImageInTarparser</code>并覆盖<code>ImageDataset</code>的默认解析器来实现同样的结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> timm.data.parsers.parser_image_in_tar <span class="keyword">import</span> ParserImageInTar</span><br><span class="line"></span><br><span class="line">data_path = <span class="string">&#x27;imagenette&#x27;</span></span><br><span class="line">ds = ImageDataset(data_path, parser=ParserImageInTar(data_path))</span><br></pre></td></tr></table></figure></p><h3 id="自定义解析器——以pets数据集为例"><a href="#自定义解析器——以pets数据集为例" class="headerlink" title="自定义解析器——以pets数据集为例"></a>自定义解析器——以pets数据集为例</h3><p>遗憾的是，数据集的结构并不总是像<code>ImageNet</code>那样；也就是说，具有以下结构：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root/class_1/xx1.jpg</span><br><span class="line">root/class_1/xx2.jpg</span><br><span class="line">root/class_2/xx1.jpg</span><br><span class="line">root/class_2/xx2.jpg</span><br></pre></td></tr></table></figure><br>对于这些数据集，<code>ImageDataset</code>不会开箱即用。虽然我们总是可以实现一个自定义的数据集来处理这个问题，但这可能是一个挑战，取决于数据的存储方式。另一个选择是编写一个与<code>ImageDataset</code>配合使用的自定义解析器。<br>作为一个例子，考虑前面牛津大学的宠物数据集，其中所有的图片都位于一个文件夹中，而类的名称——在这种情况下是每个品种的名称——包含在文件名中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ls pets/images/</span><br><span class="line"></span><br><span class="line">Abyssinian_100.jpg*                 keeshond_186.jpg*</span><br><span class="line">Abyssinian_100.mat                  keeshond_187.jpg*</span><br><span class="line">Abyssinian_101.jpg*                 keeshond_188.jpg*</span><br><span class="line">Abyssinian_101.mat                  keeshond_189.jpg*</span><br><span class="line">Abyssinian_102.jpg*                 keeshond_18.jpg*</span><br><span class="line">Abyssinian_102.mat                  keeshond_190.jpg*</span><br><span class="line">Abyssinian_103.jpg*                 keeshond_191.jpg*</span><br><span class="line">Abyssinian_104.jpg*                 keeshond_192.jpg*</span><br><span class="line">Abyssinian_105.jpg*                 keeshond_193.jpg*</span><br><span class="line">Abyssinian_106.jpg*                 keeshond_194.jpg*</span><br><span class="line">................</span><br></pre></td></tr></table></figure><br>在这种情况下，由于我们仍然是从本地文件系统加载图片，所以只需对<code>ParserImageFolder</code>稍作调整。<br>先看看<code>ParserImageFolder</code>是如何实现的，以获得启发：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">??timm.data.parsers.parser_image_folder.ParserImageFolder</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParserImageFolder</span>(<span class="params">Parser</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            self,</span></span></span><br><span class="line"><span class="function"><span class="params">            root,</span></span></span><br><span class="line"><span class="function"><span class="params">            class_map=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">        self.root = root</span><br><span class="line">        class_to_idx = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> class_map:</span><br><span class="line">            class_to_idx = load_class_map(class_map, root)</span><br><span class="line">        self.samples, self.class_to_idx = find_images_and_targets(root, class_to_idx=class_to_idx)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.samples) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(</span><br><span class="line">                <span class="string">f&#x27;Found 0 images in subfolders of <span class="subst">&#123;root&#125;</span>. Supported image extensions are <span class="subst">&#123;<span class="string">&quot;, &quot;</span>.join(IMG_EXTENSIONS)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        path, target = self.samples[index]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">open</span>(path, <span class="string">&#x27;rb&#x27;</span>), target</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.samples)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_filename</span>(<span class="params">self, index, basename=<span class="literal">False</span>, absolute=<span class="literal">False</span></span>):</span></span><br><span class="line">        filename = self.samples[index][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> basename:</span><br><span class="line">            filename = os.path.basename(filename)</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> absolute:</span><br><span class="line">            filename = os.path.relpath(filename, self.root)</span><br><span class="line">        <span class="keyword">return</span> filename</span><br></pre></td></tr></table></figure><br>可以看到，<code>ParserImageFolder</code>做了几件事：</p><ul><li>为类别创建一个映射<code>class_map</code></li><li>实现<code>__len__</code>以返回样本的数量</li><li>实现<code>__filename</code>来返回样本的文件名，通过选项来决定它应该是绝对路径还是相对路径</li><li>实现<code>__getitem__</code>以返回样本和目标。</li></ul><p>现在理解了必须实现的方法，可以在此基础上创建自定义的实现。此处使用了标准库中的<code>pathlib</code>来提取类别名并处理路径（可能比<code>os</code>更容易操作）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> timm.data.parsers.parser <span class="keyword">import</span> Parser</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParserImageName</span>(<span class="params">Parser</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, root, class_to_idx=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">        self.root = Path(root)</span><br><span class="line">        self.samples = <span class="built_in">list</span>(self.root.glob(<span class="string">&quot;*.jpg&quot;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> class_to_idx:</span><br><span class="line">            self.class_to_idx = class_to_idx</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            classes = <span class="built_in">sorted</span>(</span><br><span class="line">                <span class="built_in">set</span>([self.__extract_label_from_path(p) <span class="keyword">for</span> p <span class="keyword">in</span> self.samples]),</span><br><span class="line">                key=<span class="keyword">lambda</span> s: s.lower(),</span><br><span class="line">            )</span><br><span class="line">            self.class_to_idx = &#123;c: idx <span class="keyword">for</span> idx, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(classes)&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__extract_label_from_path</span>(<span class="params">self, path</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;_&quot;</span>.join(path.parts[-<span class="number">1</span>].split(<span class="string">&quot;_&quot;</span>)[<span class="number">0</span>:-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        path = self.samples[index]</span><br><span class="line">        target = self.class_to_idx[self.__extract_label_from_path(path)]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">open</span>(path, <span class="string">&quot;rb&quot;</span>), target</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.samples)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_filename</span>(<span class="params">self, index, basename=<span class="literal">False</span>, absolute=<span class="literal">False</span></span>):</span></span><br><span class="line">        filename = self.samples[index][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> basename:</span><br><span class="line">            filename = filename.parts[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> absolute:</span><br><span class="line">            filename = filename.absolute()</span><br><span class="line">        <span class="keyword">return</span> filename</span><br></pre></td></tr></table></figure><br>现在就可以把解析器的一个实例传递给<code>ImageDataset</code>，应该能使它正确地加载宠物数据集：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data_path = Path(<span class="string">&#x27;pets/images&#x27;</span>)</span><br><span class="line">ds = ImageDataset(<span class="built_in">str</span>(data_path), parser=ParserImageName(data_path))</span><br><span class="line">ds[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">(&lt;PIL.Image.Image image mode=RGB size=500x332&gt;, <span class="number">9</span>)</span><br></pre></td></tr></table></figure><br>此外，与默认的解析器一样，可以查看类别与索引之间的映射：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">ds.parser.class_to_idx</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&#x27;Abyssinian&#x27;</span>: <span class="number">0</span>,</span><br><span class="line"> <span class="string">&#x27;american_bulldog&#x27;</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="string">&#x27;american_pit_bull_terrier&#x27;</span>: <span class="number">2</span>,</span><br><span class="line"> <span class="string">&#x27;basset_hound&#x27;</span>: <span class="number">3</span>,</span><br><span class="line"> <span class="string">&#x27;beagle&#x27;</span>: <span class="number">4</span>,</span><br><span class="line"> <span class="string">&#x27;Bengal&#x27;</span>: <span class="number">5</span>,</span><br><span class="line"> <span class="string">&#x27;Birman&#x27;</span>: <span class="number">6</span>,</span><br><span class="line"> <span class="string">&#x27;Bombay&#x27;</span>: <span class="number">7</span>,</span><br><span class="line"> <span class="string">&#x27;boxer&#x27;</span>: <span class="number">8</span>,</span><br><span class="line"> <span class="string">&#x27;British_Shorthair&#x27;</span>: <span class="number">9</span>,</span><br><span class="line"> <span class="string">&#x27;chihuahua&#x27;</span>: <span class="number">10</span>,</span><br><span class="line"> <span class="string">&#x27;Egyptian_Mau&#x27;</span>: <span class="number">11</span>,</span><br><span class="line"> <span class="string">&#x27;english_cocker_spaniel&#x27;</span>: <span class="number">12</span>,</span><br><span class="line"> <span class="string">&#x27;english_setter&#x27;</span>: <span class="number">13</span>,</span><br><span class="line"> <span class="string">&#x27;german_shorthaired&#x27;</span>: <span class="number">14</span>,</span><br><span class="line"> <span class="string">&#x27;great_pyrenees&#x27;</span>: <span class="number">15</span>,</span><br><span class="line"> <span class="string">&#x27;havanese&#x27;</span>: <span class="number">16</span>,</span><br><span class="line"> <span class="string">&#x27;japanese_chin&#x27;</span>: <span class="number">17</span>,</span><br><span class="line"> <span class="string">&#x27;keeshond&#x27;</span>: <span class="number">18</span>,</span><br><span class="line"> <span class="string">&#x27;leonberger&#x27;</span>: <span class="number">19</span>,</span><br><span class="line"> <span class="string">&#x27;Maine_Coon&#x27;</span>: <span class="number">20</span>,</span><br><span class="line"> <span class="string">&#x27;miniature_pinscher&#x27;</span>: <span class="number">21</span>,</span><br><span class="line"> <span class="string">&#x27;newfoundland&#x27;</span>: <span class="number">22</span>,</span><br><span class="line"> <span class="string">&#x27;Persian&#x27;</span>: <span class="number">23</span>,</span><br><span class="line"> <span class="string">&#x27;pomeranian&#x27;</span>: <span class="number">24</span>,</span><br><span class="line"> <span class="string">&#x27;pug&#x27;</span>: <span class="number">25</span>,</span><br><span class="line"> <span class="string">&#x27;Ragdoll&#x27;</span>: <span class="number">26</span>,</span><br><span class="line"> <span class="string">&#x27;Russian_Blue&#x27;</span>: <span class="number">27</span>,</span><br><span class="line"> <span class="string">&#x27;saint_bernard&#x27;</span>: <span class="number">28</span>,</span><br><span class="line"> <span class="string">&#x27;samoyed&#x27;</span>: <span class="number">29</span>,</span><br><span class="line"> <span class="string">&#x27;scottish_terrier&#x27;</span>: <span class="number">30</span>,</span><br><span class="line"> <span class="string">&#x27;shiba_inu&#x27;</span>: <span class="number">31</span>,</span><br><span class="line"> <span class="string">&#x27;Siamese&#x27;</span>: <span class="number">32</span>,</span><br><span class="line"> <span class="string">&#x27;Sphynx&#x27;</span>: <span class="number">33</span>,</span><br><span class="line"> <span class="string">&#x27;staffordshire_bull_terrier&#x27;</span>: <span class="number">34</span>,</span><br><span class="line"> <span class="string">&#x27;wheaten_terrier&#x27;</span>: <span class="number">35</span>,</span><br><span class="line"> <span class="string">&#x27;yorkshire_terrier&#x27;</span>: <span class="number">36</span>&#125;</span><br></pre></td></tr></table></figure></p><h1 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h1><p><code>timm</code>具有大量的优化器，其中一些是<code>PyTorch</code>所不具备的。除了使人们能够方便地使用<code>SGD</code>、<code>Adam</code>和<code>AdamW</code>等熟悉的优化器外，还有一些值得注意的优化器有：</p><ul><li><code>AdamP</code>：见<a href="https://arxiv.org/abs/2006.08217">该论文</a></li><li><code>RMSPropTF</code>：基于原始<code>TensorFlow</code>实现的<code>RMSProp</code>的实现，以及<a href="https://github.com/pytorch/pytorch/issues/23796">这里</a>讨论的其他小的调整。根据<code>Chris Hughes</code>的经验，这通常会产生比<code>PyTorch</code>版本更稳定的训练效果。</li><li><code>LAMB</code>：来自<code>Apex</code>的<code>FusedLAMB</code>优化器的纯<code>pytorch</code>变体，在使用<code>PyTorch XLA</code>时，它与<code>TPU</code>兼容。</li><li><code>AdaBelief</code>：见<a href="https://arxiv.org/abs/2010.07468">该论文</a>。关于设置超参数的指导可在<a href="https://github.com/juntang-zhuang/Adabelief-Optimizer#quick-guide">此</a>获得。</li><li><code>MADGRAD</code>：见<a href="https://arxiv.org/abs/2101.11075">该论文</a></li><li><code>AdaHessian</code>：自适应二阶优化器，见<a href="https://arxiv.org/abs/2006.00719">该论文</a>。</li></ul><p><code>timm</code>中的优化器支持与<code>torch.optim</code>中的优化器相同的接口，在大多数情况下，可以简单地放入训练脚本中，不需要做任何改动。<br>要查看<code>timm</code>实现的所有优化器，可以查看<code>timm.opt</code>模块：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"><span class="keyword">import</span> timm.optim</span><br><span class="line"></span><br><span class="line">[cls_name <span class="keyword">for</span> cls_name, cls_obj <span class="keyword">in</span> inspect.getmembers(timm.optim) <span class="keyword">if</span> inspect.isclass(cls_obj) <span class="keyword">if</span> cls_name !=<span class="string">&#x27;Lookahead&#x27;</span>]</span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;AdaBelief&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Adafactor&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Adahessian&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;AdamP&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;AdamW&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Lamb&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Lars&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;MADGRAD&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Nadam&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;NvNovoGrad&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;RAdam&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;RMSpropTF&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;SGDP&#x27;</span>]</span><br></pre></td></tr></table></figure><br>创建一个优化器的最简单方法是使用<code>create_optimizer_v2</code>工厂函数，该函数期望得到以下信息：</p><ul><li>一个模型，或一组参数</li><li>优化器的名称</li><li>任何要传递给优化器的参数</li></ul><p>可以使用这个函数来创建基于<code>timm</code>的优化器，以及来自<code>torch.optimizer</code>的优化器和来自<code>Apex</code>的<a href="https://nvidia.github.io/apex/optimizers.html">融合优化器</a>（如果已安装）的任意的优化器。</p><p>看一下一些例子。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">model = torch.nn.Sequential(</span><br><span class="line">    torch.nn.Linear(<span class="number">2</span>, <span class="number">1</span>),</span><br><span class="line">    torch.nn.Flatten(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line">optimizer = timm.optim.create_optimizer_v2(model, opt=<span class="string">&#x27;sgd&#x27;</span>, lr=<span class="number">0.01</span>, momentum=<span class="number">0.8</span>); </span><br><span class="line"></span><br><span class="line">optimizer, <span class="built_in">type</span>(optimizer)</span><br><span class="line"></span><br><span class="line">(SGD (</span><br><span class="line"> Parameter Group <span class="number">0</span></span><br><span class="line">     dampening: <span class="number">0</span></span><br><span class="line">     lr: <span class="number">0.01</span></span><br><span class="line">     momentum: <span class="number">0.8</span></span><br><span class="line">     nesterov: <span class="literal">True</span></span><br><span class="line">     weight_decay: <span class="number">0.0</span></span><br><span class="line"> ),</span><br><span class="line"> torch.optim.sgd.SGD)</span><br></pre></td></tr></table></figure><br>可以看到，由于<code>timm</code>不包含<code>SGD</code>的实现，上述代码使用<code>torch.optim</code>的实现来创建了优化器。<br>再试着创建一个在<code>timm</code>中实现的优化器：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">optimizer = timm.optim.create_optimizer_v2(model, </span><br><span class="line">                                           opt=<span class="string">&#x27;lamb&#x27;</span>,</span><br><span class="line">                                           lr=<span class="number">0.01</span>,</span><br><span class="line">                                           weight_decay=<span class="number">0.01</span>)</span><br><span class="line">optimizer, <span class="built_in">type</span>(optimizer)</span><br><span class="line"></span><br><span class="line">(Lamb (</span><br><span class="line"> Parameter Group <span class="number">0</span></span><br><span class="line">     always_adapt: <span class="literal">False</span></span><br><span class="line">     betas: (<span class="number">0.9</span>, <span class="number">0.999</span>)</span><br><span class="line">     bias_correction: <span class="literal">True</span></span><br><span class="line">     eps: <span class="number">1e-06</span></span><br><span class="line">     grad_averaging: <span class="literal">True</span></span><br><span class="line">     lr: <span class="number">0.01</span></span><br><span class="line">     max_grad_norm: <span class="number">1.0</span></span><br><span class="line">     trust_clip: <span class="literal">False</span></span><br><span class="line">     weight_decay: <span class="number">0.0</span></span><br><span class="line"> </span><br><span class="line"> Parameter Group <span class="number">1</span></span><br><span class="line">     always_adapt: <span class="literal">False</span></span><br><span class="line">     betas: (<span class="number">0.9</span>, <span class="number">0.999</span>)</span><br><span class="line">     bias_correction: <span class="literal">True</span></span><br><span class="line">     eps: <span class="number">1e-06</span></span><br><span class="line">     grad_averaging: <span class="literal">True</span></span><br><span class="line">     lr: <span class="number">0.01</span></span><br><span class="line">     max_grad_norm: <span class="number">1.0</span></span><br><span class="line">     trust_clip: <span class="literal">False</span></span><br><span class="line">     weight_decay: <span class="number">0.01</span></span><br><span class="line"> ),</span><br><span class="line"> timm.optim.lamb.Lamb)</span><br></pre></td></tr></table></figure><br>当然，如果不愿意使用<code>create_optimizer_v2</code>，所有这些优化器都可以用常规的方式创建。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimizer = timm.optim.RMSpropTF(model.parameters(), lr=<span class="number">0.01</span>)</span><br></pre></td></tr></table></figure></p><h2 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h2><p>大部分的优化器用法如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># replace </span></span><br><span class="line"><span class="comment"># optimizer = torch.optim.Adam(model.parameters(), lr=0.01)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># with</span></span><br><span class="line">optimizer = timm.optim.AdamP(model.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> num_epochs:</span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> training_dataloader:</span><br><span class="line">        inputs, targets = batch</span><br><span class="line">        outputs = model(inputs)</span><br><span class="line">        loss = loss_function(outputs, targets)</span><br><span class="line"></span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        optimizer.zero_grad()</span><br></pre></td></tr></table></figure><br>截至当前，唯一的例外是二阶<code>Adahessian</code>优化器，它在执行反向传播步骤时需要一个小的调整；类似的调整可能需要用于未来可能添加的其他二阶优化器。即：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">optimizer = timm.optim.Adahessian(model.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">is_second_order = <span class="built_in">hasattr</span>(optimizer, <span class="string">&#x27;is_second_order&#x27;</span>) <span class="keyword">and</span> optimizer.is_second_order <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> num_epochs:</span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> training_dataloader:</span><br><span class="line">        inputs, targets = batch</span><br><span class="line">        outputs = model(inputs)</span><br><span class="line">        loss = loss_function(outputs, targets)</span><br><span class="line"></span><br><span class="line">        loss.backward(create_graph=second_order)</span><br><span class="line">        optimizer.step()</span><br><span class="line">        optimizer.zero_grad()</span><br></pre></td></tr></table></figure></p><h2 id="Lookahead"><a href="#Lookahead" class="headerlink" title="Lookahead"></a>Lookahead</h2><p><code>timm</code>也使我们能够将<code>lookahead</code>算法应用于优化器；参考资料比如<a href="https://www.youtube.com/watch?v=TxGxiDK0Ccc">这个视频</a>。<code>Lookahead</code>可以提高学习的稳定性并降低其内部优化器的方差，其计算和内存成本可以忽略不计。<br>可以通过在优化器名称前加上<code>lookahead_</code>来将<code>Lookahead</code>应用到优化器中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimizer = timm.optim.create_optimizer_v2(model.parameters(), opt=<span class="string">&#x27;lookahead_adam&#x27;</span>, lr=<span class="number">0.01</span>)</span><br></pre></td></tr></table></figure><br>或由<code>timm</code>的<code>Lookahead</code>类中的优化器实例进行包装：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timm.optim.Lookahead(optimizer, alpha=<span class="number">0.5</span>, k=<span class="number">6</span>)</span><br></pre></td></tr></table></figure><br>当使用<code>Lookahead</code>时，需要更新训练脚本，加入以下一行，以更新慢的权重：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimizer.sync_lookahead()</span><br></pre></td></tr></table></figure><br>一个例子如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">optimizer = timm.optim.AdamP(model.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line">optimizer = timm.optim.Lookahead(optimizer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> num_epochs:</span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> training_dataloader:</span><br><span class="line">        inputs, targets = batch</span><br><span class="line">        outputs = model(inputs)</span><br><span class="line">        loss = loss_function(outputs, targets)</span><br><span class="line"></span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">    optimizer.sync_lookahead()</span><br></pre></td></tr></table></figure></p><h1 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h1><p><code>timm</code>包含以下调度器</p><ul><li><code>StepLRScheduler</code>：学习率每<code>n</code>步衰减；类似于<code>torch.optim.lr_scheduler.StepLR</code></li><li><code>MultiStepLRScheduler</code>：一个支持多个目标里程碑的步进调度器，在这些里程碑上降低学习率；类似于<code>torch.optim.lr_scheduler.MultiStepLR</code></li><li><code>PlateauLRScheduler</code>：在每次指定的指标出现高原期时，以指定的系数降低学习率；类似于<code>`torch.optim.lr_scheduler.ReduceLROnPlateau</code></li><li><code>CosineLRScheduler</code>：具有重启功能的余弦衰减调度器；类似于<code>torch.optim.lr_scheduler.CosineAnnealingWarmRestarts</code></li><li><code>TanhLRScheduler</code>：带重启的双曲正切衰变调度器</li><li><code>PolyLRScheduler</code>：多项式衰变调度器。</li></ul><p>虽然许多在<code>timm</code>中实现的调度器在<code>PyTorch</code>中也有对应的调度器，但<code>timm</code>版本通常有不同的默认超参数，并提供额外的选项和灵活性；所有<code>timm</code>调度器都有预热<code>epochs</code>，以及在调度中添加随机噪声的选项。此外，<code>CosineLRScheduler</code>和<code>PolyLRScheduler</code>支持被称为<code>k-decay</code>的衰减选项。</p><h2 id="应用案例-1"><a href="#应用案例-1" class="headerlink" title="应用案例"></a>应用案例</h2><p>在研究这些调度器提供的一些选项之前，首先探讨一下如何在自定义训练脚本中使用<code>timm</code>的调度器。<br>与<code>PyTorch</code>中包含的调度器不同，在每个<code>epoch</code>中更新两次<code>timm</code>调度器是最佳实践。</p><ul><li><code>.step_update</code>方法应该在每次优化器更新后被调用，并给出下一次更新的索引；这就是<code>PyTorch</code>调度器调用<code>.step</code>的地方</li><li><code>.step</code>方法应该在每个<code>epoch</code>结束时被调用，并标明下一个<code>epoch</code>的索引。</li></ul><p>通过明确提供更新次数和<code>epoch</code>索引，这使得<code>timm</code>调度器能够消除在<code>PyTorch</code>调度器中观察到的混乱的 <code>last_epoch</code>和<code>-1</code>行为。一个例子如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">training_epochs = <span class="number">300</span></span><br><span class="line">cooldown_epochs = <span class="number">10</span></span><br><span class="line">num_epochs = training_epochs + cooldown_epochs</span><br><span class="line"></span><br><span class="line">optimizer = timm.optim.AdamP(my_model.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line">scheduler = timm.scheduler.CosineLRScheduler(optimizer, t_initial=training_epochs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line"></span><br><span class="line">    num_steps_per_epoch = <span class="built_in">len</span>(train_dataloader)</span><br><span class="line">    num_updates = epoch * num_steps_per_epoch</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> training_dataloader:</span><br><span class="line">        inputs, targets = batch</span><br><span class="line">        outputs = model(inputs)</span><br><span class="line">        loss = loss_function(outputs, targets)</span><br><span class="line"></span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        scheduler.step_update(num_updates=num_updates)</span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">    scheduler.step(epoch + <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><h2 id="调节学习率调度器"><a href="#调节学习率调度器" class="headerlink" title="调节学习率调度器"></a>调节学习率调度器</h2><p>为了展示<code>timm</code>提供的一些选项，探索一些可用的超参数，以及修改这些参数对学习率调度的影响。<br>在这里，将专注于<code>CosineLRScheduler</code>，因为这是<code>timm</code>训练脚本中默认使用的调度器。然而，如上所述，添加预热和噪声等功能存在于上述所有的调度器中。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scheduler = timm.scheduler.CosineLRScheduler(optimizer,</span><br><span class="line">                                            t_initial=num_epoch_repeat*num_steps_per_epoch,</span><br><span class="line">                                            lr_min=<span class="number">1e-6</span>,</span><br><span class="line">                                            cycle_limit=num_epoch_repeat+<span class="number">1</span>,</span><br><span class="line">                                            t_in_epochs=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></p><h1 id="指数滑动平均模型"><a href="#指数滑动平均模型" class="headerlink" title="指数滑动平均模型"></a>指数滑动平均模型</h1><p>在训练一个模型时，通过对整个训练过程中观察到的参数进行移动平均来设置模型的权重值，而不是使用最后一次增量更新后得到的参数，这样做是有益的。在实践中，这通常是通过维护<code>EMA</code>模型来实现的，<code>EMA</code>模型是我们正在训练的模型的一个副本。然而，我们不是在每个更新步骤后更新这个模型的所有参数，而是使用现有参数值和更新值的线性组合来设置这些参数。<br>为了理解为什么这可能是有益的，让我们考虑这样的情况：我们的模型，在训练的早期阶段，在一批数据上表现得特别差。这可能会导致对参数进行大量更新，过度补偿所获得的高损失，这对接下来的批次是不利的。通过只纳入最新参数的一小部分，大的更新将被 “平滑”，对模型的权重产生较小的整体影响。<br>有时，这些平均的参数在评估过程中有时会产生明显更好的结果，这种技术已经被用于流行模型的一些训练方案中，如训练<code>MNASNet</code>、<code>MobileNet-V3</code>和<code>EfficientNet</code>。使用<code>timm</code>中实现的<code>ModelEmaV2</code>模块，可以复制这种行为，并将同样的做法应用于自己的训练脚本。<br>（具体技术细节不再详述）</p>]]></content>
    
    
    <summary type="html">参考文档：0、1、2

简介
PyTorch Image Models (timm)是Ross Wightman创建的深度学习库，是一个大型集合，包括了SOTA计算机视觉模型、神经网络层、实用函数、优化器、调度器、数据加载器、数据增强器以及训练/验证脚本等。

安装
1


pip install timm


示例数据集（可选）
在演示之前，先下载一些流行的数据集作为示范。在这里，Chris Hughes使用了两个数据集：

 * 牛津大学IIIT宠物数据集，该数据集有37个类别，每个类别大约有200张图片
 * Imagenette，这是Imagenet中10个容易分类的类别的一个子集。
</summary>
    
    
    
    <category term="machine learning" scheme="http://qixinbo.github.io/categories/machine-learning/"/>
    
    
    <category term="PyTorch" scheme="http://qixinbo.github.io/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>物联网应用的低代码开发工具Node-RED上手及案例</title>
    <link href="http://qixinbo.github.io/2022/06/19/node_red/"/>
    <id>http://qixinbo.github.io/2022/06/19/node_red/</id>
    <published>2022-06-18T16:00:00.000Z</published>
    <updated>2022-06-19T07:48:00.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://nodered.org/">Node-RED</a>是一种低代码的将各种硬件设备、API和在线服务连接起来的编程工具，比如将各种传感器（如树莓派上的传感器）、工业控制器（如<code>MQTT</code>、<code>OPC-UA</code>协议）、在线API（比如获取天气情况、发送邮件等）等以图形化拖拽编程的形式进行高效组态。因此，<code>Node-RED</code>广泛地应用在物联网流程和程序开发中。</p><h1 id="安装和运行"><a href="#安装和运行" class="headerlink" title="安装和运行"></a>安装和运行</h1><p><code>Node-RED</code>可以运行在多种设备上，比如本地计算机运行、设备上运行（如树莓派、Arduino和Android等），以及在云端运行（比如IBM云、AWS云和微软Azure云等）。<br>具体可以查看<a href="https://nodered.org/docs/getting-started/">这里</a>。<br>下面将以本地计算机运行为例，同时最简单的就是使用<code>docker</code>方式进行安装、运行。<br><code>docker</code>安装运行只需一条命令即可：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p 1880:1880 -v node_red_data:/data --name mynodered nodered/node-red</span><br></pre></td></tr></table></figure><br>对该命令具体解释一下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run              - 利用镜像创建容器，会先检查本地是否存在指定的镜像，或不存在就从公有仓库下载</span><br><span class="line">-it                     - 附加一个交互式的终端，以查看输出内容</span><br><span class="line">-p 1880:1880            - 指定端口映射</span><br><span class="line">-v node_red_data:/data  - 挂载容器数据卷，实现容器数据的持久化，前者是主机目录，后者是容器内目录</span><br><span class="line">--name mynodered        - 自定义一个容器名</span><br><span class="line">nodered/node-red        - 该容器所基于的镜像文件</span><br></pre></td></tr></table></figure><br>启动命令后就可以在浏览器中通过<code>http://&#123;host-ip&#125;:1880</code>这样的地址访问<code>Node-RED</code>，比如<code>http://127.0.0.1:1880/</code>。</p><h2 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h2><p>此时命令运行在终端，如果对运行情况满意，可以通过<code>Ctrl-p</code> <code>Ctrl-q</code>命令将其转入守护模式，此时容器就会在后台运行，</p><h2 id="前台运行"><a href="#前台运行" class="headerlink" title="前台运行"></a>前台运行</h2><p>如果想重新在终端中查看运行日志，则重新附加到终端运行，即：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach mynodered</span><br></pre></td></tr></table></figure></p><h2 id="停止和重启"><a href="#停止和重启" class="headerlink" title="停止和重启"></a>停止和重启</h2><p>停止容器，使用：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop mynodered</span><br></pre></td></tr></table></figure><br>如果想重启容器（比如计算机重启后或Docker daemon守护进程重启后），则：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start mynodered</span><br></pre></td></tr></table></figure></p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>更多关于<code>docker</code>安装和运行<code>Node-RED</code>，可以查看<a href="https://nodered.org/docs/getting-started/docker">这里</a>，里面详述了数据持久化、升级、其他设备上的安装方式等。</p><h1 id="创建第一个flow"><a href="#创建第一个flow" class="headerlink" title="创建第一个flow"></a>创建第一个flow</h1><p>这部分将创建<code>Node-RED</code>的第一个<code>flow</code>，来入门学习<code>Node-RED</code>。</p><h2 id="访问编辑器"><a href="#访问编辑器" class="headerlink" title="访问编辑器"></a>访问编辑器</h2><p>当在后台运行了<code>Node-RED</code>后，就可以在浏览器中打开编辑器。<br>如果浏览器与<code>Node-RED</code>运行在同一台电脑上，那么就可以通过<code>http://localhost:1880</code>打开编辑器。<br>如果在另一台电脑上打开浏览器，则使用具体ip地址访问即可，即：<code>http://&lt;ip-address&gt;:1880</code>。</p><h2 id="添加inject节点"><a href="#添加inject节点" class="headerlink" title="添加inject节点"></a>添加inject节点</h2><p><code>inject</code>节点可以对一个<code>flow</code>发射消息，比如在这个节点上点击它上面的左侧小按钮，或者在多个<code>injects</code>之间设置时间间隔。<br>从左侧面板中拖动<code>inject</code>节点到中间工作区中。</p><h2 id="添加debug节点"><a href="#添加debug节点" class="headerlink" title="添加debug节点"></a>添加debug节点</h2><p><code>debug</code>节点能够将信息显示在<code>Debug</code>边栏中。默认情况下，它会只显示消息的<code>payload</code>（即承载的内容），也有可能显示整个消息对象。<br>从左侧面板中拖动<code>debug</code>节点到中间工作区中。</p><h2 id="连线"><a href="#连线" class="headerlink" title="连线"></a>连线</h2><p>在<code>inject</code>节点的输出拖动到<code>debug</code>节点的输入上，两者之间的连线即表明两者连接起来了。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>经过如上步骤，这两个节点仅存在于编辑器中，还必须部署到服务器上。<br>点击右上角的<code>Deploy</code>按钮。<br>打开<code>debug</code>边栏（即右上角那个小虫子图标），然后点击<code>inject</code>节点上的左侧小按钮，就可以在边栏中看到有数字出现。默认情况下，<code>inject</code>节点将<code>1970年1月1日</code>依赖的毫秒数作为它的<code>payload</code>。</p><h2 id="添加function节点"><a href="#添加function节点" class="headerlink" title="添加function节点"></a>添加function节点</h2><p><code>function</code>节点可以将消息传入一个<code>JavaScript</code>函数中。<br>选择现在已有的连线，然后删除它。<br>从左侧面板中选择<code>function</code>节点，放到<code>inject</code>节点和<code>debug</code>节点中间，然后将它们三个顺序连接起来。<br>双击<code>function</code>节点，打开编辑对话框，填入如下内容：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a Date object from the payload</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(msg.payload);</span><br><span class="line"><span class="comment">// Change the payload to be a formatted Date string</span></span><br><span class="line">msg.payload = date.toString();</span><br><span class="line"><span class="comment">// Return the message so it can be sent on</span></span><br><span class="line"><span class="keyword">return</span> msg;</span><br></pre></td></tr></table></figure><br>点击<code>done</code>按钮关闭该对话框，然后点击<code>deploy</code>按钮。<br>此时再次点击<code>inject</code>节点，就会发现边栏中的消息已经变成了带格式的可读的时间戳形式。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个<code>flow</code>清晰地展示了如何创建<code>flow</code>的基本过程。</p><h1 id="创建第二个flow"><a href="#创建第二个flow" class="headerlink" title="创建第二个flow"></a>创建第二个flow</h1><p>第二个<code>flow</code>基于上面的第一个<code>flow</code>，它可以从外部导入数据，并进行操作。</p><h2 id="添加inject节点-1"><a href="#添加inject节点-1" class="headerlink" title="添加inject节点"></a>添加inject节点</h2><p>在第一个<code>flow</code>中，<code>inject</code>节点是用来在鼠标点击时触发一个<code>flow</code>。<br>在第二个<code>flow</code>中，<code>inject</code>节点会配置成在一定间隔下触发一个<code>flow</code>。<br>从左侧面板中拖动<code>inject</code>节点到中间工作区中，然后双击打开编辑对话框，在<code>Repeat</code>下选择<code>interval</code>，然后设置成<code>every 5 seconds</code>。点击<code>done</code>保存该设置。</p><h2 id="添加http-request节点"><a href="#添加http-request节点" class="headerlink" title="添加http request节点"></a>添加http request节点</h2><p><code>http request</code>节点可以用来获得一个web页面。<br>从左侧面板中拖动<code>http request</code>节点到中间工作区中，编辑<code>URL</code>一项为：<code>https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/significant_month.csv</code>。该链接是从美国地质调查局网站上获得的上一个月的地震信息，是一个<code>csv</code>文件。</p><h2 id="添加csv节点"><a href="#添加csv节点" class="headerlink" title="添加csv节点"></a>添加csv节点</h2><p>添加<code>csv</code>节点，在<code>Input</code>中勾选<code>First row contains column names</code>。</p><h2 id="添加debug节点-1"><a href="#添加debug节点-1" class="headerlink" title="添加debug节点"></a>添加debug节点</h2><p>添加<code>debug</code>节点作为输出。</p><h2 id="连线-1"><a href="#连线-1" class="headerlink" title="连线"></a>连线</h2><p>将上述节点顺序连接。</p><h2 id="添加switch节点"><a href="#添加switch节点" class="headerlink" title="添加switch节点"></a>添加switch节点</h2><p>添加<code>switch</code>节点，双击打开编辑框，依次设置如下属性：<br>将<code>Property</code>设置为<code>msg.payload.mag</code>，判断条件设置为<code>&gt;=</code>，判断对象类型设置为<code>number</code>（从下拉列表选择），判断值设置为<code>7</code>。<br>从<code>csv</code>节点的输出中引出第二条连线到<code>switch</code>节点上。</p><h2 id="添加change节点"><a href="#添加change节点" class="headerlink" title="添加change节点"></a>添加change节点</h2><p>添加<code>change</code>节点，将<code>switch</code>节点的输出连接到该节点上。<br>双击<code>change</code>节点，设置<code>msg.payload</code>到字符串<code>PANIC!</code>。</p><h2 id="添加debug节点-2"><a href="#添加debug节点-2" class="headerlink" title="添加debug节点"></a>添加debug节点</h2><p>再次添加<code>debug</code>节点，将<code>change</code>节点的输出连接到它的输入上。</p><h2 id="部署-1"><a href="#部署-1" class="headerlink" title="部署"></a>部署</h2><p>点击<code>Deploy</code>进行部署。<br>可以发现，每隔<code>5s</code>它就会发一次请求，然后得到如下内容：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msg.payload : <span class="built_in">Object</span></span><br><span class="line">&#123; <span class="attr">time</span>: <span class="string">&quot;2022-05-19T10:13:31.625Z&quot;</span>, <span class="attr">latitude</span>: -<span class="number">54.132</span>, <span class="attr">longitude</span>: <span class="number">159.0545</span>, <span class="attr">depth</span>: <span class="number">10</span>, <span class="attr">mag</span>: <span class="number">6.9</span> … &#125;</span><br></pre></td></tr></table></figure><br>可以点击该消息左侧的小箭头查看详情。<br>如果地震的烈度大于<code>7</code>，还会收到如下消息：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msg.payload : string[<span class="number">6</span>]</span><br><span class="line"><span class="string">&quot;PANIC!&quot;</span></span><br></pre></td></tr></table></figure></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>该<code>flow</code>演示了每隔一段时间自动触发从某个<code>url</code>获取数据的操作。同时对数据进行解析和判断。</p><h1 id="新增节点"><a href="#新增节点" class="headerlink" title="新增节点"></a>新增节点</h1><p>参考教程见<a href="https://nodered.17coding.net/docs/getting-started/adding-nodes">这里</a>。<br><code>Node-RED</code>本身只包含了一些核心的基本节点，但还有大量来自于<code>Node-RED</code>项目和广大社区的其他节点可以使用。<br>可以在<a href="https://flows.nodered.org/">Node-RED代码库</a>或<a href="https://www.npmjs.com/search?q=keywords:node-red">npm仓库</a>中寻找所需要的节点。</p><h2 id="使用编辑器"><a href="#使用编辑器" class="headerlink" title="使用编辑器"></a>使用编辑器</h2><p>从<code>0.15</code>版开始，可以直接通过编辑器安装节点。具体做法是，在右上角的菜单中选择“管理面板”<code>Manage Palette</code>，然后在出现的面板中选择<code>Install</code>标签，这样就可以搜索安装新的节点，并启用或禁用已有节点了。</p><h2 id="通过npm安装"><a href="#通过npm安装" class="headerlink" title="通过npm安装"></a>通过npm安装</h2><p>可以通过<code>npm</code>将节点安装到保存用户数据的本地目录中(默认为<code>$HOME/.node-red)</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME/.node-red</span><br><span class="line">npm install &lt;npm-package-name&gt;</span><br></pre></td></tr></table></figure><br>也可以安装到全局目录中:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g &lt;npm-package-name&gt;</span><br></pre></td></tr></table></figure><br>但是这样需要重启<code>Node-RED</code>，以便它能够获取到新的节点。</p><h2 id="复制节点文件"><a href="#复制节点文件" class="headerlink" title="复制节点文件"></a>复制节点文件</h2><p>将<code>.js</code>和<code>.html</code>文件复制到保存用户数据目录中的<code>nodes</code>子目录，也是安装节点的一个可行方式。如果这些节点中存在一些<code>npm</code>依赖项，那么也必须将其安装到用户数据目录中。但建议只是在开发阶段使用这种方式。</p><h1 id="MQTT例子"><a href="#MQTT例子" class="headerlink" title="MQTT例子"></a>MQTT例子</h1><p>参考教程<a href="https://www.emqx.com/zh/blog/using-node-red-to-process-mqtt-data">1</a>、<a href="https://www.v5w.com/iot/node-red/127.html">2</a>、<a href="https://www.youtube.com/watch?v=XDrwgMSQrEY">3</a>。<br>除<code>HTTP</code>、<code>WebScoket</code>等一些基础的网络服务应用节点外，<code>Node-RED</code>还提供对于<code>MQTT</code>协议的连接支持。目前同时提供了一个<code>MQTT</code>的订阅节点和<code>MQTT</code>的发布节点，订阅节点用于数据的输入，而发布节点可以用于数据的输出。<br>关于<code>MQTT</code>，<a href="https://siot.readthedocs.io/zh_CN/latest/1.about/02_mqtt.html">这里</a>有一个很好的介绍。摘录一个架构图如下：<br><img src="https://user-images.githubusercontent.com/6218739/174246248-dce70e2e-1986-47a8-a92a-1f2743c91efc.png" alt="mqtt"></p><h2 id="安装MQTT消息服务器"><a href="#安装MQTT消息服务器" class="headerlink" title="安装MQTT消息服务器"></a>安装MQTT消息服务器</h2><h3 id="安装EMQX"><a href="#安装EMQX" class="headerlink" title="安装EMQX"></a>安装EMQX</h3><p>开源免费的<code>MQTT</code>消息服务器有很多，如<a href="https://github.com/emqx/emqx">EMQX</a>、<a href="https://github.com/eclipse/mosquitto">Mosquitto</a>、<a href="https://github.com/moscajs/mosca">Mosca</a>等。<br>这里选择<code>EMQX</code>，使用<code>docker</code>安装：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name emqx -p 1883:1883 -p 8081:8081 -p 8083:8083 -p 8883:8883 -p 8084:8084 -p 18083:18083 emqx/emqx</span><br></pre></td></tr></table></figure></p><h2 id="配置Node-RED"><a href="#配置Node-RED" class="headerlink" title="配置Node-RED"></a>配置Node-RED</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p><code>Node-RED</code>中的<code>flow</code>结构配置为：<br><img src="https://user-images.githubusercontent.com/6218739/174427721-ad0b02c6-144d-4042-b209-c95f6b0f97f6.png" alt="flow"><br>上方是发布节点<code>mqtt out</code>，用于发布数据；下方是订阅节点<code>mqtt in</code>，是用于订阅数据。</p><h3 id="发布消息"><a href="#发布消息" class="headerlink" title="发布消息"></a>发布消息</h3><p>对触发消息的节点<code>inject</code>进行配置（这是为了模拟一个简单的传感器的开关）：<br><img src="https://user-images.githubusercontent.com/6218739/174256774-dc145287-371d-4f9e-a3a4-98b70f36a7d6.png" alt="sensor1"><br>对发布数据的节点<code>mqtt out</code>进行配置：<br>最开始配置时，<code>Server</code>一项需要新建，可按如下新建（注意<code>IP</code>地址设置正确，因为这里是<code>docker</code>安装的消息服务器，所以不能用<code>localhost</code>或者<code>127.0.0.1</code>这样的本地地址）：<br><img src="https://user-images.githubusercontent.com/6218739/174427243-23b6211b-29f2-49e8-bec8-4ca2995aa4d6.png" alt="broker"><br>然后<code>mqtt out</code>的配置都使用如下的默认即可（因为它的<code>topic</code>和<code>payload</code>都是通过前面的<code>inject</code>节点传输过来）<br><img src="https://user-images.githubusercontent.com/6218739/174427394-cc56d998-fbf6-4dc2-8bca-fcbd4d4144bb.png" alt="mqttout"><br>以上就是相当于建立了一个<code>mqtt</code>的发布服务，点击<code>inject</code>后就会对<code>EMQX</code>消息服务器发送指定主题的消息。</p><h3 id="订阅消息"><a href="#订阅消息" class="headerlink" title="订阅消息"></a>订阅消息</h3><p>然后再配置<code>mqtt in</code>节点用来订阅消息，如下：<br><img src="https://user-images.githubusercontent.com/6218739/174427603-ca2a14ef-fd15-4725-b7ea-8e4e445d1ddc.png" alt="mqttin"><br>它的<code>Server</code>默认与<code>mqtt out</code>的相同，以及<code>Topic</code>设置为<code>sensors/#</code>，其中<code>#</code>时一个通配符。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>点击<code>inject</code>后，就会发现在<code>Debug</code>边栏中出现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sensors/sensor1 : msg.payload : string[<span class="number">4</span>]</span><br><span class="line"><span class="string">&quot;Open&quot;</span></span><br></pre></td></tr></table></figure><br>即，通过<code>mqtt out</code>客户端发送了主题为<code>sensors/sensor1</code>、内容为<code>Open</code>的消息给<code>EMQX</code>消息服务器，该服务器又将消息发送给了订阅了该类主题的<code>mqtt in</code>客户端。</p><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>再把整个<code>flow</code>架构升级一下，如图：<br><img src="https://user-images.githubusercontent.com/6218739/174429564-a46b42f9-a03c-4e38-a158-4b7b381379e4.png" alt="newflow"><br>即新增了一个<code>inject</code>节点，其配置为：<br><img src="https://user-images.githubusercontent.com/6218739/174429673-ce52d8ce-b4ab-4c0c-9f62-8a6ba244cae1.png" alt="close"><br>当点击它时，<code>Debug</code>边栏中会出现<code>Close</code>消息。<br>这样就模拟了一个简单的传感器开关的效果。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>在上述例子中，<code>mqtt</code>的发送和订阅消息都是使用了<code>Node-RED</code>中的节点，更为普遍的一个情况是其他客户端或服务发送了相关的<code>topic</code>及其<code>payload</code>，然后在<code>Node-RED</code>中进行订阅（反之亦然），总之是订阅和发送的客户端不在一个地方。<br>一个尝试可以使用上面的<code>EMQ</code>开源的<code>MQTT X</code>软件，它是一款优雅的跨平台 MQTT 5.0 桌面客户端，支持 macOS, Linux, Windows。<br><code>MQTT X</code> 的<code>UI</code>采用了聊天界面形式，简化了页面操作逻辑，用户可以快速创建连接，允许保存多个客户端，方便用户快速测试<code>MQTT/MQTTS</code>连接，及<code>MQTT</code>消息的订阅和发布。<br>下载地址在<a href="https://mqttx.app/zh">这里</a>，安装后再与<code>EMQX</code>消息服务器进行连接。然后发送或者订阅<code>sensors/#</code>相关的主题，就可以实现与<code>Node-RED</code>中的<code>flow</code>的联动。</p><h1 id="时序数据的可视化"><a href="#时序数据的可视化" class="headerlink" title="时序数据的可视化"></a>时序数据的可视化</h1><p>这一部分介绍对时序数据序列进行采集，然后存储进入时序数据库中，并使用看板进行可视化。使用到的技术和软件分别为：通过<code>MQTT</code>来生成时序数据序列、通过<code>Node-RED</code>采集该时序数据序列、通过时序数据库<code>InfluxDB</code>进行存储、以及最后通过<code>Grafana</code>进行数据可视化。</p><p>主要参考教程在<a href="https://www.bilibili.com/video/BV1uW4y1C7jt">这里</a>。</p><h2 id="时序数据库InfluxDB"><a href="#时序数据库InfluxDB" class="headerlink" title="时序数据库InfluxDB"></a>时序数据库InfluxDB</h2><p>使用<code>docker</code>进行安装和部署，见<a href="https://zhuanlan.zhihu.com/p/459383022">教程</a>：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name myinfluxdb --restart always -p 8086:8086 -v influxdb2:/var/lib/influxdb2 influxdb</span><br></pre></td></tr></table></figure><br>其中的命令的含义为：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-d  启动后在后台运行，不打印日志</span><br><span class="line">--name 容器名  给容器命名，方便管理，也可以不写此参数</span><br><span class="line">--restart always  如果容器死掉，就自动将其拉起，也可以不写此参数</span><br><span class="line">-v 宿主机路径:容器内路径  将容器内指定路径挂载出来到宿主机中，这里是把数据库本地存储的目录挂出来，保证容器销毁以后数据还在</span><br><span class="line">-p 宿主机端口:容器内端口  将宿主机端口与容器内端口进行映射，influxdb默认的容器内端口是8086，容器外端口可以根据需要自己调整</span><br></pre></td></tr></table></figure></p><p>如果下载很慢，可以先配置一下<code>docker</code>的国内镜像源加速，教程见<a href="https://yeasy.gitbook.io/docker_practice/install/mirror">这里</a>：<br>在<code>/etc/docker/daemon.json</code>中写入如下内容（如果文件不存在请新建该文件）：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://mirror.baidubce.com&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意，一定要保证该文件符合json规范，否则Docker将不能启动。<br>之后重新启动服务：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure></p><p><code>InfluxDB</code>自带一个图形化的管理后台，可以通过<code>http://127.0.0.1:8086</code>登录。<br>进入以后，配置一下初始用户（比如<code>root</code>)、密码、组织、<code>buckets</code>（比如<code>test</code>）。<br>进行如上的初始配置后，另一个非常重要的是<code>API Token</code>，它可以规定对数据库的操作权限，比如可读、可写等。</p><h2 id="Node-RED配置"><a href="#Node-RED配置" class="headerlink" title="Node-RED配置"></a>Node-RED配置</h2><p>首先安装一个名为<code>node-red-contrib-influxdb</code>的节点。<br>我们这里依然复用上面<code>mqtt</code>的例子，但是要做一定的改动。整体架构图如下：<br><img src="https://user-images.githubusercontent.com/6218739/174447253-efa5ead0-5bac-4e9b-8b0d-8d62a6efcdfd.png" alt="newflow"><br>具体改动为：<br>（1）两个<code>inject</code>节点的<code>payload</code>的类型由原先的<code>string</code>都改为<code>number</code>，即原来的<code>Open</code>改为<code>1</code>、<code>Close</code>改为<code>0</code>，以数值形式存入时序数据库中，同时触发条件分别改为<code>每5秒触发一次</code>和<code>每3秒触发一次</code>，这样形成一个周期性的类似锯齿波形状的时间序列数据；<br>（2）<code>mqtt in</code>节点的<code>Output</code>属性更改为<code>a parsed JSON object</code>，如下图：<br><img src="https://user-images.githubusercontent.com/6218739/174447513-e936e93f-4ec2-420b-af10-50ecdba68ef7.png" alt="newmqttin"><br>这样才能将正确的数据传输给时序数据库。<br>（3）如总架构图所述，新增一个节点<code>influxdb out</code>节点，这样才能将<code>Node-RED</code>与<code>InfluxDB</code>连接起来。对节点第一次配置时，需要在里面新建一个<code>Server</code>，具体配置如下图（仍然注意<code>IP</code>地址，不能使用类似<code>localhost</code>这样的，因为<code>InfluxDB</code>是通过<code>docker</code>部署的）：<br><img src="https://user-images.githubusercontent.com/6218739/174447659-69abc04c-269d-4941-a0b2-99971a60e3be.png" alt="influxdbserver"><br>配置好<code>Server</code>后，然后再对具体连接的数据库进行配置，如下图所示：<br><img src="https://user-images.githubusercontent.com/6218739/174447756-cbf82931-77c6-44a1-9f2e-d370141f2c46.png" alt="dataconnect"><br>其中<code>Organization</code>和<code>Bucket</code>就是之前通过后台创建的。<code>Meansurement</code>一项可以任意填写，其会在<code>test</code>这个数据库中新建此表。</p><p>部署后，就可以通过<code>InfluxDB</code>的管理后台看到数据的输入，如下图（注意箭头的地方）：<br><img src="https://user-images.githubusercontent.com/6218739/174448258-e84dd2a1-9737-4be1-ba1c-8445753c4569.png" alt="influxdata"><br>这个看板只是<code>InfluxDB</code>后台的一个简单的可视化，没法用于真正的前端可视化（比如嵌入到网页中、免登录查看等）。因此还需要下面专业的<code>Grafana</code>进行可视化。</p><h2 id="Grafana可视化看板"><a href="#Grafana可视化看板" class="headerlink" title="Grafana可视化看板"></a>Grafana可视化看板</h2><p>通过<code>docker</code>安装和部署：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name=grafana -p 3000:3000 grafana/grafana-enterprise</span><br></pre></td></tr></table></figure><br>通过<code>http://127.0.0.1:3000/</code>登录<code>Grafana</code>后台，默认的用户名和密码都是<code>admin</code>。<br>然后与具体的数据库相连接，通过<code>Add data source</code>，选择<code>InfluxDB</code>，连接它的方式与之前<code>Node-RED</code>中的类似，但是注意选择<code>Query Language</code>为<code>Flux</code>，然后不勾选<code>Basic auth</code>，才能出现<code>orgnization</code>、<code>token</code>、<code>Default Bucket</code>等选项。<br>然后再<code>Create new dashboard</code>，如下图：<br><img src="https://user-images.githubusercontent.com/6218739/174448938-5d219710-a860-447e-8fb4-fe1c74d0cce3.png" alt="grafana"><br>这里就考验查询语句的功力了。对<code>Grafana</code>有需求的话可以仔细研究一下。</p>]]></content>
    
    
    <summary type="html">简介
Node-RED是一种低代码的将各种硬件设备、API和在线服务连接起来的编程工具，比如将各种传感器（如树莓派上的传感器）、工业控制器（如MQTT、OPC-UA协议）、在线API（比如获取天气情况、发送邮件等）等以图形化拖拽编程的形式进行高效组态。因此，Node-RED广泛地应用在物联网流程和程序开发中。

安装和运行
Node-RED可以运行在多种设备上，比如本地计算机运行、设备上运行（如树莓派、Arduino和Android等），以及在云端运行（比如IBM云、AWS云和微软Azure云等）。
具体可以查看这里。
下面将以本地计算机运行为例，同时最简单的就是使用docker方式进行安装、</summary>
    
    
    
    <category term="coding" scheme="http://qixinbo.github.io/categories/coding/"/>
    
    
    <category term="IoT" scheme="http://qixinbo.github.io/tags/IoT/"/>
    
  </entry>
  
  <entry>
    <title>使用Heroku云平台免费托管web应用</title>
    <link href="http://qixinbo.github.io/2022/06/12/heroku/"/>
    <id>http://qixinbo.github.io/2022/06/12/heroku/</id>
    <published>2022-06-11T16:00:00.000Z</published>
    <updated>2022-06-16T01:35:05.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>当开发了一款<code>web</code>应用后，需要使用服务器将其托管以供用户进行访问。服务器的选择多种多样，可以选择自己搭建服务器，也可以选择如今大火的各种云服务器。<br>虽说现在云服务器的价格已经非常亲民（尤其是对于新用户的各种优惠政策），但毕竟还是需要真金白银的付出，尤其是考虑自己开发的应用可能只是为了大家尝试的情形下，此时可以选择一些提供免费部署的云平台。<br><a href="https://www.heroku.com/"><code>Heroku</code></a>是一个非常优秀的<code>PaaS</code>(<code>Platform as a Service</code>)云平台，它有如下几个优点：<br>（1）自动软件部署：当软件的代码变动后，通过<code>git</code>进行代码追踪后，就可以自动触发软件的部署交付；<br>（2）无需关心背后的基础设施：因为<code>Heroku</code>是一个<code>PaaS</code>平台，而不是<code>IaaS</code>(<code>Infrastructure as a Service</code>)平台，所以它屏蔽了很多的细节，比如使用的操作系统、运行环境等。用户写好配置文件后，自动搭建应用程序所需的环境；<br>（3）免费额度：对于小型应用来说，免费版已足够，但是有不少限制，比如应用在<code>30</code>分钟内无访问的话会自动休眠，再次有访问时会被唤醒，可能会有<code>10</code>多秒的延迟；每个月限制在<code>550</code>小时的免费运行时长；提供给用户的<code>Postgres</code>数据库存储的数据不能超过<code>10000</code>行等。</p><h1 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h1><p>登录<a href="https://signup.heroku.com/">heroku网站</a>注册一个账号。</p><h1 id="下载并安装Heroku工具"><a href="#下载并安装Heroku工具" class="headerlink" title="下载并安装Heroku工具"></a>下载并安装Heroku工具</h1><p>注意，需要电脑上提前安装git。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>Heroku工具的<a href="https://devcenter.heroku.com/articles/heroku-cli">下载地址</a>。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>安装后进行验证：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heroku --version</span><br></pre></td></tr></table></figure></p><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>登录账号：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heroku login</span><br></pre></td></tr></table></figure></p><h1 id="创建或使用已有git仓库"><a href="#创建或使用已有git仓库" class="headerlink" title="创建或使用已有git仓库"></a>创建或使用已有git仓库</h1><p>在项目中创建git仓库，或使用已有的git仓库：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd my-project/</span><br><span class="line">git init</span><br></pre></td></tr></table></figure></p><h1 id="创建Heroku-App"><a href="#创建Heroku-App" class="headerlink" title="创建Heroku App"></a>创建Heroku App</h1><h2 id="新建或连接Heroku-App"><a href="#新建或连接Heroku-App" class="headerlink" title="新建或连接Heroku App"></a>新建或连接Heroku App</h2><p>在命令行中新建Heroku App：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heroku create my-project-test</span><br></pre></td></tr></table></figure><br>或者在Heroku网站上已创建了App，此时连接即可：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heroku git:remote -a my-project-test</span><br></pre></td></tr></table></figure></p><h1 id="操作git仓库"><a href="#操作git仓库" class="headerlink" title="操作git仓库"></a>操作git仓库</h1><p>对于项目文件的更新，使用常规的git命令即可：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -am <span class="string">&quot;make it better&quot;</span></span><br></pre></td></tr></table></figure></p><h1 id="部署到Heroku"><a href="#部署到Heroku" class="headerlink" title="部署到Heroku"></a>部署到Heroku</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push heroku master</span><br></pre></td></tr></table></figure><p>如果涉及到<code>master</code>分支更名为<code>main</code>分支，可以查看<a href="https://help.heroku.com/O0EXQZTA/how-do-i-switch-branches-from-master-to-main">该教程</a>。</p><h2 id="Vue项目部署"><a href="#Vue项目部署" class="headerlink" title="Vue项目部署"></a>Vue项目部署</h2><p>特别地，对于<code>Vue.js</code>开发的项目，要注意以下几点：<br>（<a href="https://cli.vuejs.org/guide/deployment.html#heroku">教程1</a>, <a href="https://medium.com/unalai/%E8%AA%8D%E8%AD%98-heroku-%E5%AD%B8%E7%BF%92%E5%B0%87-vue-%E5%B0%88%E6%A1%88%E9%83%A8%E7%BD%B2%E8%87%B3heroku-4f5d8bd9b8e2">教程2</a>）</p><h3 id="文件打包"><a href="#文件打包" class="headerlink" title="文件打包"></a>文件打包</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><h3 id="git加入dist路径"><a href="#git加入dist路径" class="headerlink" title="git加入dist路径"></a>git加入dist路径</h3><p>在<code>.gitignore</code>文件中删除<code>/dist</code>条目，使得该路径可以被<code>git</code>监控。</p><h3 id="新增文件"><a href="#新增文件" class="headerlink" title="新增文件"></a>新增文件</h3><p>新建<code>static.json</code>文件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;root&quot;</span>: <span class="string">&quot;dist&quot;</span>,</span><br><span class="line">  <span class="string">&quot;clean_urls&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;routes&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;/**&quot;</span>: <span class="string">&quot;index.html&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意将上述改动都通过<code>git add</code>和<code>git commit</code>提交。</p><h3 id="新增Heroku指令"><a href="#新增Heroku指令" class="headerlink" title="新增Heroku指令"></a>新增Heroku指令</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">heroku buildpacks:add heroku/nodejs</span><br><span class="line">heroku buildpacks:add https:<span class="comment">//github.com/heroku/heroku-buildpack-static</span></span><br></pre></td></tr></table></figure><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push heroku master</span><br></pre></td></tr></table></figure><h2 id="Python项目部署"><a href="#Python项目部署" class="headerlink" title="Python项目部署"></a>Python项目部署</h2><h3 id="添加python版本指定文件"><a href="#添加python版本指定文件" class="headerlink" title="添加python版本指定文件"></a>添加python版本指定文件</h3><p>新建<code>runtime.txt</code>文件，然后在里面写上<code>python</code>版本，如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python-<span class="number">3.7</span><span class="number">.13</span></span><br></pre></td></tr></table></figure><br>不过<code>python</code>版本与<code>heroku</code>的版本需要对应，具体查看<a href="https://devcenter.heroku.com/articles/python-support">这里的说明</a>。</p><h3 id="添加依赖需求文件"><a href="#添加依赖需求文件" class="headerlink" title="添加依赖需求文件"></a>添加依赖需求文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure><h3 id="添加Procfile"><a href="#添加Procfile" class="headerlink" title="添加Procfile"></a>添加Procfile</h3><p>新建<code>Procfile</code>文件，里面包含的是Web应用服务器启动时执行的命令，比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web: uvicorn main:app --host=<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> --port=$&#123;PORT:-<span class="number">5000</span>&#125;</span><br></pre></td></tr></table></figure><br>一篇很好的教程见<a href="https://towardsdatascience.com/how-to-deploy-your-fastapi-app-on-heroku-for-free-8d4271a4ab9">这里</a>。</p><h3 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h3><p>（1）遇到<code>Your account has reached its concurrent build limit</code>这个错误，可以：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heroku restart</span><br></pre></td></tr></table></figure><br>参考<a href="https://stackoverflow.com/questions/47028871/heroku-your-account-has-reached-its-concurrent-build-limit">这个问题</a>。<br>（2）项目不能太大，免费版实测压缩后最大是<code>500M</code>。<br>（3）如果用到<code>opencv</code>，需要这样配置：<br>首先添加指令：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heroku buildpacks:add --index <span class="number">1</span> heroku-community/apt</span><br></pre></td></tr></table></figure><br>然后新建<code>Aptfile</code>，内容为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">libsm6</span><br><span class="line">libxrender1</span><br><span class="line">libfontconfig1</span><br><span class="line">libice6</span><br></pre></td></tr></table></figure><br>参考<a href="https://medium.com/analytics-vidhya/deploying-your-opencv-flask-web-application-on-heroku-c23efcceb1e8">该教程</a>。</p><h1 id="启动App"><a href="#启动App" class="headerlink" title="启动App"></a>启动App</h1><p>在<code>Heroku</code>网站上的该<code>App</code>的<code>settings</code>中找到该<code>App</code>的网站<code>url</code>。<br>或者通过以下命令：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heroku open</span><br></pre></td></tr></table></figure><br>即可直接打开App。<br>以后即可通过该网址访问该<code>App</code>。</p>]]></content>
    
    
    <summary type="html">简介
当开发了一款web应用后，需要使用服务器将其托管以供用户进行访问。服务器的选择多种多样，可以选择自己搭建服务器，也可以选择如今大火的各种云服务器。
虽说现在云服务器的价格已经非常亲民（尤其是对于新用户的各种优惠政策），但毕竟还是需要真金白银的付出，尤其是考虑自己开发的应用可能只是为了大家尝试的情形下，此时可以选择一些提供免费部署的云平台。
Heroku是一个非常优秀的PaaS(Platform as a Service)云平台，它有如下几个优点：
（1）自动软件部署：当软件的代码变动后，通过git进行代码追踪后，就可以自动触发软件的部署交付；
（2）无需关心背后的基础设施：因为Herok</summary>
    
    
    
    <category term="coding" scheme="http://qixinbo.github.io/categories/coding/"/>
    
    
    <category term="Docker" scheme="http://qixinbo.github.io/tags/Docker/"/>
    
    <category term="Cloud" scheme="http://qixinbo.github.io/tags/Cloud/"/>
    
  </entry>
  
  <entry>
    <title>轻量级PyTorch通用训练模板pytorch-accelerated解析：4 -- 其他API</title>
    <link href="http://qixinbo.github.io/2022/06/12/pytorch-accelerated_4/"/>
    <id>http://qixinbo.github.io/2022/06/12/pytorch-accelerated_4/</id>
    <published>2022-06-11T16:00:00.000Z</published>
    <updated>2022-06-23T06:01:45.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这一章将研究<code>pytorch-accelerated</code>的其他<code>API</code>，包括追踪<code>Tracking</code>、运行配置<code>Run Config</code>、微调<code>Fine tuning</code>。</p><h1 id="Tracking"><a href="#Tracking" class="headerlink" title="Tracking"></a>Tracking</h1><h2 id="RunHistory抽象基类"><a href="#RunHistory抽象基类" class="headerlink" title="RunHistory抽象基类"></a>RunHistory抽象基类</h2><p><code>RunHistory</code>抽象基类定义了<code>Trainer</code>运行历史的<code>API</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pytorch_accelerated</span>.<span class="title">tracking</span>.<span class="title">RunHistory</span></span></span><br></pre></td></tr></table></figure><br>（1）获得当前<code>epoch</code>的数值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">current_epoch</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span></span></span><br></pre></td></tr></table></figure><br>（2）获得指定指标最近的记录值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_latest_metric</span>(<span class="params">self, metric_name</span>)</span></span><br></pre></td></tr></table></figure><br>（3）获得在追踪的所有指标的名字：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_metric_names</span>(<span class="params">self</span>) -&gt; Iterable</span></span><br></pre></td></tr></table></figure><br>返回的是一个集合，所以名称都是独一无二的。<br>（4）获得指定指标的所有值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_metric_values</span>(<span class="params">self, metric_name</span>) -&gt; Iterable</span></span><br></pre></td></tr></table></figure><br>（5）重置：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reset</span>(<span class="params">self</span>)</span></span><br></pre></td></tr></table></figure><br>重置<code>RunHistory</code>的状态。<br>（6）记录指定指标的值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_metric</span>(<span class="params">self, metric_name, metric_value</span>)</span></span><br></pre></td></tr></table></figure></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>上面的<code>RunHistory</code>是抽象基类，其定义的方法都没有具体的实现。<br><code>InMemoryRunHistory</code>是对<code>RunHistory</code>的一个具体实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InMemoryRunHistory</span>(<span class="params">RunHistory</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    An implementation of :class:`RunHistory` which stores all recorded values in memory.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._current_epoch = <span class="number">1</span></span><br><span class="line">        self._metrics = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_metric_names</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">set</span>(self._metrics.keys())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_metric_values</span>(<span class="params">self, metric_name</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._metrics[metric_name]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_latest_metric</span>(<span class="params">self, metric_name</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self._metrics[metric_name]) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self._metrics[metric_name][-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(</span><br><span class="line">                <span class="string">f&quot;No values have been recorded for the metric <span class="subst">&#123;metric_name&#125;</span>&quot;</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_metric</span>(<span class="params">self, metric_name, metric_value</span>):</span></span><br><span class="line">        self._metrics[metric_name].append(metric_value)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">current_epoch</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._current_epoch</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_increment_epoch</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._current_epoch += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reset</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._current_epoch = <span class="number">1</span></span><br><span class="line">        self._metrics = defaultdict(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure></p><h1 id="Run-Config"><a href="#Run-Config" class="headerlink" title="Run Config"></a>Run Config</h1><p><code>TrainerRunConfig</code>是一个不可变的数据类，包含训练器<code>Trainer</code>当前状态的数值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass(<span class="params">frozen=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrainerRunConfig</span>:</span></span><br></pre></td></tr></table></figure><br>其属性有：</p><ul><li><code>num_epochs</code>：当前训练的迭代次数</li><li><code>train_per_device_batch_size</code>：训练时每个设备上的批大小</li><li><code>train_dl_kwargs</code>：创建训练集数据加载器的所需参数</li><li><code>eval_per_device_batch_size</code>：评估时每个设备上的批大小</li><li><code>eval_dl_kwargs</code>：创建验证集数据加载器的所需参数</li><li><code>gradient_accumulation_steps</code>：训练时梯度累加的步数</li><li><code>gradient_clip_value</code>：模型参数的梯度修剪的阈值</li><li><code>train_total_batch_size</code>：训练时总批大小</li><li><code>eval_total_batch_size</code>：评估时总批大小</li><li><code>num_update_steps_per_epoch</code>：训练时当模型参数更新时的步数</li><li><code>max_num_train_steps</code>：训练的总步数，如果指定的话，会覆盖掉<code>num_epochs</code>参数</li><li><code>is_local_process_zero</code>：如果当前进程是当前节点上的主进程，则为<code>True</code>；否则为<code>False</code></li><li><code>is_world_process_zero</code>：如果当前进程是横跨所有节点的主进程，则为<code>True</code>，否则为<code>False</code></li><li><code>is_distributed</code>：如果<code>trainer</code>是分布式训练，则为<code>True</code>，否则为<code>False</code></li><li><code>mixed_precision</code>：包含所用的混合精度类型的字符串，否则为<code>no</code></li></ul><h1 id="Fine-tuning"><a href="#Fine-tuning" class="headerlink" title="Fine tuning"></a>Fine tuning</h1><p><code>ModelFreezer</code>是一个用来冻结和解冻一个模型的不同部分的类，其用来简化迁移学习中微调的操作。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pytorch_accelerated</span>.<span class="title">finetuning</span>.<span class="title">ModelFreezer</span>(<span class="params">model, freeze_batch_norms=<span class="literal">False</span></span>)</span></span><br></pre></td></tr></table></figure><br>该类使用以下的抽象定义：</p><ul><li><code>Layer</code>：是一个深度为1的<code>torch.nn.Module</code>的子类，即这个特定的<code>module</code>不是嵌套的</li><li><code>LayerGroup</code>：是模型类的属性，可以是网络层<code>layers</code>或嵌套的<code>modules</code></li></ul><p>举个例子，如下的模型：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModel</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.<span class="built_in">input</span> = nn.Linear(<span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">        self.block_1 = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">100</span>, <span class="number">100</span>),</span><br><span class="line">            nn.BatchNorm1d(<span class="number">100</span>),</span><br><span class="line">            nn.Sequential(</span><br><span class="line">                nn.Linear(<span class="number">100</span>, <span class="number">100</span>),</span><br><span class="line">                nn.BatchNorm1d(<span class="number">100</span>),</span><br><span class="line">                nn.ReLU(),</span><br><span class="line">            ),</span><br><span class="line">        )</span><br><span class="line">        self.output = nn.Linear(<span class="number">100</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = self.<span class="built_in">input</span>(x)</span><br><span class="line">        x = self.block_1(x)</span><br><span class="line">        out = self.output(x)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><br>该模型的<code>LayerGroup</code>就是<code>[input, block_1, output]</code>，而<code>Layers</code>则是一个有序的、压平的<code>Linear</code>、<code>BatchNorm</code>、<code>ReLU</code>模块列表。</p><p>主要方法有：<br>（1）冻结指定索引的<code>LayerGroup</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">freeze(from_index=<span class="number">0</span>, to_index=-<span class="number">2</span>, set_modules_as_eval=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><br>默认情况下，这将冻结所有层组，除了最后一个层组。<br>参数有：</p><ul><li><code>from_index</code>：第一个被冻结的<code>LayerGroup</code>的索引</li><li><code>to_index</code>：最后一个被冻结的<code>LayerGroup</code>的索引</li><li><code>set_modules_as_eval</code>：若为<code>True</code>，这些冻结的模块也会被置为<code>eval</code>模式。默认是<code>False</code></li></ul><p>（2）返回模型的所有<code>LayerGroups</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_layer_groups() → <span class="type">List</span>[LayerGroup]</span><br></pre></td></tr></table></figure><br>（3）返回模型的所有<code>Layer</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_layers() → <span class="type">List</span>[Layer]</span><br></pre></td></tr></table></figure><br>（4）返回所有未被冻结的模型参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_trainable_parameters()</span><br></pre></td></tr></table></figure><br>这些参数将在训练中被更新。<br>（5）解冻指定索引的<code>LayerGroup</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unfreeze(from_index=-<span class="number">1</span>, to_index=<span class="number">0</span>, set_modules_as_training=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><br>默认情况下，这将解冻所有<code>LayerGroups</code>。对于一个<code>LayerGroup</code>，任何已经解冻的参数都会被返回，这样如果需要的话，它们可以被添加到一个优化器中。<br>参数有：</p><ul><li><code>from_index</code>：第一个被解冻的<code>LayerGroup</code>的索引</li><li><code>to_index</code>：最后一个被解冻的<code>LayerGroup</code>的索引</li><li><code>set_modules_as_training</code>：若为<code>True</code>，这些解冻的模块也会被置为<code>train</code>模式。默认是<code>True</code>。</li></ul><p>返回值是：包含每一个解冻的<code>layer Group</code>的参数的字典。</p>]]></content>
    
    
    <summary type="html">简介
这一章将研究pytorch-accelerated的其他API，包括追踪Tracking、运行配置Run Config、微调Fine tuning。

Tracking
RunHistory抽象基类
RunHistory抽象基类定义了Trainer运行历史的API：
1


class pytorch_accelerated.tracking.RunHistory



（1）获得当前epoch的数值：
1


def current_epoch(self) -&gt; int



（2）获得指定指标最近的记录值：
1


def get_latest_metric(self, metric</summary>
    
    
    
    <category term="machine learning" scheme="http://qixinbo.github.io/categories/machine-learning/"/>
    
    
    <category term="PyTorch" scheme="http://qixinbo.github.io/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>轻量级PyTorch通用训练模板pytorch-accelerated解析：3 -- API之Schedulers</title>
    <link href="http://qixinbo.github.io/2022/06/05/pytorch-accelerated_3/"/>
    <id>http://qixinbo.github.io/2022/06/05/pytorch-accelerated_3/</id>
    <published>2022-06-04T16:00:00.000Z</published>
    <updated>2022-06-23T06:28:43.918Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这一章将研究<code>pytorch-accelerated</code>的调度器<code>API</code>。<br><code>PyTorch-accelerated</code>提供了一些调度器的实现，可以在任何<code>PyTorch</code>训练循环中使用。然而，与<code>PyTorch</code>的原生调度器不同——这些原生调度器可以在训练循环的不同点上被调用——所有<code>Pytorch-accelerated</code>调度器都期望在每次优化器更新后被调用。</p><h1 id="内置调度器"><a href="#内置调度器" class="headerlink" title="内置调度器"></a>内置调度器</h1><p><code>PyTorch-accelerated</code>内置了一个有状态的余弦退火学习率调度器，基于<a href="https://arxiv.org/abs/1608.03983">这篇论文</a>，但没有论文中的<code>restart</code>。<br>这个调度器与<code>PyTorch</code>的<code>CosineAnnealingLR</code>不同，它提供了增加<code>warmup</code>和<code>cooldown</code>的<code>epoch</code>的选项。此外，可以通过调整<code>k-decay</code>参数来修改退火率，可详见<a href="https://arxiv.org/abs/2004.05909">这篇论文</a>。<br>关于该调度器的具体细节，暂不深究，具体可以查看<a href="https://pytorch-accelerated.readthedocs.io/en/latest/schedulers.html#pytorch_accelerated.schedulers.cosine_scheduler.CosineLrScheduler">这个文档</a>。</p><h1 id="调度器基类"><a href="#调度器基类" class="headerlink" title="调度器基类"></a>调度器基类</h1><p><code>PyTorch-accelerated</code>提供了两种类型的调度器的基类。</p><h2 id="有状态的调度器"><a href="#有状态的调度器" class="headerlink" title="有状态的调度器"></a>有状态的调度器</h2><p>有状态的调度器维护一个内部计数，其对应于调度器的<code>step()</code>方法被调用了多少次。由于这些调度器与原生的<code>PyTorch</code>调度器具有相同的接口，因此<code>Trainer</code>默认支持这些调度器。<br>基类为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pytorch_accelerated</span>.<span class="title">schedulers</span>.<span class="title">scheduler_base</span>.<span class="title">StatefulSchedulerBase</span>(<span class="params">optimizer, param_group_field: <span class="built_in">str</span> = <span class="string">&#x27;lr&#x27;</span></span>)</span></span><br></pre></td></tr></table></figure><br>一个有状态的参数调度器基类，可用于更新优化器的参数组中的任意字段。这方面最常见的用例是学习率调度。<br>与<code>PyTorch</code>的调度器（它可以在训练循环的不同点被调用）不同的是，该类的目的是在每次优化器更新结束时被一致调用。<br>这个类负责维护更新的数量，在每次计算调度器的步骤时增加一个内部计数。<br>该类的一个用法如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> current_epoch, epoch <span class="keyword">in</span> <span class="built_in">enumerate</span>(num_epochs):</span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> train_dataloader:</span><br><span class="line">        xb, yb = batch</span><br><span class="line">        predictions = model(xb)</span><br><span class="line">        loss = loss_func(predictions, yb)</span><br><span class="line"></span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        scheduler.step()</span><br></pre></td></tr></table></figure></p><h2 id="无状态的调度器"><a href="#无状态的调度器" class="headerlink" title="无状态的调度器"></a>无状态的调度器</h2><p>无状态的调度器没有维护关于当前训练运行的内部状态，因此需要在调用时明确提供当前的更新数量。如果要在训练器中使用无状态调度器，这就需要对<code>Trainer</code>进行子类化，并重写<code>scheduler_step()</code>方法。<br>基类是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pytorch_accelerated</span>.<span class="title">schedulers</span>.<span class="title">scheduler_base</span>.<span class="title">SchedulerBase</span>(<span class="params">optimizer: Optimizer, param_group_field: <span class="built_in">str</span> = <span class="string">&#x27;lr&#x27;</span></span>)</span></span><br></pre></td></tr></table></figure><br>该类也可用于更新优化器参数组中的任何字段。这方面最常见的用例是学习率调度。<br>与`PyTorch   的调度器（它可以根据实现方式在训练循环的不同点被调用）不同的是，这个类的目的是在每次优化器更新结束时被一致调用。<br>由于这个类在默认情况下是无状态的，它希望更新的数量是明确提供的，如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> current_epoch, epoch <span class="keyword">in</span> <span class="built_in">enumerate</span>(num_epochs):</span><br><span class="line">    num_updates = current_epoch * num_update_steps_per_epoch</span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> train_dataloader:</span><br><span class="line">        xb, yb = batch</span><br><span class="line">        predictions = model(xb)</span><br><span class="line">        loss = loss_func(predictions, yb)</span><br><span class="line"></span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        num_updates +=<span class="number">1</span></span><br><span class="line">        scheduler.step_update(num_updates)</span><br></pre></td></tr></table></figure></p><h1 id="创建新的调度器"><a href="#创建新的调度器" class="headerlink" title="创建新的调度器"></a>创建新的调度器</h1><p>虽然调度器通常用于调度学习率，但<code>PyTorch-accelerated</code>中的调度器基类可用于调度优化器参数组中的任意参数。<br>要创建一个新的调度器，在大多数情况下，只需要对其中一个基类进行子类化，并重写<code>get_updated_values()</code>方法。</p><h2 id="案例1：创建一个简单的目标学习率调度器"><a href="#案例1：创建一个简单的目标学习率调度器" class="headerlink" title="案例1：创建一个简单的目标学习率调度器"></a>案例1：创建一个简单的目标学习率调度器</h2><p>下面是一个例子，说明如何实现一个调度器，在每次达到一个<code>milestone</code>目标时，以一个系数<code>gamma</code>调整每个参数组的学习率：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pytorch_accelerated.schedulers <span class="keyword">import</span> StatefulSchedulerBase</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MilestoneLrScheduler</span>(<span class="params">StatefulSchedulerBase</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        self, optimizer, gamma=<span class="number">0.5</span>, epoch_milestones=(<span class="params"><span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span></span>), num_steps_per_epoch=<span class="number">100</span></span></span></span><br><span class="line"><span class="function"><span class="params">    </span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(optimizer, param_group_field=<span class="string">&quot;lr&quot;</span>)</span><br><span class="line">        self.milestones = <span class="built_in">set</span>(</span><br><span class="line">            (num_steps_per_epoch * milestone <span class="keyword">for</span> milestone <span class="keyword">in</span> epoch_milestones)</span><br><span class="line">        )</span><br><span class="line">        self.gamma = gamma</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_updated_values</span>(<span class="params">self, num_updates: <span class="built_in">int</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> num_updates <span class="keyword">in</span> self.milestones:</span><br><span class="line">            lr_values = [</span><br><span class="line">                group[self.param_group_field] <span class="keyword">for</span> group <span class="keyword">in</span> self.optimizer.param_groups</span><br><span class="line">            ]</span><br><span class="line">            updated_lrs = [lr * self.gamma <span class="keyword">for</span> lr <span class="keyword">in</span> lr_values]</span><br><span class="line">            <span class="keyword">return</span> updated_lrs</span><br></pre></td></tr></table></figure></p><h2 id="案例2：对权重衰减进行调度"><a href="#案例2：对权重衰减进行调度" class="headerlink" title="案例2：对权重衰减进行调度"></a>案例2：对权重衰减进行调度</h2><p>下面是一个例子，说明可以定义一个调度器，每隔<code>n</code>步就递增一个系数<code>gamma</code>来增加权重衰减量：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pytorch_accelerated.schedulers <span class="keyword">import</span> StatefulSchedulerBase</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StepWdScheduler</span>(<span class="params">StatefulSchedulerBase</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, optimizer, n=<span class="number">1000</span>, gamma=<span class="number">1.1</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(optimizer, param_group_field=<span class="string">&quot;weight_decay&quot;</span>)</span><br><span class="line">        self.n = n</span><br><span class="line">        self.gamma = gamma</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_updated_values</span>(<span class="params">self, num_updates: <span class="built_in">int</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> num_updates % self.n == <span class="number">0</span> <span class="keyword">and</span> num_updates &gt; <span class="number">0</span>:</span><br><span class="line">            wd_values = [</span><br><span class="line">                group[self.param_group_field] <span class="keyword">for</span> group <span class="keyword">in</span> self.optimizer.param_groups</span><br><span class="line">            ]</span><br><span class="line">            updated_wd_values = [wd * self.gamma <span class="keyword">for</span> wd <span class="keyword">in</span> wd_values]</span><br><span class="line">            <span class="keyword">return</span> updated_wd_values</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">简介
这一章将研究pytorch-accelerated的调度器API。
PyTorch-accelerated提供了一些调度器的实现，可以在任何PyTorch训练循环中使用。然而，与PyTorch的原生调度器不同——这些原生调度器可以在训练循环的不同点上被调用——所有Pytorch-accelerated调度器都期望在每次优化器更新后被调用。

内置调度器
PyTorch-accelerated内置了一个有状态的余弦退火学习率调度器，基于这篇论文，但没有论文中的restart。
这个调度器与PyTorch的CosineAnnealingLR不同，它提供了增加warmup和cooldown的e</summary>
    
    
    
    <category term="machine learning" scheme="http://qixinbo.github.io/categories/machine-learning/"/>
    
    
    <category term="PyTorch" scheme="http://qixinbo.github.io/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>轻量级PyTorch通用训练模板pytorch-accelerated解析：2 -- API之Callbacks</title>
    <link href="http://qixinbo.github.io/2022/06/04/pytorch-accelerated_2/"/>
    <id>http://qixinbo.github.io/2022/06/04/pytorch-accelerated_2/</id>
    <published>2022-06-03T16:00:00.000Z</published>
    <updated>2022-06-23T02:49:30.738Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这一章将研究<code>pytorch-accelerated</code>的回调机制。</p><h1 id="Callback概览"><a href="#Callback概览" class="headerlink" title="Callback概览"></a>Callback概览</h1><p>在<code>Trainer</code>中除了可重写的钩子（即自定义训练器的行为）之外，<code>Trainer</code>还包括一个回调系统。<br>建议将回调<code>Callbacks</code>用于对训练循环的操作不是很重要的代码中，比如日志，但这个决定由用户根据具体的使用情况进行判断。<br>注意：回调是按顺序执行的，所以如果一个回调被用来修改状态，比如更新一个指标，用户有责任确保这个回调被放在任何将读取这个状态的回调之前（即为了记录的目的）。<br>回调是在其相应的钩子之后被调用，例如，<code>on_train_epoch_end</code>回调方法在<code>pytorch_accelerated.trainer.train_epoch_end()</code>方法之后被调用。这样做是为了支持在一个方法中更新训练器的状态，然后再在回调中读取这个状态。</p><h1 id="内置回调"><a href="#内置回调" class="headerlink" title="内置回调"></a>内置回调</h1><p>（1）该回调用于在训练或验证过程中，如果检测到损失为<code>NaN</code>，则中止训练。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pytorch_accelerated</span>.<span class="title">callbacks</span>.<span class="title">TerminateOnNaNCallback</span></span></span><br></pre></td></tr></table></figure><br>（2）该回调记录<code>Trainer</code>运行历史中更新的任何指标的最新值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pytorch_accelerated</span>.<span class="title">callbacks</span>.<span class="title">LogMetricsCallback</span></span></span><br></pre></td></tr></table></figure><br>默认情况下，它在每个机器上向命令行打印一次。<br>以<code>train</code>为前缀的指标在一个训练<code>epoch</code>结束时被记录，所有其他指标在验证评估后被记录。<br>通过重载<code>log_metrics()</code>方法，可以对其进行子类化以创建不同平台的记录器。<br>（3）该回调在训练的开始和结束时，以及在每个<code>epoch</code>开始时打印一个信息。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pytorch_accelerated</span>.<span class="title">callbacks</span>.<span class="title">PrintProgressCallback</span></span></span><br></pre></td></tr></table></figure><br>（4）该回调使用一个进度条来显示每个训练和验证<code>epoch</code>的状态。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pytorch_accelerated</span>.<span class="title">callbacks</span>.<span class="title">ProgressBarCallback</span></span></span><br></pre></td></tr></table></figure><br>（5）该回调根据一个给定的指标，在训练期间保存最佳模型。最佳模型的权重在训练结束时被加载。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pytorch_accelerated</span>.<span class="title">callbacks</span>.<span class="title">SaveBestModelCallback</span>(<span class="params">save_path=<span class="string">&#x27;best_model.pt&#x27;</span>, watch_metric=<span class="string">&#x27;eval_loss_epoch&#x27;</span>, greater_is_better: <span class="built_in">bool</span> = <span class="literal">False</span>, reset_on_train: <span class="built_in">bool</span> = <span class="literal">True</span></span>)</span></span><br></pre></td></tr></table></figure><br>参数有：</p><ul><li><code>save_path</code>：保存检查点的路径，应该以<code>.pt</code>结尾</li><li><code>watch_metric</code>：该指标用来对比模型性能，它可从<code>trainer</code>的运行历史中获得</li><li><code>greater_is_better</code>：指定<code>watch_metric</code>怎样解释，是否是越大越好，默认是<code>False</code></li><li><code>reset_on_train</code>：指定是否在后续训练中重置最佳指标。如果为<code>True</code>，将只比较当前训练运行期间观察到的指标。</li></ul><p>（6）该回调用于提前终止。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pytorch_accelerated</span>.<span class="title">callbacks</span>.<span class="title">EarlyStoppingCallback</span>(<span class="params">early_stopping_patience: <span class="built_in">int</span> = <span class="number">1</span>, early_stopping_threshold: <span class="built_in">float</span> = <span class="number">0.01</span>, watch_metric=<span class="string">&#x27;eval_loss_epoch&#x27;</span>, greater_is_better: <span class="built_in">bool</span> = <span class="literal">False</span>, reset_on_train: <span class="built_in">bool</span> = <span class="literal">True</span></span>)</span></span><br></pre></td></tr></table></figure><br>参数有：</p><ul><li><code>early_stopping_patience</code>：设置指标没有改善的<code>epochs</code>数目，之后将停止训练</li><li><code>early_stopping_threshold</code>：指定在<code>watch_metric</code>上的最小变化，将其定义为<code>指标改善</code>，也就是说，绝对变化小于这个阈值，将被视为没有改善。</li><li><code>watch_metric</code>：用来评价模型性能的指标，可从<code>trainer</code>的运行历史中获得</li><li><code>great_is_better</code>：指定<code>watch_metric</code>是否是越大越好</li><li><code>reset_on_train</code>：指定是否在后续训练中重置最佳指标。如果为<code>True</code>，将只比较当前训练运行期间观察到的指标。</li></ul><p>（7）该回调在训练或评估开始时将任意<code>Trainer</code>属性转移到适当的设备上。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pytorch_accelerated</span>.<span class="title">callbacks</span>.<span class="title">MoveModulesToDeviceCallback</span></span></span><br></pre></td></tr></table></figure><br>这里的属性是<code>torch.nn.Module</code>的实例。<br>注意，这里不包括模型，因为它将由<code>Trainer</code>内部的<code>accelerate.Accelerator</code>实例单独准备。</p><h1 id="创建新的回调"><a href="#创建新的回调" class="headerlink" title="创建新的回调"></a>创建新的回调</h1><p>要创建一个包含自定义行为的新的回调，例如，将日志转移到一个外部平台，可以通过子类化<code>TrainerCallback</code>实现。为了避免与<code>Trainer</code>的方法相混淆，所有回调方法都以<code>on_</code>为前缀。<br>注意：为了获得最大的灵活性，<code>Trainer</code>的当前实例在每个回调方法中都是可用的。然而，在回调中改变<code>Trainer</code>的状态可能会产生意想不到的后果，因为这可能会影响训练运行的其他部分。如果使用回调来修改训练器的状态，用户有责任确保一切继续按计划进行。</p><h2 id="回调基类"><a href="#回调基类" class="headerlink" title="回调基类"></a>回调基类</h2><p>当创建新的回调时，需要使用如下的抽象基类。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pytorch_accelerated</span>.<span class="title">callbacks</span>.<span class="title">TrainerCallback</span></span></span><br></pre></td></tr></table></figure><br>它的方法（以下称为事件<code>event</code>，原因是这些方法被后面的回调句柄的<code>call_event</code>方法调用，称为事件<code>event</code>也更容易被用户理解和联想）包括：<br>（1）<code>trainer</code>初始化结束后触发的事件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">on_init_end(trainer, **kwargs)</span><br></pre></td></tr></table></figure><br>（2）在训练开始时触发的事件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">on_training_run_start(trainer, **kwargs)</span><br></pre></td></tr></table></figure><br>（3）在每一个训练<code>epoch</code>开始时触发的事件（即对每一个<code>epoch</code>进行循环）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">on_train_epoch_start(trainer, **kwargs)</span><br></pre></td></tr></table></figure><br>（4）在每一个训练步<code>step</code>开始时触发的事件（即对每一个<code>batch</code>进行循环）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">on_train_step_start(trainer, **kwargs)</span><br></pre></td></tr></table></figure><br>（5）在每一个训练步<code>step</code>结束后触发的事件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">on_train_step_end(trainer, batch, batch_output, **kwargs)</span><br></pre></td></tr></table></figure><br>参数有：</p><ul><li><code>batch</code>：训练集的当前<code>batch</code></li><li><code>batch_output</code>：由<code>pytorch_accelerated.trainer.Trainer.calculate_train_batch_loss()</code>所返回的输出</li></ul><p>（6）在每一个训练<code>epoch</code>结束后触发的事件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">on_train_epoch_end(trainer, **kwargs)</span><br></pre></td></tr></table></figure><br>（7）在每一个验证<code>epoch</code>开始时触发的事件（即对每一个<code>epoch</code>进行循环）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">on_eval_epoch_start(trainer, **kwargs)</span><br></pre></td></tr></table></figure><br>（8）在每一个验证步<code>step</code>开始时触发的事件（即对每一个<code>batch</code>进行循环）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">on_eval_step_start(trainer, **kwargs)</span><br></pre></td></tr></table></figure><br>（9）在每一个验证步<code>step</code>结束后触发的事件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">on_eval_step_end(trainer, batch, batch_output, **kwargs)</span><br></pre></td></tr></table></figure><br>参数有：</p><ul><li><code>batch</code>：验证集的当前<code>batch</code></li><li><code>batch_output</code>：由<code>pytorch_accelerated.trainer.Trainer.calculate_eval_batch_loss()</code>所返回的输出</li></ul><p>（10）在每一个验证<code>epoch</code>结束后触发的事件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">on_eval_epoch_end(trainer, **kwargs)</span><br></pre></td></tr></table></figure><br>（11）在训练结束后触发的事件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">on_training_run_end(trainer, **kwargs)</span><br></pre></td></tr></table></figure><br>（12）当出现训练错误后触发的事件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">on_stop_training_error(trainer, **kwargs)</span><br></pre></td></tr></table></figure><br>一个训练可能通过发出<code>StopTrainingError</code>异常来被提前停止。</p><h2 id="案例1：使用回调来追踪指标"><a href="#案例1：使用回调来追踪指标" class="headerlink" title="案例1：使用回调来追踪指标"></a>案例1：使用回调来追踪指标</h2><p>默认情况下，<code>pytorch_accelerated.trainer.Trainer</code>记录的唯一指标是训练和评估期间观察到的损失。为了跟踪其他指标，我们可以使用回调来扩展这一行为。<br>下面是一个例子，说明如何定义一个回调并使用<code>RunHistory</code>来跟踪用<code>TorchMetrics</code>计算的指标。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torchmetrics <span class="keyword">import</span> MetricCollection, Accuracy, Precision, Recall</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassificationMetricsCallback</span>(<span class="params">TrainerCallback</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_classes</span>):</span></span><br><span class="line">        self.metrics = MetricCollection(</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;accuracy&quot;</span>: Accuracy(num_classes=num_classes),</span><br><span class="line">                <span class="string">&quot;precision&quot;</span>: Precision(num_classes=num_classes),</span><br><span class="line">                <span class="string">&quot;recall&quot;</span>: Recall(num_classes=num_classes),</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_move_to_device</span>(<span class="params">self, trainer</span>):</span></span><br><span class="line">        self.metrics.to(trainer.device)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_training_run_start</span>(<span class="params">self, trainer, **kwargs</span>):</span></span><br><span class="line">        self._move_to_device(trainer)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_evaluation_run_start</span>(<span class="params">self, trainer, **kwargs</span>):</span></span><br><span class="line">        self._move_to_device(trainer)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_eval_step_end</span>(<span class="params">self, trainer, batch, batch_output, **kwargs</span>):</span></span><br><span class="line">        preds = batch_output[<span class="string">&quot;model_outputs&quot;</span>].argmax(dim=-<span class="number">1</span>)</span><br><span class="line">        self.metrics.update(preds, batch[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_eval_epoch_end</span>(<span class="params">self, trainer, **kwargs</span>):</span></span><br><span class="line">        metrics = self.metrics.compute()</span><br><span class="line">        trainer.run_history.update_metric(<span class="string">&quot;accuracy&quot;</span>, metrics[<span class="string">&quot;accuracy&quot;</span>].cpu())</span><br><span class="line">        trainer.run_history.update_metric(<span class="string">&quot;precision&quot;</span>, metrics[<span class="string">&quot;precision&quot;</span>].cpu())</span><br><span class="line">        trainer.run_history.update_metric(<span class="string">&quot;recall&quot;</span>, metrics[<span class="string">&quot;recall&quot;</span>].cpu())</span><br><span class="line"></span><br><span class="line">        self.metrics.reset()</span><br></pre></td></tr></table></figure></p><h2 id="案例2：创建自定义日志的回调"><a href="#案例2：创建自定义日志的回调" class="headerlink" title="案例2：创建自定义日志的回调"></a>案例2：创建自定义日志的回调</h2><p>建议使用回调来处理日志，以使训练循环集中在机器学习相关的代码上。通过对<code>LogMetricsCallback</code>回调的子类化，很容易为其他平台创建日志记录器。<br>例如，可以为<code>AzureML</code>（使用<code>MLFlow API</code>）创建一个记录器，如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mlflow</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AzureMLLoggerCallback</span>(<span class="params">LogMetricsCallback</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        mlflow.set_tracking_uri(os.environ[<span class="string">&#x27;MLFLOW_TRACKING_URI&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_training_run_start</span>(<span class="params">self, trainer, **kwargs</span>):</span></span><br><span class="line">        mlflow.set_tags(trainer.run_config.to_dict())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log_metrics</span>(<span class="params">self, trainer, metrics</span>):</span></span><br><span class="line">        <span class="keyword">if</span> trainer.run_config.is_world_process_zero:</span><br><span class="line">            mlflow.log_metrics(metrics)</span><br></pre></td></tr></table></figure></p><h2 id="案例3：自定义回调以在评估后保存结果"><a href="#案例3：自定义回调以在评估后保存结果" class="headerlink" title="案例3：自定义回调以在评估后保存结果"></a>案例3：自定义回调以在评估后保存结果</h2><p>下面是一个自定义回调的例子，在评估期间记录预测结果，然后在评估周期结束时将其保存为<code>csv</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SavePredictionsCallback</span>(<span class="params">TrainerCallback</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, out_filename=<span class="string">&#x27;./outputs/valid_predictions.csv&#x27;</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.predictions = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        self.out_filename = out_filename</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_eval_step_end</span>(<span class="params">self, trainer, batch, batch_output, **kwargs</span>):</span></span><br><span class="line">        input_features, targets = batch</span><br><span class="line">        class_preds = trainer.gather(batch_output[<span class="string">&#x27;model_outputs&#x27;</span>]).argmax(dim=-<span class="number">1</span>)</span><br><span class="line">        self.predictions[<span class="string">&#x27;prediction&#x27;</span>].extend(class_preds.cpu().tolist())</span><br><span class="line">        self.predictions[<span class="string">&#x27;targets&#x27;</span>].extend(targets.cpu().tolist())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_eval_epoch_end</span>(<span class="params">self, trainer, **kwargs</span>):</span></span><br><span class="line">        trainer._accelerator.wait_for_everyone()</span><br><span class="line">        <span class="keyword">if</span> trainer.run_config.is_local_process_zero:</span><br><span class="line">            df = pd.DataFrame.from_dict(self.predictions)</span><br><span class="line">            df.to_csv(<span class="string">f&#x27;<span class="subst">&#123;self.out_filename&#125;</span>&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></p><h1 id="回调句柄"><a href="#回调句柄" class="headerlink" title="回调句柄"></a>回调句柄</h1><p>传递给<code>Trainer</code>的任何回调函数都是由一个内部回调句柄类<code>CallbackHandler</code>的实例来处理的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pytorch_accelerated</span>.<span class="title">callbacks</span>.<span class="title">CallbackHandler</span>(<span class="params">callbacks</span>)</span></span><br></pre></td></tr></table></figure><br>可以看出，回调句柄<code>CallbackHandler</code>的输入参数就是一系列的回调函数，然后该句柄顺序执行它们（执行顺序是按它们传入该句柄的顺序）。<br>主要方法有：<br>（1）添加单个回调函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_callback(callback)</span><br></pre></td></tr></table></figure><br>参数为<code>callback</code>，类型是<code>TrainerCallback</code>的子类的实例。<br>（2）添加多个回调函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_callbacks(callbacks)</span><br></pre></td></tr></table></figure><br>参数为<code>callbacks</code>，是一个回调函数列表。<br>（3）对于已添加注册的所有回调，根据特定事件<code>event</code>来顺序调用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call_event(event, *args, **kwargs)</span><br></pre></td></tr></table></figure><br>参数有：</p><ul><li><code>event</code>：要触发的事件，实际</li><li><code>args</code>：传给回调的参数列表</li><li><code>kwargs</code>：传给回调的关键字列表</li></ul><h2 id="创建新的回调事件"><a href="#创建新的回调事件" class="headerlink" title="创建新的回调事件"></a>创建新的回调事件</h2><p>前面已经介绍了很多内置的回调事件，比如<code>on_init_end</code>、<code>on_training_run_start</code>等，这些事件触发的位置都在<code>Trainer</code>中已经定义好了。<br>也可以创建新的回调事件，比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VerifyBatchCallback</span>(<span class="params">TrainerCallback</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verify_train_batch</span>(<span class="params">self, trainer, xb, yb</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> xb.shape[<span class="number">0</span>] == trainer.run_config[<span class="string">&quot;train_per_device_batch_size&quot;</span>]</span><br><span class="line">        <span class="keyword">assert</span> xb.shape[<span class="number">1</span>] == <span class="number">1</span></span><br><span class="line">        <span class="keyword">assert</span> xb.shape[<span class="number">2</span>] == <span class="number">28</span></span><br><span class="line">        <span class="keyword">assert</span> xb.shape[<span class="number">3</span>] == <span class="number">28</span></span><br><span class="line">        <span class="keyword">assert</span> yb.shape[<span class="number">0</span>] == trainer.run_config[<span class="string">&quot;train_per_device_batch_size&quot;</span>]</span><br></pre></td></tr></table></figure><br>然后在训练过程中进行触发（最好就是子类化原来的<code>Trainer</code>）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrainerWithCustomCallbackEvent</span>(<span class="params">Trainer</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate_train_batch_loss</span>(<span class="params">self, batch</span>) -&gt; <span class="built_in">dict</span>:</span></span><br><span class="line">        xb, yb = batch</span><br><span class="line">        self.callback_handler.call_event(</span><br><span class="line">            <span class="string">&quot;verify_train_batch&quot;</span>, trainer=self, xb=xb, yb=yb</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().calculate_train_batch_loss(batch)</span><br></pre></td></tr></table></figure><br>这样就实现了很大的灵活性。</p>]]></content>
    
    
    <summary type="html">简介
这一章将研究pytorch-accelerated的回调机制。

Callback概览
在Trainer中除了可重写的钩子（即自定义训练器的行为）之外，Trainer还包括一个回调系统。
建议将回调Callbacks用于对训练循环的操作不是很重要的代码中，比如日志，但这个决定由用户根据具体的使用情况进行判断。
注意：回调是按顺序执行的，所以如果一个回调被用来修改状态，比如更新一个指标，用户有责任确保这个回调被放在任何将读取这个状态的回调之前（即为了记录的目的）。
回调是在其相应的钩子之后被调用，例如，on_train_epoch_end回调方法在pytorch_accelerated.t</summary>
    
    
    
    <category term="machine learning" scheme="http://qixinbo.github.io/categories/machine-learning/"/>
    
    
    <category term="PyTorch" scheme="http://qixinbo.github.io/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>轻量级PyTorch通用训练模板pytorch-accelerated解析：1 -- API之Trainer</title>
    <link href="http://qixinbo.github.io/2022/05/29/pytorch-accelerated_1/"/>
    <id>http://qixinbo.github.io/2022/05/29/pytorch-accelerated_1/</id>
    <published>2022-05-28T16:00:00.000Z</published>
    <updated>2022-06-22T15:32:38.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>从这一节开始，详细看一下<code>pytorch-accelerated</code>的<code>API</code>。<br>本文是对<code>Trainer</code>的<code>API</code>的解析。</p><h1 id="Trainer概览"><a href="#Trainer概览" class="headerlink" title="Trainer概览"></a>Trainer概览</h1><p>训练器<code>Trainer</code>用来封装特定任务的整个训练循环，将模型、损失函数和优化器结合在一起，并为训练过程的每一步提供执行行为规范。<br><code>Trainer</code>的实现是这样的：它提供了训练部分的（可重复的）实现，这些部分在被定义后很少发生变化——比如创建数据加载器，或如何将一批数据送入模型——同时与可能发生变化的部分保持解耦，比如模型、数据集、损失函数和优化器。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trainer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        self,</span></span></span><br><span class="line"><span class="function"><span class="params">        model,</span></span></span><br><span class="line"><span class="function"><span class="params">        loss_func,</span></span></span><br><span class="line"><span class="function"><span class="params">        optimizer,</span></span></span><br><span class="line"><span class="function"><span class="params">        callbacks=DEFAULT_CALLBACKS,</span></span></span><br><span class="line"><span class="function"><span class="params">        run_history=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>):</span></span><br></pre></td></tr></table></figure><br>它的初始化函数中输入的参数有：</p><ul><li><code>model</code>：用来训练的神经网络模型，是<code>nn.Module</code>的子类</li><li><code>loss_func</code>：用来训练模型的损失函数</li><li><code>optimizer</code>：用来更新模型参数的优化器</li><li><code>callbacks</code>：当训练进行时调用的回调函数列表<code>callbacks</code>，如果没有提供该列表，则使用默认的回调函数，包括<code>MoveModulesToDeviceCallback</code>、<code>TerminateOnNaNCallback</code>、<code>PrintProgressCallback</code>、<code>ProgressBarCallback</code>、<code>LogMetricsCallback</code>。</li><li><code>run_history</code>：<code>RunHistory</code>的子类的一个实例，如果不提供的话（即<code>None</code>），则会新建一个<code>InMemoryRunHistory</code>这个子类的实例。</li></ul><h1 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h1><p><code>Trainer</code>的主要入口函数是<code>train()</code>方法，其用来启动模型训练（如果提供了验证集，那么会同时包括训练和验证评估）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    self,</span></span></span><br><span class="line"><span class="function"><span class="params">    train_dataset,</span></span></span><br><span class="line"><span class="function"><span class="params">    num_epochs,</span></span></span><br><span class="line"><span class="function"><span class="params">    eval_dataset=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    per_device_batch_size=<span class="number">8</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    max_num_train_steps=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    gradient_accumulation_steps=<span class="number">1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    gradient_clip_value=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    create_scheduler_fn: <span class="type">Callable</span> = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    train_dataloader_kwargs: <span class="built_in">dict</span> = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    eval_dataloader_kwargs: <span class="built_in">dict</span> = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    reset_run_history=<span class="literal">True</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    collate_fn=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br></pre></td></tr></table></figure><br>输入参数包括：</p><ul><li><code>train_dataset</code>：训练集</li><li><code>num_epochs</code>：训练的迭代次数</li><li><code>eval_dataset</code>：验证集，如果不提供的话，则跳过模型的验证评估环节</li><li><code>per_device_batch_size</code>：每个设备上的批处理大小</li><li><code>max_num_train_steps</code>：最大迭代步数，如果提供该参数的话，会覆盖掉<code>num_epochs</code></li><li><code>gradient_accumulation_steps</code>：对特定步数进行梯度累加来模拟一个更大的批处理大小，默认该参数为<code>1</code></li><li><code>gradient_clip_value</code>：如果指定的话，模型参数的梯度将被修剪到<code>[-gradient_clip_value, gradient_clip_value]</code>之间。</li><li><code>create_scheduler_fn</code>：由于优化器需要在训练前就准备好，为了能够在优化器中使用学习率调度器，必须向<code>create_scheduler_fn</code>参数提供一个工厂函数。该工厂函数必须是一个接受优化器<code>optimizer</code>作为唯一参数的函数，并返回一个学习率调度器的实例。注意，这里不是传递一个学习率调度器的实例，而是传递一个工厂函数能返回这样的实例。</li><li><code>train_dataloader_kwargs</code>：用来传递给训练集数据加载器的构造函数的关键字参数字典，详情参见<a href="https://pytorch.org/docs/stable/data.html#torch.utils.data.DataLoader"><code>torch.utils.data.DataLoader</code></a>。</li><li><code>eval_dataloader_kwargs</code>：用来传递给验证集数据加载器的构造函数的关键字参数字典，详情参见<a href="https://pytorch.org/docs/stable/data.html#torch.utils.data.DataLoader"><code>torch.utils.data.DataLoader</code></a>。</li><li><code>reset_run_history</code>：重置<code>Trainer</code>保留的之前的运行历史</li><li><code>collate_fn</code>：训练集数据加载器和验证集数据加载器所使用的<code>collate_fn</code>函数</li></ul><h2 id="使用学习率调度器"><a href="#使用学习率调度器" class="headerlink" title="使用学习率调度器"></a>使用学习率调度器</h2><p>由于<code>Pytorch</code>学习率调度器的调用方式不尽相同，为了实现最大的灵活性，<code>PyTorch-accelerated</code>的<code>Trainer</code>期望在每次优化器更新后都默认调用一个给定的调度器。<br>请注意，由于优化器和数据加载器需要在训练前进行准备，为了使用学习率调度器，必须向<code>train()</code>提供一个工厂函数作为<code>create_scheduler_fn</code>参数。这必须是一个接受优化器作为单一参数的函数，并返回一个学习率调度器的实例。再次注意，这里不是传递一个学习率调度器的实例，而是传递一个工厂函数能返回这样的实例。<br>创建调度器工厂函数的一个简单方法是使用<code>functools.partial()</code>，比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> Partial</span><br><span class="line"><span class="keyword">from</span> torch.optim <span class="keyword">import</span> lr_scheduler</span><br><span class="line"></span><br><span class="line">create_scheduler_fn = partial(lr_scheduler.StepLR, step_size=<span class="number">7</span>, gamma=<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure><br>特别注意：<code>Trainer</code>在每个批次之后都会调用一次所提供的调度器。这可能会导致意想不到的结果，因为一些<code>PyTorch</code>调度器预期是只在每一个<code>epoch</code>后进行调用。<br>例如，在上面的例子中，我们想要学习率在每个批次都会被乘以<code>0.1</code>。但是由于这个特殊的调度器被设计为每一个<code>epoch</code>调用一次，因此这不是我们想要的行为，此时可以通过下面的方法来解决这个问题：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> Partial</span><br><span class="line"><span class="keyword">from</span> torch.optim <span class="keyword">import</span> lr_scheduler</span><br><span class="line"><span class="keyword">from</span> pytorch_accelerated <span class="keyword">import</span> TrainerPlaceholderValues</span><br><span class="line"></span><br><span class="line">epochs_step_size = <span class="number">7</span></span><br><span class="line">create_scheduler_fn = partial(</span><br><span class="line">    lr_scheduler.StepLR,</span><br><span class="line">    step_size=TrainerPlaceHolderValues.NUM_UPDATE_STEPS_PER_EPOCH * epochs_step_size</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>这里，为了确定每个<code>epoch</code>的<code>steps</code>的数值，使用了<code>TrainerPlaceholderValues</code>占位符，下面将介绍。</p><h3 id="使用TrainerPlaceHolderValues"><a href="#使用TrainerPlaceHolderValues" class="headerlink" title="使用TrainerPlaceHolderValues"></a>使用TrainerPlaceHolderValues</h3><p>一些学习率调度器需要一些信息，比如在训练运行期间的总步数<code>steps</code>。由于在创建训练数据加载器之前无法获得这些信息——这将作为<code>train()</code>方法的一部分来完成——在这种情况下可以使用一个占位符值，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from functools import Partial</span><br><span class="line">from pytorch_accelerated import TrainerPlaceholderValues</span><br><span class="line">from torch.optim.lr_scheduler import OneCycleLR</span><br><span class="line"></span><br><span class="line">create_scheduler_fn &#x3D; partial(</span><br><span class="line">            OneCycleLR,</span><br><span class="line">            max_lr&#x3D;config.lr,</span><br><span class="line">            epochs&#x3D;TrainerPlaceholderValues.NUM_EPOCHS,</span><br><span class="line">            steps_per_epoch&#x3D;TrainerPlaceholderValues.NUM_UPDATE_STEPS_PER_EPOCH,</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><br>这些占位符将由<code>trainer</code>在训练期间用正确的数值替换。<br>可用的占位符包括：</p><ul><li><code>NUM_EPOCHS</code></li><li><code>NUM_UPDATE_STEPS_PER_EPOCH</code></li><li><code>TRAIN_DATALOADER_LEN</code></li><li><code>EVAL_DATALOADER_LEN</code></li></ul><p>或者，可以通过重载<code>Trainer</code>的<code>create_scheduler()</code>方法来获得同样的结果。</p><h3 id="使用PyTorch-accelerated内置的调度器"><a href="#使用PyTorch-accelerated内置的调度器" class="headerlink" title="使用PyTorch-accelerated内置的调度器"></a>使用PyTorch-accelerated内置的调度器</h3><p><code>PyTorch-accelerated</code>包括一些调度器的实现，这些调度器具有与<code>PyTorch</code>调度器相同的接口，还有一些基类可以轻松创建自定义调度器；这些将在后面的<code>Schedulers</code>一节中详细讨论。<br>这些调度器的实现有一个替代的构造函数，可以直接作为<code>create_scheduler_fn</code>参数传递给`train()``，如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pytorch_accelerated.schedulers <span class="keyword">import</span> CosineLrScheduler</span><br><span class="line">trainer.train(</span><br><span class="line">        train_dataset=train_dataset,</span><br><span class="line">        num_epochs=num_epochs,</span><br><span class="line">        per_device_batch_size=batch_size,</span><br><span class="line">        create_scheduler_fn=CosineLrScheduler.create_scheduler_fn(num_warmup_epochs=<span class="number">5</span>,</span><br><span class="line">                                                                  warmup_starting_lr=<span class="number">1e-6</span>,</span><br><span class="line">                                                                  num_cooldown_epochs=<span class="number">5</span>),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure></p><h3 id="使用timm调度器"><a href="#使用timm调度器" class="headerlink" title="使用timm调度器"></a>使用timm调度器</h3><p><code>timm</code>中包含的调度器与原生的<code>PyTorch</code>调度器有不同的接口，所以默认情况下不能与<code>Trainer</code>一起使用。<br><code>PyTorch-accelerated</code>包含了一个替代的<code>Trainer</code>，即<code>TrainerWithTimmScheduler</code>，它与<code>timm</code>的调度器兼容；<code>timm</code>调度器应作为工厂函数传递给这个训练器，方法与上述相同。</p><h1 id="评估模型"><a href="#评估模型" class="headerlink" title="评估模型"></a>评估模型</h1><p>一旦模型被训练好，或者从检查点<code>checkpoint</code>加载，训练器<code>Trainer</code>也可以用于评估，这包括使用<code>Trainer</code>的评估循环的逻辑，在给定的数据集上运行一个<code>epoch</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    self,</span></span></span><br><span class="line"><span class="function"><span class="params">    dataset=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    per_device_batch_size=<span class="number">8</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    dataloader_kwargs: <span class="built_in">dict</span> = <span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    collate_fn=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br></pre></td></tr></table></figure><br>它的参数有：</p><ul><li><code>dataset</code>：要评估的数据集</li><li><code>per_device_batch_size</code>：每个设备上的批处理大小</li><li><code>dataloader_kwargs</code>：用来传递给数据加载器的构造函数的关键字参数字典，详情参见<a href="https://pytorch.org/docs/stable/data.html#torch.utils.data.DataLoader"><code>torch.utils.data.DataLoader</code></a>。</li><li><code>collate_fn</code>：数据加载器所使用的<code>collate_fn</code>函数。</li></ul><p>注意：启动一个评估后，会重置<code>Trainer</code>的运行历史。<br>另外，在分布式评估过程中，如果<code>per_device_batch_size * 使用的进程数</code>不能精确划分数据集，并且<code>drop_last=False</code>没有传给<code>dataloader_kwargs</code>，那么<code>dataloader</code>将在耗尽批次的进程中从头重复。在计算指标时应考虑到这一点。</p><h1 id="效用函数"><a href="#效用函数" class="headerlink" title="效用函数"></a>效用函数</h1><p><code>Trainer</code>提供了很多效用函数供使用：</p><h2 id="保存检查点"><a href="#保存检查点" class="headerlink" title="保存检查点"></a>保存检查点</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_checkpoint</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    self, save_path, checkpoint_kwargs=<span class="literal">None</span>, save_optimizer=<span class="literal">True</span>, save_per_node=<span class="literal">True</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br></pre></td></tr></table></figure><p>在一个检查点<code>checkpoint</code>文件中保存模型、优化器及其他指定的对象。<br>输入参数有：</p><ul><li><code>save_path</code>：存储检查点的路径，应该以<code>.pt</code>结尾</li><li><code>checkpoint_kwargs</code>：在检查点中应该包含的其他对象</li><li><code>save_optimizer</code>：指定是否保存优化器</li><li><code>save_per_node</code>：指定是否每个机器保存检查点，如果<code>False</code>，则仅在<code>0</code>号进程中保存。默认是<code>True</code>。</li></ul><h2 id="加载检查点"><a href="#加载检查点" class="headerlink" title="加载检查点"></a>加载检查点</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_checkpoint</span>(<span class="params">self, checkpoint_path, load_optimizer=<span class="literal">True</span></span>):</span></span><br></pre></td></tr></table></figure><p>从检查点文件中加载模型和优化器。<br>参数有：</p><ul><li><code>checkpoint_path</code>：要加载的检查点文件的路径</li><li><code>load_optimizer</code>：如果检查点文件中包含了优化器，指定是否加载它</li></ul><h2 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br></pre></td></tr></table></figure><p>用来替代原生的<code>print()</code>，以每个节点只打印一次。</p><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gather</span>(<span class="params">self, tensor</span>):</span></span><br></pre></td></tr></table></figure><p>收集所有进程的张量值，并在第一个维度上将其连接起来。在进行评估时，这对重新组合所有进程的预测值很有用。<br>注意：该聚合操作将会在所有进程中进行。</p><h1 id="自定义Trainer行为"><a href="#自定义Trainer行为" class="headerlink" title="自定义Trainer行为"></a>自定义Trainer行为</h1><p>虽然<code>Trainer</code>在简单的用例中能开箱即用，同时也鼓励对<code>Trainer</code>进行子类化并重载其方法。<br>以动词为前缀的方法，如<code>create</code>或<code>calculate</code>，期望返回一个值，所有其他方法都用于设置内部状态（如<code>optimizer.step()</code>）。</p><h2 id="与构建相关的方法"><a href="#与构建相关的方法" class="headerlink" title="与构建相关的方法"></a>与构建相关的方法</h2><p>（1）构建训练集数据加载器<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trainer.create_train_dataloader(batch_size: <span class="built_in">int</span>, train_dl_kwargs: <span class="type">Optional</span>[<span class="built_in">dict</span>] = <span class="literal">None</span>) → Iterable</span><br></pre></td></tr></table></figure><br>创建一个在训练中使用的数据加载器，该数据加载器接收通过<code>Trainer</code>传入的<code>train_dataset</code>和<code>collate</code>函数。<br>参数有：</p><ul><li><code>batch_size</code>：在每个设备上的批处理大小</li><li><code>train_dl_kwargs</code>：用来传递给数据加载器的构造函数的关键字参数字典，详情参见<a href="https://pytorch.org/docs/stable/data.html#torch.utils.data.DataLoader"><code>torch.utils.data.DataLoader</code></a></li></ul><p>注意：如果没有传入<code>train_dl_kwargs</code>参数，则使用<code>Trainer.get_default_train_dl_kwargs()</code>返回的参数。如果在<code>train_dl_kwargs</code>中同样加入了<code>batch_size</code>这一属性，则这里的<code>batch_size</code>会覆盖掉前面的<code>batch_size</code>。</p><p>（2）获得默认训练集数据加载器参数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trainer.get_default_train_dl_kwargs(batch_size) → <span class="built_in">dict</span></span><br></pre></td></tr></table></figure><br>参数为<code>batch_size</code>，返回值为训练集数据加载器的默认参数字典。<br>（3）构建验证集数据加载器<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trainer.create_eval_dataloader(batch_size: <span class="built_in">int</span>, eval_dl_kwargs: <span class="type">Optional</span>[<span class="built_in">dict</span>] = <span class="literal">None</span>) → Iterable</span><br></pre></td></tr></table></figure><br>创建一个在评估验证中使用的数据加载器，该数据加载器接收通过<code>Trainer</code>传入的<code>eval_dataset</code>和<code>collate</code>函数。<br>参数有：</p><ul><li><code>batch_size</code>：在每个设备上的批处理大小</li><li><code>eval_dl_kwargs</code>：用来传递给数据加载器的构造函数的关键字参数字典，详情参见<a href="https://pytorch.org/docs/stable/data.html#torch.utils.data.DataLoader"><code>torch.utils.data.DataLoader</code></a>。</li></ul><p>注意：如果没有传入<code>eval_dl_kwargs</code>参数，则使用<code>Trainer.get_default_eval_dl_kwargs()</code>返回的参数。如果在<code>eval_dl_kwargs</code>中同样加入了<code>batch_size</code>这一属性，则这里的<code>batch_size</code>会覆盖掉前面的<code>batch_size</code>。</p><p>（4）获得默认验证集数据加载器参数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trainer.get_default_eval_dl_kwargs(batch_size) → <span class="built_in">dict</span></span><br></pre></td></tr></table></figure><br>参数为<code>batch_size</code>，返回值为验证集数据加载器的默认参数字典。<br>（5）创建调度器<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trainer.create_scheduler()</span><br></pre></td></tr></table></figure><br>基于传给<code>Trainer</code>的<code>create_scheduler_fn</code>函数创建一个学习率调度器，返回值是一个学习率调度器的实例。</p><h2 id="与训练相关的方法"><a href="#与训练相关的方法" class="headerlink" title="与训练相关的方法"></a>与训练相关的方法</h2><p>（1）训练开始时会调用如下方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trainer.training_run_start()</span><br></pre></td></tr></table></figure><br>（2）每一个<code>epoch</code>训练和评估完成后会调用如下方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trainer.training_run_epoch_end()</span><br></pre></td></tr></table></figure><br>（3）训练结束后会调用如下方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trainer.training_run_end()</span><br></pre></td></tr></table></figure></p><h3 id="训练步相关方法"><a href="#训练步相关方法" class="headerlink" title="训练步相关方法"></a>训练步相关方法</h3><p>（1）每一训练<code>epoch</code>开始时调用如下方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trainer.train_epoch_start()</span><br></pre></td></tr></table></figure><br>该方法的默认行为是调用<code>self.model.train()</code>。<br>（2）在每一训练<code>epoch</code>后计算训练损失：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trainer.calculate_train_batch_loss(batch) → <span class="built_in">dict</span></span><br></pre></td></tr></table></figure><br>参数为</p><ul><li><code>batch</code>：训练集数据加载器的输出</li></ul><p>返回值为一个包含训练损失、模型输出和批处理大小的字典，必须包含这三个<code>keys</code>，也能包含其他的<code>keys</code>，这些额外的返回值可以通过<code>~callbacks.TrainerCallback.on_train_step_end</code>这个回调获得。<br>（3）反向传播步<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trainer.backward_step(loss)</span><br></pre></td></tr></table></figure><br>使用加速器对<code>calculate_train_batch_loss()</code>返回的损失值进行反向传播。如果启用了梯度累积，该损失会被<code>1/累积步数</code>所缩放。<br>（4）优化步<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trainer.optimizer_step()</span><br></pre></td></tr></table></figure><br>执行一个单一的优化步骤，并更新之前传递给<code>self.optimizer</code>的参数。<br>（5）学习率调度步<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trainer.scheduler_step()</span><br></pre></td></tr></table></figure><br>如果指定了学习率调度器<code>self.scheduler</code>，则执行一次调度步。<br>（6）梯度置0步<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trainer.optimizer_zero_grad()</span><br></pre></td></tr></table></figure><br>将所有优化后的<code>torch.Tensor</code>的梯度置为0。<br>（7）每一训练<code>epoch</code>结束时调用如下方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trainer.train_epoch_end()</span><br></pre></td></tr></table></figure></p><h3 id="验证步相关方法"><a href="#验证步相关方法" class="headerlink" title="验证步相关方法"></a>验证步相关方法</h3><p>（1）每一验证<code>epoch</code>开始时调用如下方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trainer.eval_epoch_start()</span><br></pre></td></tr></table></figure><br>该方法的默认行为是调用<code>self.model.eval()</code>。<br>（2）在每一验证<code>epoch</code>后计算验证损失：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trainer.calculate_eval_batch_loss(batch) → <span class="built_in">dict</span></span><br></pre></td></tr></table></figure><br>参数为</p><ul><li><code>batch</code>：验证集数据加载器的输出</li></ul><p>返回值为一个包含验证损失、模型输出和批处理大小的字典，必须包含这三个<code>keys</code>，也能包含其他的<code>keys</code>，这些额外的返回值可以通过<code>~callbacks.TrainerCallback.on_eval_step_end</code>这个回调获得。<br>（3）每一验证<code>epoch</code>结束时调用如下方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trainer.eval_epoch_end()</span><br></pre></td></tr></table></figure></p><h2 id="与评估相关的方法"><a href="#与评估相关的方法" class="headerlink" title="与评估相关的方法"></a>与评估相关的方法</h2><p>（1）模型评估开始时会调用如下方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trainer.evaluation_run_start()</span><br></pre></td></tr></table></figure><br>（2）评估结束后会调用如下方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trainer.evaluation_run_end()</span><br></pre></td></tr></table></figure></p><h2 id="内部方法"><a href="#内部方法" class="headerlink" title="内部方法"></a>内部方法</h2><p>内部方法都是带着下划线前缀。<br>本着<code>Python</code>的精神，在训练器<code>Trainer</code>中没有什么是真正隐藏的。然而，必须小心，因为通过覆盖这些内部方法，会从根本上改变了<code>Trainer</code>的内部工作方式，这可能会产生意想不到的后果。当修改一个或多个内部方法时，用户有责任确保训练器继续按预期的方式工作。</p><h3 id="内部构建"><a href="#内部构建" class="headerlink" title="内部构建"></a>内部构建</h3><p>（1）创建<a href="https://huggingface.co/docs/accelerate/main/en/accelerator#accelerate.Accelerator"><code>accelerate.Accelerator</code></a>的实例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trainer._create_accelerator()</span><br></pre></td></tr></table></figure><br>该实例将用来管理训练过程，后面简称为加速器实例。<br>（2）封装模型、优化器和数据加载器<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trainer._prepare_model_optimizer_and_dataloaders()</span><br></pre></td></tr></table></figure><br>使用加速器实例将模型、优化器和数据加载器封装在训练所需的任意封装器中(例如<code>Torch.nn.parallel.DistributedDataParallel</code>），并确保参数被放在适当的设备上。<br>默认情况下，这将把每个数据加载器转换为<a href="https://huggingface.co/docs/accelerate/main/en/internal#accelerate.data_loader.DataLoaderShard"><code>accelerate.data_loader.DataLoaderShard</code></a>的一个实例。根据数据加载器的<code>drop_last</code>属性的值，一种情况是迭代将停止在第一个太小/不能存在于所有进程的批次上，另一种情况是在数据耗尽的进程上从头开始循环批次，这样所有批次的大小都是一样的。注意：这可能会改变数据加载器的长度，所以应该在计算每个周期的更新步数（即初始化一个学习率调度器）之前调用。（这一段得再细细品）<br>（3）创建表示<code>trainer</code>当前状态的<code>TrainerRunConfig</code>的实例<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trainer._create_run_config(per_device_batch_size, num_epochs, gradient_accumulation_steps, max_num_train_steps, gradient_clip_value) → TrainerRunConfig</span><br></pre></td></tr></table></figure><br>参数有：</p><ul><li><code>per_device_batch_size</code>：每个设备上的批大小</li><li><code>num_epochs</code>：在当前训练的<code>epoch</code>数目</li><li><code>gradient_accumulation_steps</code>：训练过程中使用的梯度累加的步数</li><li><code>max_num_train_steps</code>：指定训练的最大步数，如果指定该参数的话，会覆盖<code>num_epochs</code>参数</li><li><code>gradient_clip_value</code>：指定修剪模型参数梯度的阈值</li></ul><h3 id="与训练相关的内部方法"><a href="#与训练相关的内部方法" class="headerlink" title="与训练相关的内部方法"></a>与训练相关的内部方法</h3><p>在训练开始时，会使用如下内部方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trainer._run_training()</span><br></pre></td></tr></table></figure></p><h3 id="与训练步相关的内部方法"><a href="#与训练步相关的内部方法" class="headerlink" title="与训练步相关的内部方法"></a>与训练步相关的内部方法</h3><p>（1）在每个训练步中的行为，使用如下内部方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trainer._run_train_epoch(train_dl)</span><br></pre></td></tr></table></figure><br>参数是<code>train_dl</code>，即训练集的数据加载器。<br>（2）修剪模型参数的梯度：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trainer._clip_gradients()</span><br></pre></td></tr></table></figure><br>该方法会根据之前传入<code>train()</code>方法的阈值来修剪模型参数的梯度。<br>默认情况下，使用<a href="https://huggingface.co/docs/accelerate/main/en/accelerator#accelerate.Accelerator.clip_grad_value_"><code>accelerate.Accelerator.clip_grad_value_()</code></a>来修剪梯度。</p><h3 id="与验证-评估相关的内部方法"><a href="#与验证-评估相关的内部方法" class="headerlink" title="与验证/评估相关的内部方法"></a>与验证/评估相关的内部方法</h3><p>在每个验证步中的行为，使用如下内部方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trainer._run_eval_epoch(valid_dl, is_training: <span class="built_in">bool</span> = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><br>参数是</p><ul><li><code>valid_dl</code>，即验证集或测试集的数据加载器。</li><li><code>is_training</code>：指定该评估是否是训练过程的一部分，即可以是训练过程中对验证集的评估，也可以是训练结束后在测试集上的评估。</li></ul><h1 id="记录指标"><a href="#记录指标" class="headerlink" title="记录指标"></a>记录指标</h1><p><code>Trainer</code>包含一个<code>RunHistory</code>的实例，它可以用来存储和获得训练期间要跟踪的任何指标的值。默认情况下，<code>Trainer</code>记录的唯一指标是训练和验证期间观察到的损失。<br>注意：如果使用了<code>PrintMetricsCallback</code>回调，那么运行历史中记录的所有指标将被自动打印到控制台。<br><code>RunHistory</code>的<code>API</code>稍后会详细分析。<br>下面是一个例子，说明如何对<code>Trainer</code>进行子类化，并使用<code>RunHistory</code>来跟踪用<code>TorchMetrics</code>计算的指标：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torchmetrics <span class="keyword">import</span> MetricCollection, Accuracy, Precision, Recall</span><br><span class="line"><span class="keyword">from</span> pytorch_accelerated <span class="keyword">import</span> Trainer</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrainerWithMetrics</span>(<span class="params">Trainer</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_classes, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># this will be moved to the correct device automatically by the</span></span><br><span class="line">        <span class="comment"># MoveModulesToDeviceCallback callback, which is used by default</span></span><br><span class="line">        self.metrics = MetricCollection(</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;accuracy&quot;</span>: Accuracy(num_classes=num_classes),</span><br><span class="line">                <span class="string">&quot;precision&quot;</span>: Precision(num_classes=num_classes),</span><br><span class="line">                <span class="string">&quot;recall&quot;</span>: Recall(num_classes=num_classes),</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate_eval_batch_loss</span>(<span class="params">self, batch</span>):</span></span><br><span class="line">        batch_output = <span class="built_in">super</span>().calculate_eval_batch_loss(batch)</span><br><span class="line">        preds = batch_output[<span class="string">&quot;model_outputs&quot;</span>].argmax(dim=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        self.metrics.update(preds, batch[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> batch_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eval_epoch_end</span>(<span class="params">self</span>):</span></span><br><span class="line">        metrics = self.metrics.compute()</span><br><span class="line">        self.run_history.update_metric(<span class="string">&quot;accuracy&quot;</span>, metrics[<span class="string">&quot;accuracy&quot;</span>].cpu())</span><br><span class="line">        self.run_history.update_metric(<span class="string">&quot;precision&quot;</span>, metrics[<span class="string">&quot;precision&quot;</span>].cpu())</span><br><span class="line">        self.run_history.update_metric(<span class="string">&quot;recall&quot;</span>, metrics[<span class="string">&quot;recall&quot;</span>].cpu())</span><br><span class="line"></span><br><span class="line">        self.metrics.reset()</span><br></pre></td></tr></table></figure></p><h1 id="Trainer运行过程"><a href="#Trainer运行过程" class="headerlink" title="Trainer运行过程"></a>Trainer运行过程</h1><p><code>Trainer</code>内部到底干了啥？用伪代码的话，是这样表达：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">train_dl = create_train_dataloader()</span><br><span class="line">eval_dl = create_eval_dataloader()</span><br><span class="line">scheduler = create_scheduler()</span><br><span class="line"></span><br><span class="line">training_run_start()</span><br><span class="line">on_training_run_start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> num_epochs:</span><br><span class="line">    train_epoch_start()</span><br><span class="line">    on_train_epoch_start()</span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> train_dl:</span><br><span class="line">        on_train_step_start()</span><br><span class="line">        batch_output = calculate_train_batch_loss(batch)</span><br><span class="line">        on_train_step_end(batch, batch_output)</span><br><span class="line">        backward_step(batch_output[<span class="string">&quot;loss&quot;</span>])</span><br><span class="line">        optimizer_step()</span><br><span class="line">        scheduler_step()</span><br><span class="line">        optimizer_zero_grad()</span><br><span class="line">    train_epoch_end()</span><br><span class="line">    on_train_epoch_end()</span><br><span class="line"></span><br><span class="line">    eval_epoch_start()</span><br><span class="line">    on_eval_epoch_start()</span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> eval_dl:</span><br><span class="line">        on_eval_step_start()</span><br><span class="line">        batch_output = calculate_eval_batch_loss(batch)</span><br><span class="line">        on_eval_step_end(batch, batch_output)</span><br><span class="line">    eval_epoch_end()</span><br><span class="line">    on_eval_epoch_end()</span><br><span class="line"></span><br><span class="line">    training_run_epoch_end()</span><br><span class="line">    on_training_run_epoch_end()</span><br><span class="line"></span><br><span class="line">training_run_end()</span><br><span class="line">on_training_run_end()</span><br></pre></td></tr></table></figure></p><p>同样地，一个评估过程的表达可以这样表示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">eval_dl = create_eval_dataloader()</span><br><span class="line"></span><br><span class="line">evaluation_run_start()</span><br><span class="line">on_evaluation_run_start()</span><br><span class="line"></span><br><span class="line">eval_epoch_start()</span><br><span class="line">on_eval_epoch_start()</span><br><span class="line"><span class="keyword">for</span> batch <span class="keyword">in</span> eval_dl:</span><br><span class="line">    on_eval_step_start()</span><br><span class="line">    batch_output = calculate_eval_batch_loss(batch)</span><br><span class="line">    on_eval_step_end(batch, batch_output)</span><br><span class="line">eval_epoch_end()</span><br><span class="line">on_eval_epoch_end()</span><br><span class="line"></span><br><span class="line">evaluation_run_end()</span><br><span class="line">on_evaluation_run_end()</span><br></pre></td></tr></table></figure><br>了解<code>Trainer</code>内部如何工作的最好方法是查阅<code>train()</code>方法的源代码；为了使内部方法尽可能的干净和清晰，作者们做了大量的工作。</p>]]></content>
    
    
    <summary type="html">简介
从这一节开始，详细看一下pytorch-accelerated的API。
本文是对Trainer的API的解析。

Trainer概览
训练器Trainer用来封装特定任务的整个训练循环，将模型、损失函数和优化器结合在一起，并为训练过程的每一步提供执行行为规范。
Trainer的实现是这样的：它提供了训练部分的（可重复的）实现，这些部分在被定义后很少发生变化——比如创建数据加载器，或如何将一批数据送入模型——同时与可能发生变化的部分保持解耦，比如模型、数据集、损失函数和优化器。
1
2
3
4
5
6
7
8
9


class Trainer:
    def __init__(
  </summary>
    
    
    
    <category term="machine learning" scheme="http://qixinbo.github.io/categories/machine-learning/"/>
    
    
    <category term="PyTorch" scheme="http://qixinbo.github.io/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>轻量级PyTorch通用训练模板pytorch-accelerated解析：0 -- 介绍及入门</title>
    <link href="http://qixinbo.github.io/2022/05/28/pytorch-accelerated_0/"/>
    <id>http://qixinbo.github.io/2022/05/28/pytorch-accelerated_0/</id>
    <published>2022-05-27T16:00:00.000Z</published>
    <updated>2022-06-22T15:17:40.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><a href="https://github.com/Chris-hughes10/pytorch-accelerated"><code>pytorch-accelerated</code></a>是一个轻量级的库，旨在通过提供一个最小但可扩展的训练循环（封装在一个<code>Trainer</code>对象中）来加速<code>PyTorch</code>模型的训练过程；它足够灵活，可以处理大多数用例，并且能够利用不同的硬件选项而不需要修改代码。更多介绍见原作者的<a href="https://towardsdatascience.com/introducing-pytorch-accelerated-6ba99530608c">博文</a>。<br><code>pytorch-accelerated</code>最大的两个特点就是：简单<code>simplicity</code>和透明<code>transparency</code>。怎么理解这两个词呢（个人理解）：<br>（1）简单体现在它是一套可复用的<code>PyTorch</code>的训练代码，每次有新模型和新场景需要训练时不必将原来的代码拷过来拷过去，<code>pytorch-accelerated</code>提供了一套通用但不失灵活性的代码模板；<br>（2）透明体现在它基于纯正的<code>PyTorch</code>语法和<code>API</code>，而不是对<code>PyTorch</code>进行过度封装（此处<code>PyTorch Lightning</code>中枪），否则用户会感觉新学习了一套框架和语法。<br>这里可以再扩展说一下，作者的<a href="https://towardsdatascience.com/introducing-pytorch-accelerated-6ba99530608c">介绍博文</a>后有一条评论：“这个库与<code>PyTorch Lighting</code>对比怎么样，我已经用了<code>Lightning</code>，为啥要用这个库呢？”作者给出了一个长长的回答，解释得挺清晰的：</p><blockquote><p>我使用<code>Lightning</code>很长时间了，但越来越觉得我花在理解和调试<code>Lightning</code>上的时间比花在任务上的时间多。这在一开始可能很简单，但由于选项和指标太多，我发现自己花了很多时间阅读文档，并发现源代码对我来说并不容易一目了然。<br>另外，从一开始我就发现，<code>Lightning</code>的设计，即模型和训练循环绑在一起，并不适合我想为同一个任务轻松切换不同的模型和优化器的场景；我个人更喜欢训练循环与模型分开。这意味着模型仍然是纯正的<code>PyTorch</code>；我可以插入其他库的模型，如<code>timm</code>，而不需要做任何修改，也不需要在部署时有任何额外的依赖。<br>从本质上讲，我想要一个简单易懂、易于调试的库，同时保持足够的灵活性以满足我的需要；学习曲线足够浅，我可以把它介绍给其他人，他们也可以很快上手。根据我自己的要求，我创建了PyTorch-accelerated。它在简单的情况下开箱即用，而且很容易定制行为的任何部分。</p></blockquote><p>再再扩展说一下，对于<code>PyTorch Lightning</code>，知乎上有很多真香帖（比如<a href="https://zhuanlan.zhihu.com/p/353985363">1</a>、<a href="https://zhuanlan.zhihu.com/p/157742258">2</a>），也有很多劝退帖（比如<a href="https://zhuanlan.zhihu.com/p/492703063">1</a>、<a href="https://zhuanlan.zhihu.com/p/363045412">2</a>（这篇虽然从标题和全文上看是“真香”，实则在文章最后和评论中作者表示弃坑了，采用了原生的<code>PyTorch</code>））。个人感觉采用<code>PyTorch Lightning</code>有两个很大的弊端（严格来说其实是一个）：<br>（1）与原生<code>PyTorch</code>相比，<code>PyTorch Lightning</code>进行了过度封装，感觉像是在学习另一个框架；<br>（2）假设使用<code>PyTorch Lightning</code>编写代码，如果是个人使用还好，但如果是一个团队共同维护代码，很难说服别人也采用该写法。<br>于是，本文的主角<code>pytorch-accelerated</code>就有了用武之地。</p><h2 id="目标用户"><a href="#目标用户" class="headerlink" title="目标用户"></a>目标用户</h2><p>什么类型的用户/开发者可以尝试使用<code>pytorch-accelerated</code>呢：<br>（1）熟悉PyTorch的用户，但希望避免编写常见的训练循环模板，以专注于其他更重要的部分。<br>（2）喜欢并乐于选择和创建自己的模型、损失函数、优化器和数据集的用户。<br>（3）喜欢简单但高效的功能的用户，这些功能的行为需要很容易调试、理解和推理（<code>PyTorch Lightning</code>：你报我身份证得了）。</p><p>另一方面，<code>pytorch-accelerated</code>不适合什么类型的用户/开发者呢？<br>（1）如果你正在寻找一个端到端的解决方案，包括从加载数据到推理的所有内容，该方案帮助你选择模型、优化器或损失函数，此时可能更适合使用<a href="https://github.com/fastai/fastai">fastai</a>。 <code>pytorch-accelerated</code>只关注训练过程，其他所有问题都由用户负责。<br>（2）如果你想自己编写整个训练循环，但是不想涉及恼人的设备管理问题（比如多机多卡并行），你可能最适合使用<code>Hugging Face</code>的<a href="https://github.com/huggingface/accelerate"><code>accelerate</code></a>！ <code>accelerate</code>专注于将<code>PyTorch</code>的分布式训练和混合精度训练变得简单，不过整个训练循环得自己写。<br>（3）如果你正在研究一个定制的、高度复杂的、不符合通常训练循环模式的用例，并且想在你选择的硬件上挤出每一点性能，你可能最好坚持使用原生<code>PyTorch</code>；在高度专业化的情况下，任何高级<code>API</code>都会成为一种开销。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>（注意提前安装好<code>pytorch</code>）<br>使用<code>pip</code>安装：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pytorch-accelerated</span><br></pre></td></tr></table></figure><br>其实看<code>pytorch-accelerated</code>的<code>requirements.txt</code>，它只依赖于<code>Hugging Face</code>的<code>accelerate</code>库及<code>tqdm</code>（在终端下显示进度条），因此可以说是它的<code>API</code>就是<code>PyTorch</code>的原生<code>API</code>加上<code>accelerate</code>的分布式训练的<code>API</code>。</p><h2 id="accelerate库"><a href="#accelerate库" class="headerlink" title="accelerate库"></a>accelerate库</h2><p><code>Hugging Face</code>的<code>🤗accelerate</code>库（<a href="https://github.com/huggingface/accelerate">地址</a>），可以无痛地对<code>Pytorch</code>进行多<code>GPU</code>、<code>TPU</code>、<a href="https://zhuanlan.zhihu.com/p/103685761">混合精度训练</a>。见<a href="https://mp.weixin.qq.com/s/ST0mWd4E7ZxMMl04_yTKzA">机器之心的报道</a>。</p><blockquote><p>多数 PyTorch 高级库都支持分布式训练和混合精度训练，但是它们引入的抽象化往往需要用户学习新的 API 来定制训练循环。许多 PyTorch 用户希望完全控制自己的训练循环，但不想编写和维护训练所需的复杂的样板代码。Hugging Face 最近发布的新库 Accelerate 解决了这个问题。<br><code>🤗accelerate</code>提供了一个简单的<code>API</code>，将与多<code>GPU</code>、<code>TPU</code>、<code>fp16</code>相关的样板代码抽离了出来，保持其余代码不变。<code>PyTorch</code>用户无须使用不便控制和调整的抽象类或编写、维护样板代码，就可以直接上手多<code>GPU</code>或<code>TPU</code>。</p></blockquote><p><code>🤗accelerate</code>库有两大特点：<br>（1）提供了一套简单的<code>API</code>来处理分布式训练和混合精度训练，无需在不同情形下对代码进行大的改动；<br>（2）提供了一个命令行接口工具来快速配置并并行脚本。</p><h2 id="可选"><a href="#可选" class="headerlink" title="可选"></a>可选</h2><p>如果是想为了直接运行<code>pytorch-accelerated</code>提供的<code>examples</code>，则可以这样安装<a href="https://stackoverflow.com/questions/46775346/what-do-square-brackets-mean-in-pip-install">其他所依赖的包</a>：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pytorch-accelerated[examples]</span><br></pre></td></tr></table></figure></p><h1 id="配置和运行"><a href="#配置和运行" class="headerlink" title="配置和运行"></a>配置和运行</h1><p>可以使用<code>🤗accelerate</code>的<code>CLI</code>工具来生成配置文件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accelerate config --config_file accelerate_config.yaml</span><br></pre></td></tr></table></figure><br>然后运行：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accelerate launch --config_file accelerate_config.yaml train.py [--training-args]</span><br></pre></td></tr></table></figure><br>值得注意的是，也不是必须要用<code>CLI</code>工具。如果想更精细地控制启动命令和参数，仍然可以通过通常的方式来运行脚本：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train.py / python -m torch.distributed ...</span><br></pre></td></tr></table></figure></p><h1 id="MNIST例子"><a href="#MNIST例子" class="headerlink" title="MNIST例子"></a>MNIST例子</h1><p><code>MNIST</code>手写字符分类可以说是深度学习领域的<code>Hello World</code>。<br>这一节将以<code>MNIST</code>来看看<code>pytorch-accelerated</code>是怎么使用的。</p><h2 id="数据和模型准备"><a href="#数据和模型准备" class="headerlink" title="数据和模型准备"></a>数据和模型准备</h2><p>因为<code>pytorch-accelerated</code>专注于训练模型部分，因此数据的加载和模型的构建、配置都是使用的原生的<code>PyTorch</code>的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># examples/train_mnist.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn, optim</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> random_split</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> torchvision.datasets <span class="keyword">import</span> MNIST</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据集</span></span><br><span class="line">dataset = MNIST(os.getcwd(), download=<span class="literal">True</span>, transform=transforms.ToTensor())</span><br><span class="line"><span class="comment"># 拆分数据集</span></span><br><span class="line">train_dataset, validation_dataset, test_dataset = random_split(dataset, [<span class="number">50000</span>, <span class="number">5000</span>, <span class="number">5000</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义神经网络模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MNISTModel</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.main = nn.Sequential(</span><br><span class="line">            nn.Linear(in_features=<span class="number">784</span>, out_features=<span class="number">128</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(in_features=<span class="number">128</span>, out_features=<span class="number">64</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(in_features=<span class="number">64</span>, out_features=<span class="number">10</span>),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.main(<span class="built_in">input</span>.view(<span class="built_in">input</span>.shape[<span class="number">0</span>], -<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化模型</span></span><br><span class="line">model = MNISTModel()</span><br><span class="line"><span class="comment"># 定义优化器</span></span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line"><span class="comment"># 定义损失函数</span></span><br><span class="line">loss_func = nn.CrossEntropyLoss()</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="训练循环"><a href="#训练循环" class="headerlink" title="训练循环"></a>训练循环</h2><p>加载了模型和数据后，下一步就是编写训练循环。<br>这里就是<code>pytorch-accelerated</code>的用武之地，唯一要做的就是导入<code>Trainer</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pytorch_accelerated <span class="keyword">import</span> Trainer</span><br><span class="line"></span><br><span class="line"><span class="comment"># Trainer被设计成用来封装一个完整的训练循环</span></span><br><span class="line"><span class="comment"># 将模型、损失函数和优化器都传入Trainer中</span></span><br><span class="line">trainer = Trainer(</span><br><span class="line">model,</span><br><span class="line">loss_func=loss_func,</span><br><span class="line">optimizer=optimizer,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 入口点是train方法，定义了该怎样训练</span></span><br><span class="line"><span class="comment"># 可以设置训练集、验证集（注意是验证集，不是测试集）、迭代次数、批处理大小</span></span><br><span class="line"><span class="comment"># 还可以设置学习率策略、梯度累加等，这里没有用到</span></span><br><span class="line">trainer.train(</span><br><span class="line">train_dataset=train_dataset,</span><br><span class="line">eval_dataset=validation_dataset,</span><br><span class="line">num_epochs=<span class="number">8</span>,</span><br><span class="line">per_device_batch_size=<span class="number">32</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 评估模型</span></span><br><span class="line">trainer.evaluate(</span><br><span class="line">dataset=test_dataset,</span><br><span class="line">per_device_batch_size=<span class="number">64</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><h3 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accelerate config --config_file train_mnist.yaml</span><br></pre></td></tr></table></figure><h3 id="开始训练"><a href="#开始训练" class="headerlink" title="开始训练"></a>开始训练</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accelerate launch --config_file train_mnist.yaml train_mnist.py</span><br></pre></td></tr></table></figure><h2 id="增加指标"><a href="#增加指标" class="headerlink" title="增加指标"></a>增加指标</h2><p>上述例子中追踪的指标仅仅是每次迭代的损失<code>loss</code>，为了对训练结果有更深入的洞察，可以增加更多的指标。<br>对于指标的计算，这里引入了<a href="https://github.com/Lightning-AI/metrics"><code>torchmetrics</code></a>（发现这个库还是<code>PyTorch-Lightning</code>社区开发的，这波<code>PyTorch-Lightning</code>被人摘桃了，血亏🤗），该库兼容分布式训练，因此就不需要手动从不同进程中聚合计算结果。<br>计算指标有两种方式：<br>（1）定义一个继承自<code>Trainer</code>的子类，<br>（2）使用回调<code>callback</code>。<br>具体使用哪种方式极大地取决于用户的喜好。<br>不过作者有如下建议：因为计算指标实际上是不能影响训练代码的，因此使用<code>callback</code>可能是一个好的方式，因为使用<code>Trainer</code>子类的话，它也会间接地参与训练过程。不过还是具体情况具体分析。注意，因为<code>callbacks</code>都是顺序执行的，必须保证在打印指标之前就调用这些回调。<br>下面是对比这两种实现方式。</p><h3 id="使用Trainer子类"><a href="#使用Trainer子类" class="headerlink" title="使用Trainer子类"></a>使用Trainer子类</h3><p><code>Trainer</code>有很多方法可以被重载，具体的文档在<a href="https://pytorch-accelerated.readthedocs.io/en/latest/trainer.html#customizing-trainer-behaviour">这里</a>。主要的一个特点是有动词前缀（比如<code>create</code>和<code>calculate</code>）的方法都是期望能返回一个数值，其他的方法（比如<code>optimizer.step()</code>）则是用来设置内部状态。<br>示例代码为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Copyright © 2021 Chris Hughes</span></span><br><span class="line"><span class="comment">########################################################################</span></span><br><span class="line"><span class="comment"># This example trains a model on the MNIST Dataset</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This example demonstrates how the default trainer class can be overridden</span></span><br><span class="line"><span class="comment"># so that we can record classification metrics</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Note, this example requires installing the torchmetrics package</span></span><br><span class="line"><span class="comment">########################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn, optim</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> random_split</span><br><span class="line"><span class="keyword">from</span> torchmetrics <span class="keyword">import</span> MetricCollection, Accuracy, Precision, Recall</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> torchvision.datasets <span class="keyword">import</span> MNIST</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pytorch_accelerated <span class="keyword">import</span> Trainer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MNISTModel</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.main = nn.Sequential(</span><br><span class="line">            nn.Linear(in_features=<span class="number">784</span>, out_features=<span class="number">128</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(in_features=<span class="number">128</span>, out_features=<span class="number">64</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(in_features=<span class="number">64</span>, out_features=<span class="number">10</span>),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.main(x.view(x.shape[<span class="number">0</span>], -<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrainerWithMetrics</span>(<span class="params">Trainer</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_classes, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># this will be moved to the correct device automatically by the</span></span><br><span class="line">        <span class="comment"># MoveModulesToDeviceCallback callback, which is used by default</span></span><br><span class="line">        self.metrics = MetricCollection(</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;accuracy&quot;</span>: Accuracy(num_classes=num_classes),</span><br><span class="line">                <span class="string">&quot;precision&quot;</span>: Precision(num_classes=num_classes),</span><br><span class="line">                <span class="string">&quot;recall&quot;</span>: Recall(num_classes=num_classes),</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate_eval_batch_loss</span>(<span class="params">self, batch</span>):</span></span><br><span class="line">        batch_output = <span class="built_in">super</span>().calculate_eval_batch_loss(batch)</span><br><span class="line">        preds = batch_output[<span class="string">&quot;model_outputs&quot;</span>].argmax(dim=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        self.metrics.update(preds, batch[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> batch_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eval_epoch_end</span>(<span class="params">self</span>):</span></span><br><span class="line">        metrics = self.metrics.compute()</span><br><span class="line">        self.run_history.update_metric(<span class="string">&quot;accuracy&quot;</span>, metrics[<span class="string">&quot;accuracy&quot;</span>].cpu())</span><br><span class="line">        self.run_history.update_metric(<span class="string">&quot;precision&quot;</span>, metrics[<span class="string">&quot;precision&quot;</span>].cpu())</span><br><span class="line">        self.run_history.update_metric(<span class="string">&quot;recall&quot;</span>, metrics[<span class="string">&quot;recall&quot;</span>].cpu())</span><br><span class="line"></span><br><span class="line">        self.metrics.reset()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    dataset = MNIST(os.getcwd(), download=<span class="literal">True</span>, transform=transforms.ToTensor())</span><br><span class="line">    num_classes = <span class="built_in">len</span>(dataset.class_to_idx)</span><br><span class="line"></span><br><span class="line">    train_dataset, validation_dataset, test_dataset = random_split(</span><br><span class="line">        dataset, [<span class="number">50000</span>, <span class="number">5000</span>, <span class="number">5000</span>]</span><br><span class="line">    )</span><br><span class="line">    model = MNISTModel()</span><br><span class="line">    optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line">    loss_func = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line">    trainer = TrainerWithMetrics(</span><br><span class="line">        model=model, loss_func=loss_func, optimizer=optimizer, num_classes=num_classes</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    trainer.train(</span><br><span class="line">        train_dataset=train_dataset,</span><br><span class="line">        eval_dataset=validation_dataset,</span><br><span class="line">        num_epochs=<span class="number">2</span>,</span><br><span class="line">        per_device_batch_size=<span class="number">32</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    trainer.evaluate(</span><br><span class="line">        dataset=test_dataset,</span><br><span class="line">        per_device_batch_size=<span class="number">64</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p><h3 id="使用回调"><a href="#使用回调" class="headerlink" title="使用回调"></a>使用回调</h3><p>上面的代码可能已经有所显示，对于“增加指标”这种小的微调，如果使用<code>Trainer</code>子类的话会显得有些用力过猛。<br>此例中，可以保持默认的<code>trainer</code>不变，而使用回调来扩展功能。<br>为了创建一个新的回调，需要创建<code>TrainerCallback</code>的子类，然后重载相关方法，文档见<a href="https://pytorch-accelerated.readthedocs.io/en/latest/callbacks.html#creating-new-callbacks">这里</a>。为了避免与<code>Trainer</code>的方法混淆，所有的回调方法都有<code>on_</code>前缀。<br>创建新的回调：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torchmetrics <span class="keyword">import</span> MetricCollection, Accuracy, Precision, Recall</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pytorch_accelerated.callbacks <span class="keyword">import</span> TrainerCallback</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassificationMetricsCallback</span>(<span class="params">TrainerCallback</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_classes</span>):</span></span><br><span class="line">        self.metrics = MetricCollection(</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;accuracy&quot;</span>: Accuracy(num_classes=num_classes),</span><br><span class="line">                <span class="string">&quot;precision&quot;</span>: Precision(num_classes=num_classes),</span><br><span class="line">                <span class="string">&quot;recall&quot;</span>: Recall(num_classes=num_classes),</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_move_to_device</span>(<span class="params">self, trainer</span>):</span></span><br><span class="line">        self.metrics.to(trainer.device)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_training_run_start</span>(<span class="params">self, trainer, **kwargs</span>):</span></span><br><span class="line">        self._move_to_device(trainer)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_evaluation_run_start</span>(<span class="params">self, trainer, **kwargs</span>):</span></span><br><span class="line">        self._move_to_device(trainer)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_eval_step_end</span>(<span class="params">self, trainer, batch, batch_output, **kwargs</span>):</span></span><br><span class="line">        preds = batch_output[<span class="string">&quot;model_outputs&quot;</span>].argmax(dim=-<span class="number">1</span>)</span><br><span class="line">        self.metrics.update(preds, batch[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_eval_epoch_end</span>(<span class="params">self, trainer, **kwargs</span>):</span></span><br><span class="line">        metrics = self.metrics.compute()</span><br><span class="line">        trainer.run_history.update_metric(<span class="string">&quot;accuracy&quot;</span>, metrics[<span class="string">&quot;accuracy&quot;</span>].cpu())</span><br><span class="line">        trainer.run_history.update_metric(<span class="string">&quot;precision&quot;</span>, metrics[<span class="string">&quot;precision&quot;</span>].cpu())</span><br><span class="line">        trainer.run_history.update_metric(<span class="string">&quot;recall&quot;</span>, metrics[<span class="string">&quot;recall&quot;</span>].cpu())</span><br><span class="line"></span><br><span class="line">        self.metrics.reset()</span><br></pre></td></tr></table></figure><br>需要注意的一点是，在训练或验证之前，需要手动地将指标移动到正确地设备上。不过<code>Trainer</code>已经将这一步做了非常简单的处理，可以依据上下文返回正确的设备，即：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pytorch_accelerated.trainer <span class="keyword">import</span> DEFAULT_CALLBACKS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将自定义的回调传入Trainer</span></span><br><span class="line"><span class="comment"># 因为想保持默认行为，所以将自定义的回调放在所有的默认回调之前。</span></span><br><span class="line">trainer = Trainer(</span><br><span class="line">model,</span><br><span class="line">loss_func=loss_func,</span><br><span class="line">optimizer=optimizer,</span><br><span class="line">callbacks=(</span><br><span class="line">ClassificationMetricsCallback(</span><br><span class="line">num_classes=num_classes,</span><br><span class="line">),</span><br><span class="line">*DEFAULT_CALLBACKS,</span><br><span class="line">),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>然后将上面代码复制进入最开始的代码中即可，无需变动其他地方的代码（只是需要在创建数据集后，计算一下其分类数目以传入回调<code>num_classes = len(dataset.class_to_idx)</code>）。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>实际只从这个<code>MNIST</code>例子还不能看出<code>pytorch-accelerated</code>能在多大程度上提高效率，后面需要多研究一下它的例子，毕竟<code>通用模板</code>的意义在于能适用于多种情形。留坑待填。</p>]]></content>
    
    
    <summary type="html">介绍
pytorch-accelerated是一个轻量级的库，旨在通过提供一个最小但可扩展的训练循环（封装在一个Trainer对象中）来加速PyTorch模型的训练过程；它足够灵活，可以处理大多数用例，并且能够利用不同的硬件选项而不需要修改代码。更多介绍见原作者的博文。
pytorch-accelerated最大的两个特点就是：简单simplicity和透明transparency。怎么理解这两个词呢（个人理解）：
（1）简单体现在它是一套可复用的PyTorch的训练代码，每次有新模型和新场景需要训练时不必将原来的代码拷过来拷过去，pytorch-accelerated提供了一套通用但不失灵活</summary>
    
    
    
    <category term="machine learning" scheme="http://qixinbo.github.io/categories/machine-learning/"/>
    
    
    <category term="PyTorch" scheme="http://qixinbo.github.io/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>开源深度学习计算平台ImJoy解析：13 -- Kaibu应用</title>
    <link href="http://qixinbo.github.io/2022/05/22/ImJoy_13/"/>
    <id>http://qixinbo.github.io/2022/05/22/ImJoy_13/</id>
    <published>2022-05-21T16:00:00.000Z</published>
    <updated>2022-05-23T03:17:06.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>ImJoy有一个很有用的插件或独立应用，叫做<a href="https://kaibu.org/">Kaibu</a>，它可以展示并标注普通的位图、矢量图及vtk、stl等3D格式的数据。<br>比如如下展示：<br><img src="https://user-images.githubusercontent.com/6218739/158537518-a3583f3e-4b06-494b-928a-3904f6b29fb2.png" alt="kaibu"><br>其就是位图（png格式）、矢量图（json格式）、3D模型（stl格式）的一个叠加。</p><p>Kaibu主要用了两个JS库，一个是<a href="https://openlayers.org/">OpenLayers</a>，一个是<a href="https://kitware.github.io/itk-vtk-viewer/docs/">ITK-VTK</a>，前者用于展示矢量图形、普通位图等数据，且对地图的展示异常强大，后者用于展示在医疗及科学计算中常用的3D图像、网格、点集等。</p><p>这一篇主要分析一下Kaibu的运行机理。</p><p>从script标签开始，看其运行过程。</p><h1 id="导入组件"><a href="#导入组件" class="headerlink" title="导入组件"></a>导入组件</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> layerComponents <span class="keyword">from</span> <span class="string">&quot;@/components/layers&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> widgetComponents <span class="keyword">from</span> <span class="string">&quot;@/components/widgets&quot;</span>;</span><br></pre></td></tr></table></figure><p>导入自定义的各种layers和widgets。<br>这里的layers即是Kaibu能承载的数据类型，其概念就是“图层”的含义，即不同类型的图层叠加起来，就能展示复杂的图像。具体有2D图像层ImageLayer、矢量层VectorLayer和3D模型层ItkVtkLayer。<br>这里的widgets即是Kaibu自定义的各种控件，比如树形控件TreeWidget、表单控件FormWidget、列表控件ListWidget等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> components = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> layerTypes = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">in</span> layerComponents) &#123;</span><br><span class="line">  components[layerComponents[c].name] = layerComponents[c];</span><br><span class="line">  layerTypes[layerComponents[c].type] = layerComponents[c];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;components = &#x27;</span>, components)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;layerTypes = &#x27;</span>, layerTypes)</span><br></pre></td></tr></table></figure><p>将不同的layers根据name和type分别提取到两个变量中，即components存储了以layer名称为键的图层组件，layerTypes中存储了以layer类型为键的图层组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> widgetTypes = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">in</span> widgetComponents) &#123;</span><br><span class="line">  components[widgetComponents[c].name] = widgetComponents[c];</span><br><span class="line">  widgetTypes[widgetComponents[c].type] = widgetComponents[c];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;components = &#x27;</span>, components)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;widgetTypes = &#x27;</span>, widgetTypes)</span><br></pre></td></tr></table></figure><p>将不同的widgets根据name和type分别提取到两个变量中，即之前的components中又接收了以widgets名称为键的控件组件，widgetTypes则存储了以widget类型为键的控件组件。</p><h1 id="挂载生命周期钩子"><a href="#挂载生命周期钩子" class="headerlink" title="挂载生命周期钩子"></a>挂载生命周期钩子</h1><p>Kaibu定义了很多计算属性和方法，可以先从mounted挂载这一生命周期钩子看其怎么调用的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.init();</span><br><span class="line">  <span class="built_in">this</span>.sortableOptions.layer_configs = <span class="built_in">this</span>.layer_configs;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, <span class="built_in">this</span>.updateSize);</span><br><span class="line">  <span class="built_in">window</span>.dispatchEvent(<span class="keyword">new</span> Event(<span class="string">&quot;resize&quot;</span>));</span><br><span class="line">  <span class="built_in">this</span>.openSidebar(<span class="literal">true</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><br>可以看出，挂载后第一步是初始化，它也是最重要的一步。下面对这一步进行详细的解析。</p><h2 id="创建Map"><a href="#创建Map" class="headerlink" title="创建Map"></a>创建Map</h2><p>因为Kaibu用的是OpenLayers进行渲染，因此首先创建一个OpenLayers的Map实例对象是至关重要的，即它作为画布。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> extent = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1024</span>, <span class="number">968</span>];</span><br><span class="line"><span class="keyword">const</span> projection = <span class="keyword">new</span> Projection(&#123;</span><br><span class="line">  code: <span class="string">&quot;xkcd-image&quot;</span>,</span><br><span class="line">  units: <span class="string">&quot;pixels&quot;</span>,</span><br><span class="line">  extent: extent</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(&#123;</span><br><span class="line">  interactions: defaults(&#123;</span><br><span class="line">    altShiftDragRotate: <span class="literal">false</span>,</span><br><span class="line">    pinchRotate: <span class="literal">false</span></span><br><span class="line">  &#125;),</span><br><span class="line">  target: <span class="string">&quot;map&quot;</span>,  <span class="comment">// 这里就是与template里id为map的div标签进行绑定</span></span><br><span class="line">  layers: [],</span><br><span class="line">  view: <span class="keyword">new</span> View(&#123;</span><br><span class="line">    projection: projection,</span><br><span class="line">    center: getCenter(extent),</span><br><span class="line">    zoom: <span class="number">2</span>,</span><br><span class="line">    maxZoom: <span class="number">8</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">this</span>.$store.commit(<span class="string">&quot;setMap&quot;</span>, map);</span><br></pre></td></tr></table></figure><br>这样新建了一个Map实例对象map，并且传给了vuex状态管理器。</p><h2 id="添加图层事件"><a href="#添加图层事件" class="headerlink" title="添加图层事件"></a>添加图层事件</h2><p>接下来就是添加具体的图层。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="built_in">this</span>.addLayer(&#123;</span><br><span class="line">  type: <span class="string">&quot;vector&quot;</span>,</span><br><span class="line">  name: <span class="string">&quot;shape vectors&quot;</span>,</span><br><span class="line">  data:</span><br><span class="line">    <span class="string">&quot;https://gist.githubusercontent.com/oeway/7c62128939a7f9b1701e2bbd72b809dc/raw/example_shape_vectors.json&quot;</span>,</span><br><span class="line">  predefined_tags: [<span class="string">&quot;nuclei&quot;</span>, <span class="string">&quot;cell&quot;</span>],</span><br><span class="line">  only_predefined_tags: <span class="literal">true</span>,</span><br><span class="line">  single_tag_mode: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>如上就是增加Vector图层的代码。它调用了addLayer这个方法，明显地，它接收上面的配置对象作为参数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">addLayer</span>(<span class="params">config</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    config.id = randId(); <span class="comment">// 对配置对象添加id属性</span></span><br><span class="line">    <span class="built_in">this</span>.$store.dispatch(<span class="string">&quot;addLayer&quot;</span>, config); <span class="comment">// 触发vuex共享状态</span></span><br><span class="line">    config._add_layer_promise = &#123; resolve, reject &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><br>可以看出，它首先对上面接收的配置对象config添加了一个随机的id，然后触发vuex共享状态的addLayer这个action（Vuex通过Vue的插件系统将store实例从根组件中“注入”到所有的子组件里。且子组件能通过<code>this.$store</code>访问到）。<br>详细看一下共享状态的这些事件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    layers: &#123;&#125;,</span><br><span class="line">    widgets: &#123;&#125;,</span><br><span class="line">    layer_configs: [],</span><br><span class="line">    currentLayer: <span class="literal">null</span>,</span><br><span class="line">    currentLayerWidget: <span class="literal">null</span>,</span><br><span class="line">    standaloneWidgets: &#123;&#125;,</span><br><span class="line">    map: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    <span class="function"><span class="title">addLayer</span>(<span class="params">context, config</span>)</span> &#123;</span><br><span class="line">      context.commit(<span class="string">&quot;addLayer&quot;</span>, config);</span><br><span class="line">      Vue.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (config.init) &#123;</span><br><span class="line">          config</span><br><span class="line">            .init()</span><br><span class="line">            .then(<span class="function"><span class="params">layer</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (!layer) &#123;</span><br><span class="line">                <span class="keyword">if</span> (config._add_layer_promise) &#123;</span><br><span class="line">                  config._add_layer_promise.reject(</span><br><span class="line">                    <span class="string">&quot;Failed to create layer for &quot;</span> + config.name</span><br><span class="line">                  );</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              layer.config = config;</span><br><span class="line">              layer.setVisible(config.visible);</span><br><span class="line">              layer.getLayerAPI = layer.getLayerAPI || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">              context.commit(<span class="string">&quot;initialized&quot;</span>, layer);</span><br><span class="line">              context.commit(<span class="string">&quot;setCurrentLayer&quot;</span>, layer.config);</span><br><span class="line">              context.commit(<span class="string">&quot;sortLayers&quot;</span>);</span><br><span class="line">              <span class="keyword">if</span> (config._add_layer_promise) &#123;</span><br><span class="line">                config._add_layer_promise.resolve(layer);</span><br><span class="line">                <span class="keyword">delete</span> config._add_layer_promise;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (config._add_layer_promise) &#123;</span><br><span class="line">                config._add_layer_promise.reject(e);</span><br><span class="line">                <span class="keyword">delete</span> config._add_layer_promise;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(e);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">debugger</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="function"><span class="title">addLayer</span>(<span class="params">state, config</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (config.visible === <span class="literal">undefined</span>) config.visible = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> config.index === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> index = config.index;</span><br><span class="line">        state.layer_configs.splice(index, <span class="number">0</span>, config);</span><br><span class="line">        <span class="keyword">delete</span> config.index;</span><br><span class="line">      &#125; <span class="keyword">else</span> state.layer_configs.push(config);</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><br>即，上面通过dispatch触发addLayer这个action后，在该action里又通过commit触发了addLayer这个mutation。在这个mutation中，会将配置对象config推入共享状态state的<code>layer_configs</code>属性中。<br>接下来就是非常tricky的一个操作。<br>先看store的action的这段：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">addLayer</span>(<span class="params">context, config</span>)</span> &#123;</span><br><span class="line">  context.commit(<span class="string">&quot;addLayer&quot;</span>, config);</span><br><span class="line">  Vue.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (config.init) &#123;</span><br><span class="line">      config</span><br><span class="line">        .init()</span><br></pre></td></tr></table></figure><br>如上所述，这个addLayer会通过commit触发mutations中的addLayer，从而对state的<code>layer_configs</code>属性进行更新。注意，此时的config还是非常普通的配置对象，就是上面的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: <span class="string">&quot;vector&quot;</span>,</span><br><span class="line">  name: <span class="string">&quot;shape vectors&quot;</span>,</span><br><span class="line">  data:</span><br><span class="line">    <span class="string">&quot;https://gist.githubusercontent.com/oeway/7c62128939a7f9b1701e2bbd72b809dc/raw/example_shape_vectors.json&quot;</span>,</span><br><span class="line">  predefined_tags: [<span class="string">&quot;nuclei&quot;</span>, <span class="string">&quot;cell&quot;</span>],</span><br><span class="line">  only_predefined_tags: <span class="literal">true</span>,</span><br><span class="line">  single_tag_mode: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但是，接下来<code>Vue.nextTick()</code>一执行后，该config就会根据添加的layer的不同，变成特有的config，如下所示：<br><img src="https://user-images.githubusercontent.com/6218739/163119092-4e401f8a-aac1-44cb-8912-6bafb11115dc.png" alt="config"></p><p>这是为什么呢？<br>经过一番仔细的定位，发现奥妙如下，非常巧妙（同时好难懂。。。）。<br>前面已经说了，在mutations中会对<code>state.layer_configs</code>进行更新，而在Kaibu的主组件ImageViewer里有该状态的映射，因此组件的<code>layer_configs</code>也会有更新：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...mapState(&#123;</span><br><span class="line">  layers: <span class="function"><span class="params">state</span> =&gt;</span> state.layers,</span><br><span class="line">  layer_configs: <span class="function"><span class="params">state</span> =&gt;</span> state.layer_configs,</span><br><span class="line">  standaloneWidgets: <span class="function"><span class="params">state</span> =&gt;</span> state.standaloneWidgets,</span><br><span class="line">  currentLayer: <span class="function"><span class="params">state</span> =&gt;</span> state.currentLayer,</span><br><span class="line">  currentLayerWidget: <span class="function"><span class="params">state</span> =&gt;</span> state.currentLayerWidget,</span><br><span class="line">  map: <span class="function"><span class="params">state</span> =&gt;</span> state.map</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>而该计算属性的更新会引起组件的模板中如下部分的变化：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;b-menu-list label=<span class="string">&quot;Properties&quot;</span>&gt;</span><br><span class="line">  &lt;component</span><br><span class="line">    v-<span class="keyword">for</span>=<span class="string">&quot;layer in layer_configs&quot;</span></span><br><span class="line">    v-show=<span class="string">&quot;currentLayer === layer&quot;</span></span><br><span class="line">    @update-extent=<span class="string">&quot;updateExtent&quot;</span></span><br><span class="line">    :ref=<span class="string">&quot;&#x27;layer_&#x27; + layer.id&quot;</span></span><br><span class="line">    :key=<span class="string">&quot;layer.id&quot;</span></span><br><span class="line">    :is=<span class="string">&quot;layerTypes[layer.type]&quot;</span></span><br><span class="line">    @loading=<span class="string">&quot;loading = $event&quot;</span></span><br><span class="line">    :selected=<span class="string">&quot;layer.selected&quot;</span></span><br><span class="line">    :visible=<span class="string">&quot;layer.visible&quot;</span></span><br><span class="line">    :map=<span class="string">&quot;map&quot;</span></span><br><span class="line">    :config=<span class="string">&quot;layer&quot;</span></span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/b-menu-list&gt;</span><br></pre></td></tr></table></figure><br>这个地方用到了Vue的component标签（标签，注意不是组件），它可以动态绑定组件，即根据不同的数据来显示不同的组件。<br>其通过<code>is</code>的值来确定哪个组件被渲染。<br>一个教程见<a href="https://www.cnblogs.com/yjiangling/p/12794933.html">这里</a>。<br>具体到这个例子中，因为传入的config的type键的值是<code>vector</code>，所以它会找到VectorLayer这个组件（即该文最开始的layerTypes中存储了以layer类型为键的图层组件）。<br>然后将<code>layer_configs</code>中遍历的layer（实际就是上面的config）作为config参数（注意这里是config参数标识）从ImageViewer父组件中传给VectorLayer这个子组件（子组件中会通过props属性进行接收）。换句话说，子组件中的config参数就是父组件传入的layer变量，也就是之前的普通的config对象（因为这个config对象被放入<code>layer_configs</code>中，在遍历时被称为layer）。<br>但是这个地方有一个不合常规的做法，即父组件和子组件通过props传递参数，常规是单向数据流，即子组件不能修改父组件的值。这里明显违背了这一原则，而且Vue没有报错。<br>这是因为config是个对象，而不是诸如字符串、数字等非引用类型数据，所以它不会报错，但也造成了理解的困难。<br>下面这两篇解析很好：<br><a href="https://nekolr.github.io/2020/04/26/Vue%20%E4%B9%8B%E5%9C%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%AD%E6%94%B9%E5%8F%98%E7%88%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E7%8A%B6%E6%80%81/"> Vue 之在子组件中改变父组件的状态 </a><br><a href="https://segmentfault.com/q/1010000008525755">vue2.0中，子组件修改父组件传递过来得props，该怎么解决？</a><br>可以说是，这里正好应用了这一特性，使得可以特定的子组件可以对config有特定的改变。即在子组件中会对这个config属性进行针对性地加工，比如将该组件地<code>init</code>方法传给它：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.config.init = <span class="built_in">this</span>.init;</span><br></pre></td></tr></table></figure></p><p>上面那部分模板更新后，意味着DOM更新了，此时Vue地nextTick执行，那么这时候的config就是“被特定子组件修饰过”的config。</p><h2 id="初始化图层"><a href="#初始化图层" class="headerlink" title="初始化图层"></a>初始化图层</h2><p>前面已说过，config被特定组件修饰后，就有了该组件或该图层的特性，下面就是调用特定组件的初始化方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">      Vue.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (config.init) &#123;</span><br><span class="line">          config</span><br><span class="line">            .init()</span><br><span class="line">            .then(<span class="function"><span class="params">layer</span> =&gt;</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">即`</span>config.init()<span class="string">`方法调用。</span></span><br><span class="line"><span class="string">以上面的VectorLayer这个组件为例，看一下它的初始化方法：</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.layer = <span class="keyword">await</span> <span class="built_in">this</span>.setupLayer();</span><br><span class="line">      <span class="built_in">this</span>.map.addLayer(<span class="built_in">this</span>.layer);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.config.select_enable &amp;&amp; !<span class="built_in">this</span>.config.draw_enable) &#123;</span><br><span class="line">        <span class="built_in">this</span>.enableSelectInteraction();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.updateDrawInteraction();</span><br><span class="line">      <span class="built_in">this</span>.$forceUpdate();</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.layer;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><br>其他组件也大同小异，就是在该组件中进行一系列的操作，最终是返回<code>this.layer</code>这样的特定的对象。</p><h2 id="更新共享状态"><a href="#更新共享状态" class="headerlink" title="更新共享状态"></a>更新共享状态</h2><p>特定组件初始化成功后，就会接着调用<code>then</code>方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Vue.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (config.init) &#123;</span><br><span class="line">    config</span><br><span class="line">      .init()</span><br><span class="line">      .then(<span class="function"><span class="params">layer</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;layer = &#x27;</span>, layer)</span><br><span class="line">        layer.config = config;</span><br><span class="line">        layer.setVisible(config.visible);</span><br><span class="line">        layer.getLayerAPI = layer.getLayerAPI || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">        context.commit(<span class="string">&quot;initialized&quot;</span>, layer);</span><br><span class="line">        context.commit(<span class="string">&quot;setCurrentLayer&quot;</span>, layer.config);</span><br><span class="line">        context.commit(<span class="string">&quot;sortLayers&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (config._add_layer_promise) &#123;</span><br><span class="line">          config._add_layer_promise.resolve(layer);</span><br><span class="line">          <span class="keyword">delete</span> config._add_layer_promise;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure><br>可以看出，会对上一步返回的layer对象进行一些加工后，再依次调用共享状态store中的一些mutations对共享状态进行更新：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">initialized</span>(<span class="params">state, layer</span>)</span> &#123;</span><br><span class="line">  state.layers[layer.config.id] = layer;</span><br><span class="line">  layer.setZIndex(state.layer_configs.length - <span class="number">1</span>);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">setCurrentLayer</span>(<span class="params">state, layer</span>)</span> &#123;</span><br><span class="line">  layer = state.layer_configs.filter(<span class="function"><span class="params">l</span> =&gt;</span> l.id === layer.id)[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (state.currentLayer === layer) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (state.currentLayer) &#123;</span><br><span class="line">    state.currentLayer.selected = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  state.currentLayer = layer;</span><br><span class="line">  layer.selected = <span class="literal">true</span>;</span><br><span class="line">  state.currentLayerWidget = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> <span class="built_in">Object</span>.keys(state.widgets)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      state.currentLayer.name &amp;&amp;</span><br><span class="line">      state.widgets[k].attach_to == state.currentLayer.name</span><br><span class="line">    ) &#123;</span><br><span class="line">      state.currentLayerWidget = state.widgets[k];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">sortLayers</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; state.layer_configs.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (state.layers[state.layer_configs[i].id])</span><br><span class="line">      state.layers[state.layer_configs[i].id].setZIndex(i);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(<span class="string">&quot;Layer not ready&quot;</span>, state.layer_configs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><br>主要是对state中的属性进行更新，比如<code>layers</code>信息、<code>currentLayer</code>信息等，更新后的共享状态state如下：<br><img src="https://user-images.githubusercontent.com/6218739/163129381-2a30e9dd-2c30-4ff0-a4a8-75495236656c.png" alt="state"></p><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>前面已说到，kaibu有三个非常重要的组件，用于承载不同的图层数据，分别是2D图像层ImageLayer、矢量层VectorLayer和3D模型层ItkVtkLayer。<br>2D图像层使用的是OpenLayers的<code>static image</code>，矢量层使用的是OpenLayers的<code>Vector</code>，对于3D模型层，则是使用的<a href="https://kitware.github.io/itk-vtk-viewer/docs/">ITk/Vtk Viewer</a>。</p><h2 id="ImageLayer"><a href="#ImageLayer" class="headerlink" title="ImageLayer"></a>ImageLayer</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;image-layer&quot;</span>&gt;</span><br><span class="line">    &lt;!-- 通过组件的layer属性切换是否显示 --&gt;</span><br><span class="line">    &lt;section v-<span class="keyword">if</span>=<span class="string">&quot;layer&quot;</span>&gt;</span><br><span class="line">      &lt;b-field label=<span class="string">&quot;opacity&quot;</span>&gt;</span><br><span class="line">        &lt;!-- 该组件在模板中只有一个滑动条 --&gt;</span><br><span class="line">        &lt;b-slider</span><br><span class="line">          v-model=<span class="string">&quot;config.opacity&quot;</span></span><br><span class="line">          @input=<span class="string">&quot;updateOpacity&quot;</span></span><br><span class="line">          :min=<span class="string">&quot;0&quot;</span></span><br><span class="line">          :max=<span class="string">&quot;1.0&quot;</span></span><br><span class="line">          :step=<span class="string">&quot;0.1&quot;</span></span><br><span class="line">        &gt;&lt;/b-slider&gt;</span><br><span class="line">      &lt;/b-field&gt;</span><br><span class="line">      &lt;!-- <span class="xml"><span class="tag">&lt;<span class="name">b-field</span> <span class="attr">v-if</span>=<span class="string">&quot;config.climit&quot;</span> <span class="attr">label</span>=<span class="string">&quot;contrast limit&quot;</span>&gt;</span></span></span><br><span class="line">        &lt;b-slider v-model=&quot;config.climit&quot; :min=&quot;1&quot; :max=&quot;255&quot; :step=&quot;0.5&quot; ticks&gt;</span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">b-slider</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">b-field</span>&gt;</span></span> --&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">// 从openlayers中导入必要的包</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="built_in">Map</span> &#125; <span class="keyword">from</span> <span class="string">&quot;ol&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Static <span class="keyword">from</span> <span class="string">&quot;ol/source/ImageStatic&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ImageLayer <span class="keyword">from</span> <span class="string">&quot;ol/layer/Image&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Projection <span class="keyword">from</span> <span class="string">&quot;ol/proj/Projection&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将File对象转为base64编码的对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">file2base64</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">    reader.onload = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(url2base64(event.target.result));</span><br><span class="line">    &#125;;</span><br><span class="line">    reader.onerror = <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;;</span><br><span class="line">    reader.readAsDataURL(file);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将图片url转为base64编码的对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">url2base64</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">    img.crossOrigin = <span class="string">&quot;anonymous&quot;</span>;</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line">      <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">      canvas.width = img.width;</span><br><span class="line">      canvas.height = img.height;</span><br><span class="line">      ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      resolve(&#123;</span><br><span class="line">        url: canvas.toDataURL(<span class="string">&quot;image/png&quot;</span>),</span><br><span class="line">        w: img.width,</span><br><span class="line">        h: img.height</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">      reject(<span class="string">&quot;image load error:&quot;</span> + <span class="built_in">String</span>(e));</span><br><span class="line">    &#125;;</span><br><span class="line">    img.src = url;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将无符号的整型数组转化为base64编码的对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">array2rgba</span>(<span class="params">imageArr, ch, w, h</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line">  canvas.width = w;</span><br><span class="line">  canvas.height = h;</span><br><span class="line">  <span class="keyword">const</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> canvas_img = ctx.getImageData(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line">  <span class="keyword">const</span> canvas_img_data = canvas_img.data;</span><br><span class="line">  <span class="keyword">const</span> count = w * h;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> raw = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(imageArr.buffer);</span><br><span class="line">  <span class="keyword">if</span> (imageArr <span class="keyword">instanceof</span> <span class="built_in">Uint8Array</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ch === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span>] = raw[i];</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span> + <span class="number">1</span>] = raw[i];</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span> + <span class="number">2</span>] = raw[i];</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span> + <span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span>] = raw[i * <span class="number">2</span>];</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span> + <span class="number">1</span>] = raw[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span> + <span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span> + <span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span>] = raw[i * <span class="number">3</span>];</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span> + <span class="number">1</span>] = raw[i * <span class="number">3</span> + <span class="number">1</span>];</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span> + <span class="number">2</span>] = raw[i * <span class="number">3</span> + <span class="number">2</span>];</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span> + <span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span>] = raw[i * <span class="number">3</span>];</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span> + <span class="number">1</span>] = raw[i * <span class="number">3</span> + <span class="number">1</span>];</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span> + <span class="number">2</span>] = raw[i * <span class="number">3</span> + <span class="number">2</span>];</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span> + <span class="number">3</span>] = raw[i * <span class="number">4</span> + <span class="number">3</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;unsupported array type&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.putImageData(canvas_img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    url: canvas.toDataURL(<span class="string">&quot;image/png&quot;</span>),</span><br><span class="line">    w: w,</span><br><span class="line">    h: h</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&quot;image-layer&quot;</span>,</span><br><span class="line">  type: <span class="string">&quot;2d-image&quot;</span>,</span><br><span class="line">  show: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 从父组件中接收参数</span></span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// map也是从父组件中传过来的存放于vuex中的map属性</span></span><br><span class="line">    map: &#123;</span><br><span class="line">      type: <span class="built_in">Map</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    selected: &#123;</span><br><span class="line">      type: <span class="built_in">Boolean</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    visible: &#123;</span><br><span class="line">      type: <span class="built_in">Boolean</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 这里的config会修改父组件中的config</span></span><br><span class="line">    config: &#123;</span><br><span class="line">      type: <span class="built_in">Object</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      layer: <span class="literal">null</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    visible: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.layer.setVisible(newVal);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.config.climit = [<span class="number">4</span>, <span class="number">50</span>];</span><br><span class="line">    <span class="built_in">this</span>.config.opacity = <span class="number">1.0</span>;</span><br><span class="line">    <span class="built_in">this</span>.config.init = <span class="built_in">this</span>.init;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">beforeDestroy</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.layer) &#123;</span><br><span class="line">      <span class="built_in">this</span>.map.removeLayer(<span class="built_in">this</span>.layer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// init初始化函数非常重要，它在vuex状态管理中被调用</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.layer = <span class="keyword">await</span> <span class="built_in">this</span>.setupLayer();</span><br><span class="line">      <span class="built_in">this</span>.map.addLayer(<span class="built_in">this</span>.layer);</span><br><span class="line">      <span class="built_in">this</span>.$forceUpdate();</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.layer;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">updateOpacity</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.layer) <span class="built_in">this</span>.layer.setOpacity(<span class="built_in">this</span>.config.opacity);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">selectLayer</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里就是对this.layer进行加工的详细过程了</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">setupLayer</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> imgObj;</span><br><span class="line">      <span class="keyword">const</span> data = <span class="built_in">this</span>.config.data;</span><br><span class="line">      <span class="comment">// 根据data的类型，进行不同的转换</span></span><br><span class="line">      <span class="comment">// 如果data是个字符串，比如是个图片路径</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> data === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用url2base64函数将其转化成base64编码格式</span></span><br><span class="line">        imgObj = <span class="keyword">await</span> url2base64(<span class="built_in">this</span>.config.data);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data <span class="keyword">instanceof</span> File) &#123; <span class="comment">// 如果是File对象实例，则调用file2base64</span></span><br><span class="line">        imgObj = <span class="keyword">await</span> file2base64(<span class="built_in">this</span>.config.data);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="comment">// 如果不是上面两种格式，就应该是无符号的整型数组及一些尺寸属性</span></span><br><span class="line">        data &amp;&amp;</span><br><span class="line">        data.imageType &amp;&amp;</span><br><span class="line">        data.size &amp;&amp;</span><br><span class="line">        data.imageType.componentType &amp;&amp;</span><br><span class="line">        data.data</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.imageType.componentType !== <span class="string">&quot;uint8_t&quot;</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="string">`Unsupported data type: <span class="subst">$&#123;data.imageType.componentType&#125;</span>`</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data.imageType.components &lt; <span class="number">1</span> &amp;&amp; data.imageType.components &gt; <span class="number">4</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="string">`Unsupported components number: <span class="subst">$&#123;data.imageType.components&#125;</span>`</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data.imageType.dimension !== <span class="number">2</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="string">`Dimension must be 2`</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data.imageType.pixelType !== <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="string">`Pixel type must be 1`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        imgObj = array2rgba(</span><br><span class="line">          data.data,</span><br><span class="line">          data.imageType.components,</span><br><span class="line">          data.size[<span class="number">0</span>],</span><br><span class="line">          data.size[<span class="number">1</span>]</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        imgObj = &#123;</span><br><span class="line">          url: <span class="string">&quot;https://images.proteinatlas.org/19661/221_G2_1_red_green.jpg&quot;</span>,</span><br><span class="line">          w: <span class="number">2048</span>,</span><br><span class="line">          h: <span class="number">2048</span></span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> extent = [<span class="number">0</span>, <span class="number">0</span>, imgObj.w, imgObj.h];</span><br><span class="line">      <span class="comment">// Map总是需要一个projection，这里只是想把图像坐标系映射到地图坐标系中，所以直接使用以像素为单位的图像内容来创建projection</span></span><br><span class="line">      <span class="keyword">const</span> projection = <span class="keyword">new</span> Projection(&#123;</span><br><span class="line">        code: <span class="string">&quot;image&quot;</span>,</span><br><span class="line">        units: <span class="string">&quot;pixels&quot;</span>,</span><br><span class="line">        extent: extent</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 创建一个static对象来作为下面ImageLayer的source</span></span><br><span class="line">      <span class="keyword">const</span> image_source = <span class="keyword">new</span> Static(&#123;</span><br><span class="line">        url: imgObj.url,</span><br><span class="line">        projection: projection,</span><br><span class="line">        imageExtent: extent</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 新建一个ImageLayer图层</span></span><br><span class="line">      <span class="keyword">const</span> image_layer = <span class="keyword">new</span> ImageLayer(&#123;</span><br><span class="line">        source: image_source</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 向父组件发射消息，使其能够监听到自定义事件，目前看主要是影响了显示中心位置</span></span><br><span class="line">      <span class="built_in">this</span>.$emit(<span class="string">&quot;update-extent&quot;</span>, &#123; <span class="attr">id</span>: <span class="built_in">this</span>.config.id, <span class="attr">extent</span>: extent &#125;);</span><br><span class="line">      <span class="keyword">return</span> image_layer;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Add <span class="string">&quot;scoped&quot;</span> attribute to limit CSS to <span class="built_in">this</span> component only --&gt;</span><br><span class="line">&lt;style&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="作为Imjoy插件时的API"><a href="#作为Imjoy插件时的API" class="headerlink" title="作为Imjoy插件时的API"></a>作为Imjoy插件时的API</h2><p>Kaibu作为ImJoy的插件使用时，有许多api可以调用，如<br>（1）<code>view_image</code>可以增加一个2D图像、itk/vtk 3D模型等，<br>（2）<code>add_shapes</code>可以增加一个矢量图层、<br>（3）<code>add_widgets</code>可以增加按钮、文件树等控件。<br>具体的api文档见<a href="https://kaibu.org/docs/#/api?id=kaibu-api">这里</a>，而相应源代码见<a href="https://github.com/imjoy-team/kaibu/blob/master/src/imjoyAPI.js">这里</a>。<br>其实细细研究源码可知，这些api是对原来的imageviewer这个组件中的<code>AddLayer</code>、<code>addWidget</code>等方法的二次封装。<br>所以如果不作为ImJoy插件使用时，可以直接看imageviewer这个组件中的这些方法。</p><h2 id="原生API"><a href="#原生API" class="headerlink" title="原生API"></a>原生API</h2><p>我们就以上面添加的矢量图层这个例子看看kaibu的原生API。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将通过AddLayer添加的矢量图层接收到一个变量中</span></span><br><span class="line"><span class="built_in">this</span>.shape_layer = <span class="keyword">await</span> <span class="built_in">this</span>.addLayer(&#123;</span><br><span class="line">  type: <span class="string">&quot;vector&quot;</span>,</span><br><span class="line">  name: <span class="string">&quot;shape vectors&quot;</span>,</span><br><span class="line">  data:</span><br><span class="line">    <span class="string">&quot;https://gist.githubusercontent.com/oeway/7c62128939a7f9b1701e2bbd72b809dc/raw/example_shape_vectors.json&quot;</span>,</span><br><span class="line">  predefined_tags: [<span class="string">&quot;nuclei&quot;</span>, <span class="string">&quot;cell&quot;</span>],</span><br><span class="line">  only_predefined_tags: <span class="literal">true</span>,</span><br><span class="line">  single_tag_mode: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>此时<code>this.shape_layer</code>上会有<code>getLayerAPI</code>这个方法，里面有若干适用于矢量层的API，比如<code>add_feature</code>、<code>add_features</code>、<code>get_features</code>等。<br>具体api可以见<a href="https://github.com/imjoy-team/kaibu/blob/master/src/components/layers/VectorLayer.vue">这里</a>，搜<code>getLayerAPI</code>函数。<br>除了上述API，该<code>this.shape_layer</code>也会天然地拥有openlayers库中对于它所赋予的函数，详见<a href="https://openlayers.org/en/latest/apidoc/module-ol_layer_Vector-VectorLayer.html">这里</a>。</p>]]></content>
    
    
    <summary type="html">简介
ImJoy有一个很有用的插件或独立应用，叫做Kaibu，它可以展示并标注普通的位图、矢量图及vtk、stl等3D格式的数据。
比如如下展示：

其就是位图（png格式）、矢量图（json格式）、3D模型（stl格式）的一个叠加。

Kaibu主要用了两个JS库，一个是OpenLayers，一个是ITK-VTK，前者用于展示矢量图形、普通位图等数据，且对地图的展示异常强大，后者用于展示在医疗及科学计算中常用的3D图像、网格、点集等。

这一篇主要分析一下Kaibu的运行机理。

从script标签开始，看其运行过程。

导入组件
1
2


import * as layerCompone</summary>
    
    
    
    <category term="computer vision" scheme="http://qixinbo.github.io/categories/computer-vision/"/>
    
    
    <category term="ImJoy" scheme="http://qixinbo.github.io/tags/ImJoy/"/>
    
  </entry>
  
  <entry>
    <title>FastAPI用户指南</title>
    <link href="http://qixinbo.github.io/2022/05/08/fastapi/"/>
    <id>http://qixinbo.github.io/2022/05/08/fastapi/</id>
    <published>2022-05-07T16:00:00.000Z</published>
    <updated>2022-05-13T03:58:58.584Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献：<br><a href="https://fastapi.tiangolo.com/">FastAPI官方文档</a><br><a href="https://fastapi.tiangolo.com/zh/">中文翻译</a><br>（注意，当前2022年5月8日的中文翻译有一些错误）</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>FastAPI 是一个用于构建 API 的现代、快速（高性能）的 web 框架，使用 Python 3.6+ 并基于标准的 Python 类型提示。<br>FastAPI 站在以下巨人的肩膀之上：</p><ul><li><a href="https://www.starlette.io/">Starlette</a>负责 web 部分。</li><li><a href="https://pydantic-docs.helpmanual.io/">Pydantic</a>负责数据部分。</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install fastapi</span><br></pre></td></tr></table></figure><p>还需要一个 ASGI 服务器，生产环境可以使用<a href="https://www.uvicorn.org/">Uvicorn</a>或者<a href="https://gitlab.com/pgjones/hypercorn">Hypercorn</a>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install uvicorn[standard]</span><br></pre></td></tr></table></figure></p><h1 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h1><h2 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h2><p>创建一个<code>main.py</code>文件并写入以下内容:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_root</span>():</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;Hello&quot;</span>: <span class="string">&quot;World&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_item</span>(<span class="params">item_id: <span class="built_in">int</span>, q: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;q&quot;</span>: q&#125;</span><br></pre></td></tr></table></figure></p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uvicorn main:app --reload</span><br></pre></td></tr></table></figure><p>uvicorn main:app 命令含义如下:</p><ul><li><code>main</code>：main.py 文件（一个 Python “模块”）。</li><li><code>app</code>：在 main.py 文件中通过 app = FastAPI() 创建的对象。</li><li><code>--reload</code>：让服务器在更新代码后重新启动。仅在开发时使用该选项。</li></ul><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p>使用浏览器访问<a href="http://127.0.0.1:8000/items/5?q=somequery">http://127.0.0.1:8000/items/5?q=somequery</a>。<br>将会看到如下 JSON 响应：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;item_id&quot;</span>:<span class="number">5</span>,<span class="string">&quot;q&quot;</span>:<span class="string">&quot;somequery&quot;</span>&#125;</span><br></pre></td></tr></table></figure><br>这里已经创建了一个具有以下功能的 API：</p><ul><li>通过路径 <code>/</code> 和 <code>/items/&#123;item_id&#125;</code> 接受 HTTP 请求。</li><li>以上路径 都接受 GET 操作（也被称为 HTTP 方法）。</li><li><code>/items/&#123;item_id&#125;</code> 路径 有一个路径参数 <code>item_id</code> 并且应该为<code>int</code>类型。</li><li><code>/items/&#123;item_id&#125;</code> 路径 有一个可选的<code>str</code>类型的查询参数 <code>q</code>。</li></ul><h2 id="交互式API文档"><a href="#交互式API文档" class="headerlink" title="交互式API文档"></a>交互式API文档</h2><p>现在访问<a href="http://127.0.0.1:8000/docs">http://127.0.0.1:8000/docs</a>。<br>会看到自动生成的交互式 API 文档（由 <a href="https://github.com/swagger-api/swagger-ui">Swagger UI</a>生成）。</p><h2 id="可选的API文档"><a href="#可选的API文档" class="headerlink" title="可选的API文档"></a>可选的API文档</h2><p>访问<a href="http://127.0.0.1:8000/redoc">http://127.0.0.1:8000/redoc</a>。<br>会看到另一个自动生成的文档（由<a href="http://127.0.0.1:8000/redoc">ReDoc</a>生成）。<br>Redoc也很有用，尤其有时它检测到的请求体格式要比Swagger的准确。</p><h1 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h1><p>现在修改<code>main.py</code>文件来从<code>PUT</code>请求中接收请求体。<br>以及借助<code>Pydantic</code>来使用标准的 Python 类型声明请求体。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    is_offer: <span class="type">Optional</span>[<span class="built_in">bool</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_root</span>():</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;Hello&quot;</span>: <span class="string">&quot;World&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_item</span>(<span class="params">item_id: <span class="built_in">int</span>, q: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;q&quot;</span>: q&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.put(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params">item_id: <span class="built_in">int</span>, item: Item</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;item_name&quot;</span>: item.name, <span class="string">&quot;item_id&quot;</span>: item_id&#125;</span><br></pre></td></tr></table></figure><br>请求体是一个JSON格式的数据体。</p><p>对于上面的代码，FastAPI 将会：</p><ul><li>校验<code>GET</code>和<code>PUT</code>请求的路径中是否含有<code>item_id</code></li><li>校验<code>GET</code>和<code>PUT</code>请求中的<code>item_id</code>是否为<code>int</code>类型：如果不是，客户端将会收到清晰有用的错误信息。</li><li>检查<code>GET</code>请求中是否有命名为<code>q</code>的可选查询参数：因为<code>q</code>被声明为<code>= None</code>，所以它是可选的；如果没有<code>None</code>它将会是必需的 (如<code>PUT</code>例子中的请求体)。</li><li>对于访问<code>/items/&#123;item_id&#125;</code>的<code>PUT</code>请求，将请求体读取为 JSON 并：检查是否有必需属性<code>name</code>并且值为<code>str</code>类型 、检查是否有必需属性<code>price</code>并且值为 <code>float</code>类型、检查是否有可选属性<code>is_offer</code>， 如果有的话值应该为<code>bool</code>类型；以上过程对于多层嵌套的 JSON 对象同样也会执行。</li><li>自动对 JSON 进行转换或转换成 JSON。</li><li>通过 OpenAPI 文档来记录所有内容，可被用于：交互式文档系统和许多编程语言的客户端代码自动生成系统</li><li>直接提供 2 种交互式文档 web 界面。</li></ul><h1 id="Python类型提示"><a href="#Python类型提示" class="headerlink" title="Python类型提示"></a>Python类型提示</h1><p>Python 3.6+ 版本加入了对”类型提示”的支持。<br>这些”类型提示”是一种新的语法（在 Python 3.6 版本加入）用来声明一个变量的类型。<br>类型提示是如下这样的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first_name:<span class="built_in">str</span>,last_name:<span class="built_in">str</span></span><br></pre></td></tr></table></figure><br>这和声明默认值是不同的，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first_name=<span class="string">&quot;john&quot;</span>,last_name=<span class="string">&quot;doe&quot;</span></span><br></pre></td></tr></table></figure><br>我们用的是冒号（:），不是等号（=）。<br>而且添加类型提示一般不会改变原来的运行结果。</p><h2 id="简单类型"><a href="#简单类型" class="headerlink" title="简单类型"></a>简单类型</h2><p>不只是 <code>str</code>，你能够声明所有的标准 Python 类型。<br>比如以下类型：<code>int</code>、<code>float</code>、<code>bool</code>、<code>bytes</code>。</p><h2 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h2><p>有些容器数据结构可以包含其他的值，比如 <code>dict</code>、<code>list</code>、<code>set</code> 和 <code>tuple</code>。它们内部的值也会拥有自己的类型。<br>你可以使用 Python 的 <code>typing</code> 标准库来声明这些类型以及子类型，它专门用来支持这些类型提示。<br>（注意，<code>typing</code>支持3.6版本以上的所有python版本，如果是3.9以上的版本，甚至不需要<code>typing</code>即可实现这些容器结构的类型声明）</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>例如，让我们来定义一个由 <code>str</code> 组成的 <code>list</code> 变量。<br>从 <code>typing</code> 模块导入 <code>List</code>（注意是大写的 <code>L</code>）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_items</span>(<span class="params">items: <span class="type">List</span>[<span class="built_in">str</span>]</span>):</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure><br>同样以冒号（:）来声明这个变量。输入 <code>List</code> 作为类型。<br>由于列表是带有”子类型”的类型，所以把子类型<code>str</code>放在方括号中。这表示：”变量 <code>items</code> 是一个 <code>list</code>，并且这个列表里的每一个元素都是<code>str</code>“。</p><h3 id="元组和集合"><a href="#元组和集合" class="headerlink" title="元组和集合"></a>元组和集合</h3><p>声明<code>tuple</code> 和<code>set</code>的方法也是一样的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Set</span>, <span class="type">Tuple</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_items</span>(<span class="params">items_t: <span class="type">Tuple</span>[<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">str</span>], items_s: <span class="type">Set</span>[<span class="built_in">bytes</span>]</span>):</span></span><br><span class="line">    <span class="keyword">return</span> items_t, items_s</span><br></pre></td></tr></table></figure><br>这表示：<br>（1）变量<code>items_t</code> 是一个<code>tuple</code>，其有三个元素，依次是<code>int</code>类型、<code>init</code>类型和<code>str</code>类型。<br>（2）变量<code>items_s</code>是一个<code>set</code>，其中的每个元素都是<code>bytes</code>类型。</p><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>定义 <code>dict</code> 时，需要传入两个子类型，用逗号进行分隔。<br>第一个子类型声明 <code>dict</code> 的所有键，第二个子类型声明 <code>dict</code> 的所有值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_items</span>(<span class="params">prices: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">float</span>]</span>):</span></span><br><span class="line">    <span class="keyword">for</span> item_name, item_price <span class="keyword">in</span> prices.items():</span><br><span class="line">        <span class="built_in">print</span>(item_name)</span><br><span class="line">        <span class="built_in">print</span>(item_price)</span><br></pre></td></tr></table></figure><br>这表示，变量 prices 是一个 dict：这个 dict 的所有键为 <code>str</code> 类型（可以看作是字典内每个元素的名称），这个 dict 的所有值为 <code>float</code> 类型（可以看作是字典内每个元素的价格）。</p><h2 id="类作为类型"><a href="#类作为类型" class="headerlink" title="类作为类型"></a>类作为类型</h2><p>也可以将类声明为变量的类型。<br>假设你有一个名为 <code>Person</code> 的类，拥有 <code>name</code>属性，就可以如下这样将类声明为类型：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name: <span class="built_in">str</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_person_name</span>(<span class="params">one_person: Person</span>):</span></span><br><span class="line">    <span class="keyword">return</span> one_person.name</span><br></pre></td></tr></table></figure></p><h2 id="Pydantic模型"><a href="#Pydantic模型" class="headerlink" title="Pydantic模型"></a>Pydantic模型</h2><p>Pydantic 是一个用来用来执行数据校验的 Python 库。<br>你可以将数据的”结构”声明为带属性的类，然后每个属性都拥有类型。<br>接着可以用一些值来创建这个类的实例，这些值会被校验，并被转换为适当的类型（在需要的情况下），返回一个包含所有数据的对象。<br>一个例子如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入pydantic的BaseModel</span></span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承BaseModel，形成一个带属性的类，每个属性都可以声明类型，且有默认值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span></span><br><span class="line">    name = <span class="string">&quot;John Doe&quot;</span></span><br><span class="line">    signup_ts: <span class="type">Optional</span>[datetime] = <span class="literal">None</span></span><br><span class="line">    friends: <span class="type">List</span>[<span class="built_in">int</span>] = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">external_data = &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;123&quot;</span>,</span><br><span class="line">    <span class="string">&quot;signup_ts&quot;</span>: <span class="string">&quot;2017-06-01 12:22&quot;</span>,</span><br><span class="line">    <span class="string">&quot;friends&quot;</span>: [<span class="number">1</span>, <span class="string">&quot;2&quot;</span>, <span class="string">b&quot;3&quot;</span>],</span><br><span class="line">&#125;</span><br><span class="line">user = User(**external_data)</span><br><span class="line"><span class="built_in">print</span>(user)</span><br><span class="line"><span class="comment"># &gt; User id=123 name=&#x27;John Doe&#x27; signup_ts=datetime.datetime(2017, 6, 1, 12, 22) friends=[1, 2, 3]</span></span><br><span class="line"><span class="built_in">print</span>(user.<span class="built_in">id</span>)</span><br><span class="line"><span class="comment"># &gt; 123</span></span><br></pre></td></tr></table></figure></p><h2 id="FastAPI-中的类型提示"><a href="#FastAPI-中的类型提示" class="headerlink" title="FastAPI 中的类型提示"></a>FastAPI 中的类型提示</h2><p>FastAPI 利用这些类型提示来做下面几件事。<br>使用 FastAPI 时用类型提示声明参数可以获得：<br>（1）编辑器支持，<br>（2）类型检查。<br>并且 FastAPI 还会用这些类型声明来：<br>（1）定义参数要求：声明对请求路径参数、查询参数、请求头、请求体、依赖等的要求。<br>（2）转换数据：将来自请求的数据转换为需要的类型。<br>（3）校验数据： 对于每一个请求：当数据校验失败时自动生成错误信息返回给客户端。<br>（4）使用 OpenAPI 记录 API，然后用于自动生成交互式文档的用户界面。</p><h1 id="并发和异步-等待"><a href="#并发和异步-等待" class="headerlink" title="并发和异步/等待"></a>并发和异步/等待</h1><p>如果使用的第三方库说了使用<code>await</code>来调用，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">results = <span class="keyword">await</span> some_library()</span><br></pre></td></tr></table></figure><br>那么就用<code>async def</code>声明路径操作函数，如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_results</span>():</span></span><br><span class="line">    results = <span class="keyword">await</span> some_library()</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><br>如果正在使用一个第三方库来与某些东西（数据库、API、文件系统等）进行通信，并且它不支持使用<code>await</code>（目前大多数数据库都是这种情况），那么就只需<code>def</code>声明路径操作，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">results</span>():</span></span><br><span class="line">    results = some_library()</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><br>如果你的应用程序（以某种方式）不必与其他任何东西通信并等待它响应，请使用<code>async def</code>。<br>如果你是啥都不知道，就直接使用普通<code>def</code>。</p><p>注意：可以根据需要混合使用<code>def</code>和<code>async def</code>。FastAPI 会对它们做正确的事情。<br>无论如何，在上述任何情况下，FastAPI 仍将以异步方式工作并且非常快。<br>但是按照上面的步骤，它将能够进行一些性能优化。</p><h1 id="用户指南"><a href="#用户指南" class="headerlink" title="用户指南"></a>用户指南</h1><h2 id="OpenAPI"><a href="#OpenAPI" class="headerlink" title="OpenAPI"></a>OpenAPI</h2><p>FastAPI 使用OpenAPI标准将所有 API 转换成模式schema。</p><h3 id="模式Schema"><a href="#模式Schema" class="headerlink" title="模式Schema"></a>模式Schema</h3><p>模式是对事物的一种定义或描述。它并非具体的实现代码，而只是抽象的描述。</p><h3 id="API模式"><a href="#API模式" class="headerlink" title="API模式"></a>API模式</h3><p>此时所指的API模式就是API的规范，OpenAPI 就是一种规定如何定义 API 模式的规范。<br> OpenAPI定义的模式包括API 路径，以及它们可能使用的参数等等。</p><h3 id="数据模式"><a href="#数据模式" class="headerlink" title="数据模式"></a>数据模式</h3><p>模式这个术语也可能指的是某些数据比如 JSON 的结构。<br>在这种情况下，它可以表示 JSON 的属性及其具有的数据类型，等等。</p><h3 id="OpenAPI-和-JSON-Schema"><a href="#OpenAPI-和-JSON-Schema" class="headerlink" title="OpenAPI 和 JSON Schema"></a>OpenAPI 和 JSON Schema</h3><p>OpenAPI定义了 API 模式。该模式中包含了你API 发送和接收的数据的定义（或称为数据模式），这些定义通过 JSON Schema 这一JSON 数据模式标准所生成。</p><h3 id="查看-openapi-json"><a href="#查看-openapi-json" class="headerlink" title="查看 openapi.json"></a>查看 openapi.json</h3><p>如果你对原始的 OpenAPI 模式长什么样子感到好奇，FastAPI自动生成了它，它就是一个json文件，可以通过<a href="http://127.0.0.1:8000/openapi.json">http://127.0.0.1:8000/openapi.json</a>访问。</p><h3 id="OpenAPI的用途"><a href="#OpenAPI的用途" class="headerlink" title="OpenAPI的用途"></a>OpenAPI的用途</h3><p>驱动 FastAPI 内置的 2 个交互式文档系统的正是 OpenAPI 模式。<br>并且还有数十种替代方案，它们全部都基于 OpenAPI。你可以轻松地将这些替代方案中的任何一种添加到使用 FastAPI 构建的应用程序中。<br>你还可以使用它自动生成与你的 API 进行通信的客户端代码。例如 web 前端，移动端或物联网嵌入程序。</p><h2 id="路径参数"><a href="#路径参数" class="headerlink" title="路径参数"></a>路径参数</h2><p>这里的路径指的是 URL 中从第一个 <code>/</code> 起的后半部分。<br>路径也通常被称为端点或路由。<br>开发 API 时，「路径」是用来分离「关注点」和「资源」的主要手段。<br>举例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_item</span>(<span class="params">item_id</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;item_id&quot;</span>: item_id&#125;</span><br></pre></td></tr></table></figure><br>路径参数 <code>item_id</code> 的值将作为参数 <code>item_id</code> 传递给你的函数。</p><h3 id="有类型的路径参数"><a href="#有类型的路径参数" class="headerlink" title="有类型的路径参数"></a>有类型的路径参数</h3><p>可以使用标准的 Python 类型标注为函数中的路径参数声明类型。<br>比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_item</span>(<span class="params">item_id: <span class="built_in">int</span></span>):</span> <span class="comment"># 声明item_id为int型</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;item_id&quot;</span>: item_id&#125;</span><br></pre></td></tr></table></figure></p><h3 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h3><p>如果你运行示例并打开浏览器访问<a href="http://127.0.0.1:8000/items/3">http://127.0.0.1:8000/items/3</a>，那么将得到如下返回：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;item_id&quot;</span>:<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><br>注意函数接收（并返回）的值为 3，是一个 Python <code>int</code> 值，而不是字符串 <code>&quot;3&quot;</code>。<br>所以，FastAPI 通过上面的类型声明提供了对请求的自动”解析”。</p><h3 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h3><p>但如果你通过浏览器访问<a href="http://127.0.0.1:8000/items/foo">http://127.0.0.1:8000/items/foo</a>，你会看到一个清晰可读的 HTTP 错误：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;detail&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;loc&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;path&quot;</span>,</span><br><span class="line">                <span class="string">&quot;item_id&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;value is not a valid integer&quot;</span>,</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;type_error.integer&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>所以，通过同样的 Python 类型声明，FastAPI 提供了数据校验功能。<br>注意上面的错误同样清楚地指出了校验未通过的具体原因。<br>在开发和调试与你的 API 进行交互的代码时，这非常有用。</p><h3 id="路径的顺序"><a href="#路径的顺序" class="headerlink" title="路径的顺序"></a>路径的顺序</h3><p>在创建路径操作时，会发现有些情况下路径是固定的。<br>比如 <code>/users/me</code>，我们假设它用来获取关于当前用户的数据，然后，还可以使用路径 <code>/users/&#123;user_id&#125;</code> 来通过用户 ID 获取关于特定用户的数据。<br>由于路径操作是按顺序依次运行的，需要确保路径 <code>/users/me</code> 声明在路径 <code>/users/&#123;user_id&#125;</code>之前。否则，<code>/users/&#123;user_id&#125;</code> 的路径还将与 <code>/users/me</code> 相匹配，”认为”自己正在接收一个值为 <code>&quot;me&quot;</code> 的 <code>user_id</code> 参数。 </p><h3 id="预设值"><a href="#预设值" class="headerlink" title="预设值"></a>预设值</h3><p>如果有一个接收路径参数的路径操作，但希望预先设定可能的有效参数值，则可以使用标准的 Python Enum 类型。<br>比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入 Enum 并创建一个继承自 str 和 Enum 的子类。</span></span><br><span class="line"><span class="comment"># 通过从 str 继承，API 文档将能够知道这些值必须为 string 类型并且能够正确地展示出来。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelName</span>(<span class="params"><span class="built_in">str</span>, Enum</span>):</span></span><br><span class="line">    <span class="comment"># 然后创建具有固定值的类属性，这些固定值将是可用的有效值：</span></span><br><span class="line">    alexnet = <span class="string">&quot;alexnet&quot;</span></span><br><span class="line">    resnet = <span class="string">&quot;resnet&quot;</span></span><br><span class="line">    lenet = <span class="string">&quot;lenet&quot;</span></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/models/&#123;model_name&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># 使用你定义的枚举类（ModelName）创建一个带有类型标注的路径参数：</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_model</span>(<span class="params">model_name: ModelName</span>):</span></span><br><span class="line">    <span class="comment"># 路径参数的值是一个枚举成员</span></span><br><span class="line">    <span class="comment"># 可以将它与你创建的枚举类 ModelName 中的枚举成员进行比较</span></span><br><span class="line">    <span class="keyword">if</span> model_name == ModelName.alexnet:</span><br><span class="line">        <span class="comment"># 可以返回枚举成员，即使嵌套在 JSON 结构中（例如一个 dict 中）。</span></span><br><span class="line">        <span class="comment"># 在返回给客户端之前，它们将被转换为对应的值：</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;model_name&quot;</span>: model_name, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Deep Learning FTW!&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可以使用 model_name.value 或通常来说 your_enum_member.value 来获取实际的值（在这个例子中它是一个字符串str）</span></span><br><span class="line">    <span class="comment"># 也可以通过 ModelName.lenet.value 来获取值 &quot;lenet&quot;。</span></span><br><span class="line">    <span class="keyword">if</span> model_name.value == <span class="string">&quot;lenet&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;model_name&quot;</span>: model_name, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;LeCNN all the images&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;model_name&quot;</span>: model_name, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Have some residuals&quot;</span>&#125;</span><br></pre></td></tr></table></figure></p><h3 id="包含路径的路径参数"><a href="#包含路径的路径参数" class="headerlink" title="包含路径的路径参数"></a>包含路径的路径参数</h3><p>假设有一个路径操作，它的路径为 <code>/files/&#123;file_path&#125;</code>。<br>但是你需要 <code>file_path</code> 自身也包含路径，比如 <code>home/johndoe/myfile.txt</code>。<br>因此，该文件的URL将类似于这样：<code>/files/home/johndoe/myfile.txt</code>。</p><p>OpenAPI 不支持这样的声明路径参数以在其内部包含路径，因为这可能会导致难以测试和定义的情况出现。<br>不过，你仍然可以通过 Starlette 的一个内部工具在 FastAPI 中实现它。<br>而且文档依旧可以使用，但是不会添加任何文档，来说明该参数应包含路径。<br>可以使用直接来自 Starlette 的选项来声明一个包含路径的路径参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/files/&#123;file_path:path&#125;</span><br></pre></td></tr></table></figure><br>在这种情况下，参数的名称为 <code>file_path</code>，结尾部分的 <code>:path</code> 说明该参数应匹配任意的路径。<br>因此，可以这样使用它：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 你可能会需要参数包含 /home/johndoe/myfile.txt，以斜杠（/）开头。</span></span><br><span class="line"><span class="comment"># 在这种情况下，URL 将会是 /files//home/johndoe/myfile.txt，在files 和 home 之间有一个双斜杠（//）。</span></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/files/&#123;file_path:path&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_file</span>(<span class="params">file_path: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;file_path&quot;</span>: file_path&#125;</span><br></pre></td></tr></table></figure></p><h3 id="额外校验"><a href="#额外校验" class="headerlink" title="额外校验"></a>额外校验</h3><p>可以使用Path为路径参数声明一些元数据及进行数值校验。<br>（1）声明元数据<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 fastapi 导入 Path（有关Query的用法参见下节的查询参数的校验）</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Path, Query</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 声明路径参数 item_id的 title 元数据值</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 路径参数总是必需的，因为它必须是路径的一部分。所以，你应该在声明时使用 ... 将其标记为必需参数。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 然而，即使你使用 None 声明路径参数或设置一个其他默认值也不会有任何影响，它依然会是必需参数。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    item_id: <span class="built_in">int</span> = Path(<span class="params">..., title=<span class="string">&quot;The ID of the item to get&quot;</span></span>),</span></span></span><br><span class="line"><span class="function"><span class="params">    q: <span class="type">Optional</span>[<span class="built_in">str</span>] = Query(<span class="params"><span class="literal">None</span>, alias=<span class="string">&quot;item-query&quot;</span></span>),</span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id&#125;</span><br><span class="line">    <span class="keyword">if</span> q:</span><br><span class="line">        results.update(&#123;<span class="string">&quot;q&quot;</span>: q&#125;)</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><br>（2）按需对参数排序<br>（2.1）FastAPI通过参数的名称、类型和默认值声明（Query、Path 等）来检测参数，而不在乎参数的顺序。<br>比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Path</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    q: <span class="built_in">str</span>, item_id: <span class="built_in">int</span> = Path(<span class="params">..., title=<span class="string">&quot;The ID of the item to get&quot;</span></span>)</span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id&#125;</span><br><span class="line">    <span class="keyword">if</span> q:</span><br><span class="line">        results.update(&#123;<span class="string">&quot;q&quot;</span>: q&#125;)</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><br>（2.2）另外一种排序方式<br>如果声明查询参数<code>q</code>时既不想使用Query，也不想使用默认值，与此同时，使用 Path 声明路径参数 item_id，并使它们的顺序与上面不同，Python 对此有一些特殊的语法。即传递 <code>*</code>星号 作为函数的第一个参数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Path</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># Python 不会对该 * 做任何事情，但是它将知道之后的所有参数都应作为关键字参数（键值对），也被称为 kwargs，来调用。即使它们没有默认值。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    *, item_id: <span class="built_in">int</span> = Path(<span class="params">..., title=<span class="string">&quot;The ID of the item to get&quot;</span></span>), q: <span class="built_in">str</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id&#125;</span><br><span class="line">    <span class="keyword">if</span> q:</span><br><span class="line">        results.update(&#123;<span class="string">&quot;q&quot;</span>: q&#125;)</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><br>（3）数值校验<br>使用 Query 和 Path（以及你将在后面看到的其他类）可以声明字符串约束，但也可以声明数值约束。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Path, Query</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 添加 ge=1 后，item_id 将必须是一个大于（greater than）或等于（equal）1 的整数。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># gt：大于（greater than）</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># le：小于等于（less than or equal）</span></span></span></span><br><span class="line"><span class="function"><span class="params">    *, </span></span></span><br><span class="line"><span class="function"><span class="params">    item_id: <span class="built_in">int</span> = Path(<span class="params">..., title=<span class="string">&quot;The ID of the item to get&quot;</span>, ge=<span class="number">1</span>, le=<span class="number">1000</span></span>), </span></span></span><br><span class="line"><span class="function"><span class="params">    q: <span class="built_in">str</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 数值校验同样适用于 float 值。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    size: <span class="built_in">float</span> = Query(<span class="params">..., gt=<span class="number">0</span>, lt=<span class="number">10.5</span></span>)</span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id&#125;</span><br><span class="line">    <span class="keyword">if</span> q:</span><br><span class="line">        results.update(&#123;<span class="string">&quot;q&quot;</span>: q&#125;)</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure></p><h2 id="查询参数"><a href="#查询参数" class="headerlink" title="查询参数"></a>查询参数</h2><p>声明不属于路径参数的其他函数参数时，它们将被自动解释为”查询字符串”参数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line">fake_items_db = [&#123;<span class="string">&quot;item_name&quot;</span>: <span class="string">&quot;Foo&quot;</span>&#125;, &#123;<span class="string">&quot;item_name&quot;</span>: <span class="string">&quot;Bar&quot;</span>&#125;, &#123;<span class="string">&quot;item_name&quot;</span>: <span class="string">&quot;Baz&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_item</span>(<span class="params">skip: <span class="built_in">int</span> = <span class="number">0</span>, limit: <span class="built_in">int</span> = <span class="number">10</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> fake_items_db[skip : skip + limit]</span><br></pre></td></tr></table></figure><br>查询字符串是键值对的集合，这些键值对位于 URL 的 <code>?</code> 之后，并以 <code>&amp;</code> 符号分隔。<br>比如以下URL：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8000/items/?skip=0&amp;limit=10</span><br></pre></td></tr></table></figure><br>查询参数为：<br>（1）skip：对应的值为 0<br>（2）limit：对应的值为 10<br>由于它们是 URL 的一部分，因此它们的”原始值”是字符串。<br>但是，当你为它们声明了 Python 类型（在上面的示例中为 <code>int</code>）时，它们将转换为该类型并针对该类型进行校验。<br>应用于路径参数的所有相同过程也适用于查询参数，包括编辑器支持、数据”解析”、数据校验、自动生成文档。</p><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>由于查询参数不是路径的固定部分，因此它们可以是可选的，并且可以有默认值。<br>在上面的示例中，它们具有 <code>skip=0</code> 和 <code>limit=10</code> 的默认值。</p><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>通过同样的方式，你可以将它们的默认值设置为 None 来声明可选查询参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_item</span>(<span class="params">item_id: <span class="built_in">str</span>, q: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> q:</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;q&quot;</span>: q&#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;item_id&quot;</span>: item_id&#125;</span><br></pre></td></tr></table></figure></p><h3 id="多个路径和查询参数"><a href="#多个路径和查询参数" class="headerlink" title="多个路径和查询参数"></a>多个路径和查询参数</h3><p>可以同时声明多个路径参数和查询参数，FastAPI 能够识别它们。<br>而且不需要以任何特定的顺序来声明。<br>它们将通过名称被检测到：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/users/&#123;user_id&#125;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_user_item</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    user_id: <span class="built_in">int</span>, item_id: <span class="built_in">str</span>, q: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>, short: <span class="built_in">bool</span> = <span class="literal">False</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br><span class="line">    item = &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;owner_id&quot;</span>: user_id&#125;</span><br><span class="line">    <span class="keyword">if</span> q:</span><br><span class="line">        item.update(&#123;<span class="string">&quot;q&quot;</span>: q&#125;)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> short:</span><br><span class="line">        item.update(</span><br><span class="line">            &#123;<span class="string">&quot;description&quot;</span>: <span class="string">&quot;This is an amazing item that has a long description&quot;</span>&#125;</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure></p><h3 id="必需查询参数"><a href="#必需查询参数" class="headerlink" title="必需查询参数"></a>必需查询参数</h3><p>当你为非路径参数（目前而言，我们所知道的仅有查询参数）声明了默认值时，则该参数不是必需的。<br>如果你不想添加一个特定的值，而只是想使该参数成为可选的，则将默认值设置为 None。<br>但当你想让一个查询参数成为必需的，不声明任何默认值就可以：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_user_item</span>(<span class="params">item_id: <span class="built_in">str</span>, needy: <span class="built_in">str</span></span>):</span></span><br><span class="line">    item = &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;needy&quot;</span>: needy&#125;</span><br><span class="line">    <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure></p><h3 id="额外校验-1"><a href="#额外校验-1" class="headerlink" title="额外校验"></a>额外校验</h3><p>FastAPI 允许你为参数声明额外的信息和校验，方法是使用Query。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 fastapi 导入 Query</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Query</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># 添加约束条件：即使 q 是可选的，但只要提供了该参数，则该参数值不能超过50个字符的长度。</span></span><br><span class="line"><span class="comment"># 方法就是将 Query 用作查询参数的默认值，并将它的 max_length 参数设置为 50</span></span><br><span class="line"><span class="comment"># 必须用 Query(None) 替换默认值 None，Query 的第一个参数同样也是用于定义默认值。</span></span><br><span class="line"><span class="comment"># max_length 参数将会校验数据，在数据无效时展示清晰的错误信息，并在 OpenAPI 模式的路径操作中记录该参数。</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params">q: <span class="type">Optional</span>[<span class="built_in">str</span>] = Query(<span class="params"><span class="literal">None</span>, max_length=<span class="number">50</span></span>)</span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;items&quot;</span>: [&#123;<span class="string">&quot;item_id&quot;</span>: <span class="string">&quot;Foo&quot;</span>&#125;, &#123;<span class="string">&quot;item_id&quot;</span>: <span class="string">&quot;Bar&quot;</span>&#125;]&#125;</span><br><span class="line">    <span class="keyword">if</span> q:</span><br><span class="line">        results.update(&#123;<span class="string">&quot;q&quot;</span>: q&#125;)</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 min_length 参数等更多校验，以及正则表达式</span></span><br><span class="line"><span class="comment"># @app.get(&quot;/items/&quot;)</span></span><br><span class="line"><span class="comment"># async def read_items(</span></span><br><span class="line"><span class="comment">#     q: Optional[str] = Query(None, min_length=3, max_length=50, regex=&quot;^fixedquery$&quot;)</span></span><br><span class="line"><span class="comment"># ):</span></span><br><span class="line"><span class="comment">#     results = &#123;&quot;items&quot;: [&#123;&quot;item_id&quot;: &quot;Foo&quot;&#125;, &#123;&quot;item_id&quot;: &quot;Bar&quot;&#125;]&#125;</span></span><br><span class="line"><span class="comment">#     if q:</span></span><br><span class="line"><span class="comment">#         results.update(&#123;&quot;q&quot;: q&#125;)</span></span><br><span class="line"><span class="comment">#     return results</span></span><br></pre></td></tr></table></figure></p><p>以上参数<code>q</code>默认值是<code>None</code>，所以它是可选的。<br>一般情形下不声明默认值就表明<code>q</code>是必需参数，但此时正在用 Query 声明它，因此，需要点特殊写法。<br>当在使用 Query 且需要声明一个值是必需的时，可以将 <code>...</code> 用作第一个参数值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Query</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params">q: <span class="built_in">str</span> = Query(<span class="params">..., min_length=<span class="number">3</span></span>)</span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;items&quot;</span>: [&#123;<span class="string">&quot;item_id&quot;</span>: <span class="string">&quot;Foo&quot;</span>&#125;, &#123;<span class="string">&quot;item_id&quot;</span>: <span class="string">&quot;Bar&quot;</span>&#125;]&#125;</span><br><span class="line">    <span class="keyword">if</span> q:</span><br><span class="line">        results.update(&#123;<span class="string">&quot;q&quot;</span>: q&#125;)</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><br>这将使 FastAPI 知道此查询参数是必需的。</p><h3 id="查询参数列表或多个值"><a href="#查询参数列表或多个值" class="headerlink" title="查询参数列表或多个值"></a>查询参数列表或多个值</h3><p>要声明类型为 list 的查询参数，需要显式地使用 Query，否则该参数将被解释为请求体。<br>即当你使用 Query 显式地定义查询参数时，还可以声明它去接收一组值，或换句话来说，接收多个值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Query</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params">q: <span class="type">Optional</span>[<span class="type">List</span>[<span class="built_in">str</span>]] = Query(<span class="params"><span class="literal">None</span></span>)</span>):</span></span><br><span class="line">    query_items = &#123;<span class="string">&quot;q&quot;</span>: q&#125;</span><br><span class="line">    <span class="keyword">return</span> query_items</span><br></pre></td></tr></table></figure><br>然后输入网址为:<a href="http://127.0.0.1:8000/items/?q=foo&amp;q=bar">http://127.0.0.1:8000/items/?q=foo&amp;q=bar</a><br>那么会在路径操作函数的函数参数 <code>q</code> 中以一个 Python list 的形式接收到查询参数 <code>q</code> 的多个值（<code>foo</code> 和 <code>bar</code>）。<br>也可以对多个值配置默认值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Query</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params">q: <span class="type">List</span>[<span class="built_in">str</span>] = Query(<span class="params">[<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>]</span>)</span>):</span></span><br><span class="line">    query_items = &#123;<span class="string">&quot;q&quot;</span>: q&#125;</span><br><span class="line">    <span class="keyword">return</span> query_items</span><br></pre></td></tr></table></figure></p><h3 id="Query的更多用法"><a href="#Query的更多用法" class="headerlink" title="Query的更多用法"></a>Query的更多用法</h3><p>（1）声明更多元数据<br>你可以添加更多有关该参数的信息，比如增加title和description。<br>这些信息将包含在生成的 OpenAPI 模式中，并由文档用户界面和外部工具所使用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Query</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    q: <span class="type">Optional</span>[<span class="built_in">str</span>] = Query(<span class="params"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        <span class="literal">None</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        title=<span class="string">&quot;Query string&quot;</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        description=<span class="string">&quot;Query string for the items to search in the database that have a good match&quot;</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        min_length=<span class="number">3</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    </span>)</span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;items&quot;</span>: [&#123;<span class="string">&quot;item_id&quot;</span>: <span class="string">&quot;Foo&quot;</span>&#125;, &#123;<span class="string">&quot;item_id&quot;</span>: <span class="string">&quot;Bar&quot;</span>&#125;]&#125;</span><br><span class="line">    <span class="keyword">if</span> q:</span><br><span class="line">        results.update(&#123;<span class="string">&quot;q&quot;</span>: q&#125;)</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><br>（2）别名参数<br>比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Query</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params">q: <span class="type">Optional</span>[<span class="built_in">str</span>] = Query(<span class="params"><span class="literal">None</span>, alias=<span class="string">&quot;item-query&quot;</span></span>)</span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;items&quot;</span>: [&#123;<span class="string">&quot;item_id&quot;</span>: <span class="string">&quot;Foo&quot;</span>&#125;, &#123;<span class="string">&quot;item_id&quot;</span>: <span class="string">&quot;Bar&quot;</span>&#125;]&#125;</span><br><span class="line">    <span class="keyword">if</span> q:</span><br><span class="line">        results.update(&#123;<span class="string">&quot;q&quot;</span>: q&#125;)</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><br>（3）弃用参数<br>现在假设你不再喜欢此参数。<br>你不得不将其保留一段时间，因为有些客户端正在使用它，但你希望文档清楚地将其展示为已弃用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Query</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    q: <span class="type">Optional</span>[<span class="built_in">str</span>] = Query(<span class="params"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        <span class="literal">None</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        alias=<span class="string">&quot;item-query&quot;</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        title=<span class="string">&quot;Query string&quot;</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        description=<span class="string">&quot;Query string for the items to search in the database that have a good match&quot;</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        min_length=<span class="number">3</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        max_length=<span class="number">50</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        regex=<span class="string">&quot;^fixedquery$&quot;</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        <span class="comment"># 配置该参数deprecated=True</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        deprecated=<span class="literal">True</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    </span>)</span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;items&quot;</span>: [&#123;<span class="string">&quot;item_id&quot;</span>: <span class="string">&quot;Foo&quot;</span>&#125;, &#123;<span class="string">&quot;item_id&quot;</span>: <span class="string">&quot;Bar&quot;</span>&#125;]&#125;</span><br><span class="line">    <span class="keyword">if</span> q:</span><br><span class="line">        results.update(&#123;<span class="string">&quot;q&quot;</span>: q&#125;)</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure></p><h2 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h2><p>当需要将数据从客户端（例如浏览器）发送给 API 时，需要将其作为“请求体”发送。<br>请求体request body是客户端发送给 API 的数据。响应体response body是 API 发送给客户端的数据。<br>你的 API 几乎总是要发送响应体。但是客户端并不总是需要发送请求体。<br>FastAPI使用 Pydantic 模型来声明请求体。<br>注意：不能使用 GET 操作（HTTP 方法）发送请求体。要发送数据，必须使用下列方法之一：POST（较常见）、PUT、DELETE 或 PATCH。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="comment"># 从 pydantic 中导入 BaseModel</span></span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将你的数据模型声明为继承自 BaseModel 的类</span></span><br><span class="line"><span class="comment"># 使用标准的 Python 类型来声明所有属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    <span class="comment"># 和声明查询参数时一样，当一个模型属性具有默认值时，它不是必需的。否则它是一个必需属性。将默认值设为 None 可使其成为可选属性。</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用与声明路径和查询参数的相同方式声明请求体，即可将其添加到「路径操作」中</span></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_item</span>(<span class="params">item: Item</span>):</span></span><br><span class="line">    <span class="comment"># 在函数内部，你可以直接访问模型对象的所有属性</span></span><br><span class="line">    item_dict = item.<span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">if</span> item.tax:</span><br><span class="line">        price_with_tax = item.price + item.tax</span><br><span class="line">        item_dict.update(&#123;<span class="string">&quot;price_with_tax&quot;</span>: price_with_tax&#125;)</span><br><span class="line">    <span class="keyword">return</span> item_dict</span><br></pre></td></tr></table></figure><br>可以看出，仅仅使用了 Python 类型声明，FastAPI 将会：<br>（1）将请求体作为 JSON 读取。<br>（2）转换为相应的类型（在需要时）。<br>（3）校验数据：如果数据无效，将返回一条清晰易读的错误信息，指出不正确数据的确切位置和内容。<br>（4）将接收的数据赋值到参数 item 中：由于已经在函数中将它声明为 Item 类型，还将获得对于所有属性及其类型的一切编辑器支持（代码补全等）。<br>（5）为模型生成 JSON 模式 定义，这些模式将成为生成的 OpenAPI 模式的一部分，并且被自动化文档 UI 所使用。</p><h3 id="请求体-路径参数-查询参数"><a href="#请求体-路径参数-查询参数" class="headerlink" title="请求体 + 路径参数 + 查询参数"></a>请求体 + 路径参数 + 查询参数</h3><p>还可以同时声明请求体、路径参数和查询参数。<br>FastAPI 会识别它们中的每一个，并从正确的位置获取数据。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.put(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_item</span>(<span class="params">item_id: <span class="built_in">int</span>, item: Item, q: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span>):</span></span><br><span class="line">    result = &#123;<span class="string">&quot;item_id&quot;</span>: item_id, **item.<span class="built_in">dict</span>()&#125;</span><br><span class="line">    <span class="keyword">if</span> q:</span><br><span class="line">        result.update(&#123;<span class="string">&quot;q&quot;</span>: q&#125;)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><br>函数参数将依次按如下规则进行识别：<br>（1）如果在路径中也声明了该参数，它将被用作路径参数。<br>（2）如果参数属于单一类型（比如 int、float、str、bool 等）它将被解释为查询参数。<br>（3）如果参数的类型被声明为一个 Pydantic 模型，它将被解释为请求体。</p><h3 id="可选请求体"><a href="#可选请求体" class="headerlink" title="可选请求体"></a>可选请求体</h3><p>可以通过将默认值设置为 None 来将请求体参数声明为可选参数。</p><h3 id="多个请求体参数"><a href="#多个请求体参数" class="headerlink" title="多个请求体参数"></a>多个请求体参数</h3><p>可以添加多个请求体参数到路径操作函数中，即使一个请求只能有一个请求体。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    username: <span class="built_in">str</span></span><br><span class="line">    full_name: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.put(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># FastAPI 将注意到该函数中有多个请求体参数（两个 Pydantic 模型参数）。</span></span><br><span class="line"><span class="comment"># 它将使用参数名称作为请求体中的键（字段名称），并期望一个类似于以下内容的请求体</span></span><br><span class="line"><span class="comment"># &#123;</span></span><br><span class="line"><span class="comment">#     &quot;item&quot;: &#123;</span></span><br><span class="line"><span class="comment">#         &quot;name&quot;: &quot;Foo&quot;,</span></span><br><span class="line"><span class="comment">#         &quot;description&quot;: &quot;The pretender&quot;,</span></span><br><span class="line"><span class="comment">#         &quot;price&quot;: 42.0,</span></span><br><span class="line"><span class="comment">#         &quot;tax&quot;: 3.2</span></span><br><span class="line"><span class="comment">#     &#125;,</span></span><br><span class="line"><span class="comment">#     &quot;user&quot;: &#123;</span></span><br><span class="line"><span class="comment">#         &quot;username&quot;: &quot;dave&quot;,</span></span><br><span class="line"><span class="comment">#         &quot;full_name&quot;: &quot;Dave Grohl&quot;</span></span><br><span class="line"><span class="comment">#     &#125;</span></span><br><span class="line"><span class="comment"># &#125;</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params">item_id: <span class="built_in">int</span>, item: Item, user: User</span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;item&quot;</span>: item, <span class="string">&quot;user&quot;</span>: user&#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure></p><h3 id="请求体中的单一值"><a href="#请求体中的单一值" class="headerlink" title="请求体中的单一值"></a>请求体中的单一值</h3><p>与使用 Query 和 Path 为查询参数和路径参数定义额外数据的方式相同，FastAPI 提供了一个同等的 Body。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Body, FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    username: <span class="built_in">str</span></span><br><span class="line">    full_name: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.put(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 例如，为了扩展先前的模型，你可能决定除了 item 和 user 之外，还想在同一请求体中具有另一个键 importance。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 如果就按原样声明它，因为它是一个单一值，FastAPI 将假定它是一个查询参数。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 但是可以使用 Body 指示 FastAPI 将其作为请求体的另一个键进行处理。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># Body 同样具有与 Query、Path 以及其他后面将看到的类完全相同的额外校验和元数据参数。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    item_id: <span class="built_in">int</span>, item: Item, user: User, importance: <span class="built_in">int</span> = Body(<span class="params">...</span>)</span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;item&quot;</span>: item, <span class="string">&quot;user&quot;</span>: user, <span class="string">&quot;importance&quot;</span>: importance&#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure></p><h3 id="单个请求体参数嵌入一个键中"><a href="#单个请求体参数嵌入一个键中" class="headerlink" title="单个请求体参数嵌入一个键中"></a>单个请求体参数嵌入一个键中</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Body, FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.put(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    item_id: <span class="built_in">int</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 假设只有一个来自 Pydantic 模型 Item 的请求体参数 item。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 默认情况下，FastAPI 将直接期望这样的请求体。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 但是，如果希望它拥有 item 键，就像在声明额外的请求体参数时所做的那样</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 则可以使用一个特殊的 Body 参数 embed。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 在这种情况下，FastAPI 将期望像这样的请求体：</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">#     &quot;item&quot;: &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">#         &quot;name&quot;: &quot;Foo&quot;,</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">#         &quot;description&quot;: &quot;The pretender&quot;,</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">#         &quot;price&quot;: 42.0,</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">#         &quot;tax&quot;: 3.2</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">#     &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 而不是：</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">#     &quot;name&quot;: &quot;Foo&quot;,</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">#     &quot;description&quot;: &quot;The pretender&quot;,</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">#     &quot;price&quot;: 42.0,</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">#     &quot;tax&quot;: 3.2</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    item: Item = Body(<span class="params">..., embed=<span class="literal">True</span></span>)</span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;item&quot;</span>: item&#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><h3 id="请求体中的字段校验"><a href="#请求体中的字段校验" class="headerlink" title="请求体中的字段校验"></a>请求体中的字段校验</h3><p>与使用 Query、Path 和 Body 在路径操作函数中声明额外的校验和元数据的方式相同，可以使用 Pydantic 的 Field 在 Pydantic 模型内部声明校验和元数据。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Body, FastAPI</span><br><span class="line"><span class="comment"># 注意，Field 是直接从 pydantic 导入的，而不是像其他的（Query，Path，Body 等）都从 fastapi 导入。</span></span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, Field</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    <span class="comment"># 对模型属性使用 Field</span></span><br><span class="line">    <span class="comment"># Field 的工作方式和 Query、Path 和 Body 相同，包括它们的参数等等也完全相同。</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = Field(</span><br><span class="line">        <span class="literal">None</span>, title=<span class="string">&quot;The description of the item&quot;</span>, max_length=<span class="number">300</span></span><br><span class="line">    )</span><br><span class="line">    price: <span class="built_in">float</span> = Field(..., gt=<span class="number">0</span>, description=<span class="string">&quot;The price must be greater than zero&quot;</span>)</span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.put(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params">item_id: <span class="built_in">int</span>, item: Item = Body(<span class="params">..., embed=<span class="literal">True</span></span>)</span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;item&quot;</span>: item&#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure></p><h3 id="嵌套模型"><a href="#嵌套模型" class="headerlink" title="嵌套模型"></a>嵌套模型</h3><p>（1）普通python类型作为嵌套<br>使用 FastAPI，你可以定义、校验、记录文档并使用任意深度嵌套的模型（归功于Pydantic）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 将一个属性定义为拥有子元素的类型，比如list</span></span><br><span class="line">    <span class="comment"># 这将使 tags 成为一个由元素组成的列表。不过它没有声明每个元素的类型。</span></span><br><span class="line">    <span class="comment"># tags: list = []</span></span><br><span class="line">    <span class="comment"># 但是 Python 有一种特定的方法来声明具有子类型的列表：</span></span><br><span class="line">    tags: <span class="type">List</span>[<span class="built_in">str</span>] = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.put(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params">item_id: <span class="built_in">int</span>, item: Item</span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;item&quot;</span>: item&#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><br>但是随后我们考虑了一下，意识到标签不应该重复，它们很大可能会是唯一的字符串。<br>Python 具有一种特殊的数据类型来保存一组唯一的元素，即 set。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span>, <span class="type">Set</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line">    tags: <span class="type">Set</span>[<span class="built_in">str</span>] = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.put(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params">item_id: <span class="built_in">int</span>, item: Item</span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;item&quot;</span>: item&#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><br>这样，即使你收到带有重复数据的请求，这些数据也会被转换为一组唯一项。<br>而且，每当你输出该数据时，即使源数据有重复，它们也将作为一组唯一项输出。<br>并且还会被相应地标注 / 记录文档。</p><p>（2）Pydantic模型作为嵌套<br>Pydantic 模型的每个属性都具有类型。<br>但是这个类型本身可以是另一个 Pydantic 模型。<br>因此，你可以声明拥有特定属性名称、类型和校验的深度嵌套的 JSON 对象。<br>上述这些都可以任意的嵌套。<br>比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span>, <span class="type">Set</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    url: <span class="built_in">str</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line">    tags: <span class="type">Set</span>[<span class="built_in">str</span>] = []</span><br><span class="line">    <span class="comment"># 将子模型用作类型</span></span><br><span class="line">    <span class="comment"># 这意味着 FastAPI 将期望类似于以下内容的请求体：</span></span><br><span class="line">    <span class="comment"># &#123;</span></span><br><span class="line">    <span class="comment">#     &quot;name&quot;: &quot;Foo&quot;,</span></span><br><span class="line">    <span class="comment">#     &quot;description&quot;: &quot;The pretender&quot;,</span></span><br><span class="line">    <span class="comment">#     &quot;price&quot;: 42.0,</span></span><br><span class="line">    <span class="comment">#     &quot;tax&quot;: 3.2,</span></span><br><span class="line">    <span class="comment">#     &quot;tags&quot;: [&quot;rock&quot;, &quot;metal&quot;, &quot;bar&quot;],</span></span><br><span class="line">    <span class="comment">#     &quot;image&quot;: &#123;</span></span><br><span class="line">    <span class="comment">#         &quot;url&quot;: &quot;http://example.com/baz.jpg&quot;,</span></span><br><span class="line">    <span class="comment">#         &quot;name&quot;: &quot;The Foo live&quot;</span></span><br><span class="line">    <span class="comment">#     &#125;</span></span><br><span class="line">    <span class="comment"># &#125;</span></span><br><span class="line"></span><br><span class="line">    image: <span class="type">Optional</span>[Image] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.put(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params">item_id: <span class="built_in">int</span>, item: Item</span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;item&quot;</span>: item&#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><br>（3）特殊类型及其校验<br>除了普通的单一值类型（如 str、int、float 等）外，还可以使用其他的更复杂的单一值类型。<br>要了解所有的可用选项，请查看关于 <a href="https://pydantic-docs.helpmanual.io/usage/types/">Pydantic字段类型</a> 的文档。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span>, <span class="type">Set</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, HttpUrl</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    <span class="comment"># 例如，在 Image 模型中我们有一个 url 字段，我们可以把它声明为 Pydantic 的 HttpUrl，而不是 str。</span></span><br><span class="line">   <span class="comment"># 该字符串将被检查是否为有效的 URL，并在 JSON Schema / OpenAPI 文档中进行记录。</span></span><br><span class="line">    url: HttpUrl</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line">    tags: <span class="type">Set</span>[<span class="built_in">str</span>] = <span class="built_in">set</span>()</span><br><span class="line">    image: <span class="type">Optional</span>[Image] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.put(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params">item_id: <span class="built_in">int</span>, item: Item</span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;item&quot;</span>: item&#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><br>（4）深度嵌套模型<br>可以定义任意深度的嵌套模型：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span>, <span class="type">Set</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, HttpUrl</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    url: HttpUrl</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line">    tags: <span class="type">Set</span>[<span class="built_in">str</span>] = <span class="built_in">set</span>()</span><br><span class="line">    images: <span class="type">Optional</span>[<span class="type">List</span>[Image]] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Offer</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    items: <span class="type">List</span>[Item]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/offers/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_offer</span>(<span class="params">offer: Offer</span>):</span></span><br><span class="line">    <span class="keyword">return</span> offer</span><br></pre></td></tr></table></figure></p><h3 id="纯列表请求体"><a href="#纯列表请求体" class="headerlink" title="纯列表请求体"></a>纯列表请求体</h3><p>如果你期望的 JSON 请求体的最外层是一个 JSON <code>array</code>（即 Python <code>list</code>），则可以在路径操作函数的参数中声明此类型。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, HttpUrl</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    url: HttpUrl</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/images/multiple/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_multiple_images</span>(<span class="params">images: <span class="type">List</span>[Image]</span>):</span></span><br><span class="line">    <span class="keyword">return</span> images</span><br></pre></td></tr></table></figure></p><h3 id="任意dict构成的请求体"><a href="#任意dict构成的请求体" class="headerlink" title="任意dict构成的请求体"></a>任意dict构成的请求体</h3><p>也可以将请求体声明为使用某类型的key和其他类型的value的 dict。<br>无需事先知道有效的字段/属性（比如使用 Pydantic 模型的场景）是什么。<br>如果你想接收一些尚且未知的键，这将很有用。<br>还有一些奇葩的场景，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/index-weights/&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># 当你想要接收其他类型的键（键的类型通常都是str）时，例如 int。</span></span><br><span class="line"><span class="comment"># 请记住 JSON 仅支持将 str 作为键。</span></span><br><span class="line"><span class="comment"># 但是 Pydantic 具有自动转换数据的功能。</span></span><br><span class="line"><span class="comment"># 这意味着，即使你的 API 客户端只能将字符串作为键发送，只要这些字符串内容仅包含整数，Pydantic 就会对其进行转换并校验。</span></span><br><span class="line"><span class="comment"># 然后你接收的名为 weights 的 dict 实际上将具有 int 类型的键和 float 类型的值。</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_index_weights</span>(<span class="params">weights: <span class="type">Dict</span>[<span class="built_in">int</span>, <span class="built_in">float</span>]</span>):</span></span><br><span class="line">    <span class="keyword">return</span> weights</span><br></pre></td></tr></table></figure></p><h3 id="声明请求体的示例数据"><a href="#声明请求体的示例数据" class="headerlink" title="声明请求体的示例数据"></a>声明请求体的示例数据</h3><p>可以声明你想接收的数据的示例模样。<br>有几种方法可以做到：<br>（1）Pydantic schema_extra<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可以使用 Config 和 schema_extra 为Pydantic模型声明一个示例</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Config</span>:</span></span><br><span class="line">        schema_extra = &#123;</span><br><span class="line">            <span class="string">&quot;example&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Foo&quot;</span>,</span><br><span class="line">                <span class="string">&quot;description&quot;</span>: <span class="string">&quot;A very nice Item&quot;</span>,</span><br><span class="line">                <span class="string">&quot;price&quot;</span>: <span class="number">35.4</span>,</span><br><span class="line">                <span class="string">&quot;tax&quot;</span>: <span class="number">3.2</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.put(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params">item_id: <span class="built_in">int</span>, item: Item</span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;item&quot;</span>: item&#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><br>（2）Field 的附加参数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, Field</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    <span class="comment"># 在 Field, Path, Query, Body 和其他你之后将会看到的工厂函数中，</span></span><br><span class="line">    <span class="comment"># 可以通过给工厂函数传递其他的任意参数来给JSON模式声明额外信息，比如增加 example。</span></span><br><span class="line">    <span class="comment"># 请记住，传递的那些额外参数不会添加任何验证，只会添加注释，用于文档的目的。</span></span><br><span class="line">    name: <span class="built_in">str</span> = Field(..., example=<span class="string">&quot;Foo&quot;</span>)</span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = Field(<span class="literal">None</span>, example=<span class="string">&quot;A very nice Item&quot;</span>)</span><br><span class="line">    price: <span class="built_in">float</span> = Field(..., example=<span class="number">35.4</span>)</span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = Field(<span class="literal">None</span>, example=<span class="number">3.2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.put(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params">item_id: <span class="built_in">int</span>, item: Item</span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;item&quot;</span>: item&#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><br>（3）Body的额外参数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Body, FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.put(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    item_id: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    item: Item = Body(<span class="params"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        ...,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        example=&#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Foo&quot;</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">            <span class="string">&quot;description&quot;</span>: <span class="string">&quot;A very nice Item&quot;</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">            <span class="string">&quot;price&quot;</span>: <span class="number">35.4</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">            <span class="string">&quot;tax&quot;</span>: <span class="number">3.2</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        &#125;,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    </span>),</span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;item&quot;</span>: item&#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure></p><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>（1）用<code>PUT</code>更新数据<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> fastapi.encoders <span class="keyword">import</span> jsonable_encoder</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line">    tax: <span class="built_in">float</span> = <span class="number">10.5</span></span><br><span class="line">    tags: <span class="type">List</span>[<span class="built_in">str</span>] = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">items = &#123;</span><br><span class="line">    <span class="string">&quot;foo&quot;</span>: &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Foo&quot;</span>, <span class="string">&quot;price&quot;</span>: <span class="number">50.2</span>&#125;,</span><br><span class="line">    <span class="string">&quot;bar&quot;</span>: &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Bar&quot;</span>, <span class="string">&quot;description&quot;</span>: <span class="string">&quot;The bartenders&quot;</span>, <span class="string">&quot;price&quot;</span>: <span class="number">62</span>, <span class="string">&quot;tax&quot;</span>: <span class="number">20.2</span>&#125;,</span><br><span class="line">    <span class="string">&quot;baz&quot;</span>: &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Baz&quot;</span>, <span class="string">&quot;description&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;price&quot;</span>: <span class="number">50.2</span>, <span class="string">&quot;tax&quot;</span>: <span class="number">10.5</span>, <span class="string">&quot;tags&quot;</span>: []&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span>, response_model=Item</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_item</span>(<span class="params">item_id: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> items[item_id]</span><br><span class="line"></span><br><span class="line"><span class="comment"># PUT 用于接收替换现有数据的数据。</span></span><br><span class="line"><span class="meta">@app.put(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span>, response_model=Item</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params">item_id: <span class="built_in">str</span>, item: Item</span>):</span></span><br><span class="line">    <span class="comment"># 把输入数据转换为以 JSON 格式存储的数据（比如，使用 NoSQL 数据库时），可以使用 jsonable_encoder。例如，把 datetime 转换为 str。</span></span><br><span class="line">    update_item_encoded = jsonable_encoder(item)</span><br><span class="line">    items[item_id] = update_item_encoded</span><br><span class="line">    <span class="keyword">return</span> update_item_encoded</span><br></pre></td></tr></table></figure><br>当使用如下请求体：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bar111&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">  <span class="string">&quot;price&quot;</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>用<code>PUT</code>更新<code>bar</code>时，因为上述数据未包含已存储的属性 <code>&quot;tax&quot;: 20.2</code>，新的输入模型会把 <code>&quot;tax&quot;: 10.5</code> 作为默认值。<br>因此，本次操作把 <code>tax</code> 的值「更新」为 <code>10.5</code>。<br>（2）用<code>PATCH</code>进行部分更新<br>HTTP PATCH 操作用于更新 部分 数据。<br>即，只发送要更新的数据，其余数据保持不变。<br>PATCH 没有 PUT 知名，也怎么不常用。<br>很多人甚至只用 PUT 实现部分更新。<br>FastAPI 对此没有任何限制，可以随意互换使用这两种操作。<br>但本指南也会分别介绍这两种操作各自的用途。<br>仍然以上述请求体为例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> fastapi.encoders <span class="keyword">import</span> jsonable_encoder</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line">    tax: <span class="built_in">float</span> = <span class="number">10.5</span></span><br><span class="line">    tags: <span class="type">List</span>[<span class="built_in">str</span>] = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">items = &#123;</span><br><span class="line">    <span class="string">&quot;foo&quot;</span>: &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Foo&quot;</span>, <span class="string">&quot;price&quot;</span>: <span class="number">50.2</span>&#125;,</span><br><span class="line">    <span class="string">&quot;bar&quot;</span>: &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Bar&quot;</span>, <span class="string">&quot;description&quot;</span>: <span class="string">&quot;The bartenders&quot;</span>, <span class="string">&quot;price&quot;</span>: <span class="number">62</span>, <span class="string">&quot;tax&quot;</span>: <span class="number">20.2</span>&#125;,</span><br><span class="line">    <span class="string">&quot;baz&quot;</span>: &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Baz&quot;</span>, <span class="string">&quot;description&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;price&quot;</span>: <span class="number">50.2</span>, <span class="string">&quot;tax&quot;</span>: <span class="number">10.5</span>, <span class="string">&quot;tags&quot;</span>: []&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span>, response_model=Item</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_item</span>(<span class="params">item_id: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> items[item_id]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.patch(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span>, response_model=Item</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params">item_id: <span class="built_in">str</span>, item: Item</span>):</span></span><br><span class="line">    stored_item_data = items[item_id]</span><br><span class="line">    stored_item_model = Item(**stored_item_data)</span><br><span class="line">    <span class="comment"># 更新部分数据时，可以在 Pydantic 模型的 `.dict()` 中使用 `exclude_unset` 参数。</span></span><br><span class="line">    <span class="comment"># 如下代码生成的 dict 只包含创建 item 模型时显式设置的数据，而不包括默认值。</span></span><br><span class="line">    <span class="comment"># 即：update_data =  &#123;&#x27;name&#x27;: &#x27;bar111&#x27;, &#x27;description&#x27;: &#x27;string&#x27;, &#x27;price&#x27;: 0.0&#125;</span></span><br><span class="line">    <span class="comment"># 而不是</span></span><br><span class="line">    <span class="comment"># update_data =  &#123;&#x27;name&#x27;: &#x27;bar111&#x27;, &#x27;description&#x27;: &#x27;string&#x27;, &#x27;price&#x27;: 0.0, &#x27;tax&#x27;: 10.5, &#x27;tags&#x27;: []&#125;</span></span><br><span class="line">    update_data = item.<span class="built_in">dict</span>(exclude_unset=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 接下来，用 .copy() 为已有模型创建调用 update 参数的副本，该参数为包含更新数据的 dict。</span></span><br><span class="line">    updated_item = stored_item_model.copy(update=update_data)</span><br><span class="line">    items[item_id] = jsonable_encoder(updated_item)</span><br><span class="line">    <span class="keyword">return</span> updated_item</span><br></pre></td></tr></table></figure><br>实际上，HTTP <code>PUT</code> 也可以完成相同的操作。 但本节以 <code>PATCH</code> 为例的原因是，该操作就是为了这种用例创建的。</p><h2 id="其他数据类型"><a href="#其他数据类型" class="headerlink" title="其他数据类型"></a>其他数据类型</h2><p>到目前为止，一直在使用常见的数据类型，如:<code>int</code>、<code>float</code>、<code>str</code>、<code>bool</code>，但是也可以使用更复杂的数据类型。<br>在这些复杂数据类型上，也能有如下功能：编辑器支持、传入请求的数据转换、响应数据的转换、数据验证、自动补全和文档。<br>一些常用的复杂数据类型:<br>（1）<code>UUID</code>:<br>一种标准的 “通用唯一标识符” ，在许多数据库和系统中用作ID。<br>在请求和响应中将以 <code>str</code> 表示。<br>（2）<code>datetime.datetime</code>:<br>日期时间。<br>在请求和响应中将表示为 ISO 8601 格式的 str ，比如: <code>2008-09-15T15:53:00+05:00</code>.<br>（3）<code>datetime.date</code>:<br>日期。<br>在请求和响应中将表示为 ISO 8601 格式的 str ，比如: <code>2008-09-15</code>.<br>（4）<code>datetime.time</code>:<br>时间。<br>在请求和响应中将表示为 ISO 8601 格式的 str ，比如: <code>14:23:55.003</code>.<br>（5）<code>datetime.timedelta</code>:<br>时间间隔。<br>在请求和响应中将表示为 float 代表总秒数。<br>Pydantic 也允许将其表示为 “ISO 8601 时间差异编码”。<br>（6）<code>frozenset</code>:<br>在请求和响应中，作为 <code>set</code> 对待：<br>在请求中，列表将被读取，消除重复，并将其转换为一个 <code>set</code>。<br>在响应中 <code>set</code> 将被转换为 <code>list</code> 。<br>产生的schema将指定哪些<code>set</code> 的值是唯一的 (使用 JSON Schema的 <code>uniqueItems</code>)。<br>（7）bytes:<br>标准的 Python <code>bytes</code>。<br>在请求和响应中被当作 <code>str</code> 处理。<br>生成的schema将指定这个 <code>str</code> 是 <code>binary</code> “格式”。<br>（8）Decimal:<br>标准的 Python <code>Decimal</code>。<br>在请求和响应中被当做 <code>float</code> 一样处理。<br>（9）可以在这里检查所有有效的pydantic数据类型: <a href="https://pydantic-docs.helpmanual.io/usage/types/">Pydantic data types</a>。</p><h2 id="Cookie参数"><a href="#Cookie参数" class="headerlink" title="Cookie参数"></a>Cookie参数</h2><p>可以像定义 <code>Query</code> 参数和 <code>Path</code> 参数一样来定义 <code>Cookie</code> 参数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"><span class="comment"># 导入 Cookie</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Cookie, FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># 需要使用 Cookie 来声明 cookie 参数，否则参数将会被解释为查询参数。</span></span><br><span class="line"><span class="comment"># 声明 Cookie 参数的结构与声明 Query 参数和 Path 参数时相同。</span></span><br><span class="line"><span class="comment"># 第一个值是参数的默认值，同时也可以传递所有验证参数或注释参数，来校验参数</span></span><br><span class="line"><span class="comment"># Cookie 、Path 、Query是兄弟类，它们都继承自公共的 Param 类</span></span><br><span class="line"><span class="comment"># 但请记住，从 fastapi 导入的 Query、Path、Cookie 或其他参数声明函数，这些实际上是返回特殊类的函数。</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params">ads_id: <span class="type">Optional</span>[<span class="built_in">str</span>] = Cookie(<span class="params"><span class="literal">None</span></span>)</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;ads_id&quot;</span>: ads_id&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Header参数"><a href="#Header参数" class="headerlink" title="Header参数"></a>Header参数</h2><p>可以使用定义 <code>Query</code>, <code>Path</code> 和 <code>Cookie</code> 参数一样的方法定义 <code>Header</code> 参数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"><span class="comment"># 导入 Header</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Header</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># 为了声明headers， 需要使用Header, 否则参数将被解释为查询参数。</span></span><br><span class="line"><span class="comment"># 使用和Path, Query and Cookie 一样的结构定义 header 参数</span></span><br><span class="line"><span class="comment"># 第一个值是默认值，你可以传递所有的额外验证或注释参数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params">user_agent: <span class="type">Optional</span>[<span class="built_in">str</span>] = Header(<span class="params"><span class="literal">None</span></span>)</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;User-Agent&quot;</span>: user_agent&#125;</span><br></pre></td></tr></table></figure></p><h3 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h3><p>Header 在 Path、 Query 和 Cookie 提供的功能之上有一点额外的功能。<br>大多数标准的headers用 “连字符” 分隔，也称为 “减号” (-)。<br>但是像 <code>user-agent</code> 这样的变量在Python中是无效的。<br>因此, 默认情况下, Header 将把参数名称的字符从下划线 (_) 转换为连字符 (-) 来提取并记录 headers.<br>同时，HTTP headers 是大小写不敏感的，因此，因此可以使用标准Python样式(也称为 “<code>snake_case</code>“)声明它们。<br>因此，可以像通常在Python代码中那样使用 <code>user_agent</code> ，而不需要将首字母大写为 <code>User_Agent</code> 或类似的东西。<br>如果出于某些原因，需要禁用下划线到连字符的自动转换，设置Header的参数 <code>convert_underscores</code> 为 <code>False</code>（注意，一些HTTP代理和服务器不允许使用带有下划线的headers。）。</p><h3 id="重复的headers"><a href="#重复的headers" class="headerlink" title="重复的headers"></a>重复的headers</h3><p>有可能收到重复的headers。这意味着，相同的header具有多个值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Header</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># 可以在类型声明中使用一个list来定义这些情况。</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params">x_token: <span class="type">Optional</span>[<span class="type">List</span>[<span class="built_in">str</span>]] = Header(<span class="params"><span class="literal">None</span></span>)</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;X-Token values&quot;</span>: x_token&#125;</span><br></pre></td></tr></table></figure></p><h2 id="响应模型"><a href="#响应模型" class="headerlink" title="响应模型"></a>响应模型</h2><p>可以在任意的路径操作中使用 <code>response_model</code> 参数来声明用于响应的模型。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line">    tags: <span class="type">List</span>[<span class="built_in">str</span>] = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/items/&quot;</span>, response_model=Item</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_item</span>(<span class="params">item: Item</span>):</span></span><br><span class="line">    <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><br>注意，<code>response_model</code>是「装饰器」方法（<code>get</code>，<code>post</code> 等）的一个参数。不像之前的所有参数和请求体，它不属于路径操作函数。<br>它接收的类型与为 Pydantic 模型属性所声明的类型相同，因此它可以是一个 Pydantic 模型，但也可以是一个由 Pydantic 模型组成的 list，例如 <code>List[Item]</code>。<br>FastAPI 将使用此 <code>response_model</code> 来：<br>（1）将输出数据转换为其声明的类型。<br>（2）校验数据。<br>（3）在 OpenAPI 的路径操作中为响应添加一个 JSON Schema。<br>（4）并在自动生成文档系统中使用。<br>但最重要的是：<br>会将输出数据限制在该模型定义内。这一点非常重要。<br>（响应模型在参数中被声明，而不是作为函数返回类型标注，这是因为路径函数可能不会真正返回该响应模型，而是返回一个 dict、数据库对象或其他模型，然后再使用 <code>response_model</code> 来执行字段约束和序列化。）<br>比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, EmailStr</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个有明文密码的输入模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserIn</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    username: <span class="built_in">str</span></span><br><span class="line">    password: <span class="built_in">str</span></span><br><span class="line">    email: EmailStr</span><br><span class="line">    full_name: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个没有明文密码的输出模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserOut</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    username: <span class="built_in">str</span></span><br><span class="line">    email: EmailStr</span><br><span class="line">    full_name: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 response_model 声明为了不包含密码的 UserOut 模型</span></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/user/&quot;</span>, response_model=UserOut</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_user</span>(<span class="params">user: UserIn</span>):</span></span><br><span class="line">    <span class="comment"># 即便我们的路径操作函数将会返回包含密码的相同输入用户</span></span><br><span class="line">    <span class="comment"># FastAPI 将会负责过滤掉未在输出模型中声明的所有数据（使用 Pydantic）。</span></span><br><span class="line">    <span class="keyword">return</span> user</span><br></pre></td></tr></table></figure></p><h3 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    <span class="comment"># 响应模型可以具有默认值</span></span><br><span class="line">    <span class="comment"># 但如果它们并没有存储实际的值，你可能想从结果中忽略它们的默认值。</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="built_in">float</span> = <span class="number">10.5</span></span><br><span class="line">    tags: <span class="type">List</span>[<span class="built_in">str</span>] = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">items = &#123;</span><br><span class="line">    <span class="string">&quot;foo&quot;</span>: &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Foo&quot;</span>, <span class="string">&quot;price&quot;</span>: <span class="number">50.2</span>&#125;,</span><br><span class="line">    <span class="string">&quot;bar&quot;</span>: &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Bar&quot;</span>, <span class="string">&quot;description&quot;</span>: <span class="string">&quot;The bartenders&quot;</span>, <span class="string">&quot;price&quot;</span>: <span class="number">62</span>, <span class="string">&quot;tax&quot;</span>: <span class="number">20.2</span>&#125;,</span><br><span class="line">    <span class="string">&quot;baz&quot;</span>: &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Baz&quot;</span>, <span class="string">&quot;description&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;price&quot;</span>: <span class="number">50.2</span>, <span class="string">&quot;tax&quot;</span>: <span class="number">10.5</span>, <span class="string">&quot;tags&quot;</span>: []&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以设置路径操作装饰器的 response_model_exclude_unset=True 参数</span></span><br><span class="line"><span class="comment"># 这样响应中将不会包含那些默认值，而是仅有实际设置的值，比如foo这个id</span></span><br><span class="line"><span class="comment"># 如果你的数据在具有默认值的模型字段中有实际的值，比如bar这个id，这些值将包含在响应中。</span></span><br><span class="line"><span class="comment"># 如果数据具有与默认值相同的值，例如 ID 为 baz 的项，它们将包含在 JSON 响应中。</span></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span>, response_model=Item, response_model_exclude_unset=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_item</span>(<span class="params">item_id: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> items[item_id]</span><br></pre></td></tr></table></figure><h3 id="多个模型"><a href="#多个模型" class="headerlink" title="多个模型"></a>多个模型</h3><p>从前面的示例继续，拥有多个相关的模型是很常见的。<br>对用户模型来说尤其如此，因为：<br>（1）输入模型需要拥有密码属性。<br>（2）输出模型不应该包含密码。<br>（3）数据库模型很可能需要保存密码的哈希值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, EmailStr</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserIn</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    username: <span class="built_in">str</span></span><br><span class="line">    password: <span class="built_in">str</span></span><br><span class="line">    email: EmailStr</span><br><span class="line">    full_name: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserOut</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    username: <span class="built_in">str</span></span><br><span class="line">    email: EmailStr</span><br><span class="line">    full_name: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInDB</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    username: <span class="built_in">str</span></span><br><span class="line">    hashed_password: <span class="built_in">str</span></span><br><span class="line">    email: EmailStr</span><br><span class="line">    full_name: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fake_password_hasher</span>(<span class="params">raw_password: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;supersecret&quot;</span> + raw_password</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fake_save_user</span>(<span class="params">user_in: UserIn</span>):</span></span><br><span class="line">    hashed_password = fake_password_hasher(user_in.password)</span><br><span class="line">    <span class="comment"># user_in 是一个 UserIn 类的 Pydantic 模型.</span></span><br><span class="line">    <span class="comment"># Pydantic 模型具有 .dict（） 方法，该方法返回一个拥有模型数据的 dict，暂时命名为user_dict。</span></span><br><span class="line">    <span class="comment"># 如果将该dict以 **user_dict 形式传递给一个函数（或类），Python将对其进行「解包」。它会将 user_dict 的键和值作为关键字参数直接传递。</span></span><br><span class="line">    <span class="comment"># 这样就获得了一个来自于其他 Pydantic 模型中的数据的 Pydantic 模型。</span></span><br><span class="line">    user_in_db = UserInDB(**user_in.<span class="built_in">dict</span>(), hashed_password=hashed_password)</span><br><span class="line">    <span class="comment"># 如下效果就是：</span></span><br><span class="line">    <span class="comment"># user_in_db = UserInDB(</span></span><br><span class="line">    <span class="comment">#     username = user_dict[&quot;username&quot;],</span></span><br><span class="line">    <span class="comment">#     password = user_dict[&quot;password&quot;],</span></span><br><span class="line">    <span class="comment">#     email = user_dict[&quot;email&quot;],</span></span><br><span class="line">    <span class="comment">#     full_name = user_dict[&quot;full_name&quot;],</span></span><br><span class="line">    <span class="comment">#     hashed_password = hashed_password,</span></span><br><span class="line">    <span class="comment"># )</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;User saved! ..not really&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> user_in_db</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/user/&quot;</span>, response_model=UserOut</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_user</span>(<span class="params">user_in: UserIn</span>):</span></span><br><span class="line">    user_saved = fake_save_user(user_in)</span><br><span class="line">    <span class="keyword">return</span> user_saved</span><br></pre></td></tr></table></figure></p><p>（1）减少重复<br>减少代码重复是 FastAPI 的核心思想之一。<br>因为代码重复会增加出现 bug、安全性问题、代码失步问题（当你在一个位置更新了代码但没有在其他位置更新）等的可能性。<br>上面的这些模型都共享了大量数据，并拥有重复的属性名称和类型。<br>我们可以声明一个 <code>UserBase</code> 模型作为其他模型的基类。然后可以创建继承该模型属性（类型声明，校验等）的子类。<br>所有的数据转换、校验、文档生成等仍将正常运行。<br>这样，可以仅声明模型之间的差异部分（具有明文的 <code>password</code>、具有 <code>hashed_password</code> 以及不包括密码）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, EmailStr</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserBase</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    username: <span class="built_in">str</span></span><br><span class="line">    email: EmailStr</span><br><span class="line">    full_name: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserIn</span>(<span class="params">UserBase</span>):</span></span><br><span class="line">    password: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserOut</span>(<span class="params">UserBase</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInDB</span>(<span class="params">UserBase</span>):</span></span><br><span class="line">    hashed_password: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fake_password_hasher</span>(<span class="params">raw_password: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;supersecret&quot;</span> + raw_password</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fake_save_user</span>(<span class="params">user_in: UserIn</span>):</span></span><br><span class="line">    hashed_password = fake_password_hasher(user_in.password)</span><br><span class="line">    user_in_db = UserInDB(**user_in.<span class="built_in">dict</span>(), hashed_password=hashed_password)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;User saved! ..not really&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> user_in_db</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/user/&quot;</span>, response_model=UserOut</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_user</span>(<span class="params">user_in: UserIn</span>):</span></span><br><span class="line">    user_saved = fake_save_user(user_in)</span><br><span class="line">    <span class="keyword">return</span> user_saved</span><br></pre></td></tr></table></figure><br>（2）Union 或者 anyOf<br>以将一个响应声明为两种类型的 <code>Union</code>，这意味着该响应将是两种类型中的任何一种。<br>这将在 OpenAPI 中使用 <code>anyOf</code> 进行定义。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseItem</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    description: <span class="built_in">str</span></span><br><span class="line">    <span class="built_in">type</span>: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarItem</span>(<span class="params">BaseItem</span>):</span></span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&quot;car&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlaneItem</span>(<span class="params">BaseItem</span>):</span></span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&quot;plane&quot;</span></span><br><span class="line">    size: <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">items = &#123;</span><br><span class="line">    <span class="string">&quot;item1&quot;</span>: &#123;<span class="string">&quot;description&quot;</span>: <span class="string">&quot;All my friends drive a low rider&quot;</span>, <span class="string">&quot;type&quot;</span>: <span class="string">&quot;car&quot;</span>&#125;,</span><br><span class="line">    <span class="string">&quot;item2&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Music is my aeroplane, it&#x27;s my aeroplane&quot;</span>,</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;plane&quot;</span>,</span><br><span class="line">        <span class="string">&quot;size&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个 Union 类型时，首先包括最详细的类型，然后是不太详细的类型。</span></span><br><span class="line"><span class="comment"># 在下面的示例中，更详细的 PlaneItem 位于 Union[PlaneItem，CarItem] 中的 CarItem 之前。</span></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span>, response_model=<span class="type">Union</span>[CarItem, PlaneItem]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_item</span>(<span class="params">item_id: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> items[item_id]</span><br></pre></td></tr></table></figure></p><p>（3）模型列表<br>可以用同样的方式声明由对象列表构成的响应。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">items = [</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Foo&quot;</span>, <span class="string">&quot;description&quot;</span>: <span class="string">&quot;There comes my hero&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Red&quot;</span>, <span class="string">&quot;description&quot;</span>: <span class="string">&quot;It&#x27;s my aeroplane&quot;</span>&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span>, response_model=<span class="type">List</span>[Item]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>():</span></span><br><span class="line">    <span class="keyword">return</span> items</span><br></pre></td></tr></table></figure><br>（4）任意dict构成的响应<br>还可以使用一个任意的普通 dict 声明响应，仅声明键和值的类型，而不使用 Pydantic 模型。<br>如果你事先不知道有效的字段/属性名称（对于 Pydantic 模型是必需的），这将很有用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/keyword-weights/&quot;</span>, response_model=<span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">float</span>]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_keyword_weights</span>():</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;foo&quot;</span>: <span class="number">2.3</span>, <span class="string">&quot;bar&quot;</span>: <span class="number">3.4</span>&#125;</span><br></pre></td></tr></table></figure></p><h2 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h2><p>与指定响应模型的方式相同，也可以在以下任意的路径操作中使用 <code>status_code</code> 参数来声明用于响应的 HTTP 状态码。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># status_code 参数接收一个表示 HTTP 状态码的数字。</span></span><br><span class="line"><span class="comment"># status_code 也能够接收一个 IntEnum 类型，比如 Python 的 http.HTTPStatus。</span></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/items/&quot;</span>, status_code=<span class="number">201</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_item</span>(<span class="params">name: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;name&quot;</span>: name&#125;</span><br></pre></td></tr></table></figure><br>注意，<code>status_code</code> 是「装饰器」方法（<code>get</code>，<code>post</code> 等）的一个参数。不像之前的所有参数和请求体，它不属于路径操作函数。<br>在 HTTP 协议中，将发送 3 位数的数字状态码作为响应的一部分。<br>这些状态码有一个识别它们的关联名称，但是重要的还是数字。<br>（1）100 及以上状态码用于「消息」响应。很少直接使用它们。具有这些状态代码的响应不能带有响应体。<br>（2）200 及以上状态码用于「成功」响应。这些是最常使用的。</p><ul><li>200 是默认状态代码，它表示一切「正常」。</li><li>201表示「已创建」。它通常在数据库中创建了一条新记录后使用。</li><li>204表示「无内容」。此响应在没有内容返回给客户端时使用，因此该响应不能包含响应体。</li></ul><p>（3）300 及以上状态码用于「重定向」。具有这些状态码的响应可能有或者可能没有响应体，但 304「未修改」是个例外，该响应不得含有响应体。<br>（4）400 及以上状态码用于「客户端错误」响应。这些可能是第二常用的类型。</p><ul><li>404，用于「未找到」响应。</li><li>对于来自客户端的一般错误，可以只使用 400。</li></ul><p>（5）500 及以上状态码用于服务器端错误。几乎永远不会直接使用它们。当你的应用程序代码或服务器中的某些部分出现问题时，它将自动返回这些状态代码之一。<br>要了解有关每个状态代码以及适用场景的更多信息，请查看<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">MDN 关于 HTTP 状态码的文档</a>。</p><h2 id="表单数据"><a href="#表单数据" class="headerlink" title="表单数据"></a>表单数据</h2><p>接收的不是 JSON，而是表单字段时，要使用 Form。<br>要使用表单，需预先安装<code>python-multipart</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install python-multipart</span><br></pre></td></tr></table></figure><br>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 fastapi 导入 Form</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Form</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/login/&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># 创建表单（Form）参数的方式与 Body 和 Query 一样</span></span><br><span class="line"><span class="comment"># OAuth2 规范的 &quot;密码流&quot; 模式规定要通过表单字段发送 username 和 password。</span></span><br><span class="line"><span class="comment"># 该规范要求字段必须命名为 username 和 password，并通过表单字段发送，不能用 JSON。</span></span><br><span class="line"><span class="comment"># 使用 Form 可以声明与 Body （及 Query、Path、Cookie）相同的元数据和验证。</span></span><br><span class="line"><span class="comment"># 声明表单体要显式使用 Form ，否则，FastAPI 会把该参数当作查询参数或请求体（JSON）参数。</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">username: <span class="built_in">str</span> = Form(<span class="params">...</span>), password: <span class="built_in">str</span> = Form(<span class="params">...</span>)</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;username&quot;</span>: username&#125;</span><br></pre></td></tr></table></figure></p><p>与 JSON 不同，HTML 表单（<code>&lt;form&gt;&lt;/form&gt;</code>）向服务器发送数据通常使用「特殊」的编码。<br>FastAPI 要确保从正确的位置读取数据，而不是读取 JSON。<br>表单数据的「媒体类型」编码一般为 <code>application/x-www-form-urlencoded</code>。<br>但包含文件的表单编码为 <code>multipart/form-data</code>。文件处理详见下节。</p><p>可在一个路径操作中声明多个 Form 参数，但不能同时声明要接收 JSON 的 Body 字段。因为此时请求体的编码是 <code>application/x-www-form-urlencoded</code>，不是 <code>application/json</code>。<br>这不是 FastAPI 的问题，而是 HTTP 协议的规定。</p><h2 id="请求文件"><a href="#请求文件" class="headerlink" title="请求文件"></a>请求文件</h2><p><code>File</code> 用于定义客户端的上传文件。<br>因为上传文件以「表单数据」形式发送。<br>所以接收上传文件，要预先安装 <code>python-multipart</code>。<br>有两种文件请求方式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 fastapi 导入 File 和 UploadFile</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, File, UploadFile</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/files/&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># 创建文件（File）参数的方式与 Body 和 Form 一样</span></span><br><span class="line"><span class="comment"># 声明文件体必须使用 File，否则，FastAPI 会把该参数当作查询参数或请求体（JSON）参数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果把路径操作函数参数的类型声明为 bytes，FastAPI 将以 bytes 形式读取和接收文件内容。</span></span><br><span class="line"><span class="comment"># 这种方式把文件的所有内容都存储在内存里，适用于小型文件。</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_file</span>(<span class="params">file: <span class="built_in">bytes</span> = File(<span class="params">...</span>)</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;file_size&quot;</span>: <span class="built_in">len</span>(file)&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/uploadfile/&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># 不过，很多情况下，UploadFile 更好用。</span></span><br><span class="line"><span class="comment"># 定义 File 参数时使用 UploadFile</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_upload_file</span>(<span class="params">file: UploadFile</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;filename&quot;</span>: file.filename&#125;</span><br></pre></td></tr></table></figure><br>UploadFile 与 bytes 相比有更多优势：<br>（1）使用 spooled 文件：存储在内存的文件超出最大上限时，FastAPI 会把文件存入磁盘；<br>（2）这种方式更适于处理图像、视频、二进制文件等大型文件，好处是不会占用所有内存；<br>（3）可获取上传文件的元数据；<br>（4）自带 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-file-like-object">file-like</a> <code>async</code> 接口；<br>（5）它暴露了一个 Python <code>SpooledTemporaryFile</code> 对象，可直接传递给其他想要<code>file-like</code>对象的库。</p><p>UploadFile 的属性如下：<br>（1）<code>filename</code>：上传文件的文件名字符串（str），例如<code>myimage.jpg</code>；<br>（2）<code>content_type</code>：内容的类型（MIME 类型 / 媒体类型）字符串（str），例如<code>image/jpeg</code>；<br>（3）<code>file</code>： <code>SpooledTemporaryFile</code>（一个<code>file-like</code> 对象）。该对象可直接传递给其他想要 <code>file-like</code> 对象的函数或库。</p><p>UploadFile 支持以下 <code>async</code> 方法，（使用内部 <code>SpooledTemporaryFile</code>）可调用如下方法。<br>（1）<code>write(data)</code>：把 <code>data</code> （<code>str</code> 或 <code>bytes</code>）写入文件；<br>（2）<code>read(size)</code>：按指定数量的字节或字符（<code>size (int)</code>）读取文件内容；<br>（3）<code>seek(offset)</code>：移动至文件<code>offset (int)</code> 字节处的位置；<br>例如，<code>await myfile.seek(0)</code>移动到文件开头；<br>执行 <code>await myfile.read()</code> 后，需再次读取已读取内容时，这种方法特别好用。<br>（4）<code>close()</code>：关闭文件。<br>因为上述方法都是 <code>async</code> 方法，要搭配<code>await</code>使用。<br>例如，在 <code>async</code> 路径操作函数 内，要用以下方式读取文件内容：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contents = <span class="keyword">await</span> myfile.read()</span><br></pre></td></tr></table></figure><br>在普通 <code>def</code> 路径操作函数 内，则可以直接访问<code>UploadFile.file</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contents = myfile.file.read()</span><br></pre></td></tr></table></figure></p><p>多文件上传：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, File, UploadFile</span><br><span class="line"><span class="keyword">from</span> fastapi.responses <span class="keyword">import</span> HTMLResponse</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/files/&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># 可用同一个「表单字段」发送含多个文件的「表单数据」。</span></span><br><span class="line"><span class="comment"># 上传多个文件时，要声明含 bytes 或 UploadFile 的列表（List）：</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_files</span>(<span class="params">files: <span class="type">List</span>[<span class="built_in">bytes</span>] = File(<span class="params">...</span>)</span>):</span></span><br><span class="line">    <span class="comment"># 接收的也是含 bytes 或 UploadFile 的列表（list）。</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;file_sizes&quot;</span>: [<span class="built_in">len</span>(file) <span class="keyword">for</span> file <span class="keyword">in</span> files]&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/uploadfiles/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_upload_files</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 也可以声明元数据</span></span></span></span><br><span class="line"><span class="function"><span class="params">    files: <span class="type">List</span>[UploadFile] = File(<span class="params">..., description=<span class="string">&quot;Multiple files as UploadFile&quot;</span></span>)</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;filenames&quot;</span>: [file.filename <span class="keyword">for</span> file <span class="keyword">in</span> files]&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    content = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;form action=&quot;/files/&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;input name=&quot;files&quot; type=&quot;file&quot; multiple&gt;</span></span><br><span class="line"><span class="string">&lt;input type=&quot;submit&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;form action=&quot;/uploadfiles/&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;input name=&quot;files&quot; type=&quot;file&quot; multiple&gt;</span></span><br><span class="line"><span class="string">&lt;input type=&quot;submit&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> HTMLResponse(content=content)</span><br></pre></td></tr></table></figure></p><h2 id="请求表单和文件"><a href="#请求表单和文件" class="headerlink" title="请求表单和文件"></a>请求表单和文件</h2><p>FastAPI 支持同时使用 <code>File</code> 和 <code>Form</code> 定义文件和表单字段。<br>在同一个请求中接收数据和文件时，应同时使用 File 和 Form。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, File, Form, UploadFile</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/files/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_file</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 创建文件和表单参数的方式与 Body 和 Query 一样</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 可在一个路径操作中声明多个 File 与 Form 参数，但不能同时声明要接收 JSON 的 Body 字段。因为此时请求体的编码为 multipart/form-data，不是 application/json。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 这不是 FastAPI 的问题，而是 HTTP 协议的规定。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    file: <span class="built_in">bytes</span> = File(<span class="params">...</span>), fileb: UploadFile = File(<span class="params">...</span>), token: <span class="built_in">str</span> = Form(<span class="params">...</span>)</span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;file_size&quot;</span>: <span class="built_in">len</span>(file),</span><br><span class="line">        <span class="string">&quot;token&quot;</span>: token,</span><br><span class="line">        <span class="string">&quot;fileb_content_type&quot;</span>: fileb.content_type,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h2><p>某些情况下，需要向客户端返回错误提示。<br>这里所谓的客户端包括前端浏览器、其他应用程序、物联网设备等。<br>需要向客户端返回错误提示的场景主要如下：<br>（1）客户端没有执行操作的权限<br>（2）客户端没有访问资源的权限<br>（3）客户端要访问的项目不存在<br>等等 …<br>遇到这些情况时，通常要返回 4XX（400 至 499）HTTP 状态码。</p><h3 id="使用HTTPException"><a href="#使用HTTPException" class="headerlink" title="使用HTTPException"></a>使用HTTPException</h3><p>向客户端返回 HTTP 错误响应，可以使用 <code>HTTPException</code>。<br>HTTPException 是一个常规 Python 异常，包含了和 API 有关的额外数据。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 HTTPException</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, HTTPException</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line">items = &#123;<span class="string">&quot;foo&quot;</span>: <span class="string">&quot;The Foo Wrestlers&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_item</span>(<span class="params">item_id: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> item_id <span class="keyword">not</span> <span class="keyword">in</span> items:</span><br><span class="line">        <span class="comment"># 因为是 Python 异常，所以不能 return，只能 raise。</span></span><br><span class="line">        <span class="comment"># 如在调用路径操作函数里的工具函数时，触发了 HTTPException，FastAPI 就不再继续执行路径操作函数中的后续代码，而是立即终止请求，并把 HTTPException 的 HTTP 错误发送至客户端。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 触发 HTTPException 时，可以用参数 detail 传递任何能转换为 JSON 的值，不仅限于 str。</span></span><br><span class="line">        <span class="comment"># 还支持传递 dict、list 等数据结构。</span></span><br><span class="line">        <span class="comment"># FastAPI 能自动处理这些数据，并将之转换为 JSON。</span></span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">404</span>, detail=<span class="string">&quot;Item not found&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;item&quot;</span>: items[item_id]&#125;</span><br></pre></td></tr></table></figure><br>有些场景下要为 HTTP 错误添加自定义响应头。例如，出于某些方面的安全需要。<br>一般情况下可能不会需要在代码中直接使用响应头。<br>但对于某些高级应用场景，还是需要添加自定义响应头：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, HTTPException</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line">items = &#123;<span class="string">&quot;foo&quot;</span>: <span class="string">&quot;The Foo Wrestlers&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items-header/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_item_header</span>(<span class="params">item_id: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> item_id <span class="keyword">not</span> <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(</span><br><span class="line">            status_code=<span class="number">404</span>,</span><br><span class="line">            detail=<span class="string">&quot;Item not found&quot;</span>,</span><br><span class="line">            headers=&#123;<span class="string">&quot;X-Error&quot;</span>: <span class="string">&quot;There goes my error&quot;</span>&#125;,</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;item&quot;</span>: items[item_id]&#125;</span><br></pre></td></tr></table></figure></p><h3 id="安装自定义异常处理器"><a href="#安装自定义异常处理器" class="headerlink" title="安装自定义异常处理器"></a>安装自定义异常处理器</h3><p>添加自定义处理器，要使用<a href="https://www.starlette.io/exceptions/">Starlette 的异常工具</a>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Request</span><br><span class="line"><span class="keyword">from</span> fastapi.responses <span class="keyword">import</span> JSONResponse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设要触发的自定义异常叫作 UnicornException。</span></span><br><span class="line"><span class="comment"># 且需要 FastAPI 实现全局处理该异常。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnicornException</span>(<span class="params">Exception</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name: <span class="built_in">str</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以用 @app.exception_handler() 添加自定义异常控制器</span></span><br><span class="line"><span class="meta">@app.exception_handler(<span class="params">UnicornException</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">unicorn_exception_handler</span>(<span class="params">request: Request, exc: UnicornException</span>):</span></span><br><span class="line">    <span class="comment"># 接收到的错误信息清晰明了，HTTP 状态码为 418，JSON 内容如下：</span></span><br><span class="line">    <span class="keyword">return</span> JSONResponse(</span><br><span class="line">        status_code=<span class="number">418</span>,</span><br><span class="line">        content=&#123;<span class="string">&quot;message&quot;</span>: <span class="string">f&quot;Oops! <span class="subst">&#123;exc.name&#125;</span> did something. There goes a rainbow...&quot;</span>&#125;,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/unicorns/&#123;name&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_unicorn</span>(<span class="params">name: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="comment"># 请求 /unicorns/yolo 时，路径操作会触发 UnicornException。</span></span><br><span class="line">    <span class="comment"># 但该异常将会被 unicorn_exception_handler 处理。</span></span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">&quot;yolo&quot;</span>:</span><br><span class="line">        <span class="keyword">raise</span> UnicornException(name=name)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;unicorn_name&quot;</span>: name&#125;</span><br></pre></td></tr></table></figure></p><h3 id="覆盖默认异常处理器"><a href="#覆盖默认异常处理器" class="headerlink" title="覆盖默认异常处理器"></a>覆盖默认异常处理器</h3><p>FastAPI 自带了一些默认异常处理器。<br>触发 <code>HTTPException</code> 或请求无效数据时，这些处理器返回默认的 JSON 响应结果。<br>不过，也可以使用自定义处理器覆盖默认异常处理器。<br>（这部分内容太高阶，且一般情况下使用默认异常处理器即可。跳过本部分）</p><h2 id="路径操作配置"><a href="#路径操作配置" class="headerlink" title="路径操作配置"></a>路径操作配置</h2><p>路径操作装饰器支持多种配置参数。<br>通过传递参数给路径操作装饰器 ，即可轻松地配置路径操作、添加元数据。<br>注意：以下参数应直接传递给路径操作装饰器，不能传递给路径操作函数。</p><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p><code>status_code</code> 用于定义路径操作响应中的 HTTP 状态码。<br>可以直接传递 <code>int</code> 代码， 比如 404。<br>如果记不住数字码的涵义，也可以用 <code>status</code> 的快捷常量，如<code>status.HTTP_201_CREATED</code>。</p><h3 id="tags参数"><a href="#tags参数" class="headerlink" title="tags参数"></a>tags参数</h3><p>tags 参数的值是由 str 组成的 list （一般只有一个 str ），tags 用于为路径操作添加标签。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span>, <span class="type">Set</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line">    tags: <span class="type">Set</span>[<span class="built_in">str</span>] = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/items/&quot;</span>, response_model=Item, tags=[<span class="string">&quot;items&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_item</span>(<span class="params">item: Item</span>):</span></span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span>, tags=[<span class="string">&quot;items&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Foo&quot;</span>, <span class="string">&quot;price&quot;</span>: <span class="number">42</span>&#125;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/users/&quot;</span>, tags=[<span class="string">&quot;users&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_users</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;username&quot;</span>: <span class="string">&quot;johndoe&quot;</span>&#125;]</span><br></pre></td></tr></table></figure><br>OpenAPI schema会自动添加标签，供 API 文档接口使用。</p><h3 id="summary-和-description-参数"><a href="#summary-和-description-参数" class="headerlink" title="summary 和 description 参数"></a>summary 和 description 参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span>, <span class="type">Set</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line">    tags: <span class="type">Set</span>[<span class="built_in">str</span>] = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"></span></span></span><br><span class="line"><span class="meta"><span class="params">    <span class="string">&quot;/items/&quot;</span>,</span></span></span><br><span class="line"><span class="meta"><span class="params">    response_model=Item,</span></span></span><br><span class="line"><span class="meta"><span class="params">    <span class="comment"># 对api的概要</span></span></span></span><br><span class="line"><span class="meta"><span class="params">    summary=<span class="string">&quot;Create an item&quot;</span>,</span></span></span><br><span class="line"><span class="meta"><span class="params">    <span class="comment"># 详细说明，更复杂的说明可以使用下面的文档字符串</span></span></span></span><br><span class="line"><span class="meta"><span class="params">    description=<span class="string">&quot;Create an item with all the information, name, description, price, tax and a set of unique tags&quot;</span>,</span></span></span><br><span class="line"><span class="meta"><span class="params"></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_item</span>(<span class="params">item: Item</span>):</span></span><br><span class="line">    <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><h3 id="文档字符串"><a href="#文档字符串" class="headerlink" title="文档字符串"></a>文档字符串</h3><p>描述内容比较长且占用多行时，可以在函数的 docstring 中声明路径操作的描述，FastAPI 支持从文档字符串中读取描述内容。<br>文档字符串支持 Markdown，能正确解析和显示 Markdown 的内容，但要注意文档字符串的缩进。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span>, <span class="type">Set</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line">    tags: <span class="type">Set</span>[<span class="built_in">str</span>] = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/items/&quot;</span>, response_model=Item, summary=<span class="string">&quot;Create an item&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_item</span>(<span class="params">item: Item</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Create an item with all the information:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    - **name**: each item must have a name</span></span><br><span class="line"><span class="string">    - **description**: a long description</span></span><br><span class="line"><span class="string">    - **price**: required</span></span><br><span class="line"><span class="string">    - **tax**: if the item doesn&#x27;t have tax, you can omit this</span></span><br><span class="line"><span class="string">    - **tags**: a set of unique tag strings for this item</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure></p><h3 id="响应描述"><a href="#响应描述" class="headerlink" title="响应描述"></a>响应描述</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span>, <span class="type">Set</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line">    tags: <span class="type">Set</span>[<span class="built_in">str</span>] = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"></span></span></span><br><span class="line"><span class="meta"><span class="params">    <span class="string">&quot;/items/&quot;</span>,</span></span></span><br><span class="line"><span class="meta"><span class="params">    response_model=Item,</span></span></span><br><span class="line"><span class="meta"><span class="params">    summary=<span class="string">&quot;Create an item&quot;</span>,</span></span></span><br><span class="line"><span class="meta"><span class="params">    <span class="comment"># response_description 参数用于定义响应的描述说明</span></span></span></span><br><span class="line"><span class="meta"><span class="params">    <span class="comment"># OpenAPI 规定每个路径操作都要有响应描述。</span></span></span></span><br><span class="line"><span class="meta"><span class="params">    <span class="comment"># 如果没有定义响应描述，FastAPI 则自动生成内容为 &quot;Successful response&quot; 的响应描述。</span></span></span></span><br><span class="line"><span class="meta"><span class="params">    response_description=<span class="string">&quot;The created item&quot;</span>,</span></span></span><br><span class="line"><span class="meta"><span class="params"></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_item</span>(<span class="params">item: Item</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Create an item with all the information:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    - **name**: each item must have a name</span></span><br><span class="line"><span class="string">    - **description**: a long description</span></span><br><span class="line"><span class="string">    - **price**: required</span></span><br><span class="line"><span class="string">    - **tax**: if the item doesn&#x27;t have tax, you can omit this</span></span><br><span class="line"><span class="string">    - **tags**: a set of unique tag strings for this item</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><h3 id="弃用路径操作"><a href="#弃用路径操作" class="headerlink" title="弃用路径操作"></a>弃用路径操作</h3><p><code>deprecated</code> 参数可以把路径操作标记为弃用，无需直接删除。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span>, tags=[<span class="string">&quot;items&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Foo&quot;</span>, <span class="string">&quot;price&quot;</span>: <span class="number">42</span>&#125;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/users/&quot;</span>, tags=[<span class="string">&quot;users&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_users</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;username&quot;</span>: <span class="string">&quot;johndoe&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/elements/&quot;</span>, tags=[<span class="string">&quot;items&quot;</span>], deprecated=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_elements</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;item_id&quot;</span>: <span class="string">&quot;Foo&quot;</span>&#125;]</span><br></pre></td></tr></table></figure></p><h2 id="JSON兼容编码器"><a href="#JSON兼容编码器" class="headerlink" title="JSON兼容编码器"></a>JSON兼容编码器</h2><p>在某些情况下，可能需要将一个数据类型（如 Pydantic 模型）转换为与 JSON 兼容的类型（如<code>dict</code>、<code>list</code>等）。<br>比如想将该数据存储在数据库中。<br>为此，FastAPI提供了一个<code>jsonable_encoder()</code>功能。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="comment"># 导入jsonable_encoder</span></span><br><span class="line"><span class="keyword">from</span> fastapi.encoders <span class="keyword">import</span> jsonable_encoder</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设fake_db数据库只接收 JSON 兼容的数据。</span></span><br><span class="line"><span class="comment"># 例如，它不接收datetime对象，因为它们与 JSON 不兼容。</span></span><br><span class="line"><span class="comment"># 因此，datetime对象必须转换为包含ISO格式数据的str对象。</span></span><br><span class="line"><span class="comment"># 同样，该数据库不会接收 Pydantic 模型（具有属性的对象），只会接收dict.</span></span><br><span class="line">fake_db = &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    title: <span class="built_in">str</span></span><br><span class="line">    timestamp: datetime</span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.put(<span class="params"><span class="string">&quot;/items/&#123;id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params"><span class="built_in">id</span>: <span class="built_in">str</span>, item: Item</span>):</span></span><br><span class="line">    <span class="comment"># jsonable_encoder将 Pydantic 模型转换为一个dict，并将datetime转换为str。</span></span><br><span class="line">    <span class="comment"># 它不会返回一个大的str，里面包含JSON格式的数据（作为字符串）。</span></span><br><span class="line">    <span class="comment"># 而是返回一个Python标准数据结构（例如一个dict），其中的值和子值都与 JSON 兼容。</span></span><br><span class="line">    json_compatible_item_data = jsonable_encoder(item)</span><br><span class="line">    fake_db[<span class="built_in">id</span>] = json_compatible_item_data</span><br></pre></td></tr></table></figure></p><h2 id="依赖项"><a href="#依赖项" class="headerlink" title="依赖项"></a>依赖项</h2><p>FastAPI 提供了简单易用，但功能强大的依赖注入系统。<br>这个依赖系统设计的简单易用，可以让开发人员轻松地把组件集成至 FastAPI。</p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>编程中的「依赖注入」是声明代码（本文中为路径操作函数 ）运行所需的，或要使用的「依赖」的一种方式。<br>然后，由系统（本文中为 FastAPI）负责执行任意需要的逻辑，为代码提供这些依赖（「注入」依赖项）。<br>依赖注入常用于以下场景：<br>（1）共享业务逻辑（复用相同的代码逻辑）<br>（2）共享数据库连接<br>（3）实现安全、验证、角色权限<br>等……<br>上述场景均可以使用依赖注入，将代码重复最小化。<br>依赖注入系统支持构建集成和「插件」。但实际上，FastAPI 根本不需要创建「插件」，因为使用依赖项可以声明不限数量的、可用于路径操作函数的集成与交互。<br>创建依赖项非常简单、直观，并且还支持导入 Python 包。毫不夸张地说，只要几行代码就可以把需要的 Python 包与 API 函数集成在一起。</p><h3 id="FastAPI-兼容性"><a href="#FastAPI-兼容性" class="headerlink" title="FastAPI 兼容性"></a>FastAPI 兼容性</h3><p>依赖注入系统如此简洁的特性，让 FastAPI 可以与下列系统兼容：</p><ul><li>关系型数据库</li><li>NoSQL 数据库</li><li>外部支持库</li><li>外部 API</li><li>认证和鉴权系统</li><li>API 使用监控系统</li><li>响应数据注入系统<br>等等……</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"><span class="comment"># 导入 Depends</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Depends, FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建依赖项</span></span><br><span class="line"><span class="comment"># 依赖项函数的形式和结构与路径操作函数一样。</span></span><br><span class="line"><span class="comment"># 可以把依赖项当作没有「装饰器」（即，没有 @app.get(&quot;/some-path&quot;) ）的路径操作函数。</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">common_parameters</span>(<span class="params">q: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>, skip: <span class="built_in">int</span> = <span class="number">0</span>, limit: <span class="built_in">int</span> = <span class="number">100</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;q&quot;</span>: q, <span class="string">&quot;skip&quot;</span>: skip, <span class="string">&quot;limit&quot;</span>: limit&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明依赖项</span></span><br><span class="line"><span class="comment"># 与在路径操作函数参数中使用 Body、Query 的方式相同，声明依赖项需要使用 Depends 和一个新的参数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 虽然，在路径操作函数的参数中使用 Depends 的方式与 Body、Query 相同，但 Depends 的工作方式略有不同。</span></span><br><span class="line"><span class="comment"># 这里只能传给 Depends 一个参数。</span></span><br><span class="line"><span class="comment"># 且该参数必须是可调用对象，比如函数。</span></span><br><span class="line"><span class="comment"># 该函数接收的参数和路径操作函数的参数一样。</span></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params">commons: <span class="built_in">dict</span> = Depends(<span class="params">common_parameters</span>)</span>):</span></span><br><span class="line">    <span class="keyword">return</span> commons</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收到新的请求时，FastAPI 执行如下操作：</span></span><br><span class="line"><span class="comment"># （1）用正确的参数调用依赖项函数（「可依赖项」）</span></span><br><span class="line"><span class="comment"># （2）获取函数返回的结果</span></span><br><span class="line"><span class="comment"># （3）把函数返回的结果赋值给路径操作函数的参数</span></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/users/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_users</span>(<span class="params">commons: <span class="built_in">dict</span> = Depends(<span class="params">common_parameters</span>)</span>):</span></span><br><span class="line">    <span class="keyword">return</span> commons</span><br></pre></td></tr></table></figure><p>虽然，层级式依赖注入系统的定义与使用十分简单，但它却非常强大。<br>比如，可以定义依赖其他依赖项的依赖项。<br>最后，依赖项层级树构建后，依赖注入系统会处理所有依赖项及其子依赖项，并为每一步操作提供（注入）结果。</p><h3 id="类作为依赖项"><a href="#类作为依赖项" class="headerlink" title="类作为依赖项"></a>类作为依赖项</h3><p>上面例子中依赖项的声明是个函数，它的返回值是个字典。这种方式可行，但可以更好，比如此时编辑器就没法提供很好的支持，因为它不知道字典的键和值是什么。<br>函数并不是声明依赖关系的唯一方法（尽管它可能更常见）。关键因素是依赖项应该是“可调用的”。<br>Python 中的“可调用”是 Python 可以像函数一样“调用”的任何东西，比如类<code>class</code>也是可调用的。</p><p>FastAPI 实际检查的是它是“可调用的”（函数、类或其他任何东西）和定义的参数。<br>如果在FastAPI 中将“可调用”作为依赖项传递，它将分析该“可调用”的参数，并以与路径操作函数的参数相同的方式处理它们。包括子依赖。<br>这也适用于完全没有参数的可调用对象。与没有参数的路径操作函数相同。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Depends, FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_items_db = [&#123;<span class="string">&quot;item_name&quot;</span>: <span class="string">&quot;Foo&quot;</span>&#125;, &#123;<span class="string">&quot;item_name&quot;</span>: <span class="string">&quot;Bar&quot;</span>&#125;, &#123;<span class="string">&quot;item_name&quot;</span>: <span class="string">&quot;Baz&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将依赖项从上面的函数common_parameters更改为类CommonQueryParams</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonQueryParams</span>:</span></span><br><span class="line">    <span class="comment"># __init__用于创建类实例的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, q: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>, skip: <span class="built_in">int</span> = <span class="number">0</span>, limit: <span class="built_in">int</span> = <span class="number">100</span></span>):</span></span><br><span class="line">        self.q = q</span><br><span class="line">        self.skip = skip</span><br><span class="line">        self.limit = limit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># 使用这个类来声明依赖</span></span><br><span class="line"><span class="comment"># 这将创建该类的“实例”，并且该实例将作为参数传递commons给函数。</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params">commons: CommonQueryParams = Depends(<span class="params">CommonQueryParams</span>)</span>):</span></span><br><span class="line">    response = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> commons.q:</span><br><span class="line">        response.update(&#123;<span class="string">&quot;q&quot;</span>: commons.q&#125;)</span><br><span class="line">    items = fake_items_db[commons.skip : commons.skip + commons.limit]</span><br><span class="line">    response.update(&#123;<span class="string">&quot;items&quot;</span>: items&#125;)</span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure></p><h3 id="子依赖项"><a href="#子依赖项" class="headerlink" title="子依赖项"></a>子依赖项</h3><p>FastAPI 支持创建含子依赖项的依赖项。<br>并且，可以按需声明任意深度的子依赖项嵌套层级。<br>FastAPI 负责处理解析不同深度的子依赖项。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Cookie, Depends, FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建第一层依赖项</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query_extractor</span>(<span class="params">q: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建另一个依赖项函数，并同时再声明一个依赖项</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query_or_cookie_extractor</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    q: <span class="built_in">str</span> = Depends(<span class="params">query_extractor</span>), last_query: <span class="type">Optional</span>[<span class="built_in">str</span>] = Cookie(<span class="params"><span class="literal">None</span></span>)</span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> q:</span><br><span class="line">        <span class="keyword">return</span> last_query</span><br><span class="line">    <span class="keyword">return</span> q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_query</span>(<span class="params">query_or_default: <span class="built_in">str</span> = Depends(<span class="params">query_or_cookie_extractor</span>)</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;q_or_cookie&quot;</span>: query_or_default&#125;</span><br></pre></td></tr></table></figure><br>如果在同一个路径操作 多次声明了同一个依赖项，例如，多个依赖项共用一个子依赖项，FastAPI 在处理同一请求时，只调用一次该子依赖项。<br>FastAPI 不会为同一个请求多次调用同一个依赖项，而是把依赖项的返回值进行「缓存」，并把它传递给同一请求中所有需要使用该返回值的「依赖项」。<br>在高级使用场景中，如果不想使用「缓存」值，而是为需要在同一请求的每一步操作（多次）中都实际调用依赖项，可以把 Depends 的参数 <code>use_cache</code> 的值设置为 <code>False</code> :<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">needy_dependency</span>(<span class="params">fresh_value: <span class="built_in">str</span> = Depends(<span class="params">get_value, use_cache=<span class="literal">False</span></span>)</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;fresh_value&quot;</span>: fresh_value&#125;</span><br></pre></td></tr></table></figure></p><h3 id="路径操作装饰器中的依赖项"><a href="#路径操作装饰器中的依赖项" class="headerlink" title="路径操作装饰器中的依赖项"></a>路径操作装饰器中的依赖项</h3><p>有时，我们并不需要在路径操作函数中使用依赖项的返回值。或者说，有些依赖项不返回值。<br>但仍要执行或解析该依赖项。<br>对于这种情况，不必在声明路径操作函数的参数时使用 Depends，而是可以在路径操作装饰器中添加一个由 <code>dependencies</code> 组成的 <code>list</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Depends, FastAPI, Header, HTTPException</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">verify_token</span>(<span class="params">x_token: <span class="built_in">str</span> = Header(<span class="params">...</span>)</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x_token != <span class="string">&quot;fake-super-secret-token&quot;</span>:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">400</span>, detail=<span class="string">&quot;X-Token header invalid&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">verify_key</span>(<span class="params">x_key: <span class="built_in">str</span> = Header(<span class="params">...</span>)</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x_key != <span class="string">&quot;fake-super-secret-key&quot;</span>:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">400</span>, detail=<span class="string">&quot;X-Key header invalid&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> x_key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 路径操作装饰器支持可选参数dependencies。</span></span><br><span class="line"><span class="comment"># 该参数的值是由 Depends() 组成的 list</span></span><br><span class="line"><span class="comment"># 路径操作装饰器依赖项（以下简称为“路径装饰器依赖项”）的执行或解析方式和普通依赖项一样，但就算这些依赖项会返回值，它们的值也不会传递给路径操作函数。</span></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span>, dependencies=[Depends(<span class="params">verify_token</span>), Depends(<span class="params">verify_key</span>)]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;item&quot;</span>: <span class="string">&quot;Foo&quot;</span>&#125;, &#123;<span class="string">&quot;item&quot;</span>: <span class="string">&quot;Bar&quot;</span>&#125;]</span><br></pre></td></tr></table></figure></p><h3 id="全局依赖项"><a href="#全局依赖项" class="headerlink" title="全局依赖项"></a>全局依赖项</h3><p>有时，我们要为整个应用添加依赖项。<br>通过与定义路径装饰器依赖项 类似的方式，可以把依赖项添加至整个 FastAPI 应用。<br>这样一来，就可以为所有路径操作应用该依赖项。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Depends, FastAPI, Header, HTTPException</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">verify_token</span>(<span class="params">x_token: <span class="built_in">str</span> = Header(<span class="params">...</span>)</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x_token != <span class="string">&quot;fake-super-secret-token&quot;</span>:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">400</span>, detail=<span class="string">&quot;X-Token header invalid&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">verify_key</span>(<span class="params">x_key: <span class="built_in">str</span> = Header(<span class="params">...</span>)</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x_key != <span class="string">&quot;fake-super-secret-key&quot;</span>:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">400</span>, detail=<span class="string">&quot;X-Key header invalid&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> x_key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局依赖项</span></span><br><span class="line"><span class="comment"># 路径装饰器依赖项一节的思路均适用于全局依赖项</span></span><br><span class="line">app = FastAPI(dependencies=[Depends(verify_token), Depends(verify_key)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;item&quot;</span>: <span class="string">&quot;Portal Gun&quot;</span>&#125;, &#123;<span class="string">&quot;item&quot;</span>: <span class="string">&quot;Plumbus&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/users/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_users</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;username&quot;</span>: <span class="string">&quot;Rick&quot;</span>&#125;, &#123;<span class="string">&quot;username&quot;</span>: <span class="string">&quot;Morty&quot;</span>&#125;]</span><br></pre></td></tr></table></figure></p><h3 id="有yield的依赖项"><a href="#有yield的依赖项" class="headerlink" title="有yield的依赖项"></a>有yield的依赖项</h3><p>FastAPI 支持在完成后执行一些额外步骤的依赖项。<br>为此，请使用<code>yield</code>代替<code>return</code>，并在之后编写额外的步骤。<br>确保使用<code>yield</code>一次。<br>一个典型例子是想在发送请求时创建一个数据库对话，然后发送完成后就关闭它。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># async或普通函数都可以</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_db</span>():</span></span><br><span class="line">    <span class="comment"># 只有在yield之前和包含yield那行代码会在发送请求前执行</span></span><br><span class="line">    db = DBSession()</span><br><span class="line">    <span class="keyword">try</span>: <span class="comment">#使用try能收到异常</span></span><br><span class="line">        <span class="comment"># yield的值会注入到路径操作中，或其他依赖中</span></span><br><span class="line">        <span class="keyword">yield</span> db</span><br><span class="line">    <span class="comment"># 在yield之后的代码会在发送响应后再执行</span></span><br><span class="line">    <span class="keyword">finally</span>: <span class="comment"># 使用finally来确保执行退出步骤，无论是否有异常。</span></span><br><span class="line">        db.close()</span><br></pre></td></tr></table></figure></p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>有许多方法可以处理安全性、身份认证和授权等问题。<br>而且这通常是一个复杂而「困难」的话题。<br>在许多框架和系统中，仅处理安全性和身份认证就会花费大量的精力和代码（在许多情况下，可能占编写的所有代码的 50％ 或更多）。<br>FastAPI 提供了多种工具，可帮助你以标准的方式轻松、快速地处理安全性，而无需研究和学习所有的安全规范。</p><h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><p>（1）OAuth2<br>OAuth2是一个规范，它定义了几种处理身份认证和授权的方法。<br>它是一个相当广泛的规范，涵盖了一些复杂的使用场景。<br>它包括了使用「第三方」进行身份认证的方法。这就是所有带有「使用 Facebook，Google，Twitter，GitHub 登录」的系统背后所使用的机制。<br>有一个 OAuth 1，它与 OAuth2 完全不同，并且更为复杂，因为它直接包含了有关如何加密通信的规范。<br>如今它已经不是很流行，没有被广泛使用了。<br>OAuth2 没有指定如何加密通信，它期望你为应用程序使用 HTTPS 进行通信。<br>（2）OpenID Connect<br>OpenID Connect 是另一个基于 OAuth2 的规范。<br>它只是扩展了 OAuth2，并明确了一些在 OAuth2 中相对模糊的内容，以尝试使其更具互操作性。<br>例如，Google 登录使用 OpenID Connect（底层使用OAuth2）。<br>但是 Facebook 登录不支持 OpenID Connect。它具有自己的 OAuth2 风格。<br>（3）OpenID（非「OpenID Connect」）<br>还有一个「OpenID」规范。它试图解决与 OpenID Connect 相同的问题，但它不是基于 OAuth2。<br>因此，它是一个完整的附加系统。<br>如今它已经不是很流行，没有被广泛使用了。<br>（4）OpenAPI<br>OpenAPI（以前称为 Swagger）是用于构建 API 的开放规范（现已成为 Linux Foundation 的一部分）。<br>FastAPI 基于 OpenAPI。<br>这就是使多个自动交互式文档界面，代码生成等成为可能的原因。<br>OpenAPI 有一种定义多个安全「方案」的方法。<br>通过使用它们，你可以利用所有这些基于标准的工具，包括这些交互式文档系统。<br>OpenAPI 定义了以下安全方案：<br>（4.1）<code>apiKey</code>：一个特定于应用程序的密钥，可以来自：查询参数、请求头、cookie。<br>（4.2）<code>http</code>：标准的 HTTP 身份认证系统，包括：</p><ul><li>bearer: 一个值为 Bearer 加令牌字符串的 Authorization 请求头。这是从 OAuth2 继承的。</li><li>HTTP Basic 认证方式。</li><li>HTTP Digest，等等。</li></ul><p>（4.3）<code>oauth2</code>：所有的 OAuth2 处理安全性的方式（称为「流程」）。<br>以下几种流程适合构建 OAuth 2.0 身份认证的提供者（例如 Google，Facebook，Twitter，GitHub 等）：<code>implicit</code>、<code>clientCredentials</code>、<code>authorizationCode</code>。<br>但是有一个特定的「流程」可以完美地用于直接在同一应用程序中处理身份认证：<code>password</code>：接下来的几章将介绍它的示例。<br>（4.4）<code>openIdConnect</code>：提供了一种定义如何自动发现 OAuth2 身份认证数据的方法。此自动发现机制是 OpenID Connect 规范中定义的内容。</p><h3 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h3><p>假设在某个域中拥有后端API。并且在另一个域或同一域的不同路径中（或在移动应用程序中）有一个前端。<br>此时希望有一种方法让前端使用<code>username</code>和<code>password</code>与后端进行身份验证。<br>我们可以使用FastAPI提供的<code>OAuth2</code>构建它。<br>（注意，需要首先安装<code>python-multipart</code>，这是因为OAuth2使用“表单数据”来发送<code>username</code>和<code>password</code>。）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Depends, FastAPI</span><br><span class="line"><span class="comment"># FastAPI提供了多种不同抽象级别的工具来实现安全功能。</span></span><br><span class="line"><span class="comment"># 在此示例中，将使用OAuth2，配合Password流和Bearer令牌。</span></span><br><span class="line"><span class="comment"># 具体地，使用OAuth2PasswordBearer类来做到这一点。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bearer令牌不是唯一的选择。但它是该用例的最佳选择。</span></span><br><span class="line"><span class="comment"># 对于大多数用例来说，它可能是最好的，除非你是 OAuth2 专家并且确切地知道为什么有另一个选项更适合需求。</span></span><br><span class="line"><span class="keyword">from</span> fastapi.security <span class="keyword">import</span> OAuth2PasswordBearer</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当创建OAuth2PasswordBearer类的实例时，传入tokenUrl参数。</span></span><br><span class="line"><span class="comment"># 此参数包含客户端（在用户浏览器中运行的前端）用于发送username和password以获取令牌的URL。</span></span><br><span class="line"><span class="comment"># 这里的tokenUrl=&quot;token&quot;指的是一个相对URL，所以它相当于./token，不过该URL还尚未创建。</span></span><br><span class="line"><span class="comment"># 因为使用的是相对 URL，如果API位于https://example.com/，那么它将引用https://example.com/token。</span></span><br><span class="line"><span class="comment"># 但如果API 位于https://example.com/api/v1/，那么它就是https://example.com/api/v1/token.</span></span><br><span class="line"><span class="comment"># 使用相对 URL 非常重要，可以确保应用程序即使在像代理服务器后面这样的高级用例中也能正常工作。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tokenUrl=&quot;token&quot;不会创建该路径操作，但声明了/token这个URL将是客户端应该用来获取令牌的URL。该信息在 OpenAPI 中使用，然后在交互式 API 文档系统中使用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># oauth2_scheme变量是OAuth2PasswordBearer的一个实例，但它也是“可调用的”。</span></span><br><span class="line"><span class="comment"># 因此它可被Depends使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 它将查看请求中的Authorization这个header，检查该值是否是Bearer以及一些令牌，并返回str类型的令牌.</span></span><br><span class="line"><span class="comment"># 如果它没有看到Authorization标头，或者该值没有Bearer标记，它将直接返回 401状态代码错误(UNAUTHORIZED)。</span></span><br><span class="line">oauth2_scheme = OAuth2PasswordBearer(tokenUrl=<span class="string">&quot;token&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># 这个依赖将提供一个str赋值给token这个参数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params">token: <span class="built_in">str</span> = Depends(<span class="params">oauth2_scheme</span>)</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;token&quot;</span>: token&#125;</span><br></pre></td></tr></table></figure><br>以上只是一个基本框架，还没有实际功能。</p><h3 id="完整功能"><a href="#完整功能" class="headerlink" title="完整功能"></a>完整功能</h3><p>在查看真正的具有安全功能的代码时，需要用到JWT令牌和哈希密码。<br>（1）JWT令牌<br>JWT 表示 「JSON Web Tokens」。<br>它是一个将 JSON 对象编码为密集且没有空格的长字符串的标准。字符串看起来像这样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span><br></pre></td></tr></table></figure><br>它没有被加密，因此任何人都可以从字符串内容中还原数据。<br>但它经过了签名。因此，当你收到一个由你发出的令牌时，可以校验令牌是否真的由你发出。<br>通过这种方式，你可以创建一个有效期为 1 周的令牌。然后当用户第二天使用令牌重新访问时，你知道该用户仍然处于登入状态。<br>一周后令牌将会过期，用户将不会通过认证，必须再次登录才能获得一个新令牌。而且如果用户（或第三方）试图修改令牌以篡改过期时间，你将因为签名不匹配而能够发觉。</p><p>对JWT令牌进行签名，实际就是一个密钥。要生成一个安全的随机密钥，可使用openssl。<br>windows版的openssl可以用别人编译好的，在<a href="https://slproweb.com/products/Win32OpenSSL.html">这里</a>。<br>在终端中使用以下命令：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rand -<span class="built_in">hex</span> <span class="number">32</span></span><br></pre></td></tr></table></figure></p><p>需要安装 python-jose 以在 Python 中生成和校验 JWT 令牌（Python-jose 需要一个额外的加密后端。这里推荐：pyca/cryptography。）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install python-jose[cryptography]</span><br></pre></td></tr></table></figure></p><p>（2）哈希密码<br>「哈希」的意思是：将某些内容（在本例中为密码）转换为看起来像乱码的字节序列（只是一个字符串）。<br>每次你传入完全相同的内容（完全相同的密码）时，你都会得到完全相同的乱码。<br>但是你不能从乱码转换回密码。<br>PassLib 是一个用于处理哈希密码的很棒的 Python 包。<br>它支持许多安全哈希算法以及配合算法使用的实用程序。<br>推荐的算法是 「Bcrypt」。<br>因此，安装附带 Bcrypt 的 PassLib：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install passlib[bcrypt]</span><br></pre></td></tr></table></figure></p><p>完整实例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Depends, FastAPI, HTTPException, status</span><br><span class="line"><span class="comment"># 将使用 FastAPI 的安全性实用工具来获取 username 和 password。</span></span><br><span class="line"><span class="comment"># OAuth2 规定在使用「password 流程」时，客户端/用户必须将 username 和 password 字段作为表单数据发送（因此，此处不能使用 JSON）。</span></span><br><span class="line"><span class="comment"># 而且规范明确了字段必须这样命名。因此 user-name 或 email 是行不通的。</span></span><br><span class="line"><span class="comment"># 不过不用担心，你可以在前端按照你的想法将它展示给最终用户。</span></span><br><span class="line"><span class="comment"># 而且你的数据库模型也可以使用你想用的任何其他名称。</span></span><br><span class="line"><span class="comment"># 但是对于登录路径操作，我们需要使用这些名称来与规范兼容（以具备例如使用集成的 API 文档系统的能力）。</span></span><br><span class="line"><span class="comment"># 具体地，导入 OAuth2PasswordRequestForm</span></span><br><span class="line"><span class="keyword">from</span> fastapi.security <span class="keyword">import</span> OAuth2PasswordBearer, OAuth2PasswordRequestForm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 passlib 导入我们需要的工具。</span></span><br><span class="line"><span class="keyword">from</span> passlib.context <span class="keyword">import</span> CryptContext</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入jwt相关模块</span></span><br><span class="line"><span class="keyword">from</span> jose <span class="keyword">import</span> JWTError, jwt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line"><span class="comment">#################################### JWT相关功能 #####################################</span></span><br><span class="line"><span class="comment"># 在终端中使用openssl rand -hex 32生成如下key</span></span><br><span class="line">SECRET_KEY = <span class="string">&quot;cda3c6e86b29270b741c9e1c62d052f5593921f26ae0badc4027b856f53d679f&quot;</span></span><br><span class="line"><span class="comment"># 创建用于设定 JWT 令牌签名算法的变量 「ALGORITHM」，并将其设置为 &quot;HS256&quot;。</span></span><br><span class="line">ALGORITHM = <span class="string">&quot;HS256&quot;</span></span><br><span class="line"><span class="comment"># 创建一个设置令牌过期时间的变量。</span></span><br><span class="line">ACCESS_TOKEN_EXPIRE_MINUTES = <span class="number">30</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个将在令牌端点中用于响应的 Pydantic 模型。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    access_token: <span class="built_in">str</span></span><br><span class="line">    token_type: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TokenData</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    username: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个生成新的访问令牌的工具函数。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_access_token</span>(<span class="params">data: <span class="built_in">dict</span>, expires_delta: <span class="type">Optional</span>[timedelta] = <span class="literal">None</span></span>):</span></span><br><span class="line">    to_encode = data.copy()</span><br><span class="line">    <span class="keyword">if</span> expires_delta:</span><br><span class="line">        expire = datetime.utcnow() + expires_delta</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        expire = datetime.utcnow() + timedelta(minutes=<span class="number">15</span>)</span><br><span class="line">    to_encode.update(&#123;<span class="string">&quot;exp&quot;</span>: expire&#125;)</span><br><span class="line">    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)</span><br><span class="line">    <span class="keyword">return</span> encoded_jwt</span><br><span class="line"></span><br><span class="line"><span class="comment">#################################### 数据库相关功能 #####################################</span></span><br><span class="line"><span class="comment"># 假的用户数据库</span></span><br><span class="line">fake_users_db = &#123;</span><br><span class="line">    <span class="string">&quot;johndoe&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: <span class="string">&quot;johndoe&quot;</span>,</span><br><span class="line">        <span class="string">&quot;full_name&quot;</span>: <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">        <span class="string">&quot;email&quot;</span>: <span class="string">&quot;johndoe@example.com&quot;</span>,</span><br><span class="line">        <span class="comment"># 哈希密码，不明文存储，如下是明文密目&quot;secret&quot;的哈希，所以登录时要用secret登录</span></span><br><span class="line">        <span class="string">&quot;hashed_password&quot;</span>: <span class="string">&quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;</span>,</span><br><span class="line">        <span class="string">&quot;disabled&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个用户 Pydantic 模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    username: <span class="built_in">str</span></span><br><span class="line">    email: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    full_name: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    disabled: <span class="type">Optional</span>[<span class="built_in">bool</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInDB</span>(<span class="params">User</span>):</span></span><br><span class="line">    hashed_password: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line">oauth2_scheme = OAuth2PasswordBearer(tokenUrl=<span class="string">&quot;token&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#################################### 哈希密码相关功能 #####################################</span></span><br><span class="line"><span class="comment"># 创建一个 PassLib 「上下文」。这将用于哈希和校验密码。</span></span><br><span class="line">pwd_context = CryptContext(schemes=[<span class="string">&quot;bcrypt&quot;</span>], deprecated=<span class="string">&quot;auto&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个工具函数以哈希来自用户的密码。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_password_hash</span>(<span class="params">password</span>):</span></span><br><span class="line">    <span class="keyword">return</span> pwd_context.<span class="built_in">hash</span>(password)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建另一个工具函数，用于校验接收的密码是否与存储的哈希值匹配。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verify_password</span>(<span class="params">plain_password, hashed_password</span>):</span></span><br><span class="line">    <span class="keyword">return</span> pwd_context.verify(plain_password, hashed_password)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_user</span>(<span class="params">db, username: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> username <span class="keyword">in</span> db:</span><br><span class="line">        user_dict = db[username]</span><br><span class="line">        <span class="keyword">return</span> UserInDB(**user_dict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建另一个工具函数用于认证并返回用户。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">authenticate_user</span>(<span class="params">fake_db, username: <span class="built_in">str</span>, password: <span class="built_in">str</span></span>):</span></span><br><span class="line">    user = get_user(fake_db, username)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> user:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> verify_password(password, user.hashed_password):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> user</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 get_current_user 依赖项</span></span><br><span class="line"><span class="comment"># get_current_user将具有一个之前所创建的同一个 oauth2_scheme 作为依赖项。</span></span><br><span class="line"><span class="comment"># 与之前直接在路径操作中所做的相同，新的依赖项 get_current_user 将从子依赖项 oauth2_scheme 中接收一个 str 类型的 token，具体地，就是一个JWT令牌</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_current_user</span>(<span class="params">token: <span class="built_in">str</span> = Depends(<span class="params">oauth2_scheme</span>)</span>):</span></span><br><span class="line">    credentials_exception = HTTPException(</span><br><span class="line">        status_code=status.HTTP_401_UNAUTHORIZED,</span><br><span class="line">        detail=<span class="string">&quot;Could not validate credentials&quot;</span>,</span><br><span class="line">        headers=&#123;<span class="string">&quot;WWW-Authenticate&quot;</span>: <span class="string">&quot;Bearer&quot;</span>&#125;,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 解码接收到的令牌，对其进行校验</span></span><br><span class="line">        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])</span><br><span class="line">        <span class="comment"># JWT 的规范中有一个 sub 键，值为该令牌的主题。</span></span><br><span class="line">        <span class="comment"># 使用它并不是必须的，但这是放置用户标识的地方，所以在示例中使用了它。</span></span><br><span class="line">        username: <span class="built_in">str</span> = payload.get(<span class="string">&quot;sub&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> username <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> credentials_exception</span><br><span class="line">        token_data = TokenData(username=username)</span><br><span class="line">    <span class="comment"># 如果令牌无效，立即返回一个 HTTP 错误。</span></span><br><span class="line">    <span class="keyword">except</span> JWTError:</span><br><span class="line">        <span class="keyword">raise</span> credentials_exception</span><br><span class="line">    <span class="comment"># 然后返回当前用户</span></span><br><span class="line">    user = get_user(fake_users_db, username=token_data.username)</span><br><span class="line">    <span class="keyword">if</span> user <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> credentials_exception</span><br><span class="line">    <span class="keyword">return</span> user</span><br><span class="line"></span><br><span class="line"><span class="comment"># 想要仅当此用户处于启用状态时才能获取 current_user。</span></span><br><span class="line"><span class="comment"># 因此，创建了一个额外的依赖项 get_current_active_user，而该依赖项又以 get_current_user 作为依赖项。</span></span><br><span class="line"><span class="comment"># 如果用户不存在或处于未启用状态，则这两个依赖项都将返回 HTTP 错误。</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_current_active_user</span>(<span class="params">current_user: User = Depends(<span class="params">get_current_user</span>)</span>):</span></span><br><span class="line">    <span class="keyword">if</span> current_user.disabled:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">400</span>, detail=<span class="string">&quot;Inactive user&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> current_user</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在token的路径操作中通过Depends将OAuth2PasswordRequestForm作为依赖项使用</span></span><br><span class="line"><span class="comment"># OAuth2PasswordRequestForm 是一个类依赖项，声明了如下的请求表单：</span></span><br><span class="line"><span class="comment"># - username。</span></span><br><span class="line"><span class="comment"># - password。</span></span><br><span class="line"><span class="comment"># - 一个可选的 scope 字段，但实际上它是一个由空格分隔的「作用域」组成的长字符串。每个「作用域」只是一个字符串（中间没有空格）。它们通常用于声明特定的安全权限，例如：users:read 或者 users:write 是常见的例子。类依赖项 OAuth2PasswordRequestForm 的实例不会有用空格分隔的长字符串属性 scope，而是具有一个 scopes 属性，该属性将包含实际被发送的每个作用域字符串组成的列表。</span></span><br><span class="line"><span class="comment"># - 一个可选的 grant_type.</span></span><br><span class="line"><span class="comment"># - 一个可选的 client_id（该示例不需要它）。</span></span><br><span class="line"><span class="comment"># - 一个可选的 client_secret（该示例不需要它）。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/token&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">login_for_access_token</span>(<span class="params">form_data: OAuth2PasswordRequestForm = Depends(<span class="params"></span>)</span>):</span> <span class="comment">#这个是一个快捷方式</span></span><br><span class="line">    <span class="comment"># 使用表单字段中的 username 从（伪）数据库中获取用户数据。 </span></span><br><span class="line">    <span class="comment"># 如果没有这个用户，我们将返回一个错误消息，提示「用户名或密码错误」。</span></span><br><span class="line">    user = authenticate_user(fake_users_db, form_data.username, form_data.password)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> user:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(</span><br><span class="line">            status_code=status.HTTP_401_UNAUTHORIZED,</span><br><span class="line">            detail=<span class="string">&quot;Incorrect username or password&quot;</span>,</span><br><span class="line">            headers=&#123;<span class="string">&quot;WWW-Authenticate&quot;</span>: <span class="string">&quot;Bearer&quot;</span>&#125;,</span><br><span class="line">        )</span><br><span class="line">    <span class="comment"># 创建一个真实的 JWT 访问令牌 </span></span><br><span class="line">    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)</span><br><span class="line">    access_token = create_access_token(</span><br><span class="line">        data=&#123;<span class="string">&quot;sub&quot;</span>: user.username&#125;, expires_delta=access_token_expires</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># token 端点的响应必须是一个 JSON 对象，里面包含有：</span></span><br><span class="line">    <span class="comment"># （1）token_type字段：在该例中，由于我们使用的是「Bearer」令牌，因此令牌类型应为「bearer」。</span></span><br><span class="line">    <span class="comment"># （2）access_token字段：它是一个包含我们的访问令牌的字符串。</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;access_token&quot;</span>: access_token, <span class="string">&quot;token_type&quot;</span>: <span class="string">&quot;bearer&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意声明响应模型</span></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/users/me/&quot;</span>, response_model=User</span>)</span></span><br><span class="line"><span class="comment"># 在路径操作中使用 get_current_active_user 作为 Depends</span></span><br><span class="line"><span class="comment"># 注意我们将 current_user 的类型声明为 Pydantic 模型 User。</span></span><br><span class="line"><span class="comment"># 这将帮助我们在函数内部使用所有的代码补全和类型检查。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在这个端点中，只有当用户存在，身份认证通过且处于启用状态时，我们才能获得该用户</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_users_me</span>(<span class="params">current_user: User = Depends(<span class="params">get_current_active_user</span>)</span>):</span></span><br><span class="line">    <span class="keyword">return</span> current_user</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/users/me/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_own_items</span>(<span class="params">current_user: User = Depends(<span class="params">get_current_active_user</span>)</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;item_id&quot;</span>: <span class="string">&quot;Foo&quot;</span>, <span class="string">&quot;owner&quot;</span>: current_user.username&#125;]</span><br></pre></td></tr></table></figure></p><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>可以向 FastAPI 应用添加中间件.<br>“中间件”是一个函数,它在每个请求被特定的路径操作处理之前,以及在每个响应返回之前工作.</p><ul><li>它接收你的应用程序的每一个请求.</li><li>然后它可以对这个请求做一些事情或者执行任何需要的代码.</li><li>然后它将请求传递给应用程序的其他部分 (通过某种路径操作).</li><li>然后它获取应用程序生产的响应 (通过某种路径操作).</li><li>它可以对该响应做些什么或者执行任何需要的代码.</li><li>然后它返回这个响应。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Request</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要创建中间件你可以在函数的顶部使用装饰器 @app.middleware(&quot;http&quot;).</span></span><br><span class="line"><span class="comment"># 中间件参数接收如下参数:</span></span><br><span class="line">- request.</span><br><span class="line">- call_next函数：它将接收 request 作为参数.</span><br><span class="line">（<span class="number">1</span>）这个函数将 request 传递给相应的 路径操作.</span><br><span class="line">（<span class="number">2</span>）然后它将返回由相应的路径操作生成的 response.</span><br><span class="line">（<span class="number">3</span>）然后你可以在返回 response 前进一步修改它.</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.middleware(<span class="params"><span class="string">&quot;http&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">add_process_time_header</span>(<span class="params">request: Request, call_next</span>):</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    response = <span class="keyword">await</span> call_next(request)</span><br><span class="line">    process_time = time.time() - start_time</span><br><span class="line">    <span class="comment"># 可以 用&#x27;X-&#x27; 前缀添加专有自定义请求头.</span></span><br><span class="line">    <span class="comment"># 但是如果你想让浏览器中的客户端看到你的自定义请求头, 你需要把它们加到 CORS 配置 (CORS (Cross-Origin Resource Sharing)) 的 expose_headers 参数中</span></span><br><span class="line">    response.headers[<span class="string">&quot;X-Process-Time&quot;</span>] = <span class="built_in">str</span>(process_time)</span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><h2 id="CORS跨域资源共享"><a href="#CORS跨域资源共享" class="headerlink" title="CORS跨域资源共享"></a>CORS跨域资源共享</h2><p>CORS 或者「跨域资源共享」 指浏览器中运行的前端拥有与后端通信的 JavaScript 代码，而后端处于与前端不同的「源」的情况。<br>源origin是协议（<code>http</code>，<code>https</code>）、域（<code>myapp.com</code>，<code>localhost</code>，<code>localhost.tiangolo.com</code>）以及端口（<code>80</code>、<code>443</code>、<code>8080</code>）的组合。</p><p>因此，这些都是不同的源：<code>http://localhost</code>、<code>https://localhost</code>、<code>http://localhost:8080</code>。<br>即使它们都在 localhost 中，但是它们使用不同的协议或者端口，所以它们都是不同的「源」。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>假设你的浏览器中有一个前端运行在<code>http://localhost:8080</code>，并且它的 JavaScript 正在尝试与运行在<code>http://localhost</code>的后端通信（因为我们没有指定端口，浏览器会采用默认的端口<code>80</code>）。<br>然后，浏览器会向后端发送一个 <code>HTTP OPTIONS</code> 请求，如果后端发送适当的 <code>headers</code> 来授权来自这个不同源（<code>http://localhost:8080</code>）的通信，浏览器将允许前端的 JavaScript 向后端发送请求。<br>为此，后端必须有一个「允许的源」列表。<br>在这种情况下，它必须包含<code>http://localhost:8080</code>，前端才能正常工作。</p><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>也可以使用 “*”（一个「通配符」）声明这个列表，表示全部都是允许的。<br>但这仅允许某些类型的通信，不包括所有涉及凭据的内容：像 Cookies 以及那些使用 Bearer 令牌的授权 headers 等。<br>因此，为了一切都能正常工作，最好显式地指定允许的源。</p><h3 id="使用CORSMiddleware"><a href="#使用CORSMiddleware" class="headerlink" title="使用CORSMiddleware"></a>使用CORSMiddleware</h3><p>可以在 FastAPI 应用中使用 CORSMiddleware 来配置它。<br>（1）导入 CORSMiddleware。<br>（2）创建一个允许的源列表（由字符串组成）。<br>（3）将其作为「中间件」添加到你的 FastAPI 应用中。</p><p>也可以指定后端是否允许：<br>（1）凭证（授权 headers，Cookies 等）。<br>（2）特定的 HTTP 方法（POST，PUT）或者使用通配符 “<em>“ 允许所有方法。<br>（3）特定的 HTTP headers 或者使用通配符 “</em>“ 允许所有 headers。</p><p>默认情况下，这个 CORSMiddleware 实现所使用的默认参数较为保守，所以你需要显式地启用特定的源、方法或者 headers，以便浏览器能够在跨域上下文中使用它们。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> fastapi.middleware.cors <span class="keyword">import</span> CORSMiddleware</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line">origins = [</span><br><span class="line">    <span class="string">&quot;http://localhost.tiangolo.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://localhost.tiangolo.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://localhost&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://localhost:8080&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">app.add_middleware(</span><br><span class="line">    CORSMiddleware,</span><br><span class="line">    <span class="comment"># allow_origins：一个允许跨域请求的源列表。例如 [&#x27;https://example.org&#x27;, &#x27;https://www.example.org&#x27;]。可以使用 [&#x27;*&#x27;] 允许任何源。</span></span><br><span class="line">    allow_origins=origins,</span><br><span class="line">    <span class="comment"># allow_credentials：指示跨域请求支持 cookies。默认是 False。另外，允许凭证时 allow_origins 不能设定为 [&#x27;*&#x27;]，必须指定源。</span></span><br><span class="line">    allow_credentials=<span class="literal">True</span>,</span><br><span class="line">    <span class="comment"># allow_methods：一个允许跨域请求的 HTTP 方法列表。默认为 [&#x27;GET&#x27;]。你可以使用 [&#x27;*&#x27;] 来允许所有标准方法。</span></span><br><span class="line">    allow_methods=[<span class="string">&quot;*&quot;</span>],</span><br><span class="line">    <span class="comment"># allow_headers：一个允许跨域请求的 HTTP 请求头列表。默认为 []。你可以使用 [&#x27;*&#x27;] 允许所有的请求头。</span></span><br><span class="line">    <span class="comment"># Accept、Accept-Language、Content-Language 以及 Content-Type 请求头总是允许 CORS 请求。</span></span><br><span class="line">    allow_headers=[<span class="string">&quot;*&quot;</span>],</span><br><span class="line">    <span class="comment"># 还有其他，比如：</span></span><br><span class="line">    <span class="comment"># allow_origin_regex：一个正则表达式字符串，匹配的源允许跨域请求。例如 &#x27;https://.*\.example\.org&#x27;。</span></span><br><span class="line">    <span class="comment"># expose_headers：指示可以被浏览器访问的响应头。默认为 []。</span></span><br><span class="line">    <span class="comment"># max_age：设定浏览器缓存 CORS 响应的最长时间，单位是秒。默认为 600。</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello World&quot;</span>&#125;</span><br></pre></td></tr></table></figure><br>中间件响应两种特定类型的 HTTP 请求：<br>（1）CORS 预检请求<br>这是些带有 Origin 和 Access-Control-Request-Method 请求头的 OPTIONS 请求。<br>在这种情况下，中间件将拦截传入的请求并进行响应，出于提供信息的目的返回一个使用了适当的 CORS headers 的 200 或 400 响应。<br>（2）简单请求<br>任何带有 Origin 请求头的请求。在这种情况下，中间件将像平常一样传递请求，但是在响应中包含适当的 CORS headers。</p><h2 id="SQL数据库"><a href="#SQL数据库" class="headerlink" title="SQL数据库"></a>SQL数据库</h2><p>FastAPI不要求使用 SQL（关系）数据库。不过可以使用任何想要的关系数据库（通过SQLAlchemy实现）。<br>在下面示例中，将使用SQLite，因为它使用单个文件并且 Python 具有集成支持。对于大的生产应用程序，可能希望使用像PostgreSQL这样的数据库服务器。<br><a href="https://github.com/tiangolo/full-stack-fastapi-postgresql">这里</a>有一个带有FastAPI和PostgreSQL的官方项目生成器，全部基于Docker，包括前端和更多工具。</p><p>首先需要安装SQLAlchemy：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install SQLAlchemy</span><br></pre></td></tr></table></figure></p><p>文件结构：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── sql_app</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    ├── crud.py</span><br><span class="line">    ├── database.py</span><br><span class="line">    ├── main.py</span><br><span class="line">    ├── models.py</span><br><span class="line">    └── schemas.py</span><br></pre></td></tr></table></figure><br>（1）对于database.py文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 SQLAlchemy 部件</span></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为 SQLAlchemy 创建数据库 URL</span></span><br><span class="line">SQLALCHEMY_DATABASE_URL = <span class="string">&quot;sqlite:///./sql_app.db&quot;</span></span><br><span class="line"><span class="comment"># SQLALCHEMY_DATABASE_URL = &quot;postgresql://user:password@postgresserver/db&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 SQLAlchemy engine</span></span><br><span class="line">engine = create_engine(</span><br><span class="line">    <span class="comment"># connect_args仅用于SQLite. 其他数据库不需要它</span></span><br><span class="line">    <span class="comment"># 默认情况下，SQLite只允许一个线程与其通信，假设每个线程将处理一个独立的请求。</span></span><br><span class="line">    <span class="comment"># 这是为了防止意外地为不同的事物（不同的请求）共享相同的连接。</span></span><br><span class="line">    <span class="comment"># 但是在 FastAPI 中，使用普通函数 ( def) 多个线程可以为同一个请求与数据库交互，因此我们需要让 SQLite 知道它应该允许这个connect_args=&#123;&quot;check_same_thread&quot;: False&#125;</span></span><br><span class="line">    <span class="comment"># 此外，我们将确保每个请求获得自己的数据库连接会话，因此不需要该默认机制。</span></span><br><span class="line">    SQLALCHEMY_DATABASE_URL, connect_args=&#123;<span class="string">&quot;check_same_thread&quot;</span>: <span class="literal">False</span>&#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 创建一个SessionLocal类</span></span><br><span class="line"><span class="comment"># SessionLocal类的每一个实例都是一个数据库会话。该类本身并不是数据库会话。</span></span><br><span class="line">SessionLocal = sessionmaker(autocommit=<span class="literal">False</span>, autoflush=<span class="literal">False</span>, bind=engine)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用declarative_base()返回一个类。</span></span><br><span class="line"><span class="comment"># 稍后将从这个类继承来创建每个数据库模型或类（ORM 模型）：</span></span><br><span class="line">Base = declarative_base()</span><br></pre></td></tr></table></figure><br>（2）对于models.py文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Boolean, Column, ForeignKey, Integer, String</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> relationship</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从database.py文件中导入Base类</span></span><br><span class="line"><span class="keyword">from</span> .database <span class="keyword">import</span> Base</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Base的子类，这些类都是SQLAlchemy模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">Base</span>):</span></span><br><span class="line">    <span class="comment"># __tablename__属性告诉SQLAlchemy这些模型在数据库中的文件</span></span><br><span class="line">    __tablename__ = <span class="string">&quot;users&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建模型字段，每个字段在数据库中都是一列Column，也就是数据表的字段</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>, index=<span class="literal">True</span>)</span><br><span class="line">    email = Column(String, unique=<span class="literal">True</span>, index=<span class="literal">True</span>)</span><br><span class="line">    hashed_password = Column(String)</span><br><span class="line">    is_active = Column(Boolean, default=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建数据表之间的关系</span></span><br><span class="line">    items = relationship(<span class="string">&quot;Item&quot;</span>, back_populates=<span class="string">&quot;owner&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&quot;items&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>, index=<span class="literal">True</span>)</span><br><span class="line">    title = Column(String, index=<span class="literal">True</span>)</span><br><span class="line">    description = Column(String, index=<span class="literal">True</span>)</span><br><span class="line">    owner_id = Column(Integer, ForeignKey(<span class="string">&quot;users.id&quot;</span>))</span><br><span class="line"></span><br><span class="line">    owner = relationship(<span class="string">&quot;User&quot;</span>, back_populates=<span class="string">&quot;items&quot;</span>)</span><br></pre></td></tr></table></figure><br>（3）对于schemas.py文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了不搞混SQLAlchemy模型和Pydantic模型，就用models.py存放SQLAlchemy模型，而该文件schemas.py存放Pydantic模型</span></span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建ItemBase这一Pydantic模型，作为一个盛放关于item统一属性的模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ItemBase</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    title: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ItemCreate</span>(<span class="params">ItemBase</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">ItemBase</span>):</span></span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span></span><br><span class="line">    owner_id: <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用config属性对Pydantic模型进行配置</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Config</span>:</span></span><br><span class="line">        <span class="comment"># orm_mode参数告诉Pydantic模型读取数据，即使它不是一个dict，而是一个ORM模型（或其他任意带属性的对象）</span></span><br><span class="line">        <span class="comment"># 此时它会尝试通过id = data.id这样获取属性的方式来读取数据，</span></span><br><span class="line">        <span class="comment"># 而不是id = data[&#x27;id&#x27;]这样字典读key的方法</span></span><br><span class="line">        <span class="comment"># 这样Pydantic模型就与ORM模型可以兼容，</span></span><br><span class="line">        <span class="comment"># 在路径操作中也可使用response_model来声明</span></span><br><span class="line">        orm_mode = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserBase</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    email: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserCreate</span>(<span class="params">UserBase</span>):</span></span><br><span class="line">    password: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">UserBase</span>):</span></span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span></span><br><span class="line">    is_active: <span class="built_in">bool</span></span><br><span class="line">    items: <span class="type">List</span>[Item] = []</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Config</span>:</span></span><br><span class="line">        orm_mode = <span class="literal">True</span></span><br></pre></td></tr></table></figure></p><p>（4）对于crud.py文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 该文件就是对数据库的操作，即增删改查</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从SQLAlchemy.orm中导入Session，这将允许对下面的db参数进行类型声明，从而有类型检查和补全功能</span></span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> Session</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入SQLAlchemy模型和Pydantic模型</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> models, schemas</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建几个工具函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># （1）通过id读取单个用户</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_user</span>(<span class="params">db: Session, user_id: <span class="built_in">int</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> db.query(models.User).<span class="built_in">filter</span>(models.User.<span class="built_in">id</span> == user_id).first()</span><br><span class="line"><span class="comment"># （2）通过邮箱读取单个用户</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_user_by_email</span>(<span class="params">db: Session, email: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> db.query(models.User).<span class="built_in">filter</span>(models.User.email == email).first()</span><br><span class="line"></span><br><span class="line"><span class="comment"># （3）读取多个用户</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_users</span>(<span class="params">db: Session, skip: <span class="built_in">int</span> = <span class="number">0</span>, limit: <span class="built_in">int</span> = <span class="number">100</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> db.query(models.User).offset(skip).limit(limit).<span class="built_in">all</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># （4）创建一个用户</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_user</span>(<span class="params">db: Session, user: schemas.UserCreate</span>):</span></span><br><span class="line">    fake_hashed_password = user.password + <span class="string">&quot;notreallyhashed&quot;</span></span><br><span class="line">    db_user = models.User(email=user.email, hashed_password=fake_hashed_password)</span><br><span class="line">    <span class="comment"># add添加实例对象</span></span><br><span class="line">    db.add(db_user)</span><br><span class="line">    <span class="comment"># commit提交更改</span></span><br><span class="line">    db.commit()</span><br><span class="line">    <span class="comment"># refresh刷新以获得最新数据</span></span><br><span class="line">    db.refresh(db_user)</span><br><span class="line">    <span class="keyword">return</span> db_user</span><br><span class="line"></span><br><span class="line"><span class="comment"># （5）读取多个items</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_items</span>(<span class="params">db: Session, skip: <span class="built_in">int</span> = <span class="number">0</span>, limit: <span class="built_in">int</span> = <span class="number">100</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> db.query(models.Item).offset(skip).limit(limit).<span class="built_in">all</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># （6）创建一个item</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_user_item</span>(<span class="params">db: Session, item: schemas.ItemCreate, user_id: <span class="built_in">int</span></span>):</span></span><br><span class="line">    <span class="comment"># **是用来解包，并且附加另一个参数</span></span><br><span class="line">    db_item = models.Item(**item.<span class="built_in">dict</span>(), owner_id=user_id)</span><br><span class="line">    db.add(db_item)</span><br><span class="line">    db.commit()</span><br><span class="line">    db.refresh(db_item)</span><br><span class="line">    <span class="keyword">return</span> db_item</span><br></pre></td></tr></table></figure></p><p>（5）对于main.py文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Depends, FastAPI, HTTPException</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> Session</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> crud, models, schemas</span><br><span class="line"><span class="keyword">from</span> .database <span class="keyword">import</span> SessionLocal, engine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据库的数据表</span></span><br><span class="line"><span class="comment"># 通常，可能会使用Alembic初始化数据库（创建表等）。</span></span><br><span class="line"><span class="comment"># 还可以使用 Alembic 进行“迁移”（这是它的主要工作）。</span></span><br><span class="line"><span class="comment"># “迁移”是每当更改 SQLAlchemy 模型的结构、添加新属性等以在数据库中复制这些更改、添加新列、新表等时所需的一组步骤。</span></span><br><span class="line"><span class="comment"># 可以在Project Generation - Template的模板中找到一个 FastAPI 项目中的 Alembic 示例。</span></span><br><span class="line">models.Base.metadata.create_all(bind=engine)</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个依赖项</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_db</span>():</span></span><br><span class="line">    <span class="comment"># 每个请求都有一个独立的会话，请求结束后就关闭它</span></span><br><span class="line">    <span class="comment"># 但所有会话都是同一个</span></span><br><span class="line">    db = SessionLocal()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># yield的用法可以参考之前部分</span></span><br><span class="line">        <span class="keyword">yield</span> db</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        db.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/users/&quot;</span>, response_model=schemas.User</span>)</span></span><br><span class="line"><span class="comment"># 在路径操作中都使用上述依赖</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_user</span>(<span class="params">user: schemas.UserCreate, db: Session = Depends(<span class="params">get_db</span>)</span>):</span></span><br><span class="line">    db_user = crud.get_user_by_email(db, email=user.email)</span><br><span class="line">    <span class="keyword">if</span> db_user:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">400</span>, detail=<span class="string">&quot;Email already registered&quot;</span>)</span><br><span class="line">    <span class="comment"># 返回的是SQLAlchemy模型，但是因为设置了orm_mode，就能与响应模型兼容</span></span><br><span class="line">    <span class="keyword">return</span> crud.create_user(db=db, user=user)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/users/&quot;</span>, response_model=<span class="type">List</span>[schemas.User]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_users</span>(<span class="params">skip: <span class="built_in">int</span> = <span class="number">0</span>, limit: <span class="built_in">int</span> = <span class="number">100</span>, db: Session = Depends(<span class="params">get_db</span>)</span>):</span></span><br><span class="line">    users = crud.get_users(db, skip=skip, limit=limit)</span><br><span class="line">    <span class="keyword">return</span> users</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/users/&#123;user_id&#125;&quot;</span>, response_model=schemas.User</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_user</span>(<span class="params">user_id: <span class="built_in">int</span>, db: Session = Depends(<span class="params">get_db</span>)</span>):</span></span><br><span class="line">    db_user = crud.get_user(db, user_id=user_id)</span><br><span class="line">    <span class="keyword">if</span> db_user <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">404</span>, detail=<span class="string">&quot;User not found&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> db_user</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/users/&#123;user_id&#125;/items/&quot;</span>, response_model=schemas.Item</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_item_for_user</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    user_id: <span class="built_in">int</span>, item: schemas.ItemCreate, db: Session = Depends(<span class="params">get_db</span>)</span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br><span class="line">    <span class="keyword">return</span> crud.create_user_item(db=db, item=item, user_id=user_id)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span>, response_model=<span class="type">List</span>[schemas.Item]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params">skip: <span class="built_in">int</span> = <span class="number">0</span>, limit: <span class="built_in">int</span> = <span class="number">100</span>, db: Session = Depends(<span class="params">get_db</span>)</span>):</span></span><br><span class="line">    items = crud.get_items(db, skip=skip, limit=limit)</span><br><span class="line">    <span class="keyword">return</span> items</span><br></pre></td></tr></table></figure></p><p>运行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uvicorn sql_app.main:app --reload</span><br></pre></td></tr></table></figure><br>注意得在包外面，按如上方式运行。因为文件内有相对路径导入。</p><p>查看SQLite数据，可以使用在线工具，如<a href="https://inloop.github.io/sqlite-viewer/">https://inloop.github.io/sqlite-viewer/</a>。</p><h2 id="大型项目的文件组织"><a href="#大型项目的文件组织" class="headerlink" title="大型项目的文件组织"></a>大型项目的文件组织</h2><p>如果正在开发一个应用程序或 Web API，很少会将所有的内容都放在一个文件中。<br>FastAPI 提供了一个方便的工具，可以在保持所有灵活性的同时构建你的应用程序。<br>如果你来自 Flask，那这将相当于 Flask 的 Blueprints。</p><p>文件结构：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── app                  <span class="comment"># 「app」是一个 Python 包</span></span><br><span class="line">│   ├── __init__.py      <span class="comment"># 这个文件使「app」成为一个 Python 包</span></span><br><span class="line">│   ├── main.py          <span class="comment"># 「main」模块，例如 import app.main</span></span><br><span class="line">│   ├── dependencies.py  <span class="comment"># 「dependencies」模块，例如 import app.dependencies</span></span><br><span class="line">│   └── routers          <span class="comment"># 「routers」是一个「Python 子包」</span></span><br><span class="line">│   │   ├── __init__.py  <span class="comment"># 使「routers」成为一个「Python 子包」</span></span><br><span class="line">│   │   ├── items.py     <span class="comment"># 「items」子模块，例如 import app.routers.items</span></span><br><span class="line">│   │   └── users.py     <span class="comment"># 「users」子模块，例如 import app.routers.users</span></span><br><span class="line">│   └── internal         <span class="comment"># 「internal」是一个「Python 子包」</span></span><br><span class="line">│       ├── __init__.py  <span class="comment"># 使「internal」成为一个「Python 子包」</span></span><br><span class="line">│       └── admin.py     <span class="comment"># 「admin」子模块，例如 import app.internal.admin</span></span><br></pre></td></tr></table></figure></p><h3 id="APIRouter路由"><a href="#APIRouter路由" class="headerlink" title="APIRouter路由"></a>APIRouter路由</h3><p>APIRouter可以使得对于不同对象的路径操作写在不同文件中，以使其井井有条。<br>（1）专门用于处理用户逻辑的文件是位于 <code>/app/routers/users.py</code> 的子模块<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 专门处理用户逻辑的路由文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入 APIRouter</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> APIRouter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过与 FastAPI 类相同的方式创建一个「实例」</span></span><br><span class="line">router = APIRouter()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以将 APIRouter 视为一个「迷你 FastAPI」类。</span></span><br><span class="line"><span class="comment"># 所有相同的选项都得到支持。</span></span><br><span class="line"><span class="comment"># 所有相同的 parameters、responses、dependencies、tags 等等。</span></span><br><span class="line"><span class="meta">@router.get(<span class="params"><span class="string">&quot;/users/&quot;</span>, tags=[<span class="string">&quot;users&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_users</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;username&quot;</span>: <span class="string">&quot;Rick&quot;</span>&#125;, &#123;<span class="string">&quot;username&quot;</span>: <span class="string">&quot;Morty&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@router.get(<span class="params"><span class="string">&quot;/users/me&quot;</span>, tags=[<span class="string">&quot;users&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_user_me</span>():</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;username&quot;</span>: <span class="string">&quot;fakecurrentuser&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@router.get(<span class="params"><span class="string">&quot;/users/&#123;username&#125;&quot;</span>, tags=[<span class="string">&quot;users&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_user</span>(<span class="params">username: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;username&quot;</span>: username&#125;</span><br></pre></td></tr></table></figure><br>（2）专门用于处理应用程序中「项目」的路由操作：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> APIRouter, Depends, HTTPException</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ..dependencies <span class="keyword">import</span> get_token_header</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此模块中的所有路径操作都有相同的：</span></span><br><span class="line">    <span class="comment"># 路径 prefix：/items。</span></span><br><span class="line">    <span class="comment"># tags：（仅有一个 items 标签）。</span></span><br><span class="line">    <span class="comment"># 额外的 responses。</span></span><br><span class="line">    <span class="comment"># dependencies：它们都需要我们创建的 X-Token 依赖项。</span></span><br><span class="line"><span class="comment"># 因此，我们可以将其添加到 APIRouter 中，而不是将其添加到每个路径操作中。</span></span><br><span class="line">router = APIRouter(</span><br><span class="line">    prefix=<span class="string">&quot;/items&quot;</span>,</span><br><span class="line">    tags=[<span class="string">&quot;items&quot;</span>],</span><br><span class="line">    dependencies=[Depends(get_token_header)],</span><br><span class="line">    responses=&#123;<span class="number">404</span>: &#123;<span class="string">&quot;description&quot;</span>: <span class="string">&quot;Not found&quot;</span>&#125;&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_items_db = &#123;<span class="string">&quot;plumbus&quot;</span>: &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Plumbus&quot;</span>&#125;, <span class="string">&quot;gun&quot;</span>: &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Portal Gun&quot;</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@router.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>():</span></span><br><span class="line">    <span class="keyword">return</span> fake_items_db</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@router.get(<span class="params"><span class="string">&quot;/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_item</span>(<span class="params">item_id: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> item_id <span class="keyword">not</span> <span class="keyword">in</span> fake_items_db:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">404</span>, detail=<span class="string">&quot;Item not found&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;name&quot;</span>: fake_items_db[item_id][<span class="string">&quot;name&quot;</span>], <span class="string">&quot;item_id&quot;</span>: item_id&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@router.put(<span class="params"></span></span></span><br><span class="line"><span class="meta"><span class="params">    <span class="string">&quot;/&#123;item_id&#125;&quot;</span>,</span></span></span><br><span class="line"><span class="meta"><span class="params">    <span class="comment"># 仍然可以添加更多将会应用于特定的路径操作的tags，以及一些特定于该路径操作的额外 responses</span></span></span></span><br><span class="line"><span class="meta"><span class="params">    <span class="comment"># 最后的这个路径操作将包含标签的组合：[&quot;items&quot;，&quot;custom&quot;]。</span></span></span></span><br><span class="line"><span class="meta"><span class="params">    <span class="comment"># 并且在文档中也会有两个响应，一个用于 404，一个用于 403。</span></span></span></span><br><span class="line"><span class="meta"><span class="params">    tags=[<span class="string">&quot;custom&quot;</span>],</span></span></span><br><span class="line"><span class="meta"><span class="params">    responses=&#123;<span class="number">403</span>: &#123;<span class="string">&quot;description&quot;</span>: <span class="string">&quot;Operation forbidden&quot;</span>&#125;&#125;,</span></span></span><br><span class="line"><span class="meta"><span class="params"></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params">item_id: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> item_id != <span class="string">&quot;plumbus&quot;</span>:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(</span><br><span class="line">            status_code=<span class="number">403</span>, detail=<span class="string">&quot;You can only update the item: plumbus&quot;</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;name&quot;</span>: <span class="string">&quot;The great Plumbus&quot;</span>&#125;</span><br></pre></td></tr></table></figure></p><p>也可以在另一个 APIRouter 中包含 APIRouter，通过：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.include_router(other_router)</span><br></pre></td></tr></table></figure><br>请确保在你将 <code>router</code> 包含到 FastAPI 应用程序之前进行此操作，以便 <code>other_router</code> 中的路径操作也能被包含进来。</p><p>（3）现在，假设你的组织为你提供了 <code>app/internal/admin.py</code> 文件。<br>它包含一个带有一些由你的组织在多个项目之间共享的管理员路径操作的 <code>APIRouter</code>。<br>对于此示例，它将非常简单。但是假设由于它是与组织中的其他项目所共享的，因此我们无法对其进行修改，以及直接在 APIRouter 中添加 <code>prefix</code>、<code>dependencies</code>、<code>tags</code> 等：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> APIRouter</span><br><span class="line"></span><br><span class="line">router = APIRouter()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@router.post(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_admin</span>():</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Admin getting schwifty&quot;</span>&#125;</span><br></pre></td></tr></table></figure><br>但是我们仍然希望在包含 APIRouter 时设置一个自定义的 <code>prefix</code>，以便其所有路径操作以 <code>/admin</code> 开头，我们希望使用本项目已经有的 <code>dependencies</code> 保护它，并且我们希望它包含自定义的 <code>tags</code> 和 <code>responses</code>。<br>这些将在主体文件<code>main.py</code>中实现。</p><h3 id="依赖项-1"><a href="#依赖项-1" class="headerlink" title="依赖项"></a>依赖项</h3><p>我们将需要一些在应用程序的好几个地方所使用的依赖项。<br>因此，将它们放在 <code>dependencies</code> 模块（<code>app/dependencies.py</code>）中。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Header, HTTPException</span><br><span class="line"><span class="comment"># 我们正在使用虚构的请求首部来简化此示例。</span></span><br><span class="line"><span class="comment"># 但在实际情况下，使用集成的安全性实用工具会得到更好的效果。</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_token_header</span>(<span class="params">x_token: <span class="built_in">str</span> = Header(<span class="params">...</span>)</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x_token != <span class="string">&quot;fake-super-secret-token&quot;</span>:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">400</span>, detail=<span class="string">&quot;X-Token header invalid&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_query_token</span>(<span class="params">token: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> token != <span class="string">&quot;jessica&quot;</span>:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">400</span>, detail=<span class="string">&quot;No Jessica token provided&quot;</span>)</span><br></pre></td></tr></table></figure><br>所有的这些路径操作都将在自身之前计算/执行 dependencies 列表。</p><ul><li>如果你还在一个具体的路径操作中声明了依赖项，它们也会被执行。</li><li>路由器的依赖项最先执行，然后是装饰器中的 dependencies，再然后是普通的参数依赖项。</li><li>你还可以添加具有 scopes 的 Security 依赖项。</li></ul><h3 id="主体"><a href="#主体" class="headerlink" title="主体"></a>主体</h3><p><code>app/main.py</code>模块导入并使用 FastAPI 类。<br>这将是你的应用程序中将所有内容联结在一起的主文件。<br>并且由于你的大部分逻辑现在都存在于其自己的特定模块中，因此主文件的内容将非常简单。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Depends, FastAPI</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .dependencies <span class="keyword">import</span> get_query_token, get_token_header</span><br><span class="line"><span class="keyword">from</span> .internal <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> .routers <span class="keyword">import</span> items, users</span><br><span class="line"></span><br><span class="line"><span class="comment"># 甚至可以声明全局依赖项，它会和每个 APIRouter 的依赖项组合在一起：</span></span><br><span class="line">app = FastAPI(dependencies=[Depends(get_query_token)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含来自 users 和 items 子模块的 router。</span></span><br><span class="line"><span class="comment"># 使用 app.include_router()，我们可以将每个 APIRouter 添加到主 FastAPI 应用程序中。</span></span><br><span class="line">app.include_router(users.router)</span><br><span class="line">app.include_router(items.router)</span><br><span class="line"><span class="comment"># 通过将以下这些参数传递给 app.include_router() 来完成所有的声明，而不必修改原始的 APIRouter</span></span><br><span class="line"><span class="comment"># 这样，原始的APIRouter将保持不变，因此我们仍然可以与组织中的其他项目共享相同的 app/internal/admin.py 文件。</span></span><br><span class="line"><span class="comment"># 但这只会影响我们应用中的 APIRouter，而不会影响使用它的任何其他代码。</span></span><br><span class="line"><span class="comment"># 因此，举例来说，其他项目能够以不同的身份认证方法使用相同的 APIRouter。</span></span><br><span class="line">app.include_router(</span><br><span class="line">    admin.router,</span><br><span class="line">    prefix=<span class="string">&quot;/admin&quot;</span>,</span><br><span class="line">    tags=[<span class="string">&quot;admin&quot;</span>],</span><br><span class="line">    dependencies=[Depends(get_token_header)],</span><br><span class="line">    responses=&#123;<span class="number">418</span>: &#123;<span class="string">&quot;description&quot;</span>: <span class="string">&quot;I&#x27;m a teapot&quot;</span>&#125;&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以直接将路径操作添加到 FastAPI 应用中</span></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">root</span>():</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello Bigger Applications!&quot;</span>&#125;</span><br></pre></td></tr></table></figure></p><h2 id="后台任务"><a href="#后台任务" class="headerlink" title="后台任务"></a>后台任务</h2><p>可以定义在返回响应后运行的后台任务。<br>这对于需要在请求之后发生的操作很有用，但客户端实际上不必在接收响应之前等待操作完成。<br>这包括，例如：<br>（1）执行操作后发送的电子邮件通知： 由于连接到电子邮件服务器并发送电子邮件往往“慢”（几秒钟），可以立即返回响应并在后台发送电子邮件通知。<br>（2）处理数据：例如，假设您收到一个必须经过缓慢处理的文件，您可以返回“已接受”（HTTP 202）的响应并在后台处理它。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入BackgroundTasks</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> BackgroundTasks, FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个作为后台任务运行的函数。</span></span><br><span class="line"><span class="comment"># 它是一个可以接收参数的标准函数。</span></span><br><span class="line"><span class="comment"># 它可以是一个async def或普通def函数，FastAPI会知道如何正确处理它。</span></span><br><span class="line"><span class="comment"># 该例中任务函数将写入文件（模拟发送电子邮件的场景）。</span></span><br><span class="line"><span class="comment"># 并且由于写操作不使用async和await，我们用 normal 定义函数def：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_notification</span>(<span class="params">email: <span class="built_in">str</span>, message=<span class="string">&quot;&quot;</span></span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;log.txt&quot;</span>, mode=<span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> email_file:</span><br><span class="line">        content = <span class="string">f&quot;notification for <span class="subst">&#123;email&#125;</span>: <span class="subst">&#123;message&#125;</span>&quot;</span></span><br><span class="line">        email_file.write(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/send-notification/&#123;email&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">send_notification</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    email: <span class="built_in">str</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 定义一个参数，其类型声明为：BackgroundTasks </span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># FastAPI将为您创建类型的对象BackgroundTasks并将其作为该参数传递。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    background_tasks: BackgroundTasks</span>):</span></span><br><span class="line">    <span class="comment"># 在路径操作函数内部，使用以下方法将任务函数传递给后台任务对象</span></span><br><span class="line">    background_tasks.add_task(write_notification, email, message=<span class="string">&quot;some notification&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Notification sent in the background&quot;</span>&#125;</span><br></pre></td></tr></table></figure></p><p>注意：<br>如果需要执行繁重的后台计算并且不一定需要它由同一进程运行（例如，不需要共享内存、变量等），可能会受益于使用其他更大的工具，例如Celery。<br>它们往往需要更复杂的配置，消息/作业队列管理器，如 RabbitMQ 或 Redis，但它们允许在多个进程中运行后台任务，尤其是在多个服务器中。<br>要查看示例，请查看Project Generators，它们都包含已配置的 Celery。<br>但是，如您需要从同一个FastAPI应用程序访问变量和对象，或者需要执行小型后台任务（例如发送电子邮件通知），只需使用BackgroundTasks.</p><h3 id="依赖注入-1"><a href="#依赖注入-1" class="headerlink" title="依赖注入"></a>依赖注入</h3><p><code>BackgroundTasks</code>也适用于依赖注入系统。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> BackgroundTasks, Depends, FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_log</span>(<span class="params">message: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;log.txt&quot;</span>, mode=<span class="string">&quot;a&quot;</span>) <span class="keyword">as</span> log:</span><br><span class="line">        log.write(message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_query</span>(<span class="params">background_tasks: BackgroundTasks, q: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> q:</span><br><span class="line">        message = <span class="string">f&quot;found query: <span class="subst">&#123;q&#125;</span>\n&quot;</span></span><br><span class="line">        background_tasks.add_task(write_log, message)</span><br><span class="line">    <span class="keyword">return</span> q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/send-notification/&#123;email&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">send_notification</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 在此示例中，消息将在发送响应后写入文件log.txt。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 如果请求中有查询，它将在后台任务中写入日志。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 然后在路径操作函数处生成的另一个后台任务将使用email路径参数写入一条消息。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    email: <span class="built_in">str</span>, background_tasks: BackgroundTasks, q: <span class="built_in">str</span> = Depends(<span class="params">get_query</span>)</span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br><span class="line">    message = <span class="string">f&quot;message to <span class="subst">&#123;email&#125;</span>\n&quot;</span></span><br><span class="line">    background_tasks.add_task(write_log, message)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Message sent&quot;</span>&#125;</span><br></pre></td></tr></table></figure></p><h2 id="元数据和文档URL"><a href="#元数据和文档URL" class="headerlink" title="元数据和文档URL"></a>元数据和文档URL</h2><p>可以在 FastAPI 应用中自定义几个元数据配置。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">description = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">ChimichangApp API helps you do awesome stuff. 🚀</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Items</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">You can **read items**.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Users</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">You will be able to:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* **Create users** (_not implemented_).</span></span><br><span class="line"><span class="string">* **Read users** (_not implemented_).</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">app = FastAPI(</span><br><span class="line">    <span class="comment"># Title：在 OpenAPI 和自动 API 文档用户界面中作为 API 的标题/名称使用。</span></span><br><span class="line">    title=<span class="string">&quot;ChimichangApp&quot;</span>,</span><br><span class="line">    <span class="comment"># Description：在 OpenAPI 和自动 API 文档用户界面中用作 API 的描述。</span></span><br><span class="line">    description=description,</span><br><span class="line">    <span class="comment"># Version：API 版本，例如 v2 或者 2.5.0。</span></span><br><span class="line">    version=<span class="string">&quot;0.0.1&quot;</span>,</span><br><span class="line">    terms_of_service=<span class="string">&quot;http://example.com/terms/&quot;</span>,</span><br><span class="line">    contact=&#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Deadpoolio the Amazing&quot;</span>,</span><br><span class="line">        <span class="string">&quot;url&quot;</span>: <span class="string">&quot;http://x-force.example.com/contact/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;email&quot;</span>: <span class="string">&quot;dp@x-force.example.com&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    license_info=&#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Apache 2.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;url&quot;</span>: <span class="string">&quot;https://www.apache.org/licenses/LICENSE-2.0.html&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Katana&quot;</span>&#125;]</span><br></pre></td></tr></table></figure></p><h3 id="标签元数据"><a href="#标签元数据" class="headerlink" title="标签元数据"></a>标签元数据</h3><p>也可以使用参数 <code>openapi_tags</code>，为用于分组路径操作的不同标签添加额外的元数据。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接受一个列表，这个列表包含每个标签对应的一个字典。</span></span><br><span class="line"><span class="comment"># 每个标签元数据字典的顺序也定义了在文档用户界面显示的顺序。</span></span><br><span class="line">tags_metadata = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"># name（必要）：一个 str，它与路径操作和 APIRouter 中使用的 tags 参数有相同的标签名。</span></span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;users&quot;</span>,</span><br><span class="line">        <span class="comment"># description：一个用于简短描述标签的 str。它支持 Markdown 并且会在文档用户界面中显示。</span></span><br><span class="line">        <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Operations with users. The **login** logic is also here.&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;items&quot;</span>,</span><br><span class="line">        <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Manage items. So _fancy_ they have their own docs.&quot;</span>,</span><br><span class="line">        <span class="comment"># externalDocs：一个描述外部文档的 dict：</span></span><br><span class="line">            <span class="comment"># description：用于简短描述外部文档的 str。</span></span><br><span class="line">            <span class="comment"># url（必要）：外部文档的 URL str。</span></span><br><span class="line">        <span class="string">&quot;externalDocs&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Items external docs&quot;</span>,</span><br><span class="line">            <span class="string">&quot;url&quot;</span>: <span class="string">&quot;https://fastapi.tiangolo.com/&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">app = FastAPI(openapi_tags=tags_metadata)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 tags 参数和路径操作（以及 APIRouter）一起使用，将其分配给不同的标签</span></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/users/&quot;</span>, tags=[<span class="string">&quot;users&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_users</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Harry&quot;</span>&#125;, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Ron&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span>, tags=[<span class="string">&quot;items&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_items</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;wand&quot;</span>&#125;, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;flying broom&quot;</span>&#125;]</span><br></pre></td></tr></table></figure></p><h3 id="文档URL"><a href="#文档URL" class="headerlink" title="文档URL"></a>文档URL</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="comment"># 可以配置两个文档用户界面，包括：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     Swagger UI：服务于 /docs。</span></span><br><span class="line"><span class="comment">#         可以使用参数 docs_url 设置它的 URL。</span></span><br><span class="line"><span class="comment">#         可以通过设置 docs_url=None 禁用它。</span></span><br><span class="line"><span class="comment">#     ReDoc：服务于 /redoc。</span></span><br><span class="line"><span class="comment">#         可以使用参数 redoc_url 设置它的 URL。</span></span><br><span class="line"><span class="comment">#         可以通过设置 redoc_url=None 禁用它。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 例如，设置 Swagger UI 服务于 /documentation 并禁用 ReDoc：</span></span><br><span class="line">app = FastAPI(docs_url=<span class="string">&quot;/documentation&quot;</span>, redoc_url=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Foo&quot;</span>&#125;]</span><br></pre></td></tr></table></figure><h2 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h2><p>可以使用<code>StaticFiles</code>来挂载静态文件。</p><h2 id="测试客户端"><a href="#测试客户端" class="headerlink" title="测试客户端"></a>测试客户端</h2><p>基于Starlette，测试FastAPI应用程序变得简单而愉快。具体地，它基于Requests，因此非常熟悉和直观。<br>有了它，可以直接将pytest与FastAPI一起使用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="comment"># 导入TestClient</span></span><br><span class="line"><span class="keyword">from</span> fastapi.testclient <span class="keyword">import</span> TestClient</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_main</span>():</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;Hello World&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client = TestClient(app)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_read_main</span>():</span></span><br><span class="line">    response = client.get(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">    <span class="keyword">assert</span> response.status_code == <span class="number">200</span></span><br><span class="line">    <span class="keyword">assert</span> response.json() == &#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;Hello World&quot;</span>&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">参考文献：
FastAPI官方文档
中文翻译
（注意，当前2022年5月8日的中文翻译有一些错误）

介绍
FastAPI 是一个用于构建 API 的现代、快速（高性能）的 web 框架，使用 Python 3.6+ 并基于标准的 Python 类型提示。
FastAPI 站在以下巨人的肩膀之上：

 * Starlette负责 web 部分。
 * Pydantic负责数据部分。

安装
1


pip install fastapi


还需要一个 ASGI 服务器，生产环境可以使用Uvicorn或者Hypercorn。
1


pip install uvicorn[standard]
</summary>
    
    
    
    <category term="coding" scheme="http://qixinbo.github.io/categories/coding/"/>
    
    
    <category term="FastAPI" scheme="http://qixinbo.github.io/tags/FastAPI/"/>
    
  </entry>
  
  <entry>
    <title>Docker知识点</title>
    <link href="http://qixinbo.github.io/2022/04/20/docker/"/>
    <id>http://qixinbo.github.io/2022/04/20/docker/</id>
    <published>2022-04-19T16:00:00.000Z</published>
    <updated>2022-04-20T13:22:18.326Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献：<br><a href="https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">Docker 入门教程</a><br><a href="https://yeasy.gitbook.io/docker_practice/">Docker —— 从入门到实践</a><br><a href="https://www.bilibili.com/video/BV1og4y1q7M4">【狂神说Java】Docker最新超详细版教程通俗易懂</a></p><h1 id="为什么要用Docker"><a href="#为什么要用Docker" class="headerlink" title="为什么要用Docker"></a>为什么要用Docker</h1><p>Docker解决的问题是将软件连带其环境一起安装。</p><h2 id="虚拟机与容器"><a href="#虚拟机与容器" class="headerlink" title="虚拟机与容器"></a>虚拟机与容器</h2><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。<br>虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。<br>（1）资源占用多<br>虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。<br>（2）冗余步骤多<br>虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。<br>（3）启动慢<br>启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。</p><h3 id="Linux容器"><a href="#Linux容器" class="headerlink" title="Linux容器"></a>Linux容器</h3><p>由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。<br>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。<br>由于容器是进程级别的，相比虚拟机有很多优势。<br>（1）启动快<br>容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。<br>（2）资源占用少<br>容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。<br>（3）体积小<br>容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。<br>总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。<br>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。<br>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p><h1 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h1><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>首先安装一下Docker，然后实操起来看看什么是Docker。<br>参考官方教程，在<a href="https://docs.docker.com/engine/install/">这里</a>或<a href="https://yeasy.gitbook.io/docker_practice/install">该教程</a>。<br>以ubuntu为例：<br>（1）卸载旧版本<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure><br>（2）安装依赖包<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ca-certificates curl gnupg lsb-release</span><br></pre></td></tr></table></figure><br>（3）添加官方的key<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSLhttps://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor-o/usr/share/keyrings/docker-archive-keyring.gpg</span><br></pre></td></tr></table></figure><br>（4）配置仓库<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">&quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu  $(lsb_release -cs) stable&quot;</span>| sudo tee /etc/apt/sources.<span class="built_in">list</span>.d/docker.<span class="built_in">list</span> &gt;/dev/null</span><br></pre></td></tr></table></figure><br>注意这个地方是特用于ubuntu的。如果是基于ubuntu的再次发行版，比如Linux Mint，需要将自动探测版本那块的代码改成确定的ubuntu的版本，否则会报找不到包的错误。<br>比如改成：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">&quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu  bionic stable&quot;</span>| sudo tee /etc/apt/sources.<span class="built_in">list</span>.d/docker.<span class="built_in">list</span> &gt;/dev/null</span><br></pre></td></tr></table></figure><br>（5）安装Docker Engine<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure></p><p>安装完成后，使用下面命令验证是否安装成功：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure></p><h2 id="配置权限"><a href="#配置权限" class="headerlink" title="配置权限"></a>配置权限</h2><p>Docker 是服务器——客户端架构。命令行运行docker命令的时候，需要本机有 Docker 服务。如果这项服务没有启动，可以用下面其中一个命令启动：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo service docker start</span><br><span class="line">或</span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure></p><p>Docker 需要用户具有 sudo 权限，为了避免每次命令都输入sudo，可以把用户加入 Docker 用户组：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><br>添加后需要重新启动系统。</p><h2 id="镜像文件"><a href="#镜像文件" class="headerlink" title="镜像文件"></a>镜像文件</h2><p>Docker 把应用程序及其依赖，打包在 image 镜像文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。<br>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。<br>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本机的所有 image 文件。</span></span><br><span class="line">$ docker image ls</span><br><span class="line"><span class="comment"># 删除 image 文件</span></span><br><span class="line">$ docker image rm [imageName]</span><br></pre></td></tr></table></figure><br>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库，用于集中的存储、分发镜像，Docker Registry 就是这样的服务。<br>一个 Docker Registry 中可以包含多个 仓库（Repository）；每个仓库可以包含多个 标签（Tag）；每个标签对应一个镜像。<br>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。<br>仓库名经常以 两段式路径 形式出现，比如 jwilder/nginx-proxy，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。<br>最常使用的 Registry 公开服务是官方的 Docker Hub，这也是默认的 Registry，并拥有大量的高质量的官方镜像。<br>如果在使用过程中发现拉取 Docker 镜像十分缓慢，可以配置 Docker<a href="https://yeasy.gitbook.io/docker_practice/install/mirror">国内镜像加速</a>。<br>从docker官方拉取hello-world镜像：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull hello-world</span><br></pre></td></tr></table></figure></p><h2 id="容器文件"><a href="#容器文件" class="headerlink" title="容器文件"></a>容器文件</h2><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。<br>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。</p><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。<br>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p><p>生成容器：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run IMAGE</span><br></pre></td></tr></table></figure><br>run命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。<br>当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p><pre><code>- 检查本地是否存在指定的镜像，不存在就从公有仓库下载- 利用镜像创建并启动一个容器- 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层- 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去- 从地址池配置一个 ip 地址给容器- 执行用户指定的应用程序- 执行完毕后容器被终止</code></pre><p>如果希望重复使用容器，就要使用start命令，它用来启动已经生成、已经停止运行的容器文件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start IMAGE</span><br></pre></td></tr></table></figure><br>image 文件生成的容器实例，本身也是一个文件，称为容器文件。也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本机正在运行的容器</span></span><br><span class="line">$ docker container ls</span><br><span class="line"><span class="comment"># 列出本机所有容器，包括终止运行的容器</span></span><br><span class="line">$ docker container ls --<span class="built_in">all</span></span><br></pre></td></tr></table></figure></p><p>终止运行的容器文件，依然会占据硬盘空间，可以使用以下命令删除。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rm [containerID]</span><br></pre></td></tr></table></figure></p><h1 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令"></a>镜像相关命令</h1><p>列出镜像：<code>docker images</code>，REPOSITORY/TAG指明了一个具体镜像<br>查看镜像详细信息：<code>docker inspect</code><br>删除镜像：<code>docker rmi</code> 镜像名或ID，如果是镜像名，可能只删除了某个tag，如果是ID，则将这个镜像完全删除。</p><p>搜索镜像：<code>docker search</code>，也可以通过官网搜索，在<a href="https://hub.docker.com/search">https://hub.docker.com/search</a>。<br>拉取镜像：<code>docker pull</code>，可以修改<code>/etc/default/docker</code>文件，添加镜像源。<br>推送镜像：<code>docker push</code></p><p>构建镜像的作用：<br>（1）保存对容器的修改，并再次使用；<br>（2）自定义镜像的能力；<br>（3）以软件的形式打包并分发服务及其运行环境<br>构建镜像的方式：<br>（1）通过容器构建：<code>docker commit</code><br>（2）通过Dockerfile文件构建：<code>docker build</code></p><p>Dockerfile指令格式：INSTRUCTION argument。常用指令的有趣解释如下：<br><img src="https://user-images.githubusercontent.com/6218739/164161578-bf4e791f-8351-4f38-b353-986324ceabb9.png" alt="dockerfile"></p><p><code>FROM &lt;image&gt;</code>或<code>FROM &lt;image&gt;:&lt;tag&gt;</code><br><code>MAINTAINER &lt;name&gt;</code>指定镜像的作者信息，包含镜像的所有者和联系信息<br><code>RUN &lt;command&gt;</code> 或 <code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>指定当前构建过程中运行的命令，前者是shell模式，后者是exec模式。<br><code>EXPOSE &lt;port&gt; [&lt;port&gt;…]</code> 指定运行该镜像的容器使用的端口<br><code>CMD command param1 param2</code> 或 <code>CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> 或 <code>CMD [&quot;param1&quot;, &quot;param2&quot;]</code> 指定容器运行时的默认行为，即如果<code>docker run</code>时指定了命令，它会将这里的命令覆盖。第一种是shell模式，第二种是exec模式，第三种是作为EXTRYPOINT指令的默认参数。<br><code>ENTRYPOINT command param1 param2</code> 或 <code>ENTRYPOINT [&quot;exectable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> 与CMD指令类似，但ENTRYPOINT指令不会被<code>docker run</code>中的命令所覆盖，只能使用<code>docker run --entrypoint</code>来覆盖。<br><code>ADD &lt;src&gt; … &lt;dst&gt;</code> 或 <code>ADD [&quot;&lt;src&gt;&quot;… &quot;&lt;dst&gt;&quot;]</code> 复制文件，且ADD包含类似tar的解压功能，来源路径是构建路径中的相对路径，目标路径必须是镜像中的绝对路径，后者适用于文件路径中有空格的情况<br><code>COPY &lt;src&gt; … &lt;dst&gt;</code> 或 <code>COPY [&quot;&lt;src&gt;&quot;… &quot;&lt;dst&gt;&quot;]</code> 单纯复制文件推荐使用COPY指令<br><code>WORKDIR /path/to/workdir</code> 指定工作目录，一般为绝对路径，若为相对路径，则路径会传递。<br><code>ENV &lt;key&gt; &lt;value&gt;</code>或<code>ENV &lt;key&gt;=&lt;value&gt;</code> 指定环境变量，构建过程中或容器运行中都有效<br><code>USER user</code> 指定镜像以什么用户运行，若不指定，则默认使用root运行。<br><code>ONBUILD [INSTRUCTION]</code> 为镜像添加触发器，当该镜像被其他镜像作为基础镜像时运行</p><p>Dockerfile构建过程（docker build会删除中间的容器，但不会删除中间的镜像，所以可以利用中间层镜像进行调试）：<br>（1）从基础镜像运行一个容器；<br>（2）执行一条指令，对容器做出修改；<br>（3）执行类似docker commit的操作，提交一个新的镜像层；<br>（4）再基于刚提交的镜像运行一个新容器；<br>（5）指定Dockerfile中的下一条指令，直至所有指令执行完毕。</p><p><code>docker history</code> 查看镜像构建过程。</p><h1 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h1><p>启动容器：<code>docker run IMAGE [command] [args]</code><br>启动交互式容器： <code>docker run -i -t IMAGE [command] [args]</code> （-i —interactive -t —tty），比如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure><br>退出容器就是<code>exit</code>。</p><p>自定义容器名：加上<code>--name</code>选项<br>查看容器：<br>（1）<code>docker ps [-a] [-l]</code> （列出当前正在运行的容器，加上<code>-a</code>就是列出所有）<br>（2）<code>docker inspect NameOfContainer</code>查看容器的元数据，包括主机配置、ip地址等。<br>重新启动已经停止的容器：<code>docker start [-i] NameOfContainer</code><br>删除已经停止的容器：<code>docker rm</code> （加上<code>-f</code>可以强制删除正在运行的容器）</p><p>守护式容器：（1）能够长期运行；（2）没有交互式会话；（3）适合运行应用程序和服务<br>启动守护式容器的两种方式：<br>（1）将容器以交互式方式启动后，<code>Ctrl+P Ctrl+Q</code>即可进入守护模式，然后附加到正在运行的容器：<code>docker attach</code><br>（2）<code>docker run -d</code><br>查看容器中的日志：<code>docker logs [-f] [-t] [--tail] NameOfContainer</code> （-f —follow -t —timestamps）<br>查看容器中的进程：<code>docker top</code><br>在运行中的容器内启动新进程：<code>decker exec [-d] [-i] [-t] 容器名 [COMMAND] [args]</code>，比如进入这个容器：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure></p><p>停止守护式容器：<br><code>docker stop</code> 发送一个停止信号，等待停止；<br><code>docker kill</code> 直接杀死容器</p><p>设置容器的端口映射：<br><code>docker run [-P] [-p]</code><br>-P —publish-all=true | false，为容器暴露的所有端口进行映射<br>-p 指定特定的端口，可以单独指定容器端口、宿主机端口和容器端口、ip地址+容器端口、ip地址+宿主机端口和容器端口</p><p>对于端口映射这块，额外补充个知识点。因为我主机是Windows系统，然后通过Virtualbox虚拟了一个Linux Mint系统，而docker是放在Linux虚拟机中的，所以需要外面的Windows系统能访问到Linux系统，此时可以通过在Virtualbox中设置端口转发，来建立两者之间的联系，这样就是涉及了三个端口，一个是主机windows的端口，一个是linux的端口，一个是docker容器的端口，三者之间要建立好映射。<br>一篇很好的教程见：<br><a href="https://www.cnblogs.com/Reyzal/p/7743747.html">VirtualBox主机和虚拟机互相通信</a></p><p><code>-v 主机目录:容器内目录</code>：容器数据卷，实现容器数据的持久化和同步。</p><p><code>docker port</code> 查看容器到宿主机的端口映射<br><code>docker cp</code> 拷贝容器内的文件到主机</p><p>常用命令图谱：<br><img src="https://user-images.githubusercontent.com/6218739/164161697-fdf5da26-5f65-406d-9cc1-687c32e7b76a.png" alt="cmd"></p><h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><p>Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。<br>在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。<br>Compose 恰好满足了这样的需求。它允许用户通过一个单独的<code>docker-compose.yml</code>模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。<br>Compose 中有两个重要的概念：<br>（1）服务 (service)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。<br>（2）项目 (project)：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。<br>Compose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>（1）下载安装包<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L<span class="string">&quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span>-o/usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><br>（2）对二进制包添加权限<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s/usr/<span class="built_in">local</span>/bin/docker-compose /usr/bin/docker-compose</span><br></pre></td></tr></table></figure><br>测试是否安装成功：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">参考文献：
Docker 入门教程
Docker —— 从入门到实践
【狂神说Java】Docker最新超详细版教程通俗易懂

为什么要用Docker
Docker解决的问题是将软件连带其环境一起安装。

虚拟机与容器
虚拟机
虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。
虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个</summary>
    
    
    
    <category term="coding" scheme="http://qixinbo.github.io/categories/coding/"/>
    
    
    <category term="Docker" scheme="http://qixinbo.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>开源深度学习计算平台ImJoy解析：12 -- 基于web的绘图库OpenLayers</title>
    <link href="http://qixinbo.github.io/2022/03/16/ImJoy_12/"/>
    <id>http://qixinbo.github.io/2022/03/16/ImJoy_12/</id>
    <published>2022-03-15T16:00:00.000Z</published>
    <updated>2022-03-16T07:26:31.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>ImJoy有一个很有用的插件或独立应用，叫做<a href="https://kaibu.org/">Kaibu</a>，它可以展示普通的位图、矢量图及vtk、stl等3D格式的数据。<br>比如如下展示：<br><img src="https://user-images.githubusercontent.com/6218739/158537518-a3583f3e-4b06-494b-928a-3904f6b29fb2.png" alt="kaibu"><br>其就是位图（png格式）、矢量图（json格式）、3D模型（stl格式）的一个叠加。</p><p>Kaibu主要用了两个JS库，一个是<a href="https://openlayers.org/">OpenLayers</a>，一个是<a href="https://kitware.github.io/itk-vtk-viewer/docs/">ITK-VTK</a>，前者用于展示矢量图形、普通位图等数据，且对地图的展示异常强大，后者用于展示在医疗及科学计算中常用的3D图像、网格、点集等。</p><p>这一篇主要介绍OpenLayers的相关知识。</p><h1 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h1><p>从<a href="https://github.com/openlayers/workshop/releases">OpenLayers workshop releases</a>里下载最新的资料包。<br>安装依赖：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><br>启动：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><br>这会启动一个开发服务器。可以通过<code>http://localhost:1234</code>查看一个“欢迎”的弹出窗口，以及<code>http://localhost:1234/doc/</code>查看说明文档。</p><h1 id="开发入门"><a href="#开发入门" class="headerlink" title="开发入门"></a>开发入门</h1><p>这一部分会通过OpenLayers map来创建一个简单的web页面。<br>在OpenLayers中，一个map是在web页面中被渲染的一系列“层”layers的集合。OpenLayers支持很多种layers：<br>（1）针对平铺光栅切片数据的Tile layer；<br>（2）针对位图图像的Image layer；<br>（3）针对矢量数据的Vector layer；<br>（4）针对平铺矢量切片数据的Vector tile layer。<br>除了这些layers，一个map还可以通过一系列的控制（即在map上面的UI元素）和交互（即与map进行交互反馈的部件）来进行配置。<br>为了创建一个map，需要通过HTML中的元素来创建（如一个<code>&lt;div&gt;</code>元素），以及一些样式来指定合适的尺寸。</p><h2 id="HTML页面"><a href="#HTML页面" class="headerlink" title="HTML页面"></a>HTML页面</h2><p>将项目根目录中的<code>index.html</code>里的内容替换为如下代码（注释写在了代码中）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;OpenLayers&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      <span class="comment">/*引入OpenLayers的样式*/</span></span><br><span class="line">      @<span class="keyword">import</span> <span class="string">&quot;node_modules/ol/ol.css&quot;</span>;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      <span class="comment">/*该部分样式使得map容器完全充满整个页面*/</span></span><br><span class="line">      html, body, #map-container &#123;</span><br><span class="line">        margin: <span class="number">0</span>;</span><br><span class="line">        height: <span class="number">100</span>%;</span><br><span class="line">        width: <span class="number">100</span>%;</span><br><span class="line">        font-family: sans-serif;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;!-- 该div标签是map的渲染容器 --&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;map-container&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;!-- 引入相关的js代码 --&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;./main.js&quot;</span> type=<span class="string">&quot;module&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h2 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h2><p>将项目根目录中的<code>main.js</code>里的内容替换为如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从OpenLayers中导入必要的模块</span></span><br><span class="line"><span class="keyword">import</span> OSM <span class="keyword">from</span> <span class="string">&#x27;ol/source/OSM&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> TileLayer <span class="keyword">from</span> <span class="string">&#x27;ol/layer/Tile&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="built_in">Map</span>, View&#125; <span class="keyword">from</span> <span class="string">&#x27;ol&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;fromLonLat&#125; <span class="keyword">from</span> <span class="string">&#x27;ol/proj&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Map对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>(&#123;</span><br><span class="line">  <span class="comment">// 目标是HTML中的那个div元素</span></span><br><span class="line">  target: <span class="string">&#x27;map-container&#x27;</span>,</span><br><span class="line">  layers: [</span><br><span class="line">    <span class="comment">// 具体的layer是使用了Tile Layer</span></span><br><span class="line">    <span class="keyword">new</span> TileLayer(&#123;</span><br><span class="line">      source: <span class="keyword">new</span> OSM(),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// view定义了初始的中心点和缩放比例</span></span><br><span class="line">  view: <span class="keyword">new</span> View(&#123;</span><br><span class="line">    <span class="comment">// 中心点的指定是通过fromLonLat函数获取地理坐标</span></span><br><span class="line">    center: fromLonLat([<span class="number">0</span>, <span class="number">0</span>]),</span><br><span class="line">    zoom: <span class="number">2</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>此时打开<code>http://localhost:1234</code>，会看到世界地图：<br><img src="https://user-images.githubusercontent.com/6218739/158340705-a8876d2b-035e-4764-9c77-229e722be721.png" alt="basic"></p><h1 id="矢量数据"><a href="#矢量数据" class="headerlink" title="矢量数据"></a>矢量数据</h1><p>在这一部分，将会创建一个可以操作矢量数据的编辑器，使得用户可以导入数据、绘制形状、修改已有形状及导出结果等。<br>本部分会使用<a href="https://geojson.org/">GeoJSON</a>数据，不过OpenLayers支持其他大量的矢量数据格式。</p><h2 id="渲染GeoJSON"><a href="#渲染GeoJSON" class="headerlink" title="渲染GeoJSON"></a>渲染GeoJSON</h2><p>在开发编辑功能之前，先看一下基本的对矢量数据的渲染功能。<br>在项目的data路径下有一个名为<code>countries.json</code>的GeoJSON文件，这里将加载该数据并在地图上渲染出来。<br>首先，编辑一下刚才的<code>index.html</code>，这里新加一行控制背景颜色的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;OpenLayers&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      @<span class="keyword">import</span> <span class="string">&quot;node_modules/ol/ol.css&quot;</span>;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      html, body, #map-container &#123;</span><br><span class="line">        margin: <span class="number">0</span>;</span><br><span class="line">        height: <span class="number">100</span>%;</span><br><span class="line">        width: <span class="number">100</span>%;</span><br><span class="line">        font-family: sans-serif;</span><br><span class="line">        <span class="comment">/*新加了这一行来控制背景颜色*/</span></span><br><span class="line">        background-color: #04041b;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;map-container&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;./main.js&quot;</span> type=<span class="string">&quot;module&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><br>然后将<code>main.js</code>中的内容替换为如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入GeoJSON包来读写该格式的数据</span></span><br><span class="line"><span class="keyword">import</span> GeoJSON <span class="keyword">from</span> <span class="string">&#x27;ol/format/GeoJSON&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="built_in">Map</span> <span class="keyword">from</span> <span class="string">&#x27;ol/Map&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorLayer <span class="keyword">from</span> <span class="string">&#x27;ol/layer/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorSource <span class="keyword">from</span> <span class="string">&#x27;ol/source/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> View <span class="keyword">from</span> <span class="string">&#x27;ol/View&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>(&#123;</span><br><span class="line">  target: <span class="string">&#x27;map-container&#x27;</span>,</span><br><span class="line">  layers: [</span><br><span class="line">    <span class="comment">// layer使用的是处理和渲染矢量数据的VectorLayer</span></span><br><span class="line">    <span class="keyword">new</span> VectorLayer(&#123;</span><br><span class="line">      <span class="comment">// VectorSource用来获取GeoJSON数据，并管理空间索引</span></span><br><span class="line">      source: <span class="keyword">new</span> VectorSource(&#123;</span><br><span class="line">        format: <span class="keyword">new</span> GeoJSON(),</span><br><span class="line">        <span class="comment">// 导入data目录下的JSON文件</span></span><br><span class="line">        url: <span class="string">&#x27;./data/countries.json&#x27;</span>,</span><br><span class="line">      &#125;),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  view: <span class="keyword">new</span> View(&#123;</span><br><span class="line">    center: [<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    zoom: <span class="number">2</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>效果如下：<br><img src="https://user-images.githubusercontent.com/6218739/158343566-6f7fa033-d8ec-4741-b50f-5e65ce122485.png" alt="json"></p><p>因为我们会重载这个页面很多次，目前代码下每次重载页面都会回到初始的view方式，即初始的中心点和缩放大小。如果能每次重载都能保持map在相同的位置就能节省很多人力。<br>此时可以借助<code>ol-hashed</code>包实现，修改代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> GeoJSON <span class="keyword">from</span> <span class="string">&#x27;ol/format/GeoJSON&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="built_in">Map</span> <span class="keyword">from</span> <span class="string">&#x27;ol/Map&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorLayer <span class="keyword">from</span> <span class="string">&#x27;ol/layer/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorSource <span class="keyword">from</span> <span class="string">&#x27;ol/source/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> View <span class="keyword">from</span> <span class="string">&#x27;ol/View&#x27;</span>;</span><br><span class="line"><span class="comment">// 导入ol-hashed包</span></span><br><span class="line"><span class="keyword">import</span> sync <span class="keyword">from</span> <span class="string">&#x27;ol-hashed&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Map对象分配到一个变量上</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(&#123;</span><br><span class="line">  target: <span class="string">&#x27;map-container&#x27;</span>,</span><br><span class="line">  layers: [</span><br><span class="line">    <span class="keyword">new</span> VectorLayer(&#123;</span><br><span class="line">      source: <span class="keyword">new</span> VectorSource(&#123;</span><br><span class="line">        format: <span class="keyword">new</span> GeoJSON(),</span><br><span class="line">        url: <span class="string">&#x27;./data/countries.json&#x27;</span>,</span><br><span class="line">      &#125;),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  view: <span class="keyword">new</span> View(&#123;</span><br><span class="line">    center: [<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    zoom: <span class="number">2</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将上面的变量传递给sync函数</span></span><br><span class="line">sync(map);</span><br></pre></td></tr></table></figure><br>此时，你会发现，将地图移动和缩放到某一特定程度后，下次重新载入代码仍然保持该视角不变。</p><h2 id="拖放"><a href="#拖放" class="headerlink" title="拖放"></a>拖放</h2><p>对于要实现的编辑器，想要允许用户能够导入自己的数据进行编辑。为此，这里将添加<code>DragAndDrop</code>功能。<br>跟以前一样，这里仍只处理GeoJSON这种数据，不过该交互也支持其他类型的数据格式。<br>修改<code>main.js</code>为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> GeoJSON <span class="keyword">from</span> <span class="string">&#x27;ol/format/GeoJSON&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="built_in">Map</span> <span class="keyword">from</span> <span class="string">&#x27;ol/Map&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorLayer <span class="keyword">from</span> <span class="string">&#x27;ol/layer/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorSource <span class="keyword">from</span> <span class="string">&#x27;ol/source/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> View <span class="keyword">from</span> <span class="string">&#x27;ol/View&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> sync <span class="keyword">from</span> <span class="string">&#x27;ol-hashed&#x27;</span>;</span><br><span class="line"><span class="comment">// 导入DragAndDrop包</span></span><br><span class="line"><span class="keyword">import</span> DragAndDrop <span class="keyword">from</span> <span class="string">&#x27;ol/interaction/DragAndDrop&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个Map对象，只指定它的目标和视图</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(&#123;</span><br><span class="line">  target: <span class="string">&#x27;map-container&#x27;</span>,</span><br><span class="line">  view: <span class="keyword">new</span> View(&#123;</span><br><span class="line">    center: [<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    zoom: <span class="number">2</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sync(map);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建数据源VectorSource，但是里面没有任何数据</span></span><br><span class="line"><span class="keyword">const</span> source = <span class="keyword">new</span> VectorSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建VectorLayer，里面的source传入上面定义的空的source</span></span><br><span class="line"><span class="keyword">const</span> layer = <span class="keyword">new</span> VectorLayer(&#123;</span><br><span class="line">  source: source,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 将layer添加到map中</span></span><br><span class="line">map.addLayer(layer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对map添加拖放交互</span></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> DragAndDrop(&#123;</span><br><span class="line">    <span class="comment">// 将拖放动作作用在Vector Source上</span></span><br><span class="line">    source: source,</span><br><span class="line">    <span class="comment">// 指定GeoJSON格式</span></span><br><span class="line">    formatConstructors: [GeoJSON],</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>此时就能将GeoJSON文件拖放到该页面上，从而进行渲染。</p><h2 id="修改特征"><a href="#修改特征" class="headerlink" title="修改特征"></a>修改特征</h2><p>现在可以将数据拖放到编辑器中，下面是添加“修改”功能。<br>实现方式是使用<code>Modify</code>交互。<br>修改<code>main.js</code>为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> DragAndDrop <span class="keyword">from</span> <span class="string">&#x27;ol/interaction/DragAndDrop&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> GeoJSON <span class="keyword">from</span> <span class="string">&#x27;ol/format/GeoJSON&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="built_in">Map</span> <span class="keyword">from</span> <span class="string">&#x27;ol/Map&#x27;</span>;</span><br><span class="line"><span class="comment">// 导入Modify包</span></span><br><span class="line"><span class="keyword">import</span> Modify <span class="keyword">from</span> <span class="string">&#x27;ol/interaction/Modify&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorLayer <span class="keyword">from</span> <span class="string">&#x27;ol/layer/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorSource <span class="keyword">from</span> <span class="string">&#x27;ol/source/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> View <span class="keyword">from</span> <span class="string">&#x27;ol/View&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> sync <span class="keyword">from</span> <span class="string">&#x27;ol-hashed&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(&#123;</span><br><span class="line">  target: <span class="string">&#x27;map-container&#x27;</span>,</span><br><span class="line">  view: <span class="keyword">new</span> View(&#123;</span><br><span class="line">    center: [<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    zoom: <span class="number">2</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sync(map);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source = <span class="keyword">new</span> VectorSource();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> layer = <span class="keyword">new</span> VectorLayer(&#123;</span><br><span class="line">  source: source,</span><br><span class="line">&#125;);</span><br><span class="line">map.addLayer(layer);</span><br><span class="line"></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> DragAndDrop(&#123;</span><br><span class="line">    source: source,</span><br><span class="line">    formatConstructors: [GeoJSON],</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在map上添加Modify交互，并配置交互对象</span></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> Modify(&#123;</span><br><span class="line">    source: source,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>此时就可以拖动顶点来修改特征。也可以使用<code>Alt+Click</code>来删除顶点。</p><h2 id="绘制特征"><a href="#绘制特征" class="headerlink" title="绘制特征"></a>绘制特征</h2><p>接下来添加<code>Draw</code>交互来使得用户可以绘制新的特征，并添加到数据中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> DragAndDrop <span class="keyword">from</span> <span class="string">&#x27;ol/interaction/DragAndDrop&#x27;</span>;</span><br><span class="line"><span class="comment">// 导入Draw包</span></span><br><span class="line"><span class="keyword">import</span> Draw <span class="keyword">from</span> <span class="string">&#x27;ol/interaction/Draw&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> GeoJSON <span class="keyword">from</span> <span class="string">&#x27;ol/format/GeoJSON&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="built_in">Map</span> <span class="keyword">from</span> <span class="string">&#x27;ol/Map&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Modify <span class="keyword">from</span> <span class="string">&#x27;ol/interaction/Modify&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorLayer <span class="keyword">from</span> <span class="string">&#x27;ol/layer/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorSource <span class="keyword">from</span> <span class="string">&#x27;ol/source/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> View <span class="keyword">from</span> <span class="string">&#x27;ol/View&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> sync <span class="keyword">from</span> <span class="string">&#x27;ol-hashed&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(&#123;</span><br><span class="line">  target: <span class="string">&#x27;map-container&#x27;</span>,</span><br><span class="line">  view: <span class="keyword">new</span> View(&#123;</span><br><span class="line">    center: [<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    zoom: <span class="number">2</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sync(map);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source = <span class="keyword">new</span> VectorSource();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> layer = <span class="keyword">new</span> VectorLayer(&#123;</span><br><span class="line">  source: source,</span><br><span class="line">&#125;);</span><br><span class="line">map.addLayer(layer);</span><br><span class="line"></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> DragAndDrop(&#123;</span><br><span class="line">    source: source,</span><br><span class="line">    formatConstructors: [GeoJSON],</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> Modify(&#123;</span><br><span class="line">    source: source,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在map上添加Draw交互</span></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> Draw(&#123;</span><br><span class="line">    <span class="comment">// 指定绘制形状，该值可以是任意的GeoJSON的几何形状</span></span><br><span class="line">    type: <span class="string">&#x27;Polygon&#x27;</span>,</span><br><span class="line">    <span class="comment">// 配置交互对象</span></span><br><span class="line">    source: source,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h2 id="自动吸附"><a href="#自动吸附" class="headerlink" title="自动吸附"></a>自动吸附</h2><p>上面的绘制功能添加后，可以发现，当绘制图形时，很难沿着之前的图形进行精确绘制。<br>此时可以添加<code>snap</code>功能，当鼠标移动到某个像素一定范围内时，就能自动吸附到该像素，从而完成精确绘制。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> DragAndDrop <span class="keyword">from</span> <span class="string">&#x27;ol/interaction/DragAndDrop&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Draw <span class="keyword">from</span> <span class="string">&#x27;ol/interaction/Draw&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> GeoJSON <span class="keyword">from</span> <span class="string">&#x27;ol/format/GeoJSON&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> GeometryType <span class="keyword">from</span> <span class="string">&#x27;ol/geom/GeometryType&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="built_in">Map</span> <span class="keyword">from</span> <span class="string">&#x27;ol/Map&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Modify <span class="keyword">from</span> <span class="string">&#x27;ol/interaction/Modify&#x27;</span>;</span><br><span class="line"><span class="comment">// 添加Snap包</span></span><br><span class="line"><span class="keyword">import</span> Snap <span class="keyword">from</span> <span class="string">&#x27;ol/interaction/Snap&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorLayer <span class="keyword">from</span> <span class="string">&#x27;ol/layer/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorSource <span class="keyword">from</span> <span class="string">&#x27;ol/source/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> View <span class="keyword">from</span> <span class="string">&#x27;ol/View&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> sync <span class="keyword">from</span> <span class="string">&#x27;ol-hashed&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(&#123;</span><br><span class="line">  target: <span class="string">&#x27;map-container&#x27;</span>,</span><br><span class="line">  view: <span class="keyword">new</span> View(&#123;</span><br><span class="line">    center: [<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    zoom: <span class="number">2</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sync(map);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source = <span class="keyword">new</span> VectorSource();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> layer = <span class="keyword">new</span> VectorLayer(&#123;</span><br><span class="line">  source: source,</span><br><span class="line">&#125;);</span><br><span class="line">map.addLayer(layer);</span><br><span class="line"></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> DragAndDrop(&#123;</span><br><span class="line">    source: source,</span><br><span class="line">    formatConstructors: [GeoJSON],</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> Modify(&#123;</span><br><span class="line">    source: source,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> Draw(&#123;</span><br><span class="line">    source: source,</span><br><span class="line">    type: GeometryType.POLYGON,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在map上添加Snap交互</span></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> Snap(&#123;</span><br><span class="line">    <span class="comment">// 配置作用对象</span></span><br><span class="line">    source: source,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h2 id="下载特征"><a href="#下载特征" class="headerlink" title="下载特征"></a>下载特征</h2><p>当上传数据，且对其编辑后，希望能下载特征。<br>为了能实现这个功能，这里将特征数据序列化为GeoJSON数据，然后创建一个带<code>download</code>属性的<code>&lt;a&gt;</code>元素，这样就能触发浏览器的文件保存对话框。<br>同时，在map上添加一个按钮，可以使得用户清除现在的特征，重新绘制。<br>修改<code>index.html</code>为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;OpenLayers&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      @<span class="keyword">import</span> <span class="string">&quot;node_modules/ol/ol.css&quot;</span>;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      html, body, #map-container &#123;</span><br><span class="line">        margin: <span class="number">0</span>;</span><br><span class="line">        height: <span class="number">100</span>%;</span><br><span class="line">        width: <span class="number">100</span>%;</span><br><span class="line">        font-family: sans-serif;</span><br><span class="line">        background-color: #04041b;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*对id为tools的div进行样式设定*/</span></span><br><span class="line">      #tools &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 1rem;</span><br><span class="line">        right: 1rem;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*对id为tools中的两个后代a元素设定样式*/</span></span><br><span class="line">      <span class="comment">/*css语法可以参见这里：*/</span></span><br><span class="line">      <span class="comment">/*https://www.runoob.com/css/css-combinators.html*/</span></span><br><span class="line">      #tools a &#123;</span><br><span class="line">        display: inline-block;</span><br><span class="line">        padding: <span class="number">0.</span>5rem;</span><br><span class="line">        background: white;</span><br><span class="line">        cursor: pointer;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*! [tools] */</span></span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;map-container&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;./main.js&quot;</span> type=<span class="string">&quot;module&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!-- 新增一个div元素，里面包含了两个a元素 --&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;tools&quot;</span>&gt;</span><br><span class="line">      &lt;a id=<span class="string">&quot;clear&quot;</span>&gt;Clear&lt;/a&gt;</span><br><span class="line">      &lt;a id=<span class="string">&quot;download&quot;</span> download=<span class="string">&quot;features.json&quot;</span>&gt;Download&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><br>修改<code>main.js</code>为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> GeoJSON <span class="keyword">from</span> <span class="string">&#x27;ol/format/GeoJSON&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> GeometryType <span class="keyword">from</span> <span class="string">&#x27;ol/geom/GeometryType&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="built_in">Map</span> <span class="keyword">from</span> <span class="string">&#x27;ol/Map&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorLayer <span class="keyword">from</span> <span class="string">&#x27;ol/layer/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorSource <span class="keyword">from</span> <span class="string">&#x27;ol/source/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> View <span class="keyword">from</span> <span class="string">&#x27;ol/View&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> sync <span class="keyword">from</span> <span class="string">&#x27;ol-hashed&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;DragAndDrop, Draw, Modify, Snap&#125; <span class="keyword">from</span> <span class="string">&#x27;ol/interaction&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(&#123;</span><br><span class="line">  target: <span class="string">&#x27;map-container&#x27;</span>,</span><br><span class="line">  view: <span class="keyword">new</span> View(&#123;</span><br><span class="line">    center: [<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    zoom: <span class="number">2</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sync(map);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source = <span class="keyword">new</span> VectorSource();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> layer = <span class="keyword">new</span> VectorLayer(&#123;</span><br><span class="line">  source: source,</span><br><span class="line">&#125;);</span><br><span class="line">map.addLayer(layer);</span><br><span class="line"></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> DragAndDrop(&#123;</span><br><span class="line">    source: source,</span><br><span class="line">    formatConstructors: [GeoJSON],</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> Modify(&#123;</span><br><span class="line">    source: source,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> Draw(&#123;</span><br><span class="line">    source: source,</span><br><span class="line">    type: GeometryType.POLYGON,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> Snap(&#123;</span><br><span class="line">    source: source,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现清除功能</span></span><br><span class="line"><span class="comment">// 首先通过DOM选取clear按钮</span></span><br><span class="line"><span class="keyword">const</span> clear = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;clear&#x27;</span>);</span><br><span class="line"><span class="comment">// 对该按钮添加鼠标事件</span></span><br><span class="line">clear.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  source.clear();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现下载功能</span></span><br><span class="line"><span class="comment">// 这里序列化数据为GeoJSON格式</span></span><br><span class="line"><span class="keyword">const</span> format = <span class="keyword">new</span> GeoJSON(&#123;<span class="attr">featureProjection</span>: <span class="string">&#x27;EPSG:3857&#x27;</span>&#125;);</span><br><span class="line"><span class="comment">// 通过DOM获取download按钮</span></span><br><span class="line"><span class="keyword">const</span> download = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;download&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为这里是期望随时都能下载最新的数据，所以将数据获取及序列化的工作绑定在source的change事件上</span></span><br><span class="line"><span class="comment">// 即，只要source改变，download按钮所能获得的数据就是最新的source</span></span><br><span class="line">source.on(<span class="string">&#x27;change&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获得特征</span></span><br><span class="line">  <span class="keyword">const</span> features = source.getFeatures();</span><br><span class="line">  <span class="comment">// 序列化特征</span></span><br><span class="line">  <span class="keyword">const</span> json = format.writeFeatures(features);</span><br><span class="line">  <span class="comment">// 这里将原json字符串转换成URI组成部分，将附加到下载按钮的href中</span></span><br><span class="line">  download.href =</span><br><span class="line">    <span class="string">&#x27;data:application/json;charset=utf-8,&#x27;</span> + <span class="built_in">encodeURIComponent</span>(json);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>效果如下：<br><img src="https://user-images.githubusercontent.com/6218739/158392776-41d856f4-1c85-43e2-a129-380ab1131356.png" alt="download"></p><h2 id="配置绘图样式"><a href="#配置绘图样式" class="headerlink" title="配置绘图样式"></a>配置绘图样式</h2><p>前面的编辑功能都是使用了默认样式，这里增加更多的属性来使得编辑功能更加强大，比如设置画笔宽度、设置填充颜色等。</p><h3 id="静态样式"><a href="#静态样式" class="headerlink" title="静态样式"></a>静态样式</h3><p>如果单纯想将样式都调成一个模样，那么可以直接简单地将样式固定即可，如下面代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> layer = <span class="keyword">new</span> VectorLayer(&#123;</span><br><span class="line">  source: source,</span><br><span class="line">  style: <span class="keyword">new</span> Style(&#123;</span><br><span class="line">    fill: <span class="keyword">new</span> Fill(&#123;</span><br><span class="line">      color: <span class="string">&#x27;red&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    stroke: <span class="keyword">new</span> Stroke(&#123;</span><br><span class="line">      color: <span class="string">&#x27;white&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>即都填充成红色，笔画都是白色。</p><h3 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h3><p>更多情况下，动态样式使用得更多，即按照一定的规则自动设置样式。<br>如下面：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">constlayer = newVectorLayer(&#123;</span><br><span class="line">  source: source,</span><br><span class="line">  style: <span class="function"><span class="keyword">function</span>(<span class="params">feature, resolution</span>) </span>&#123;</span><br><span class="line">    constname = feature.get(<span class="string">&#x27;name&#x27;</span>).toUpperCase();</span><br><span class="line">    returnname &lt; <span class="string">&quot;N&quot;</span>? style1 : style2; <span class="comment">// assuming these are created elsewhere&#125;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>就是根据feature的name来设置样式，如果是<code>A-M</code>，就用style1，如果是<code>N-Z</code>，则使用style2。<br>所以设定好规则非常重要。<br>下面将展示如何根据几何区域设定样式。<br>修改<code>main.js</code>为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> DragAndDrop <span class="keyword">from</span> <span class="string">&#x27;ol/interaction/DragAndDrop&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Draw <span class="keyword">from</span> <span class="string">&#x27;ol/interaction/Draw&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> GeoJSON <span class="keyword">from</span> <span class="string">&#x27;ol/format/GeoJSON&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> GeometryType <span class="keyword">from</span> <span class="string">&#x27;ol/geom/GeometryType&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="built_in">Map</span> <span class="keyword">from</span> <span class="string">&#x27;ol/Map&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Modify <span class="keyword">from</span> <span class="string">&#x27;ol/interaction/Modify&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Snap <span class="keyword">from</span> <span class="string">&#x27;ol/interaction/Snap&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorLayer <span class="keyword">from</span> <span class="string">&#x27;ol/layer/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorSource <span class="keyword">from</span> <span class="string">&#x27;ol/source/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> View <span class="keyword">from</span> <span class="string">&#x27;ol/View&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> sync <span class="keyword">from</span> <span class="string">&#x27;ol-hashed&#x27;</span>;</span><br><span class="line"><span class="comment">// 导入必要的样式库</span></span><br><span class="line"><span class="keyword">import</span> &#123;Fill, Stroke, Style&#125; <span class="keyword">from</span> <span class="string">&#x27;ol/style&#x27;</span>;</span><br><span class="line"><span class="comment">// 导入colormap包</span></span><br><span class="line"><span class="keyword">import</span> colormap <span class="keyword">from</span> <span class="string">&#x27;colormap&#x27;</span>;</span><br><span class="line"><span class="comment">// 从OpenLayers导入getArea包</span></span><br><span class="line"><span class="keyword">import</span> &#123;getArea&#125; <span class="keyword">from</span> <span class="string">&#x27;ol/sphere&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 根据面积计算颜色：开始 ----</span></span><br><span class="line"><span class="keyword">const</span> min = <span class="number">1e8</span>; <span class="comment">// the smallest area</span></span><br><span class="line"><span class="keyword">const</span> max = <span class="number">2e13</span>; <span class="comment">// the biggest area</span></span><br><span class="line"><span class="keyword">const</span> steps = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">const</span> ramp = colormap(&#123;</span><br><span class="line">  colormap: <span class="string">&#x27;blackbody&#x27;</span>,</span><br><span class="line">  nshades: steps,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clamp</span>(<span class="params">value, low, high</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(low, <span class="built_in">Math</span>.min(value, high));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params">feature</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> area = getArea(feature.getGeometry());</span><br><span class="line">  <span class="keyword">const</span> f = <span class="built_in">Math</span>.pow(clamp((area - min) / (max - min), <span class="number">0</span>, <span class="number">1</span>), <span class="number">1</span> / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> index = <span class="built_in">Math</span>.round(f * (steps - <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> ramp[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// --- 根据面积计算颜色：结束 ----</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(&#123;</span><br><span class="line">  target: <span class="string">&#x27;map-container&#x27;</span>,</span><br><span class="line">  view: <span class="keyword">new</span> View(&#123;</span><br><span class="line">    center: [<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    zoom: <span class="number">2</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sync(map);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source = <span class="keyword">new</span> VectorSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加样式</span></span><br><span class="line"><span class="keyword">const</span> layer = <span class="keyword">new</span> VectorLayer(&#123;</span><br><span class="line">  source: source,</span><br><span class="line">  style: <span class="function"><span class="keyword">function</span> (<span class="params">feature</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Style(&#123;</span><br><span class="line">      fill: <span class="keyword">new</span> Fill(&#123;</span><br><span class="line">        color: getColor(feature),</span><br><span class="line">      &#125;),</span><br><span class="line">      stroke: <span class="keyword">new</span> Stroke(&#123;</span><br><span class="line">        color: <span class="string">&#x27;rgba(255,255,255,0.8)&#x27;</span>,</span><br><span class="line">      &#125;),</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">map.addLayer(layer);</span><br><span class="line"></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> DragAndDrop(&#123;</span><br><span class="line">    source: source,</span><br><span class="line">    formatConstructors: [GeoJSON],</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> Modify(&#123;</span><br><span class="line">    source: source,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> Draw(&#123;</span><br><span class="line">    source: source,</span><br><span class="line">    type: GeometryType.POLYGON,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> Snap(&#123;</span><br><span class="line">    source: source,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clear = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;clear&#x27;</span>);</span><br><span class="line">clear.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  source.clear();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> format = <span class="keyword">new</span> GeoJSON(&#123;<span class="attr">featureProjection</span>: <span class="string">&#x27;EPSG:3857&#x27;</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> download = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;download&#x27;</span>);</span><br><span class="line">source.on(<span class="string">&#x27;change&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> features = source.getFeatures();</span><br><span class="line">  <span class="keyword">const</span> json = format.writeFeatures(features);</span><br><span class="line">  download.href = <span class="string">&#x27;data:text/json;charset=utf-8,&#x27;</span> + json;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>效果如下：<br><img src="https://user-images.githubusercontent.com/6218739/158398065-704634ef-a6dc-4d17-a4a6-a87edc51c8f1.png" alt="style"></p><h1 id="移动端地图和数据集成"><a href="#移动端地图和数据集成" class="headerlink" title="移动端地图和数据集成"></a>移动端地图和数据集成</h1><p>这一部分将创建一个移动端的地图来展示用户的GPS位置和朝向。该项目的目的是为了展示怎样将OpenLayers与浏览器的API及第三方工具进行集成。<br>具体地，仅使用几行代码即可调用浏览器的关于地理位置的API，从而得到GPS位置，以及使用<a href="https://www.npmjs.com/package/kompas">kompas</a>库通过设备的陀螺仪获得朝向。然后，通过使用Vector Layer，就能很轻易地在地图上显示结果。</p><p>因为这一部分需要移动端的配合，不再具体分析。</p><p>更多用法留坑待填。</p>]]></content>
    
    
    <summary type="html">简介
ImJoy有一个很有用的插件或独立应用，叫做Kaibu，它可以展示普通的位图、矢量图及vtk、stl等3D格式的数据。
比如如下展示：

其就是位图（png格式）、矢量图（json格式）、3D模型（stl格式）的一个叠加。

Kaibu主要用了两个JS库，一个是OpenLayers，一个是ITK-VTK，前者用于展示矢量图形、普通位图等数据，且对地图的展示异常强大，后者用于展示在医疗及科学计算中常用的3D图像、网格、点集等。

这一篇主要介绍OpenLayers的相关知识。

配置环境
从OpenLayers workshop releases里下载最新的资料包。
安装依赖：
1


n</summary>
    
    
    
    <category term="computer vision" scheme="http://qixinbo.github.io/categories/computer-vision/"/>
    
    
    <category term="ImJoy" scheme="http://qixinbo.github.io/tags/ImJoy/"/>
    
  </entry>
  
  <entry>
    <title>用Python开发web应用——Streamlit框架解析：3 -- 组件</title>
    <link href="http://qixinbo.github.io/2022/03/11/streamlit_3/"/>
    <id>http://qixinbo.github.io/2022/03/11/streamlit_3/</id>
    <published>2022-03-10T16:00:00.000Z</published>
    <updated>2022-03-11T08:46:28.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Streamlit的组件Components是一系列第三方的Python模块，其极大地扩展了Streamlit的功能。<br>Components带来了无穷的想象力和可能性，比如与React、Vue等前端框架联动、创建自定义风格和行为的新部件、以及增加新的可视化图表类型等。</p><h1 id="使用组件"><a href="#使用组件" class="headerlink" title="使用组件"></a>使用组件</h1><h2 id="查找可用组件"><a href="#查找可用组件" class="headerlink" title="查找可用组件"></a>查找可用组件</h2><p>查找组件有两个常用的途径：<br>一是<a href="https://streamlit.io/components">Component Gallery</a>，这是官方挑选出来的特色组件；<br>二是<a href="https://discuss.streamlit.io/t/streamlit-components-community-tracker/4634">Streamlit Components - Community Tracker</a>这个论坛帖子，里面搜集了很多社区成员创建的组件。</p><h2 id="安装组件"><a href="#安装组件" class="headerlink" title="安装组件"></a>安装组件</h2><p>安装这些组件，只需：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install some_cool_component</span><br></pre></td></tr></table></figure><br>以<a href="https://github.com/PablocFonseca/streamlit-aggrid">AgGrid</a>组件为例，安装命令为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install streamlit-aggrid</span><br></pre></td></tr></table></figure></p><h2 id="使用组件-1"><a href="#使用组件-1" class="headerlink" title="使用组件"></a>使用组件</h2><p>查看组件的使用文档，还是以AgGrid为例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> st_aggrid <span class="keyword">import</span> AgGrid</span><br><span class="line">AgGrid(my_dataframe)</span><br></pre></td></tr></table></figure></p><h1 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h1><p>如果已有的组件不满足自己的需求，还可以自己创建组件。<br>先来看一下插件的类型：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"></span><br><span class="line">x = st.slider(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">st.markdown(<span class="string">f&#x27;`<span class="subst">&#123;x&#125;</span>` squared is `<span class="subst">&#123;x * x&#125;</span>`&#x27;</span>)</span><br></pre></td></tr></table></figure><br>如上代码中有两种组件：<br>（1）静态组件static components，即<code>st.markdown</code>，它是无状态的，仅向浏览器发送和渲染数据；<br>（2）双向组件bidirectional components，即<code>st.slider</code>，它有内部状态，会从浏览器中返回数据，也可以向浏览器发送和渲染数据，即在后台Python代码和前端JavaScript代码之间交换数据。</p><p>对于组件开发，Streamlit提供了<code>streamlit.components.v1</code>这个包：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">importstreamlit.components.v1 <span class="keyword">as</span> components</span><br></pre></td></tr></table></figure><br>这个略显冗长的导入声明对组件API明确地指明了版本号，这样以后升级后就不会破坏已有的组件。</p><p>具体地，对于静态组件，有两种方法可供使用：<br>（1）<code>html(...)</code>可以基于HTML、JavaScript和CSS来创建组件；<br>（2）<code>iframe(...)</code>可以嵌入外部网站。<br>对于双向组件：<br><code>declare_component(...)</code>可以创建在Streamlit和浏览器之间双向交换数据的动态部件。</p><h2 id="创建静态组件"><a href="#创建静态组件" class="headerlink" title="创建静态组件"></a>创建静态组件</h2><p>如果创建的组件目的是为了仅仅展示HTML代码或从Python可视化库中渲染图表，那么可以有两种很简单的方法实现<code>components.html()</code>和<code>components.iframe()</code>。</p><h3 id="示例1：Gist代码段"><a href="#示例1：Gist代码段" class="headerlink" title="示例1：Gist代码段"></a>示例1：Gist代码段</h3><p>比如想在页面中嵌入如下这种Github Gist代码段：<br><img src="https://user-images.githubusercontent.com/6218739/157794777-0778762a-cb06-437e-98bc-6f63cc6f4a11.png" alt="gist"><br>那么，可以这样写：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"><span class="keyword">import</span> streamlit.components.v1 <span class="keyword">as</span> components</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">github_gist</span>(<span class="params">gist_creator, gist_id, height=<span class="number">600</span>, scrolling=<span class="literal">True</span></span>):</span></span><br><span class="line">    components.html(</span><br><span class="line">        <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      &lt;script src=&quot;https://gist.github.com/<span class="subst">&#123;gist_creator&#125;</span>/<span class="subst">&#123;gist_id&#125;</span>.js&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;/script&gt;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>,</span><br><span class="line">        height=height,</span><br><span class="line">        scrolling=scrolling,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">github_gist(<span class="string">&#x27;gwen001&#x27;</span>, <span class="string">&#x27;6843c83d878ff22783bd573ac48a2c93&#x27;</span>, height=<span class="number">600</span>)</span><br></pre></td></tr></table></figure><br>可以看出，在<code>components.html()</code>可以方便地嵌入和调用javascript脚本。</p><h3 id="示例2：boostrap"><a href="#示例2：boostrap" class="headerlink" title="示例2：boostrap"></a>示例2：boostrap</h3><p>如下例子是使用bootstrap库创建自定义按钮。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"><span class="keyword">import</span> streamlit.components.v1 <span class="keyword">as</span> components</span><br><span class="line"></span><br><span class="line"><span class="comment"># bootstrap 4 collapse example</span></span><br><span class="line">components.html(</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css&quot; integrity=&quot;sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm&quot; crossorigin=&quot;anonymous&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;script src=&quot;https://code.jquery.com/jquery-3.2.1.slim.min.js&quot; integrity=&quot;sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script src=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js&quot; integrity=&quot;sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;div id=&quot;accordion&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;div class=&quot;card&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;card-header&quot; id=&quot;headingOne&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;h5 class=&quot;mb-0&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;button class=&quot;btn btn-link&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#collapseOne&quot; aria-expanded=&quot;true&quot; aria-controls=&quot;collapseOne&quot;&gt;</span></span><br><span class="line"><span class="string">            Collapsible Group Item #1</span></span><br><span class="line"><span class="string">            &lt;/button&gt;</span></span><br><span class="line"><span class="string">          &lt;/h5&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div id=&quot;collapseOne&quot; class=&quot;collapse show&quot; aria-labelledby=&quot;headingOne&quot; data-parent=&quot;#accordion&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;div class=&quot;card-body&quot;&gt;</span></span><br><span class="line"><span class="string">            Collapsible Group Item #1 content</span></span><br><span class="line"><span class="string">          &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;div class=&quot;card&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;card-header&quot; id=&quot;headingTwo&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;h5 class=&quot;mb-0&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;button class=&quot;btn btn-link collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#collapseTwo&quot; aria-expanded=&quot;false&quot; aria-controls=&quot;collapseTwo&quot;&gt;</span></span><br><span class="line"><span class="string">            Collapsible Group Item #2</span></span><br><span class="line"><span class="string">            &lt;/button&gt;</span></span><br><span class="line"><span class="string">          &lt;/h5&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div id=&quot;collapseTwo&quot; class=&quot;collapse&quot; aria-labelledby=&quot;headingTwo&quot; data-parent=&quot;#accordion&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;div class=&quot;card-body&quot;&gt;</span></span><br><span class="line"><span class="string">            Collapsible Group Item #2 content</span></span><br><span class="line"><span class="string">          &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>,</span><br><span class="line">    height=<span class="number">600</span>,</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>效果如下：<br><img src="https://user-images.githubusercontent.com/6218739/157795147-df1b82ca-51b5-4d86-97ba-d1c3c608da06.png" alt="bootstrap"><br>可以看出，可以嵌入任意的HTML、CSS和JavaScript代码。<br>同时，因为Component运行在由一个<code>iframe</code>创建的沙盒sandbox中，不用担心安全问题。</p><h3 id="示例3：嵌入外部网站"><a href="#示例3：嵌入外部网站" class="headerlink" title="示例3：嵌入外部网站"></a>示例3：嵌入外部网站</h3><p><code>components.iframe</code>与<code>components.html</code>功能类似，只是它的输入是URL地址，这样就能轻松地将外部网站嵌入到Streamlit app中。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"><span class="keyword">import</span> streamlit.components.v1 <span class="keyword">as</span> components</span><br><span class="line"></span><br><span class="line"><span class="comment"># embed streamlit docs in a streamlit app</span></span><br><span class="line">st.title(<span class="string">&quot;Embed external website&quot;</span>)</span><br><span class="line">components.iframe(<span class="string">&quot;http://www.bing.com/&quot;</span>, height=<span class="number">600</span>, width=<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><br>效果如下：<br><img src="https://user-images.githubusercontent.com/6218739/157796219-22acc939-89b1-49aa-ad11-e67803a14446.png" alt="iframe"></p><h2 id="创建双向组件"><a href="#创建双向组件" class="headerlink" title="创建双向组件"></a>创建双向组件</h2><p>双向组件由两部分构成：<br>（1）一个前端frontend：基于HTML或任意web技术栈（JS技术，React、Vue等框架）构建，然后在Streamlit app中通过一个<code>iframe</code>标签所渲染；<br>（2）一个Python API：使得app可以实例化，并与前端交流数据。</p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>要创建双向组件，需要先安装如下环境：<br>（1）Python3.7-python3.9<br>（2）Streamlit 0.63+<br>（3）nodejs<br>（4）npm或yarn</p><h3 id="下载模板"><a href="#下载模板" class="headerlink" title="下载模板"></a>下载模板</h3><p>可以使用任意web技术来构建组件，Streamlit官方提供了基于React.js前端和纯TypeScript的开发模板，见<a href="https://github.com/streamlit/component-template">这个仓库</a>。<br>也可以使用Vue.js及其他技术。这里以一个社区成员提供的<a href="https://github.com/andfanilo/streamlit-component-template-vue">Vue3模板</a>为例，下载该模板：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:andfanilo/streamlit-component-template-vue.git</span><br></pre></td></tr></table></figure></p><h3 id="安装依赖并运行模板"><a href="#安装依赖并运行模板" class="headerlink" title="安装依赖并运行模板"></a>安装依赖并运行模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd my_component/frontend</span><br><span class="line">$ npm install    <span class="comment"># Install npm dependencies</span></span><br><span class="line">$ npm run serve  <span class="comment"># Start the Webpack dev server</span></span><br></pre></td></tr></table></figure><p>注意这里是使用了开发服务器来运行前端代码，好处是开发阶段，每次代码的变动都能直接起效。<br>在实际上线过程中，使用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><br>来进行打包。具体详情可查看“发布组件”一节。</p><h3 id="运行app"><a href="#运行app" class="headerlink" title="运行app"></a>运行app</h3><p>另开一个终端，然后运行该模板所对应的app：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">streamlit run my_component/__init__.py  <span class="comment"># run the example</span></span><br></pre></td></tr></table></figure></p><p>效果如下：<br><img src="https://user-images.githubusercontent.com/6218739/157813585-17353496-5ccf-4126-8073-5b16ea5fc70b.png" alt="vue"></p><p>这个例子展示了双向交流数据是怎样进行的。Streamlit Component展示一个按钮（<code>python-&gt;JavaScript</code>），然后终端用户可以点击按钮。每次按钮被点击后，JavaScript前端就增加计算器数值，然后把它传递回Python（<code>JavaScript-&gt;Python</code>），然后Streamlit又再次渲染展示（<code>Python-&gt;JavaScript</code>）。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="数据交换过程"><a href="#数据交换过程" class="headerlink" title="数据交换过程"></a>数据交换过程</h4><p>（1）Python到JavaScript<br>基于Vue的前端在<code>my_component/frontend/src/MyComponent.vue</code>文件中。Python脚本传来的参数可以在<code>args</code>属性中获得：<br>以此例来说，在Python脚本中定义的函数及其参数为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_component_func = components.declare_component(</span><br><span class="line">    <span class="string">&quot;my_component&quot;</span>,</span><br><span class="line">    url=<span class="string">&quot;http://localhost:3001&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_component</span>(<span class="params">name, key=<span class="literal">None</span></span>):</span></span><br><span class="line">    component_value = _component_func(name=name, key=key, default=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> component_value</span><br><span class="line"></span><br><span class="line">num_clicks = my_component(<span class="string">&quot;World&quot;</span>)</span><br></pre></td></tr></table></figure><br>然后在前端Vue模板中可以这样接收和使用：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;span&gt;</span><br><span class="line">    Hello, &#123;&#123; args.name &#125;&#125;! &amp;nbsp;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><br>（2）JavaScript到Python<br>在前端中通过<code>Streamlit.setComponentValue()</code>向Python脚本传递数据：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Streamlit.setComponentValue(numClicks.value)</span><br></pre></td></tr></table></figure><br>在Python脚本中获得如上数值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num_clicks = my_component(<span class="string">&quot;World&quot;</span>)</span><br><span class="line">st.markdown(<span class="string">&quot;You&#x27;ve clicked %s times!&quot;</span> % <span class="built_in">int</span>(num_clicks))</span><br></pre></td></tr></table></figure><br>当调用<code>Streamlit.setComponentValue(new_value)</code>时，这个新的数值就会传给Streamlit，其就会从上到下重新运行Python脚本，当脚本重新运行后，对<code>my_component(...)</code>的调用就会返回新的数值。</p><h4 id="数据序列化"><a href="#数据序列化" class="headerlink" title="数据序列化"></a>数据序列化</h4><p>（1）Python到JavaScript<br>如前所述，可以在Python的<code>my_component</code>函数中传递数据，从而在JavaScript中获取。可以传递的数据有：</p><ul><li>任何可序列化为JSON的数据</li><li><code>numpy.array</code></li><li><code>pandas.DataFrame</code></li></ul><p>第一种任何可序列化为JSON的数据都会被序列化为JSON字符串，然后在JavaScript中反序列化。<br>第二种和第三种都是通过<a href="https://arrow.apache.org/">Apache Arrow</a>序列化，然后被反序列化为<code>ArrowType</code>，它是Arrow自定义的一种数据格式，提供了非常简便的API供调用。<br>（2）JavaScript到Python<br>如前所述，可以在JavaScript的<code>Streamlit.setComponentValue()</code>函数中传递数据给Python。不像是前面Python到JavaScript那样可以传递参数并解析参数，这个函数仅能传递一个数值。如果想传递多个数值，需要将它们封装成<code>Array</code>或<code>Object</code>。<br>从JavaScript到Python，可以传递可序列化为JSON的数据，以及<code>ArrowTable</code>这种能表示data frame的数据结构。</p><h1 id="发布组件"><a href="#发布组件" class="headerlink" title="发布组件"></a>发布组件</h1><p>新的组件创建好后，可以将其打包发布到PyPI上，供其他Python用户使用。即使不是为了公开自己的组件，对于双向组件，也是需要将前端部分进行生产环境下的打包。<br>对于静态组件的发布，以及上传PyPI，这些操作在这里都不再详述，具体可以参考<a href="https://docs.streamlit.io/library/components/publish">这里</a>。<br>这一部分主要看双向组件的配置，因为其既还有Python代码，也有JS和HTML代码，需要将这些前端代码编译成静态文件。<br>双向组件的配置基于前面的template。<br>（1）命名组件<br>首先，将<code>template/my_component/</code>文件夹重命名为<code>template/&lt;component name&gt;/</code>；<br>然后，将组件名字传入<code>declare_component()</code>的第一个参数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> _RELEASE:</span><br><span class="line">    _component_func = components.declare_component(</span><br><span class="line">        <span class="string">&quot;hello_world&quot;</span>,</span><br><span class="line">        url=<span class="string">&quot;http://localhost:3001&quot;</span>,</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    parent_dir = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">    build_dir = os.path.join(parent_dir, <span class="string">&quot;frontend/dist&quot;</span>)</span><br><span class="line">    _component_func = components.declare_component(</span><br><span class="line">        <span class="string">&quot;hello_world&quot;</span>, path=build_dir)</span><br></pre></td></tr></table></figure><br>（2）打包前端文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd frontend</span><br><span class="line">$ npm run build</span><br></pre></td></tr></table></figure><br>即将Vue代码编译为HTML、CSS和JS文件。这将会新建一个<code>frontend/dist/</code>文件夹，里面存放了这些文件。<br>（3）更改Release模式<br>将Python脚本中的模式设为release模式：<code>_RELEASE = True</code>。</p><p>这样配置以后，就无需通过<code>npm run serve</code>开启一个开发服务器，直接使用一个终端运行<code>streamlit run</code>即可。</p>]]></content>
    
    
    <summary type="html">简介
Streamlit的组件Components是一系列第三方的Python模块，其极大地扩展了Streamlit的功能。
Components带来了无穷的想象力和可能性，比如与React、Vue等前端框架联动、创建自定义风格和行为的新部件、以及增加新的可视化图表类型等。

使用组件
查找可用组件
查找组件有两个常用的途径：
一是Component Gallery，这是官方挑选出来的特色组件；
二是Streamlit Components - Community Tracker这个论坛帖子，里面搜集了很多社区成员创建的组件。

安装组件
安装这些组件，只需：
1


pip install </summary>
    
    
    
    <category term="digitalization" scheme="http://qixinbo.github.io/categories/digitalization/"/>
    
    
    <category term="Streamlit" scheme="http://qixinbo.github.io/tags/Streamlit/"/>
    
  </entry>
  
  <entry>
    <title>用Python开发web应用——Streamlit框架解析：2 -- 会话状态</title>
    <link href="http://qixinbo.github.io/2022/03/10/streamlit_2/"/>
    <id>http://qixinbo.github.io/2022/03/10/streamlit_2/</id>
    <published>2022-03-09T16:00:00.000Z</published>
    <updated>2022-03-10T06:31:51.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在Streamlit中，与一个部件widget的交互会触发“重新运行”rerun，这样一来每次运行后代码中的变量都会被重新初始化。这可能会带来很麻烦的问题，比如实现一个简单的“累加计数按钮”，每次点击后都会清零，无法实现累加功能。<br>为了解决类似问题，Streamlit引入了一种新的特性：会话状态Session State，它是一种可以在rerun之间保存变量状态、配合使用回调函数处理部件上的事件、动态改变部件状态等等的功能（注意，这些功能发生在一个session中，一个session可以简单理解为用户通过浏览器的一个标签页来访问Streamlit）。其可以用在如下场景中：<br>（1）数据或图像标注<a href="https://github.com/streamlit/release-demos/blob/0.84/0.84/demos/labelling.py">code</a>；<br>（2）创建分页<a href="https://github.com/streamlit/release-demos/blob/0.84/0.84/demos/pagination.py">code</a>；<br>（3）基于其他部件来添加部件；<br>（4）创建简单的基于状态的小游戏，如井字棋<a href="https://github.com/streamlit/release-demos/blob/0.84/0.84/demos/tic_tac_toe.py">code</a>；<br>（5）待办事项清单<a href="https://github.com/streamlit/release-demos/blob/0.84/0.84/demos/todo_list.py">code</a>。</p><h1 id="累加计数例子"><a href="#累加计数例子" class="headerlink" title="累加计数例子"></a>累加计数例子</h1><p>比如最开头提到的“累加计数按钮”的实现，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"></span><br><span class="line">st.title(<span class="string">&#x27;Counter Example&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Streamlit runs from top to bottom on every iteraction so</span></span><br><span class="line"><span class="comment"># we check if `count` has already been initialized in st.session_state.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If no, then initialize count to 0</span></span><br><span class="line"><span class="comment"># If count is already initialized, don&#x27;t do anything</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;count&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> st.session_state:</span><br><span class="line">    st.session_state.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a button which will increment the counter</span></span><br><span class="line">increment = st.button(<span class="string">&#x27;Increment&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> increment:</span><br><span class="line">    st.session_state.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A button to decrement the counter</span></span><br><span class="line">decrement = st.button(<span class="string">&#x27;Decrement&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> decrement:</span><br><span class="line">    st.session_state.count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">st.write(<span class="string">&#x27;Count = &#x27;</span>, st.session_state.count)</span><br></pre></td></tr></table></figure></p><h1 id="配合回调函数更新会话状态"><a href="#配合回调函数更新会话状态" class="headerlink" title="配合回调函数更新会话状态"></a>配合回调函数更新会话状态</h1><p>首先看一下什么是回调函数，援引维基百科上的一张图：<br><img src="https://user-images.githubusercontent.com/6218739/157572549-24b73b56-bd8d-4f5b-8825-c66eb25e0449.svg" alt="Callback-notitle"><br>这张图说明了几个事情：<br>（1）底层有一个库函数，它被其他程序（这里是Main program这个程序）所调用<br>（2）这个库函数有脾气，它不能被简单调用，需要给它提前传一个函数（即回调函数），这样才能在合适的时候执行该函数<br>（3）这个回调函数与main program处于同一层级，是由main program来指定的。<br>可以这样记忆回调函数：从库函数的视角，你先给我这个函数，我回头再调用你。<br><a href="https://www.zhihu.com/question/19801131/answer/27459821">回调函数（callback）是什么？ - no.body的回答 - 知乎</a>挺好。</p><h2 id="使用回调函数更新会话状态"><a href="#使用回调函数更新会话状态" class="headerlink" title="使用回调函数更新会话状态"></a>使用回调函数更新会话状态</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"></span><br><span class="line">st.title(<span class="string">&#x27;Counter Example using Callbacks&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;count&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> st.session_state:</span><br><span class="line">    st.session_state.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">increment_counter</span>():</span></span><br><span class="line">    st.session_state.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">st.button(<span class="string">&#x27;Increment&#x27;</span>, on_click=increment_counter)</span><br><span class="line"></span><br><span class="line">st.write(<span class="string">&#x27;Count = &#x27;</span>, st.session_state.count)</span><br></pre></td></tr></table></figure><p>即可以在输入部件（比如按钮、滑块、文本框等）的<code>on_change</code>或<code>on_click</code>的事件上绑定回调函数。</p><h2 id="在回调函数中使用args和kwargs"><a href="#在回调函数中使用args和kwargs" class="headerlink" title="在回调函数中使用args和kwargs"></a>在回调函数中使用args和kwargs</h2><p>可以在回调函数中传入参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"></span><br><span class="line">st.title(<span class="string">&#x27;Counter Example using Callbacks with args&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;count&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> st.session_state:</span><br><span class="line">    st.session_state.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">increment_value = st.number_input(<span class="string">&#x27;Enter a value&#x27;</span>, value=<span class="number">0</span>, step=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">increment_counter</span>(<span class="params">increment_value</span>):</span></span><br><span class="line">    st.session_state.count += increment_value</span><br><span class="line"></span><br><span class="line">increment = st.button(<span class="string">&#x27;Increment&#x27;</span>, on_click=increment_counter,</span><br><span class="line">    args=(increment_value, ))</span><br><span class="line"></span><br><span class="line">st.write(<span class="string">&#x27;Count = &#x27;</span>, st.session_state.count)</span><br></pre></td></tr></table></figure><br>也可以传入字典类型的命名参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"></span><br><span class="line">st.title(<span class="string">&#x27;Counter Example using Callbacks with kwargs&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;count&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> st.session_state:</span><br><span class="line">    st.session_state.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">increment_counter</span>(<span class="params">increment_value=<span class="number">0</span></span>):</span></span><br><span class="line">    st.session_state.count += increment_value</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrement_counter</span>(<span class="params">decrement_value=<span class="number">0</span></span>):</span></span><br><span class="line">    st.session_state.count -= decrement_value</span><br><span class="line"></span><br><span class="line">st.button(<span class="string">&#x27;Increment&#x27;</span>, on_click=increment_counter,</span><br><span class="line">    kwargs=<span class="built_in">dict</span>(increment_value=<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">st.button(<span class="string">&#x27;Decrement&#x27;</span>, on_click=decrement_counter,</span><br><span class="line">    kwargs=<span class="built_in">dict</span>(decrement_value=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">st.write(<span class="string">&#x27;Count = &#x27;</span>, st.session_state.count)</span><br></pre></td></tr></table></figure></p><h2 id="在表单上绑定回调函数"><a href="#在表单上绑定回调函数" class="headerlink" title="在表单上绑定回调函数"></a>在表单上绑定回调函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">st.title(<span class="string">&#x27;Counter Example&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;count&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> st.session_state:</span><br><span class="line">    st.session_state.count = <span class="number">0</span></span><br><span class="line">    st.session_state.last_updated = datetime.time(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_counter</span>():</span></span><br><span class="line">    st.session_state.count += st.session_state.increment_value</span><br><span class="line">    st.session_state.last_updated = st.session_state.update_time</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> st.form(key=<span class="string">&#x27;my_form&#x27;</span>):</span><br><span class="line">    st.time_input(label=<span class="string">&#x27;Enter the time&#x27;</span>, value=datetime.datetime.now().time(), key=<span class="string">&#x27;update_time&#x27;</span>)</span><br><span class="line">    st.number_input(<span class="string">&#x27;Enter a value&#x27;</span>, value=<span class="number">0</span>, step=<span class="number">1</span>, key=<span class="string">&#x27;increment_value&#x27;</span>)</span><br><span class="line">    submit = st.form_submit_button(label=<span class="string">&#x27;Update&#x27;</span>, on_click=update_counter)</span><br><span class="line"></span><br><span class="line">st.write(<span class="string">&#x27;Current Count = &#x27;</span>, st.session_state.count)</span><br><span class="line">st.write(<span class="string">&#x27;Last Updated = &#x27;</span>, st.session_state.last_updated)</span><br></pre></td></tr></table></figure><p>在form中仅有<code>st.form_submit_button</code>可以设置回调函数，其他在form中的部件不允许有回调函数。</p><h1 id="变量状态和部件状态的关联"><a href="#变量状态和部件状态的关联" class="headerlink" title="变量状态和部件状态的关联"></a>变量状态和部件状态的关联</h1><p>Session State存储了变量的值，而部件widgets的状态也可以存储在Session State中，变量的状态与部件的状态就可以实现梦幻联动了，方法就是将变量名设置为部件的key值。<br>比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;celsius&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> st.session_state:</span><br><span class="line">    <span class="comment"># set the initial default value of the slider widget</span></span><br><span class="line">    st.session_state.celsius = <span class="number">50.0</span></span><br><span class="line"></span><br><span class="line">st.slider(</span><br><span class="line">    <span class="string">&quot;Temperature in Celsius&quot;</span>,</span><br><span class="line">    min_value=-<span class="number">100.0</span>,</span><br><span class="line">    max_value=<span class="number">100.0</span>,</span><br><span class="line">    key=<span class="string">&quot;celsius&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This will get the value of the slider widget</span></span><br><span class="line">st.write(st.session_state.celsius)</span><br></pre></td></tr></table></figure><br>但是，有两个例外，不能通过Session State的API来改变<code>st.button</code>、<code>st.download_button</code>和<code>st.file_uploader</code>部件的状态。<br>还需要注意的是Session State变量和部件初始化的顺序，如果先初始化了部件，再通过Session State的API来更改它的状态，此时就会报错，抛出<code>StreamlitAPIException</code>的错误。<br>所以，一定注意先在Session State中定义好变量。</p><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="初始化状态"><a href="#初始化状态" class="headerlink" title="初始化状态"></a>初始化状态</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Initialization</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;key&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> st.session_state:</span><br><span class="line">    st.session_state[<span class="string">&#x27;key&#x27;</span>] = <span class="string">&#x27;value&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Session State also supports attribute based syntax</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;key&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> st.session_state:</span><br><span class="line">    st.session_state.key = <span class="string">&#x27;value&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="读取和更新"><a href="#读取和更新" class="headerlink" title="读取和更新"></a>读取和更新</h2><p>读取Session State：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取某一个状态</span></span><br><span class="line">st.write(st.session_state.key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取所有状态</span></span><br><span class="line">st.write(st.session_state)</span><br><span class="line"></span><br><span class="line"><span class="comment"># With magic:</span></span><br><span class="line">st.session_state</span><br></pre></td></tr></table></figure><br>更新状态（有两种方式）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">st.session_state.key = <span class="string">&#x27;value2&#x27;</span>     <span class="comment"># Attribute API</span></span><br><span class="line">st.session_state[<span class="string">&#x27;key&#x27;</span>] = <span class="string">&#x27;value2&#x27;</span>  <span class="comment"># Dictionary like API</span></span><br></pre></td></tr></table></figure></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Delete a single key-value pair</span></span><br><span class="line"><span class="keyword">del</span> st.session_state[key]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Delete all the items in Session state</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> st.session_state.keys():</span><br><span class="line">    <span class="keyword">del</span> st.session_state[key]</span><br></pre></td></tr></table></figure><p>也可以通过在Settings中<code>Clear Cache</code>来删除，并rerun整个app。</p><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><p>使用Session State时需要注意以下几点：<br>（1）Session State的生命周期存在于浏览器的标签页打开且连接到server期间。一旦关闭标签页后，Session State中存储的东西都会丢失。<br>（2）Session State也不能持久化，一旦server关闭，其存储的东西也会被擦除。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.streamlit.io/session-state-for-streamlit/">Session State for Streamlit</a><br><a href="https://docs.streamlit.io/library/advanced-features/session-state">Add statefulness to apps</a><br><a href="https://docs.streamlit.io/library/api-reference/session-state">Session State</a></p>]]></content>
    
    
    <summary type="html">简介
在Streamlit中，与一个部件widget的交互会触发“重新运行”rerun，这样一来每次运行后代码中的变量都会被重新初始化。这可能会带来很麻烦的问题，比如实现一个简单的“累加计数按钮”，每次点击后都会清零，无法实现累加功能。
为了解决类似问题，Streamlit引入了一种新的特性：会话状态Session State，它是一种可以在rerun之间保存变量状态、配合使用回调函数处理部件上的事件、动态改变部件状态等等的功能（注意，这些功能发生在一个session中，一个session可以简单理解为用户通过浏览器的一个标签页来访问Streamlit）。其可以用在如下场景中：
（1）数据或图</summary>
    
    
    
    <category term="digitalization" scheme="http://qixinbo.github.io/categories/digitalization/"/>
    
    
    <category term="Streamlit" scheme="http://qixinbo.github.io/tags/Streamlit/"/>
    
  </entry>
  
  <entry>
    <title>用Python开发web应用——Streamlit框架解析：1 -- 上手</title>
    <link href="http://qixinbo.github.io/2022/03/08/streamlit_1/"/>
    <id>http://qixinbo.github.io/2022/03/08/streamlit_1/</id>
    <published>2022-03-07T16:00:00.000Z</published>
    <updated>2022-03-08T03:27:07.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://streamlit.io/">Streamlit</a>是一个开源Python库，其旨在为机器学习和数据科学领域简单快速地创建和分享美观的、定制化的web应用。使用Streamlit，用户仅仅几分钟即可创建和部署强大的数据应用。<br>截几张范例的界面图：<br><img src="https://user-images.githubusercontent.com/6218739/157160066-1781000e-b957-4fac-b0df-01d23b3c7f67.png" alt="gallery1"><br><img src="https://user-images.githubusercontent.com/6218739/157160339-5e34e7fc-8886-4bd9-bc18-3e94fff749ce.png" alt="g2"><br><img src="https://user-images.githubusercontent.com/6218739/157160476-7d64aa1a-4c92-4f80-8dd3-5e449fcc56be.png" alt="g3"></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>使用pip安装：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install streamlit</span><br></pre></td></tr></table></figure></p><p>测试一下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">streamlit hello</span><br></pre></td></tr></table></figure><br>此时浏览器会打开<code>http://localhost:8501/</code>，然后出现streamlit关于动画、动态绘图、地图、pandas绘图的四个demo。</p><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><h2 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">streamlit run your_script.py [-- script args]</span><br></pre></td></tr></table></figure><p>另外一种运行方式是通过Python模块运行（这对于使用IDE如pycharm有用）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Running</span></span><br><span class="line">$ python -m streamlit your_script.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># is equivalent to:</span></span><br><span class="line">$ streamlit run your_script.py</span><br></pre></td></tr></table></figure></p><h2 id="开启开发模式"><a href="#开启开发模式" class="headerlink" title="开启开发模式"></a>开启开发模式</h2><p>在开发阶段，最好是开启“开发模式”，这样只要保存代码后，Streamlit就能重新运行app。这会极大地提高开发效率。<br>开启方式是在右上角选择“Always rerun”。</p><h2 id="展示数据"><a href="#展示数据" class="headerlink" title="展示数据"></a>展示数据</h2><h3 id="使用“魔法”"><a href="#使用“魔法”" class="headerlink" title="使用“魔法”"></a>使用“魔法”</h3><p>魔法magic和<code>st.write()</code>可以用来展示很多数据类型，比如text、data、matplotlib图表、Altair图表。直接将这些数据传给<code>st.write()</code>或者magic即可，Streamlit可以自动识别。<br>这里魔法magic的意思是不用在代码里调用Streamlit的任何方法就可以直接展示数据，原因是当Streamlit看到在一行中只有一个变量名时，就会自动在这里加上<code>st.write()</code>。<br>比如下面代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># My first app</span></span><br><span class="line"><span class="string">Here&#x27;s our first attempt at using data to create a table:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame(&#123;</span><br><span class="line">  <span class="string">&#x27;first column&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  <span class="string">&#x27;second column&#x27;</span>: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">df</span><br></pre></td></tr></table></figure><br>它跟下面的代码效果是一样的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">st.write(pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&#x27;first column&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    <span class="string">&#x27;second column&#x27;</span>: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></p><h3 id="展示data-frame"><a href="#展示data-frame" class="headerlink" title="展示data frame"></a>展示data frame</h3><p>前面说了，<code>st.write()</code>或magic几乎能展示所有数据，但也有其他的与具体数据相关的函数，如<code>st.dataframe()</code>和<code>st.table()</code>等。<br>这里可能有一个问题：“为什么我不能全用<code>st.write()</code>呢”，原因如下：<br>（1）<code>st.write()</code>或magic能自动渲染数据，但有时你可能想用另外一种方式渲染。比如，如果你不想将dataframe数据渲染成一种可交互的表格，此时就需要使用<code>st.table(df)</code>将它渲染成静态表格；<br>（2）其他方法返回的对象可以被使用和修改，比如在上面增加数据或替换数据；<br>（3）对于其他方法，可以传递更多的参数来定制化行为。<br>比如下面的例子使用Pandas的styler来高亮化某些元素：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">dataframe = pd.DataFrame(</span><br><span class="line">    np.random.randn(<span class="number">10</span>, <span class="number">20</span>),</span><br><span class="line">    columns=(<span class="string">&#x27;col %d&#x27;</span> % i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>)))</span><br><span class="line"></span><br><span class="line">st.dataframe(dataframe.style.highlight_max(axis=<span class="number">0</span>))</span><br></pre></td></tr></table></figure><br>以及静态图表：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">dataframe = pd.DataFrame(</span><br><span class="line">    np.random.randn(<span class="number">10</span>, <span class="number">20</span>),</span><br><span class="line">    columns=(<span class="string">&#x27;col %d&#x27;</span> % i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>)))</span><br><span class="line">st.table(dataframe)</span><br></pre></td></tr></table></figure></p><h3 id="展示charts和maps"><a href="#展示charts和maps" class="headerlink" title="展示charts和maps"></a>展示charts和maps</h3><p>Streamlit支持很多流行的绘图库，如Matplotlib、Altair、deck.gl、plotly等等。一些demo见<a href="https://docs.streamlit.io/library/api-reference#chart-elements">这里</a>。<br>折线图举例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">chart_data = pd.DataFrame(</span><br><span class="line">     np.random.randn(<span class="number">20</span>, <span class="number">3</span>),</span><br><span class="line">     columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">st.line_chart(chart_data)</span><br></pre></td></tr></table></figure><br>地图举例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">map_data = pd.DataFrame(</span><br><span class="line">    np.random.randn(<span class="number">1000</span>, <span class="number">2</span>) / [<span class="number">50</span>, <span class="number">50</span>] + [<span class="number">37.76</span>, -<span class="number">122.4</span>],</span><br><span class="line">    columns=[<span class="string">&#x27;lat&#x27;</span>, <span class="string">&#x27;lon&#x27;</span>])</span><br><span class="line"></span><br><span class="line">st.<span class="built_in">map</span>(map_data)</span><br></pre></td></tr></table></figure></p><h2 id="部件"><a href="#部件" class="headerlink" title="部件"></a>部件</h2><p>当想要探索得到的数据或模型时，可以使用部件进行调节，比如滑块<code>st.slider()</code>、按钮<code>st.button</code>、下拉列表<code>st.selectbox</code>。<br>使用方法也很简单，就像将这些部件视作变量。</p><h3 id="滑块"><a href="#滑块" class="headerlink" title="滑块"></a>滑块</h3><p>常用来调节数值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line">x = st.slider(<span class="string">&#x27;x&#x27;</span>)  <span class="comment"># 👈 this is a widget</span></span><br><span class="line">st.write(x, <span class="string">&#x27;squared is&#x27;</span>, x * x)</span><br></pre></td></tr></table></figure></p><h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><p>常用来显示或关闭数据。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> st.checkbox(<span class="string">&#x27;Show dataframe&#x27;</span>):</span><br><span class="line">    chart_data = pd.DataFrame(</span><br><span class="line">       np.random.randn(<span class="number">20</span>, <span class="number">3</span>),</span><br><span class="line">       columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    chart_data</span><br></pre></td></tr></table></figure></p><h3 id="下拉列表"><a href="#下拉列表" class="headerlink" title="下拉列表"></a>下拉列表</h3><p>常用来选择数据<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&#x27;first column&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    <span class="string">&#x27;second column&#x27;</span>: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">option = st.selectbox(</span><br><span class="line">    <span class="string">&#x27;Which number do you like best?&#x27;</span>,</span><br><span class="line">     df[<span class="string">&#x27;first column&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;You selected: &#x27;</span>, option</span><br></pre></td></tr></table></figure></p><h3 id="部件的key"><a href="#部件的key" class="headerlink" title="部件的key"></a>部件的key</h3><p>如果对某一部件附加了一个独特的key，那么，部件的值可以通过key来获取，比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line">st.text_input(<span class="string">&quot;Your name&quot;</span>, key=<span class="string">&quot;name&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># You can access the value at any point with:</span></span><br><span class="line">st.session_state.name</span><br></pre></td></tr></table></figure><br>有key的部件会被自动添加到Session State中，从而可以在部件间传递数据。<br>详情查看<a href="https://docs.streamlit.io/library/api-reference/session-state">这里</a>。</p><h3 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h3><p>当一个app需要运行很长时间时，可以添加进度条部件<code>st.progress()</code>来显示进度。进度条不能添加key。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;Starting a long computation...&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a placeholder</span></span><br><span class="line">latest_iteration = st.empty()</span><br><span class="line">bar = st.progress(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">  <span class="comment"># Update the progress bar with each iteration.</span></span><br><span class="line">  latest_iteration.text(<span class="string">f&#x27;Iteration <span class="subst">&#123;i+<span class="number">1</span>&#125;</span>&#x27;</span>)</span><br><span class="line">  bar.progress(i + <span class="number">1</span>)</span><br><span class="line">  time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;...and now we\&#x27;re done!&#x27;</span></span><br></pre></td></tr></table></figure></p><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="sidebar"><a href="#sidebar" class="headerlink" title="sidebar"></a>sidebar</h3><p>Streamlit提供了一个左侧侧边栏<code>st.sidebar</code>来组织上面的部件。每一个传给该侧边栏的元素都被“钉”到左边，这样用户就能专注于自己的app内容上。<br>比如使用<code>st.sidebar.slider</code>替代<code>st.slider</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a selectbox to the sidebar:</span></span><br><span class="line">add_selectbox = st.sidebar.selectbox(</span><br><span class="line">    <span class="string">&#x27;How would you like to be contacted?&#x27;</span>,</span><br><span class="line">    (<span class="string">&#x27;Email&#x27;</span>, <span class="string">&#x27;Home phone&#x27;</span>, <span class="string">&#x27;Mobile phone&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a slider to the sidebar:</span></span><br><span class="line">add_slider = st.sidebar.slider(</span><br><span class="line">    <span class="string">&#x27;Select a range of values&#x27;</span>,</span><br><span class="line">    <span class="number">0.0</span>, <span class="number">100.0</span>, (<span class="number">25.0</span>, <span class="number">75.0</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h3 id="columns和expander"><a href="#columns和expander" class="headerlink" title="columns和expander"></a>columns和expander</h3><p>除了侧边栏，Streamlit还提供了其他控制布局的方式，如<code>st.columns</code>可以一列一列地排放部件，<code>st.expander</code>可以将大片的内容隐藏或展开。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"></span><br><span class="line">left_column, right_column = st.columns(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># You can use a column just like st.sidebar:</span></span><br><span class="line">left_column.button(<span class="string">&#x27;Press me!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Or even better, call Streamlit functions inside a &quot;with&quot; block:</span></span><br><span class="line"><span class="keyword">with</span> right_column:</span><br><span class="line">    chosen = st.radio(</span><br><span class="line">        <span class="string">&#x27;Sorting hat&#x27;</span>,</span><br><span class="line">        (<span class="string">&quot;Gryffindor&quot;</span>, <span class="string">&quot;Ravenclaw&quot;</span>, <span class="string">&quot;Hufflepuff&quot;</span>, <span class="string">&quot;Slytherin&quot;</span>))</span><br><span class="line">    st.write(<span class="string">f&quot;You are in <span class="subst">&#123;chosen&#125;</span> house!&quot;</span>)</span><br></pre></td></tr></table></figure></p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>Streamlit默认支持Light和Dark两种主题。可以通过Settings进行设置。也可以自定义主题。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>当从web上加载数据、操作大型数据集以及进行大规模计算时，对状态的缓存就非常重要，Streamlit缓存使得这些情况下app仍然快速执行。<br>Streamlit提供了一些缓存方案，如<code>@st.cache</code>、<code>@st.experimental_memo</code>、<code>@st.experimental_singleton</code>。<br>具体的用法可以参考<a href="https://docs.streamlit.io/library/advanced-features/experimental-cache-primitives">这里</a>。<br>以<code>@st.cache</code>为例，当指定需要使用缓存时，就用这个装饰器包装一下函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"></span><br><span class="line"><span class="meta">@st.cache  </span><span class="comment"># 👈 This function will be cached</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_slow_function</span>(<span class="params">arg1, arg2</span>):</span></span><br><span class="line">    <span class="comment"># Do something really slow in here!</span></span><br><span class="line">    <span class="keyword">return</span> the_output</span><br></pre></td></tr></table></figure><br>这个装饰器告诉Streamlit，当该函数被调用时，它需要检查如下东西：<br>（1）该函数的输入参数；<br>（2）在函数内用到的任意外部变量；<br>（3）函数体；<br>（4）在该函数体内用到的其他函数体。<br>如果是Streamlit看到是这四个部分都是第一次以这些数值及其组合顺序运行，那么它就运行函数，然后将结果存储在局部缓存中。然后，当该缓存的函数下一次被调用时，如果上述四部分都没有改变，那么Streamlit就会跳过执行，而将上一次缓存的结果返回。</p><h2 id="运行机理"><a href="#运行机理" class="headerlink" title="运行机理"></a>运行机理</h2><p>知道了上面的零碎的知识，总结一下整体的运行机理：<br>（1）Streamlit的apps是从上到下执行的Python脚本；<br>（2）每次当一个用户打开浏览器，访问你的app后，上述脚本就会重新执行；<br>（3）当脚本执行时，Streamlit在浏览器渲染它的输出；<br>（4）脚本使用Streamlit缓存来避免重复执行昂贵的运算，所以结果更新会非常快；<br>（5）每次当用户与部件进行交互时，脚本就会重新运行，部件的返回值也会更新为最新状态。</p><h1 id="上手总结"><a href="#上手总结" class="headerlink" title="上手总结"></a>上手总结</h1><p>以上就是最基本的Streamlit用法，总体来看，确实极大地降低了开发web app的难度，可以使用原生python语法来做这件事是太香了。</p>]]></content>
    
    
    <summary type="html">简介
Streamlit是一个开源Python库，其旨在为机器学习和数据科学领域简单快速地创建和分享美观的、定制化的web应用。使用Streamlit，用户仅仅几分钟即可创建和部署强大的数据应用。
截几张范例的界面图：




安装
使用pip安装：
1


pip install streamlit




测试一下：
1


streamlit hello



此时浏览器会打开http://localhost:8501/，然后出现streamlit关于动画、动态绘图、地图、pandas绘图的四个demo。

核心概念
运行方式
1


streamlit run your_script.</summary>
    
    
    
    <category term="digitalization" scheme="http://qixinbo.github.io/categories/digitalization/"/>
    
    
    <category term="Streamlit" scheme="http://qixinbo.github.io/tags/Streamlit/"/>
    
  </entry>
  
  <entry>
    <title>开源深度学习计算平台ImJoy解析：11 -- ImJoy主站之主组件</title>
    <link href="http://qixinbo.github.io/2022/02/28/ImJoy_11/"/>
    <id>http://qixinbo.github.io/2022/02/28/ImJoy_11/</id>
    <published>2022-02-27T16:00:00.000Z</published>
    <updated>2022-03-04T07:19:56.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>前面讲了<a href="https://imjoy.io">ImJoy主站</a>的入口文件<code>main.js</code>，这一篇解析一下该主站的ImJoy组件，它也是整个app的“门面担当”，起到了统筹整个网站的作用。</p><p>为了便于分析，将很多高阶的暂时用不到的组件（比如工具栏、窗口管理、文件上传、连接后台Engine等）都删掉，留下最基本的能运行最小化imjoy插件的功能，截图如下：<br><img src="https://user-images.githubusercontent.com/6218739/156502647-18321726-6c25-4631-bcc4-b632eef39f23.png" alt="mini-imjoy"></p><p>这样便于分析整个组件的宏观结构和运行逻辑。<br>下面是对于该极小化组件的逐行代码分析。</p><h1 id="template代码"><a href="#template代码" class="headerlink" title="template代码"></a>template代码</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;imjoy noselect&quot;</span>&gt;</span><br><span class="line">    &lt;!-- 整个imjoy页面框架是通过vue material这个组件库的md-app进行组织的 --&gt;</span><br><span class="line">    &lt;!-- 它包括了md-app-toolbar工具栏、 md-app-drawer菜单栏和md-app-content内容区三部分 --&gt;</span><br><span class="line">    &lt;!-- 相关教程见：https:<span class="comment">//www.creative-tim.com/vuematerial/components/app --&gt;</span></span><br><span class="line">    &lt;md-app&gt;</span><br><span class="line">      &lt;!-- 工具栏就是最上面的横条，里面的内容直接全部删除了，仅保留架子 --&gt;</span><br><span class="line">      &lt;md-app-toolbar <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;md-dense app-toolbar&quot;</span> md-elevation=<span class="string">&quot;0&quot;</span>&gt;</span><br><span class="line">      &lt;/md-app-toolbar&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- 接下来就是左侧的菜单栏 --&gt;</span><br><span class="line">      &lt;!-- drawer的属性设置见：https:<span class="comment">//www.creative-tim.com/vuematerial/components/drawer# --&gt;</span></span><br><span class="line">      &lt;!-- 具体地： --&gt;</span><br><span class="line">      &lt;!-- (<span class="number">1</span>)菜单栏是否可见是通过md-active属性控制，其通过v-bind绑定到了menuVisible这个变量上 --&gt;</span><br><span class="line">      &lt;!-- (<span class="number">2</span>)菜单栏关闭和打开两个事件都通过v-on绑定到了wm.resizeAll()函数上 --&gt;</span><br><span class="line">      &lt;!-- (<span class="number">3</span>)菜单栏是否常驻md-persistent和菜单栏是否支持触屏下的swipe绑定到了screenWidth这个变量上 --&gt;</span><br><span class="line">      &lt;md-app-drawer</span><br><span class="line">        :md-active.sync=<span class="string">&quot;menuVisible&quot;</span></span><br><span class="line">        @md-closed=<span class="string">&quot;wm.resizeAll()&quot;</span></span><br><span class="line">        @md-opened=<span class="string">&quot;wm.resizeAll()&quot;</span></span><br><span class="line">        :md-persistent=<span class="string">&quot;screenWidth &gt; 800 ? &#x27;full&#x27; : null&quot;</span></span><br><span class="line">        :md-swipeable=<span class="string">&quot;screenWidth &gt; 600 ? false : true&quot;</span></span><br><span class="line">      &gt;</span><br><span class="line">        &lt;!-- 接下来是将上传文件,添加工作流,添加插件和插件列表都放在了一个card中 --&gt;</span><br><span class="line">        &lt;!-- 这个card的显示有两个判断语句,一个是用v-show判断plugin_loaded这个变量是否为<span class="literal">true</span> --&gt;</span><br><span class="line">        &lt;!-- 另一个是用v-<span class="keyword">if</span>判断pm这个变量是否为<span class="literal">true</span>, --&gt;</span><br><span class="line">        &lt;!-- v-<span class="keyword">if</span>和v-show看起来差不多,但有区别,见:https:<span class="comment">//cn.vuejs.org/v2/guide/conditional.html --&gt;</span></span><br><span class="line">        &lt;md-card id=<span class="string">&quot;plugin-menu&quot;</span> v-show=<span class="string">&quot;plugin_loaded&quot;</span> v-<span class="keyword">if</span>=<span class="string">&quot;pm&quot;</span>&gt;</span><br><span class="line">          &lt;!-- 将files,workflow和plugins都放在了card的header中, --&gt;</span><br><span class="line">          &lt;!-- 这里我们将files和workflow都删掉了,仅留plugins的代码 --&gt;</span><br><span class="line">          &lt;md-card-header&gt;</span><br><span class="line">            &lt;!-- 添加plugins就是一个按钮,其<span class="class"><span class="keyword">class</span>也是由<span class="title">v</span>-<span class="title">bind</span>绑定并判断 --&gt;</span></span><br><span class="line"><span class="class">            &lt;!-- 该按钮的点击时间用<span class="title">v</span>-<span class="title">on</span>绑定到了<span class="title">showPluginManagement</span>()函数上 --&gt;</span></span><br><span class="line">            &lt;!-- 当点击该按钮后, 从而执行该函数,其中有一个非常重要的变量:--&gt;</span><br><span class="line">            &lt;!-- <span class="built_in">this</span>.showAddPluginDialog会设为<span class="literal">true</span> --&gt;</span><br><span class="line">            &lt;!-- 从而会引发如下对话框的弹出:</span><br><span class="line">            &lt;md-dialog</span><br><span class="line">              <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;plugin-dialog&quot;</span></span><br><span class="line">              :md-active.sync=<span class="string">&quot;showAddPluginDialog&quot;</span></span><br><span class="line">              :md-click-outside-to-close=<span class="string">&quot;true&quot;</span></span><br><span class="line">            &gt; --&gt;</span><br><span class="line">            &lt;md-button</span><br><span class="line">              ref=<span class="string">&quot;add_plugin_button&quot;</span></span><br><span class="line">              :<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;pm.installed_plugins.length &gt; 0 ? &#x27;&#x27; : &#x27;md-primary&#x27;&quot;</span></span><br><span class="line">              @click=<span class="string">&quot;showPluginManagement()&quot;</span></span><br><span class="line">            &gt;</span><br><span class="line">              &lt;md-icon&gt;add&lt;/md-icon&gt;Plugins</span><br><span class="line">            &lt;/md-button&gt;</span><br><span class="line">          &lt;/md-card-header&gt;</span><br><span class="line"></span><br><span class="line">          &lt;!-- 接下来就是将插件列表放在card的content区域 --&gt;</span><br><span class="line">          &lt;md-card-content&gt;</span><br><span class="line">            &lt;!-- 使用v-<span class="keyword">for</span>来循环插件列表,并对每一项提供了key的身份 --&gt;</span><br><span class="line">            &lt;!-- v-<span class="keyword">for</span>的教程见:https:<span class="comment">//cn.vuejs.org/v2/guide/list.html --&gt;</span></span><br><span class="line">            &lt;div v-<span class="keyword">for</span>=<span class="string">&quot;plugin in sortedRunnablePlugins()&quot;</span> :key=<span class="string">&quot;plugin.name&quot;</span>&gt;</span><br><span class="line">              &lt;!-- 增加一个分割线 --&gt;</span><br><span class="line">              &lt;md-divider&gt;&lt;/md-divider&gt;</span><br><span class="line">              &lt;div style=<span class="string">&quot;display: flex;&quot;</span>&gt;</span><br><span class="line">                &lt;!-- 这里对每一个插件会包装一个badge徽章,用途是判断它需不需要升级 --&gt;</span><br><span class="line">                &lt;!-- 如果需要升级,会出现一个NEW的角标 --&gt;</span><br><span class="line">                &lt;md-badge</span><br><span class="line">                  :<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;plugin.update_available ? &#x27;&#x27; : &#x27;hide-badge&#x27;&quot;</span></span><br><span class="line">                  <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;md-square md-primary&quot;</span></span><br><span class="line">                  md-dense</span><br><span class="line">                  md-content=<span class="string">&quot;NEW&quot;</span></span><br><span class="line">                &gt;</span><br><span class="line">                  &lt;!-- 这里是对插件的icon按钮点击后会出现的菜单进行定义 --&gt;</span><br><span class="line">                  &lt;md-menu md-size=<span class="string">&quot;medium&quot;</span>&gt;</span><br><span class="line">                    &lt;!-- 触发菜单的icon按钮定义 --&gt;</span><br><span class="line">                    &lt;md-button</span><br><span class="line">                      <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;md-icon-button&quot;</span></span><br><span class="line">                      :<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;plugin.running ? &#x27;md-accent&#x27; : &#x27;&#x27;&quot;</span></span><br><span class="line">                      md-menu-trigger</span><br><span class="line">                    &gt;</span><br><span class="line">                      &lt;!-- 插件的加载状态 --&gt;</span><br><span class="line">                      &lt;md-progress-spinner</span><br><span class="line">                        v-<span class="keyword">if</span>=<span class="string">&quot;plugin.initializing || plugin.terminating&quot;</span></span><br><span class="line">                        <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;md-accent&quot;</span></span><br><span class="line">                        :md-diameter=<span class="string">&quot;20&quot;</span></span><br><span class="line">                        md-mode=<span class="string">&quot;indeterminate&quot;</span></span><br><span class="line">                      &gt;&lt;/md-progress-spinner&gt;</span><br><span class="line">                      &lt;!-- icon会判断该插件有没有提供自定义的图标,如果没有,则使用默认的extension图标 --&gt;</span><br><span class="line">                      &lt;!-- 这个地方调用的就是之前入口文件所全局注册的PluginIcon组件 --&gt;</span><br><span class="line">                      &lt;plugin-icon</span><br><span class="line">                        v-<span class="keyword">else</span></span><br><span class="line">                        :icon=<span class="string">&quot;plugin.config.icon&quot;</span></span><br><span class="line">                      &gt;&lt;/plugin-icon&gt;</span><br><span class="line">                      &lt;!-- 按钮的工具提示信息 --&gt;</span><br><span class="line">                      &lt;md-tooltip v-<span class="keyword">if</span>=<span class="string">&quot;screenWidth &gt; 500&quot;</span>&gt;&#123;&#123;</span><br><span class="line">                        plugin.name + <span class="string">&quot;: &quot;</span> + plugin.config.description</span><br><span class="line">                      &#125;&#125;&lt;/md-tooltip&gt;</span><br><span class="line">                    &lt;/md-button&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;!-- 点击icon按钮后弹出的菜单选项 --&gt;</span><br><span class="line">                    &lt;md-menu-content&gt;</span><br><span class="line">                      &lt;!-- Docs选项,绑定了showDoc方法 --&gt;</span><br><span class="line">                      &lt;md-menu-item @click=<span class="string">&quot;showDoc(plugin.id)&quot;</span>&gt;</span><br><span class="line">                        &lt;md-icon&gt;description&lt;/md-icon&gt;Docs</span><br><span class="line">                      &lt;/md-menu-item&gt;</span><br><span class="line">                      &lt;!-- Share选项,不一定会显示,有一个v-<span class="keyword">if</span>条件渲染 --&gt;</span><br><span class="line">                      &lt;md-menu-item</span><br><span class="line">                        v-<span class="keyword">if</span>=<span class="string">&quot;plugin.config.origin&quot;</span></span><br><span class="line">                        @click=<span class="string">&quot;sharePlugin(plugin.id)&quot;</span></span><br><span class="line">                      &gt;</span><br><span class="line">                        &lt;md-icon&gt;share&lt;/md-icon&gt;Share</span><br><span class="line">                      &lt;/md-menu-item&gt;</span><br><span class="line">                      &lt;!-- Export选项,绑定了downloadPlugin --&gt;</span><br><span class="line">                      &lt;md-menu-item @click=<span class="string">&quot;downloadPlugin(plugin.id)&quot;</span>&gt;</span><br><span class="line">                        &lt;md-icon&gt;cloud_download&lt;/md-icon&gt;Export</span><br><span class="line">                      &lt;/md-menu-item&gt;</span><br><span class="line">                      &lt;!-- Edit选项,绑定了editPlugin --&gt;</span><br><span class="line">                      &lt;md-menu-item @click=<span class="string">&quot;editPlugin(plugin.id)&quot;</span>&gt;</span><br><span class="line">                        &lt;md-icon&gt;edit&lt;/md-icon&gt;Edit</span><br><span class="line">                      &lt;/md-menu-item&gt;</span><br><span class="line">                      &lt;!-- Reload选项,绑定了reloadPlugin --&gt;</span><br><span class="line">                      &lt;md-menu-item @click=<span class="string">&quot;reloadPlugin(plugin.config)&quot;</span>&gt;</span><br><span class="line">                        &lt;md-icon&gt;autorenew&lt;/md-icon&gt;Reload</span><br><span class="line">                      &lt;/md-menu-item&gt;</span><br><span class="line">                      &lt;!-- Terminate选项,绑定了unloadPlugin --&gt;</span><br><span class="line">                      &lt;md-menu-item @click=<span class="string">&quot;unloadPlugin(plugin)&quot;</span>&gt;</span><br><span class="line">                        &lt;md-icon&gt;clear&lt;/md-icon&gt;Terminate</span><br><span class="line">                      &lt;/md-menu-item&gt;</span><br><span class="line">                      &lt;!-- Remove选项,绑定了removePlugin --&gt;</span><br><span class="line">                      &lt;md-menu-item</span><br><span class="line">                        <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;md-accent&quot;</span></span><br><span class="line">                        @click=<span class="string">&quot;removePlugin(plugin)&quot;</span></span><br><span class="line">                      &gt;</span><br><span class="line">                        &lt;md-icon&gt;delete_forever&lt;/md-icon&gt;Remove</span><br><span class="line">                      &lt;/md-menu-item&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;/md-menu-content&gt;</span><br><span class="line">                  &lt;/md-menu&gt;</span><br><span class="line">                &lt;/md-badge&gt;</span><br><span class="line"></span><br><span class="line">                &lt;!-- 接下来就是由插件的名称所形成的按钮 --&gt;</span><br><span class="line">                &lt;!-- 对于需要链接到engine的插件,还会检测其状态,如果没有链接到engine上,就会disable该按钮,从而无法运行. --&gt;</span><br><span class="line">                &lt;!-- 对于鼠标操作,也附加了鼠标按钮修饰符,防止误操作,教程见:https:<span class="comment">//cn.vuejs.org/v2/guide/events.html --&gt;</span></span><br><span class="line">                &lt;!-- 点击该按钮后就会运行runOp方法 --&gt;</span><br><span class="line">                &lt;md-button</span><br><span class="line">                  <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;joy-run-button&quot;</span></span><br><span class="line">                  :<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;</span></span><br><span class="line"><span class="string">                    plugin.running</span></span><br><span class="line"><span class="string">                      ? &#x27;busy-plugin&#x27;</span></span><br><span class="line"><span class="string">                      : plugin._disconnected &amp;&amp; plugin.engine</span></span><br><span class="line"><span class="string">                      ? &#x27;md-accent&#x27;</span></span><br><span class="line"><span class="string">                      : &#x27;md-primary&#x27;</span></span><br><span class="line"><span class="string">                  &quot;</span></span><br><span class="line">                  :disabled=<span class="string">&quot;plugin._disconnected &amp;&amp; !plugin.engine&quot;</span></span><br><span class="line">                  @click.exact=<span class="string">&quot;</span></span><br><span class="line"><span class="string">                    plugin._disconnected</span></span><br><span class="line"><span class="string">                      ? connectPlugin(plugin)</span></span><br><span class="line"><span class="string">                      : runOp(plugin.ops[plugin.name])</span></span><br><span class="line"><span class="string">                  &quot;</span></span><br><span class="line">                  @click.right.exact=<span class="string">&quot;logPlugin(plugin)&quot;</span></span><br><span class="line">                &gt;</span><br><span class="line">                  &#123;&#123; plugin.config.name + <span class="string">&quot; &quot;</span> + plugin.config.badges &#125;&#125;</span><br><span class="line">                &lt;/md-button&gt;</span><br><span class="line"></span><br><span class="line">              &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">              &lt;!-- 这个地方是ImJoy的核心!! --&gt;</span><br><span class="line">              &lt;!-- 此处也是ImJoy的名称的来源,即ImJoy来自于joy.js这个库 --&gt;</span><br><span class="line">              &lt;!-- 这个地方需要后面仔细研究机理 --&gt;</span><br><span class="line">              &lt;div</span><br><span class="line">                v-<span class="keyword">for</span>=<span class="string">&quot;op in plugin.ops&quot;</span></span><br><span class="line">                :key=<span class="string">&quot;op.plugin_id + op.name&quot;</span></span><br><span class="line">                v-show=<span class="string">&quot;true&quot;</span></span><br><span class="line">              &gt;</span><br><span class="line">                &lt;joy :config=<span class="string">&quot;op&quot;</span> :show=<span class="string">&quot;true&quot;</span>&gt;&lt;/joy&gt;</span><br><span class="line">              &lt;/div&gt;</span><br><span class="line">              &lt;md-divider&gt;&lt;/md-divider&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;md-divider&gt;&lt;/md-divider&gt;</span><br><span class="line">          &lt;/md-card-content&gt;</span><br><span class="line">        &lt;/md-card&gt;</span><br><span class="line">      &lt;/md-app-drawer&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- 接下来就是整个界面的第三部分,即内容区 --&gt;</span><br><span class="line">      &lt;md-app-content</span><br><span class="line">        :<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;workspace_dropping ? &#x27;file-dropping&#x27; : &#x27;&#x27;&quot;</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;whiteboard-content&quot;</span></span><br><span class="line">      &gt;</span><br><span class="line">        &lt;!-- 就是引用了whiteboard这个组件 --&gt;</span><br><span class="line">        &lt;whiteboard</span><br><span class="line">          v-<span class="keyword">if</span>=<span class="string">&quot;wm&quot;</span></span><br><span class="line">          id=<span class="string">&quot;whiteboard&quot;</span></span><br><span class="line">          @create=<span class="string">&quot;createWindow($event)&quot;</span></span><br><span class="line">          :mode=<span class="string">&quot;wm.window_mode&quot;</span></span><br><span class="line">          :<span class="built_in">window</span>-manager=<span class="string">&quot;wm&quot;</span></span><br><span class="line">        &gt;&lt;/whiteboard&gt;</span><br><span class="line">      &lt;/md-app-content&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 以上就是整个界面的布局 --&gt;</span><br><span class="line">    &lt;/md-app&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 这个是消息提醒对话框，当某处调用showAlert()函数时会触发，比如api.alert时--&gt;</span><br><span class="line">    &lt;md-dialog-alert</span><br><span class="line">      <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;api-dialog&quot;</span></span><br><span class="line">      :md-active.sync=<span class="string">&quot;alert_config.show&quot;</span></span><br><span class="line">      :md-title=<span class="string">&quot;alert_config.title&quot;</span></span><br><span class="line">      :md-content=<span class="string">&quot;alert_config.content&quot;</span></span><br><span class="line">      :md-confirm-text=<span class="string">&quot;alert_config.confirm_text&quot;</span></span><br><span class="line">    /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 这个是消息确认对话框，当某处调用showConfirm()函数时会触发，比如删除插件时 --&gt;</span><br><span class="line">    &lt;md-dialog-confirm</span><br><span class="line">      <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;api-dialog&quot;</span></span><br><span class="line">      :md-active.sync=<span class="string">&quot;confirm_config.show&quot;</span></span><br><span class="line">      :md-title=<span class="string">&quot;confirm_config.title&quot;</span></span><br><span class="line">      :md-content=<span class="string">&quot;confirm_config.content&quot;</span></span><br><span class="line">      :md-confirm-text=<span class="string">&quot;confirm_config.confirm_text&quot;</span></span><br><span class="line">      :md-cancel-text=<span class="string">&quot;confirm_config.canel_text&quot;</span></span><br><span class="line">      @md-confirm=<span class="string">&quot;confirm_config.confirm&quot;</span></span><br><span class="line">      @md-cancel=<span class="string">&quot;confirm_config.cancel&quot;</span></span><br><span class="line">    /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 前面已分析到，点击添加Plugins后会触发如下插件对话框的弹出 --&gt;</span><br><span class="line">    &lt;md-dialog</span><br><span class="line">      <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;plugin-dialog&quot;</span></span><br><span class="line">      :md-active.sync=<span class="string">&quot;showAddPluginDialog&quot;</span></span><br><span class="line">      :md-click-outside-to-close=<span class="string">&quot;true&quot;</span></span><br><span class="line">    &gt;</span><br><span class="line">      &lt;!-- 设置该对话框的标题 --&gt;</span><br><span class="line">      &lt;md-dialog-title</span><br><span class="line">        &gt;&#123;&#123;</span><br><span class="line">          plugin4install ? <span class="string">&quot;Plugin Installation&quot;</span> : <span class="string">&quot;ImJoy Plugin Management&quot;</span></span><br><span class="line">        &#125;&#125;</span><br><span class="line">        &lt;!-- 在标题栏添加一个关闭按钮 --&gt;</span><br><span class="line">        &lt;md-button</span><br><span class="line">          <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;md-accent&quot;</span></span><br><span class="line">          style=<span class="string">&quot;position:absolute; top:8px; right:5px;&quot;</span></span><br><span class="line">          @click=<span class="string">&quot;</span></span><br><span class="line"><span class="string">            showAddPluginDialog = false;</span></span><br><span class="line"><span class="string">            clearPluginUrl();</span></span><br><span class="line"><span class="string">          &quot;</span></span><br><span class="line">          &gt;<span class="xml"><span class="tag">&lt;<span class="name">md-icon</span>&gt;</span>clear<span class="tag">&lt;/<span class="name">md-icon</span>&gt;</span></span>&lt;/md-button</span><br><span class="line">        &gt;&lt;/md-dialog-title</span><br><span class="line">      &gt;</span><br><span class="line">      &lt;!-- 以下是对话框的内容部分 --&gt;</span><br><span class="line">      &lt;!-- 原来的插件对话框有三种添加插件的方式：（<span class="number">1</span>）通过插件模板template编写插件（<span class="number">2</span>）输入插件url地址安装（<span class="number">3</span>）通过插件商店store安装 --&gt;</span><br><span class="line">      &lt;!-- 这里我们为了代码精简，只保留了第一种，保证能运行一个最简单的插件即可 --&gt;</span><br><span class="line">      &lt;md-dialog-content&gt;</span><br><span class="line">        &lt;template v-<span class="keyword">if</span>=<span class="string">&quot;show_plugin_templates&quot;</span>&gt;</span><br><span class="line">          &lt;md-menu&gt;</span><br><span class="line">            &lt;!-- 通过模板template添加插件的按钮 --&gt;</span><br><span class="line">            &lt;md-button <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;md-primary md-raised&quot;</span> md-menu-trigger&gt;</span><br><span class="line">              &lt;md-icon&gt;add&lt;/md-icon&gt;Create a <span class="keyword">new</span> plugin</span><br><span class="line">              &lt;md-tooltip&gt;Create a <span class="keyword">new</span> plugin&lt;/md-tooltip&gt;</span><br><span class="line">            &lt;/md-button&gt;</span><br><span class="line">            &lt;!-- 点击上面按钮后弹出的菜单 --&gt;</span><br><span class="line">            &lt;md-menu-content&gt;</span><br><span class="line">              &lt;!-- 菜单项会对所有的模板进行遍历展示 --&gt;</span><br><span class="line">              &lt;!-- 每个菜单项也都会将鼠标点击事件绑定到newPlugin方法上 --&gt;</span><br><span class="line">              &lt;!-- 该方法会通过createWindow创建plugin-editor类型的窗口，即代码编辑器 --&gt;</span><br><span class="line">              &lt;md-menu-item</span><br><span class="line">                @click=<span class="string">&quot;</span></span><br><span class="line"><span class="string">                  newPlugin(template.code);</span></span><br><span class="line"><span class="string">                  showAddPluginDialog = false;</span></span><br><span class="line"><span class="string">                &quot;</span></span><br><span class="line">                v-<span class="keyword">for</span>=<span class="string">&quot;template in plugin_templates&quot;</span></span><br><span class="line">                :key=<span class="string">&quot;template.name&quot;</span></span><br><span class="line">              &gt;</span><br><span class="line">                &lt;md-icon&gt;&#123;&#123; template.icon &#125;&#125;&lt;/md-icon</span><br><span class="line">                &gt;&#123;&#123; template.name &#125;&#125;</span><br><span class="line">              &lt;/md-menu-item&gt;</span><br><span class="line">            &lt;/md-menu-content&gt;</span><br><span class="line">          &lt;/md-menu&gt;</span><br><span class="line">          &lt;br /&gt;</span><br><span class="line">          &lt;br /&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/md-dialog-content&gt;</span><br><span class="line">    &lt;/md-dialog&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h1 id="script代码"><a href="#script代码" class="headerlink" title="script代码"></a>script代码</h1><p>通过上述template文件的解析，发现插件被点击运行时执行的函数是runOp方法。<br>该代码解析留坑待填。</p>]]></content>
    
    
    <summary type="html">简介
前面讲了ImJoy主站的入口文件main.js，这一篇解析一下该主站的ImJoy组件，它也是整个app的“门面担当”，起到了统筹整个网站的作用。

为了便于分析，将很多高阶的暂时用不到的组件（比如工具栏、窗口管理、文件上传、连接后台Engine等）都删掉，留下最基本的能运行最小化imjoy插件的功能，截图如下：


这样便于分析整个组件的宏观结构和运行逻辑。
下面是对于该极小化组件的逐行代码分析。

template代码
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</summary>
    
    
    
    <category term="computer vision" scheme="http://qixinbo.github.io/categories/computer-vision/"/>
    
    
    <category term="ImJoy" scheme="http://qixinbo.github.io/tags/ImJoy/"/>
    
  </entry>
  
  <entry>
    <title>开源深度学习计算平台ImJoy解析：10 -- ImJoy主站之入口文件</title>
    <link href="http://qixinbo.github.io/2022/02/27/ImJoy_10/"/>
    <id>http://qixinbo.github.io/2022/02/27/ImJoy_10/</id>
    <published>2022-02-26T16:00:00.000Z</published>
    <updated>2022-03-02T02:46:40.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>前面讲了ImJoy的core库和rpc库作为函数库如何被集成调用，而基于这两个核心库有一个能开箱即用的完整网站，即<a href="https://imjoy.io">ImJoy主站</a>，使用它就可以无需了解上面的技术细节，直接加载各种函数插件即可（但也因为这样，你无法更改网站样貌，如果没有定制开发的需求，则直接使用该网站即可）。</p><p>从该文章开始，将尝试对ImJoy主站进行详细分析，看官方是怎样应用ImJoy的core和rpc库的。</p><h1 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h1><p>ImJoy主站是用vue.js前端框架写的，整个目录结构由vue脚手架vue-cli 4生成，所以首先要分析清楚vue脚手架生成的代码结构是怎样的，可以参考<a href="https://blog.csdn.net/weixin_43734095/article/details/106990775">这篇教程</a><br>截取其中的代码分析图：<br><img src="https://user-images.githubusercontent.com/6218739/155942379-aeaeb37b-f46f-4145-b488-4ef8ea82c446.png" alt="vue-cli"></p><p>理清楚代码结构后，从哪里开始分析呢？</p><h1 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h1><p><code>src/main.js</code>是程序执行的入口文件，所以最好是顺着代码的执行过程一步步分析。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br></pre></td></tr></table></figure><br>引入Vue函数，后面将实例化它，作为整个程度的总调度，即：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&quot;#imjoy-app&quot;</span>,</span><br><span class="line">  router,</span><br><span class="line">  data: &#123;</span><br><span class="line">    store: store,</span><br><span class="line">    router: router,</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">&quot;&lt;App/&gt;&quot;</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    App,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>可以看出，整个Vue实例绑定的是ID名为<code>imjoy-app</code>的html元素，而该元素是位于<code>public\index.html</code>文件中：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;imjoy-app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><br>即：<code>src/main.js</code>是程序执行的入口文件，<code>public\index.html</code>是网页显示的入口文件，至于这两个文件作为入口是vue的脚手架在后台指定好的。知道这两个入口文件后，就可以往后按图索骥般研究。<br>从上述代码还可以看出，该Vue实例管理了App这个根组件，由该根组件再统一去管理其他所有组件，即App根组件显示到<code>imjoy-app</code>这个html元素上。<br>新版的Vue脚手架对于vue2的实例化这块是这样书写的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><br>同样很简单地指明了Vue实例与App组件、app元素之间的关系。</p><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>在<code>src/main.js</code>里第二行就是路由的设置。<br>Vue.js 路由允许我们通过不同的 URL 访问不同的内容。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入路由</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&quot;./router&quot;</span>;</span><br></pre></td></tr></table></figure><br>路由的实现涉及很多文件，比如在如上<code>router.js</code>文件中定义路由的路径和组件（即key和value）的映射关系、在模板html文件中定义哪些元素触发路由跳转（如router-link）以及匹配到路由后组件在哪显示（router-view）、注册路由等。<br>推荐<a href="https://www.runoob.com/vue2/vue-routing.html">这篇教程</a>。<br>Imjoy定义了多个路由，如<code>/</code>、<code>/app</code>、<code>/about</code>等。</p><h1 id="前端UI"><a href="#前端UI" class="headerlink" title="前端UI"></a>前端UI</h1><h2 id="UI组件库"><a href="#UI组件库" class="headerlink" title="UI组件库"></a>UI组件库</h2><p>在<code>src/main.js</code>里第三行就是UI库的引入。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VueMaterial <span class="keyword">from</span> <span class="string">&quot;vue-material&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;vue-material/dist/vue-material.min.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;vue-material/dist/theme/default.css&quot;</span>;</span><br><span class="line">Vue.use(VueMaterial);</span><br></pre></td></tr></table></figure><br>ImJoy前端组件使用的是<a href="https://github.com/vuematerial/vue-material">Vue Material</a>这个组件库，其风格是Google开发的Material Design这种设计语言，即原生Android操作系统上的设计风格。<br>上述代码是使用了全局引入的方式。其组件的具体使用方式在<a href="https://www.creative-tim.com/vuematerial/components/app">这里</a>。</p><h2 id="栅格布局"><a href="#栅格布局" class="headerlink" title="栅格布局"></a>栅格布局</h2><p>接着引入了vue-grid-layout：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VueGridLayout <span class="keyword">from</span> <span class="string">&quot;vue-grid-layout&quot;</span>;</span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">&quot;grid-layout&quot;</span>, VueGridLayout.GridLayout);</span><br><span class="line">Vue.component(<span class="string">&quot;grid-item&quot;</span>, VueGridLayout.GridItem);</span><br></pre></td></tr></table></figure><br>vue-grid-layout是一个可拖拽、可调整大小的栅格布局系统，用于拖拽调整ImJoy各个程序运行窗口的显示位置等。 </p><h2 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h2><p>ImJoy写了很多的自定义的组件。<br>组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。组件系统让我们可以用独立可复用的小组件来构建大型应用。<br>组件的相关知识推荐<a href="https://www.runoob.com/vue2/vue-component.html">这篇教程</a>。<br>在<code>src/main.js</code>中ImJoy就引入了它写的很多组件，并进行了全局注册：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Imjoy组件，即https://imjoy.io/#/app这个链接所展示的页面。</span></span><br><span class="line"><span class="keyword">import</span> Imjoy <span class="keyword">from</span> <span class="string">&quot;@/components/Imjoy&quot;</span>;</span><br><span class="line"><span class="comment">// About组件，即http://localhost:8001/#/about所展示的页面</span></span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">&quot;@/components/About&quot;</span>;</span><br><span class="line"><span class="comment">// Whiteboard组件，即ImJoy中间的展示区，其在上面的Imjoy组件中被使用</span></span><br><span class="line"><span class="keyword">import</span> Whiteboard <span class="keyword">from</span> <span class="string">&quot;@/components/Whiteboard&quot;</span>;</span><br><span class="line"><span class="comment">// PluginList组件，即安装插件时从云端搜索并下载插件的窗口，在Imjoy组件中被使用</span></span><br><span class="line"><span class="keyword">import</span> PluginList <span class="keyword">from</span> <span class="string">&quot;@/components/PluginList&quot;</span>;</span><br><span class="line"><span class="comment">// PluginEditor组件，即代码编辑器，出现在Imjoy组件中查看插件代码时，以及PluginList组件中同样查看插件代码时。</span></span><br><span class="line"><span class="keyword">import</span> PluginEditor <span class="keyword">from</span> <span class="string">&quot;@/components/PluginEditor&quot;</span>;</span><br><span class="line"><span class="comment">// PluginIcon组件，即插件的图标，出现在插件列表最右侧，如果插件自定义了图标，则显示该图标；否则显示默认的extension图标</span></span><br><span class="line"><span class="keyword">import</span> PluginIcon <span class="keyword">from</span> <span class="string">&quot;@/components/PluginIcon&quot;</span>;</span><br><span class="line"><span class="comment">// FileItem组件，即文件列表</span></span><br><span class="line"><span class="keyword">import</span> FileItem <span class="keyword">from</span> <span class="string">&quot;@/components/FileItem&quot;</span>;</span><br><span class="line"><span class="comment">// FileDialog组件，即文件对话框</span></span><br><span class="line"><span class="keyword">import</span> FileDialog <span class="keyword">from</span> <span class="string">&quot;@/components/FileDialog&quot;</span>;</span><br><span class="line"><span class="comment">// Window组件，即代码编辑和程序运行窗口，在Imjoy组件中被使用</span></span><br><span class="line"><span class="keyword">import</span> Window <span class="keyword">from</span> <span class="string">&quot;@/components/Window&quot;</span>;</span><br><span class="line"><span class="comment">// EngineControlPanel组件，即ImJoy app右上角的小火箭图标菜单所对应的组件</span></span><br><span class="line"><span class="keyword">import</span> EngineControlPanel <span class="keyword">from</span> <span class="string">&quot;@/components/EngineControlPanel&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局注册以上组件</span></span><br><span class="line">Vue.component(<span class="string">&quot;imjoy&quot;</span>, Imjoy);</span><br><span class="line">Vue.component(<span class="string">&quot;about&quot;</span>, About);</span><br><span class="line">Vue.component(<span class="string">&quot;whiteboard&quot;</span>, Whiteboard);</span><br><span class="line">Vue.component(<span class="string">&quot;plugin-list&quot;</span>, PluginList);</span><br><span class="line">Vue.component(<span class="string">&quot;plugin-editor&quot;</span>, PluginEditor);</span><br><span class="line">Vue.component(<span class="string">&quot;plugin-icon&quot;</span>, PluginIcon);</span><br><span class="line">Vue.component(<span class="string">&quot;file-item&quot;</span>, FileItem);</span><br><span class="line">Vue.component(<span class="string">&quot;file-dialog&quot;</span>, FileDialog);</span><br><span class="line">Vue.component(<span class="string">&quot;window&quot;</span>, Window);</span><br><span class="line">Vue.component(<span class="string">&quot;engine-control-panel&quot;</span>, EngineControlPanel);</span><br></pre></td></tr></table></figure><br>还有一些组件没有被全局注册，只是被部分实例使用，如Home组件（即<a href="https://imjoy.io/#/">imjoy首页</a>展示的页面）。</p><h2 id="模态框插件"><a href="#模态框插件" class="headerlink" title="模态框插件"></a>模态框插件</h2><p>ImJoy引入了<a href="https://github.com/euvl/vue-js-modal">vue-js-modal模态框插件</a>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vmodal <span class="keyword">from</span> <span class="string">&quot;vue-js-modal&quot;</span>;</span><br><span class="line">Vue.use(vmodal);</span><br></pre></td></tr></table></figure><br>它的使用教程见<a href="https://euvl.github.io/vue-js-modal/Intro.html#static-modals">这里</a>。</p><h1 id="事件总线"><a href="#事件总线" class="headerlink" title="事件总线"></a>事件总线</h1><p>接着看<code>src/main.js</code>，接下来引入了事件总线库：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;./store.js&quot;</span>;</span><br><span class="line"></span><br><span class="line">在store.js中：</span><br><span class="line"><span class="keyword">import</span> Minibus <span class="keyword">from</span> <span class="string">&quot;minibus&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> event_bus = Minibus.create();</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  event_bus: event_bus,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>可以看出Imjoy引入了<a href="https://github.com/axelpale/minibus">minibus库</a>，实现在一个地方触发（发布）事件，然后通过事件中心通知所有订阅者（订阅）。<br>on发布订阅、once发布订阅(触发一次)、emit通知执行(触发事件)、off取消订阅。</p>]]></content>
    
    
    <summary type="html">简介
前面讲了ImJoy的core库和rpc库作为函数库如何被集成调用，而基于这两个核心库有一个能开箱即用的完整网站，即ImJoy主站，使用它就可以无需了解上面的技术细节，直接加载各种函数插件即可（但也因为这样，你无法更改网站样貌，如果没有定制开发的需求，则直接使用该网站即可）。

从该文章开始，将尝试对ImJoy主站进行详细分析，看官方是怎样应用ImJoy的core和rpc库的。

代码结构
ImJoy主站是用vue.js前端框架写的，整个目录结构由vue脚手架vue-cli 4生成，所以首先要分析清楚vue脚手架生成的代码结构是怎样的，可以参考这篇教程
截取其中的代码分析图：


理清楚代</summary>
    
    
    
    <category term="computer vision" scheme="http://qixinbo.github.io/categories/computer-vision/"/>
    
    
    <category term="ImJoy" scheme="http://qixinbo.github.io/tags/ImJoy/"/>
    
  </entry>
  
  <entry>
    <title>开源深度学习计算平台ImJoy解析：9 -- 集成</title>
    <link href="http://qixinbo.github.io/2022/02/12/ImJoy_9/"/>
    <id>http://qixinbo.github.io/2022/02/12/ImJoy_9/</id>
    <published>2022-02-11T16:00:00.000Z</published>
    <updated>2022-03-04T08:05:50.754Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>ImJoy设计的初衷就包括可以被集成使用。这意味着它可以根据需求以多种方式集成到一个项目中。<br>这里的“集成”有两个意思：<br>（1）将ImJoy的核心core库集成在自己的网站或web应用中，从而可以调用ImJoy生态中的各种插件；<br>（2）将ImJoy的运行时rpc库集成到自己的web应用中，从而将自己的web应用转换为ImJoy的一个插件，即被别人可调用和访问。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>集成ImJoy（无论是imjoy-core还是imjoy-rpc）主要有三种方式：<br>（1）在页面上以 CDN 包的形式导入。<br>（2）下载 JavaScript 文件并自行托管。<br>（3）使用 npm 安装它。<br>下面详细说明。</p><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>可以直接使用托管在CDN上的JS库（对于imjoy-core库和imjoy-rpc库都是引用这个js文件）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://lib.imjoy.io/imjoy-loader.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><br>可以看出，imjoy的核心库都在<a href="https://lib.imjoy.io">lib.imjoy.io</a>上进行了托管，可以直接使用，这里放的是最新的版本。<br>另外，在<a href="https://www.jsdelivr.com/?query=imjoy">jsdelivr</a>上也有托管。</p><h2 id="下载并自托管"><a href="#下载并自托管" class="headerlink" title="下载并自托管"></a>下载并自托管</h2><p>如果你想避免使用构建工具，但又无法在生产环境使用CDN，那么可以下载相关js文件并自行托管在自己的服务器上。然后可以通过script标签引入，与使用 CDN 的方法类似。<br>可以在<a href="https://github.com/imjoy-team/lib.imjoy.io">这个GitHub仓库</a>里直接下载那些js文件。</p><h3 id="自己打包"><a href="#自己打包" class="headerlink" title="自己打包"></a>自己打包</h3><p>这些打包好的链接库的源码在<a href="https://github.com/imjoy-team/imjoy-core">imjoy-core这个仓库</a>里，如果想对它的源码进行修改，可以克隆下来这个仓库，然后再自己打包，即：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/imjoy-team/imjoy-core.git</span></span><br><span class="line">cd imjoy-core</span><br><span class="line">npm run install</span><br><span class="line"></span><br><span class="line"># test</span><br><span class="line">npm run test</span><br><span class="line"></span><br><span class="line"># build</span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure><br>上面的命令对于linux和mac系统是适用的，如果是windows系统，可以直接：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><br>进行打包。</p><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>在用 imjoy 构建大型应用时推荐使用 npm 安装。npm能很好地和webpack等打包器配合使用。<br>对于imjoy-core库：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install imjoy-core</span><br></pre></td></tr></table></figure><br>对于imjoy-rpc库：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install imjoy-rpc</span><br></pre></td></tr></table></figure></p><h1 id="集成Imjoy-Core"><a href="#集成Imjoy-Core" class="headerlink" title="集成Imjoy Core"></a>集成Imjoy Core</h1><h2 id="直接引用"><a href="#直接引用" class="headerlink" title="直接引用"></a>直接引用</h2><h3 id="在线引用"><a href="#在线引用" class="headerlink" title="在线引用"></a>在线引用</h3><p>新建一个core-example.html的文件（这个文件在<a href="https://github.com/imjoy-team/imjoy-core/blob/master/src/core-example.html">这里</a>），写入以下内容：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;utf-8&quot;</span> /&gt;</span><br><span class="line">    &lt;title&gt;ImJoy Core Example&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;ImJoy Core Example&lt;/h1&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;https://lib.imjoy.io/imjoy-loader.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      loadImJoyCore().then(<span class="function"><span class="params">imjoyCore</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> imjoy = <span class="keyword">new</span> imjoyCore.ImJoy(&#123;</span><br><span class="line">          imjoy_api: &#123;&#125;,</span><br><span class="line">          <span class="comment">//imjoy core config</span></span><br><span class="line">        &#125;);</span><br><span class="line">        imjoy.start(&#123; <span class="attr">workspace</span>: <span class="literal">null</span> &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          alert(<span class="string">&quot;ImJoy Core started successfully!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><br>双击该页面会在浏览器中运行它，效果是呈现一个弹出框表明成功启动了ImJoy。</p><h3 id="本地托管引用"><a href="#本地托管引用" class="headerlink" title="本地托管引用"></a>本地托管引用</h3><p>上面例子是在线引用<a href="https://lib.imjoy.io/imjoy-loader.js">https://lib.imjoy.io/imjoy-loader.js</a>这个文件。<br>对于本地托管的文件，可以将上述页面的对应部分改为如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;/imjoy-loader.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  loadImJoyCore(</span><br><span class="line">    &#123;</span><br><span class="line">      base_url: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>即引用本地路径下的文件。<br>但这样改写后并不能直接运行该html文件，因为它现在是本地文件，需要将其放置在一个服务器上以http传输才行。<br>最简单的一个运行方式是在本地启用一个测试服务器，毕竟此处只是为了测试这个文件的运行。<br>如果使用python，可以使用如下命令：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server</span><br></pre></td></tr></table></figure><br>这样就可以在这个本地web服务器上查看该目录下的内容。<br>具体原理见<a href="https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/set_up_a_local_testing_server">如何设置一个本地测试服务器？</a></p><p>python的这个测试服务器功能非常弱，到了具体部署应用时，可以使用nginx来构建web服务器从而顺利找到这些文件。<br><a href="https://blog.csdn.net/vfsdfdsf/article/details/89354541">Windows环境利用nginx搭建web服务器</a></p><h2 id="npm包引用"><a href="#npm包引用" class="headerlink" title="npm包引用"></a>npm包引用</h2><p>如上所述，如果要开发大型程序，还是推荐使用npm包的形式进行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> imjoyCore <span class="keyword">from</span> <span class="string">&#x27;imjoy-core&#x27;</span></span><br><span class="line"><span class="keyword">const</span> imjoy = <span class="keyword">new</span> imjoyCore.ImJoy(&#123;</span><br><span class="line">    imjoy_api: &#123;&#125;,</span><br><span class="line">    <span class="comment">//imjoy config</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">imjoy.start(&#123;<span class="attr">workspace</span>: <span class="string">&#x27;default&#x27;</span>&#125;).then(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">    <span class="keyword">await</span> imjoy.api.alert(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><br>不过上面代码现在还没法直接运行。<br>因为ImJoy是基于浏览器的，它需要获取浏览器的window对象（即包含DOM文档的窗口），所以它得运行在前端，不能作为后端的包使用。<br>因此首先不能使用node.js来运行包含ImJoy的程序，与此同时，npm包这种编程引用方式还需要被浏览器认识，因此此时需要webpack这一类的打包工具来进行开发。<br>这里可以使用原生的webpack来打包开发，不过webpack的配置挺复杂的，这里推荐直接使用Vue.js来开发，这样既能方便地构建前端页面，也能借助Vue-cli脚手架来很方便的打包和部署（参考教程可以看下面的推荐链接）。</p><p>如果选择Vue.js进行开发，那么上面的代码可以直接放在某个Vue组件中，然后再通过：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run serve</span><br></pre></td></tr></table></figure><br>进行热部署即可运行查看。</p><h1 id="集成Imjoy-RPC"><a href="#集成Imjoy-RPC" class="headerlink" title="集成Imjoy RPC"></a>集成Imjoy RPC</h1><h2 id="直接引用-1"><a href="#直接引用-1" class="headerlink" title="直接引用"></a>直接引用</h2><h3 id="在线引用-1"><a href="#在线引用-1" class="headerlink" title="在线引用"></a>在线引用</h3><p>新建一个plugin-example.html的文件（这个demo文件在<a href="https://github.com/imjoy-team/imjoy-core/blob/master/src/plugin-example.html">这里</a>），写入以下内容：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>ImJoy Plugin Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>ImJoy Plugin Example<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://lib.imjoy.io/imjoy-loader.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      loadImJoyRPC().then(<span class="keyword">async</span> imjoyRPC =&gt; &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> api = <span class="keyword">await</span> imjoyRPC.setupRPC(&#123; <span class="attr">name</span>: <span class="string">&quot;My Awesome App&quot;</span> &#125;);</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">setup</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          api.alert(<span class="string">&quot;ImJoy RPC initialized. Hello!&quot;</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="comment">// define your api which can be called by other plugins in ImJoy</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">my_api_func</span>(<span class="params"></span>) </span>&#123;&#125;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// Importantly, you need to call `api.export(...)` in order to expose the api for your web application</span></span></span><br><span class="line">        api.export(&#123; setup: setup, my_api_func: my_api_func &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><br>但该文件并不能像上面的core-example.html那样可以直接双击运行，会报如下错误：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught (in promise) Error: imjoy-rpc should only run inside an iframe or a webworker.</span><br></pre></td></tr></table></figure><br>这是因为注入了ImJoy RPC运行时的web应用必须在ImJoy中作为一个插件使用。<code>这样做的目的是隔离运行环境，从而让插件支持任意web框架。</code>（来自ImJoy作者的交流指点，thanks）。<br>那么，为了让上面这个文件正常运行，需要进行如下操作：<br>（1）将它托管成为一个web app，得到它的使用链接。这里可以使用任意托管服务，比如上面的测试服务器、nginx服务器，以及Github pages等；<br>（2）在任意一个其他的ImJoy插件中，使用该web app。</p><p>为了简化演示，采用最简单的方法：<br>对于第一步，直接使用python的测试服务器；<br>对于第二步，修改上面的core-example.html文件为：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>ImJoy Core Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>ImJoy Core Example<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/imjoy-loader.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      loadImJoyCore().then(<span class="function"><span class="params">imjoyCore</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(imjoyCore);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> imjoy = <span class="keyword">new</span> imjoyCore.ImJoy(&#123;</span></span><br><span class="line">          imjoy_api: &#123;&#125;,</span><br><span class="line"><span class="javascript">          <span class="comment">//imjoy core config</span></span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">        imjoy.start(&#123; <span class="attr">workspace</span>: <span class="literal">null</span> &#125;).then(<span class="keyword">async</span> () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">          alert(<span class="string">&quot;ImJoy Core started successfully!&quot;</span>);</span></span><br><span class="line"><span class="javascript">          <span class="keyword">const</span> win = <span class="keyword">await</span> imjoy.api.createWindow(&#123;</span></span><br><span class="line"><span class="javascript">          type: <span class="string">&#x27;My Window&#x27;</span>,</span></span><br><span class="line"><span class="javascript">          src: <span class="string">&#x27;/plugin-example.html&#x27;</span>,</span></span><br><span class="line">          data: &#123; &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">        imjoy.event_bus.on(<span class="string">&quot;add_window&quot;</span>, <span class="function"><span class="params">w</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">const</span> container = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span></span><br><span class="line"><span class="javascript">          container.id = w.window_id; <span class="comment">// &lt;--- this is important</span></span></span><br><span class="line"><span class="javascript">          container.style.backgroundColor = <span class="string">&#x27;#ececec&#x27;</span>;</span></span><br><span class="line"><span class="javascript">          container.style.height = <span class="string">&quot;300px&quot;</span>;</span></span><br><span class="line"><span class="javascript">          container.style.width = <span class="string">&quot;100%&quot;</span>;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// Here we simply add to the body</span></span></span><br><span class="line"><span class="javascript">          <span class="comment">// but in reality, you can embed it into your UI</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">document</span>.body.appendChild(container)</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><br>现在，运行效果如下：<br><img src="https://user-images.githubusercontent.com/6218739/155644211-416c4dc6-2b49-4810-a1d5-c590a854e7b8.png" alt="rpc-demo"><br>即生成了一个窗口，里面运行了那个demo app。</p><h3 id="本地托管引用-1"><a href="#本地托管引用-1" class="headerlink" title="本地托管引用"></a>本地托管引用</h3><p>跟上面imjoy-core库的引用方式相同。</p><h2 id="npm包引用-1"><a href="#npm包引用-1" class="headerlink" title="npm包引用"></a>npm包引用</h2><p>引用方式也是类似于imjoy-core库：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; imjoyRPC &#125; <span class="keyword">from</span> <span class="string">&#x27;imjoy-rpc&#x27;</span>;</span><br><span class="line"></span><br><span class="line">imjoyRPC.setupRPC(&#123;<span class="attr">name</span>: <span class="string">&#x27;My Awesome App&#x27;</span>&#125;).then(<span class="function">(<span class="params">api</span>)=&gt;</span>&#123;</span><br><span class="line"> <span class="comment">// call api.export to expose your plugin api</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>然后也是在其他插件中使用该app才可以：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// as a new window</span></span><br><span class="line"><span class="keyword">const</span> win = <span class="keyword">await</span> api.createWindow(&#123;</span><br><span class="line">    type: <span class="string">&#x27;My Awesome App&#x27;</span>,</span><br><span class="line">    src: <span class="string">&#x27;https://my-awesome-app.com/&#x27;</span>,</span><br><span class="line">    data: &#123; &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// or, as a dialog</span></span><br><span class="line"><span class="keyword">const</span> win = <span class="keyword">await</span> api.showDialog(&#123;</span><br><span class="line">    type: <span class="string">&#x27;My Awesome App&#x27;</span>,</span><br><span class="line">    src: <span class="string">&#x27;https://my-awesome-app.com/&#x27;</span>,</span><br><span class="line">    data: &#123; &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// further interaction can be performed via `win` object</span></span><br></pre></td></tr></table></figure></p><h1 id="直接引用js的API"><a href="#直接引用js的API" class="headerlink" title="直接引用js的API"></a>直接引用js的API</h1><p>上面两种直接引用js文件的方式，其提供了三个主要的函数供调用：<br>（1）loadImJoyCore：加载ImJoy核心库，使得可以调用ImJoy的各种API<br>（2）loadImJoyRPC：加载ImJoy的rpc库，使得插件可以通信，注意仅在iframe里才能使用这个函数<br>（3）loadImJoyBasicApp：一个简易但功能完善的ImJoy最小化app。</p><p>对于这三个加载函数，可以选择性地传入以下配置对象：</p><ul><li>version: 指定imjoy-core或imjoy-rpc的版本</li><li>api_version: 仅适用于imjoy-rpc，限定RPC的api版本</li><li>debug: 加载imjoy-core未压缩过的包含调试信息的版本，开发阶段使用</li><li>base_url: 自定义加载这些库的路径（上面已演示过，可以设置这个参数来使用本地托管的库）</li></ul><p>对于loadImJoyBasicApp，还有其他额外的选项：</p><ul><li>process_url_query: 布尔值，是否处理url请求</li><li>show_window_title: 布尔值，是否显示窗口标题</li><li>show_progress_bar: 布尔值，是否显示进度条</li><li>show_empty_window: 布尔值，是否显示空白窗口</li><li>hide_about_imjoy: 布尔值，是否隐藏“关于”菜单</li><li>menu_style: Object, 菜单样式</li><li>window_style: Object, 窗口样式</li><li>main_container: String, 定义主容器的id</li><li>menu_container: String, 定义菜单容器的id</li><li>window_manager_container: String, 定义窗口管理器的id</li><li>imjoy_api: Object, 重载一些ImJoy API函数的实现</li></ul><p>这里是使用loadImJoyBasicApp编写的一个<a href="https://imjoy.io/lite">轻量化的ImJoy app</a>，源代码在<a href="https://github.com/imjoy-team/ImJoy/blob/master/web/public/lite.html">这里</a>。</p><h2 id="自动切换core和plugin"><a href="#自动切换core和plugin" class="headerlink" title="自动切换core和plugin"></a>自动切换core和plugin</h2><p>对于一个既可以作为插件plugin，又可以使用imjoy core的web app，ImJoy提供了一个函数来检测当前app，从而在两种模式间自动切换：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check if it&#x27;s inside an iframe</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.self !== <span class="built_in">window</span>.top)&#123;</span><br><span class="line">    loadImJoyRPC().then(<span class="function">(<span class="params">imjoyRPC</span>)=&gt;</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    loadImJoyCore().then(<span class="function">(<span class="params">imjoyCore</span>)=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>上面的技术需要用到的web知识：<br>（1）JavaScript语法：<br><a href="https://www.runoob.com/w3cnote/es6-module.html">ES6 模块</a><br><a href="https://www.runoob.com/js/js-async.html">JavaScript 异步编程</a><br><a href="https://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html">Javascript异步编程的4种方法</a><br><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023024413276544">Promise</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises">使用Promise</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Async_await">async和await:让异步编程更简单</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function">async函数</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await">await</a><br>（2）Webpack打包：<br><a href="https://www.jiangruitao.com/webpack/">Webpack 教程</a><br>（3）Node.js开发：<br><a href="https://segmentfault.com/q/1010000022020967">es6的import是不是也可以导入css和scss？</a><br><a href="https://www.zhihu.com/question/358026810">vue main.js中引入node_modules中的文件为什么路径不用写node_modules?</a><br><a href="https://github.com/SunshowerC/blog/issues/8">package.json 中 你还不清楚的 browser，module，main 字段优先级</a><br>（4）Vue.js开发：<br>视频教程推荐：<br><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?from=search&amp;seid=396170412927101372">尚硅谷Vue2.0+Vue3.0全套教程丨vuejs从入门到精通</a><br>文字版的教程推荐：<br><a href="https://www.runoob.com/vue2/vue-tutorial.html">Vue.js菜鸟教程</a><br><a href="https://cn.vuejs.org/v2/guide/index.html">Vue.js官方教程</a></p>]]></content>
    
    
    <summary type="html">简介
ImJoy设计的初衷就包括可以被集成使用。这意味着它可以根据需求以多种方式集成到一个项目中。
这里的“集成”有两个意思：
（1）将ImJoy的核心core库集成在自己的网站或web应用中，从而可以调用ImJoy生态中的各种插件；
（2）将ImJoy的运行时rpc库集成到自己的web应用中，从而将自己的web应用转换为ImJoy的一个插件，即被别人可调用和访问。

安装
集成ImJoy（无论是imjoy-core还是imjoy-rpc）主要有三种方式：
（1）在页面上以 CDN 包的形式导入。
（2）下载 JavaScript 文件并自行托管。
（3）使用 npm 安装它。
下面详细说明。</summary>
    
    
    
    <category term="computer vision" scheme="http://qixinbo.github.io/categories/computer-vision/"/>
    
    
    <category term="ImJoy" scheme="http://qixinbo.github.io/tags/ImJoy/"/>
    
  </entry>
  
  <entry>
    <title>开源深度学习计算平台ImJoy解析：8 -- 使用python编写计算插件</title>
    <link href="http://qixinbo.github.io/2021/12/18/ImJoy_8/"/>
    <id>http://qixinbo.github.io/2021/12/18/ImJoy_8/</id>
    <published>2021-12-17T16:00:00.000Z</published>
    <updated>2021-12-19T11:11:14.984Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇着重介绍了如何使用JavaScript库来编写插件的前端UI和后端计算逻辑，这一节会介绍如何将计算后端切换为python语言，即计算逻辑完全使用python编写，充分利用python庞大的计算生态。<br>使用python开发计算插件有两种：<br>（1）web-python：即python运行在浏览器中，其原理实际是应用了<a href="https://pyodide.org/en/stable/">Pyodide</a>这一工具，将python代码编译在浏览器中，但其缺点也很明显，首先是加载速度非常慢，因为第一次运行时需要将所用的python库都下载下来；然后其也无法应用整个python深度学习生态。<br>（2）native-python：该类型插件会链接一个本地的jupyter插件引擎，可以充分发挥python的最大价值，本篇也将着重介绍该种插件的编写。</p><h1 id="web-python的hello-world"><a href="#web-python的hello-world" class="headerlink" title="web-python的hello world"></a>web-python的hello world</h1><p>先看一个使用web-python编写的hello world例子，它会完全在浏览器中运行Python代码。<br>注意，当运行以下插件时，会需要一段时间，因为它需要将python库加载到浏览器中：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;docs lang=<span class="string">&quot;markdown&quot;</span>&gt;</span><br><span class="line">[TODO: write documentation <span class="keyword">for</span> this plugin.]</span><br><span class="line">&lt;/docs&gt;</span><br><span class="line">&lt;config lang=<span class="string">&quot;json&quot;</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Untitled Plugin&quot;</span>,</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;web-python&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.1.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;[TODO: describe this plugin with one sentence.]&quot;</span>,</span><br><span class="line">  <span class="string">&quot;tags&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;ui&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;cover&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;inputs&quot;</span>: null,</span><br><span class="line">  <span class="string">&quot;outputs&quot;</span>: null,</span><br><span class="line">  <span class="string">&quot;flags&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;extension&quot;</span>,</span><br><span class="line">  <span class="string">&quot;api_version&quot;</span>: <span class="string">&quot;0.1.8&quot;</span>,</span><br><span class="line">  <span class="string">&quot;env&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;permissions&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;requirements&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;dependencies&quot;</span>: []</span><br><span class="line">&#125;</span><br><span class="line">&lt;/config&gt;</span><br><span class="line">&lt;script lang=<span class="string">&quot;python&quot;</span>&gt;</span><br><span class="line"><span class="keyword">from</span> imjoy <span class="keyword">import</span> api</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImJoyPlugin</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span>(<span class="params">self</span>):</span></span><br><span class="line">        api.log(<span class="string">&#x27;initialized&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, ctx</span>):</span></span><br><span class="line">        api.alert(<span class="string">&#x27;hello world.&#x27;</span>)</span><br><span class="line">api.export(ImJoyPlugin())</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><br>实测速度非常慢，所以并不推荐使用web-python这种方式来编写插件。</p><h1 id="native-python开发插件"><a href="#native-python开发插件" class="headerlink" title="native-python开发插件"></a>native-python开发插件</h1><p>如果想充分利用python的深度学习生态，唯一使用的方式就是native-python这种开发模式。<br>此模式的使用可以有三种组合方式：<br>（1）<a href="https://imjoy.io/#/app">ImJoy官方部署</a>+<a href="https://mybinder.org/">MyBinder</a>插件引擎；<br>（2）<a href="https://imjoy.io/#/app">ImJoy官方部署</a>+本地Jupyter插件引擎；<br>（3）本地部署+本地Jupyter插件引擎。<br>第一种因为使用MyBinder这一免费的Jupyter托管方案，其性能会较弱，通常只用于demo用途，因此不推荐；<br>第二种会使用ImJoy的官方web app来作为应用入口，因此可能会受限于其官网的可连接性，快速开发时推荐使用；<br>第三种web app和Jupyter都是在本地部署，因此有最大的灵活性。本部分将对第三种的环境搭建做一介绍。</p><h2 id="本地部署web-app"><a href="#本地部署web-app" class="headerlink" title="本地部署web app"></a>本地部署web app</h2><p>ImJoy的主web app程序也在GitHub上进行了开源，见<a href="https://github.com/imjoy-team/ImJoy">这里</a>。<br>（1）clone该仓库：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:imjoy-team/ImJoy.git</span><br></pre></td></tr></table></figure><br>（2）安装依赖包<br>进入<code>web</code>文件夹，然后：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><br>这一步需要安装nodejs，此处不详细介绍，可以移步<a href="https://nodejs.org/zh-cn/">这里</a>。<br>（3）编译运行：<br>有两种编译和运行方式，一种是开发模式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run serve</span><br></pre></td></tr></table></figure><br>或者生产模式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><br>（4）访问app：<br>上一步运行该app后，就会生成可访问的链接，通常是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:<span class="number">8001</span></span><br></pre></td></tr></table></figure></p><h2 id="搭建本地Jupyter插件引擎"><a href="#搭建本地Jupyter插件引擎" class="headerlink" title="搭建本地Jupyter插件引擎"></a>搭建本地Jupyter插件引擎</h2><p>搭建本地Jupyter插件引擎有两种方法：<br>（1）安装Jupyter notebook（通过<code>pip install jupyter</code>），然后安装<a href="https://github.com/imjoy-team/imjoy-jupyter-extension">imjoy-jupyter-extension</a>。<br>（2）可以通过 <code>pip install imjoy</code> 安装这个<a href="https://github.com/imjoy-team/imjoy-engine">ImJoy-Engine</a>库。<br>推荐使用后者，因为这样可以对Jupyter服务器做一些对ImJoy有用的设置，并且不需要单独安装imjoy-jupyter-extension。<br>具体的搭建流程如下：<br>（1）下载并安装conda环境：推荐使用python3.7版本的Anaconda。<br>（2）安装引擎：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U imjoy[jupyter]</span><br></pre></td></tr></table></figure><br>（3）启动引擎：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imjoy --jupyter</span><br></pre></td></tr></table></figure><br>然后在终端就会得到形如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8888/?token=caac2d7f2e8e0...ad871fe</span><br></pre></td></tr></table></figure><br>的链接。这就是插件引擎的地址。<br>（4）连接web app<br>在前面开启的web app页面上<code>http://localhost:8001/#/app</code>，点击右上角的小火箭图标，然后点击<code>Add Jupyter-Engine</code>，将上面插件引擎的地址填入即可。</p><h1 id="native-python的hello-world"><a href="#native-python的hello-world" class="headerlink" title="native-python的hello world"></a>native-python的hello world</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;docs lang=<span class="string">&quot;markdown&quot;</span>&gt;</span><br><span class="line">[TODO: write documentation <span class="keyword">for</span> this plugin.]</span><br><span class="line">&lt;/docs&gt;</span><br><span class="line">&lt;config lang=<span class="string">&quot;json&quot;</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Untitled Plugin&quot;</span>,</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;native-python&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.1.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;[TODO: describe this plugin with one sentence.]&quot;</span>,</span><br><span class="line">  <span class="string">&quot;tags&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;ui&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;cover&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;inputs&quot;</span>: null,</span><br><span class="line">  <span class="string">&quot;outputs&quot;</span>: null,</span><br><span class="line">  <span class="string">&quot;flags&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;extension&quot;</span>,</span><br><span class="line">  <span class="string">&quot;api_version&quot;</span>: <span class="string">&quot;0.1.8&quot;</span>,</span><br><span class="line">  <span class="string">&quot;env&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;permissions&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;requirements&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;dependencies&quot;</span>: []</span><br><span class="line">&#125;</span><br><span class="line">&lt;/config&gt;</span><br><span class="line">&lt;script lang=<span class="string">&quot;python&quot;</span>&gt;</span><br><span class="line"><span class="keyword">from</span> imjoy <span class="keyword">import</span> api</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImJoyPlugin</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span>(<span class="params">self</span>):</span></span><br><span class="line">        api.log(<span class="string">&#x27;initialized&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, ctx</span>):</span></span><br><span class="line">        api.alert(<span class="string">&#x27;hello world.&#x27;</span>)</span><br><span class="line">api.export(ImJoyPlugin())</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="用python写图像处理插件"><a href="#用python写图像处理插件" class="headerlink" title="用python写图像处理插件"></a>用python写图像处理插件</h1><p>这一部分尝试将<a href="https://qixinbo.info/2021/12/17/imjoy_7/">构建基于Web的图像分析插件</a>这一篇中的opencv.js功能用python版的opencv实现一遍。<br>在此例中，有<strong>两个插件</strong>：UI插件和compute插件。一般来说，有两种方法可以连接它们：<br>（1）首先用<code>api.createWindow(...)</code>从compute插件实例化UI插件，然后与返回的窗口对象进行交互；<br>（2）也可以直接启动UI插件，然后通过<code>api.getPlugin()</code>来获取compute插件提供的api。<br>两种方法到底用哪一种取决于应用程序的实际需要，这里推荐第一种方式用于Python插件的编写，因为它可以更轻松地在Jupyter笔记本中调试。</p><p>这里的插件是用Python重写计算功能、JavaScript仍然是前端，因此涉及到两种语言对图像格式的转译，需要进行编码和解码以使它们交叉兼容。最简单的方法是将图像编码为“base64”字符串。<br>因此，整个插件的流程为（本节末尾会给出所有代码，这里是将代码分解）：<br>（1）从UI插件（即图像查看器）的canvas画布中得到图像的<code>base64</code>编码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvas-id&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// get `base64` encoded image from a canvas</span></span><br><span class="line"><span class="keyword">const</span> base64String = canvas.toDataURL()</span><br></pre></td></tr></table></figure><br>（2）在UI插件中调用compute插件中的函数，并传递上面的<code>base64</code>编码：<br>UI插件能调用compute插件中的python函数，是通过插件中的<code>ctx</code>变量来得到它，形如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the run funciton of the image viewer</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">run</span>(<span class="params">ctx</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// check if there is a process function passed in</span></span><br><span class="line">    <span class="keyword">if</span>(ctx.data &amp;&amp; ctx.data.process)&#123;</span><br><span class="line">        <span class="comment">// show an additional &quot;Process in Python&quot; button</span></span><br><span class="line">        <span class="comment">// and set the call back to use this process function</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>相对应地，在Python插件中就可以执行<code>await api.createWindow(type=&quot;Image Viewer&quot;, data=&#123;&quot;process&quot;: self.process&#125;)</code>来传给JS插件（假设已经在插件中定义了一个名为 <code>process</code>的函数）。<br>在调用<code>api.createWindow</code> 时，有两种方法可以引用另一个窗口插件：<br>（a）将<code>type</code>键设置为窗口插件名称，例如如果UI插件名为<code>My Window Plugin</code>，就将其设置为<code>type</code>。注意，这个名称是从 <code>&lt;config&gt;</code> 块中的 <code>name</code> 定义中获得的。<br>（b）如果UI插件是源代码的形式或者由公共服务器提供，可以设置<code>src</code>作为插件源代码或者插件URL，比如<code>name=&quot;Kaibu&quot;,src=&quot;https://kaibu.org/#/app&quot;</code>。在这种情况下，插件将被动态填充。例如，它允许将窗口插件存储为Python中的字符串，甚至可以根据模板动态生成窗口插件。</p><p>另外一个需要注意的是，如果是使用<code>await api.createWindow(type=&quot;Image Viewer&quot;, data=&#123;&quot;process&quot;: self.process&#125;)</code>，此时会发现，如果第二次单击该按钮，它将不再起作用，并且如果转到浏览器控制台，将看到一条错误消息，提示<code>Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function.</code>。这是因为在第一次调用后从窗口中删除了<code>process</code>函数。为了明确地告诉窗口保留<code>process</code>函数，可以将一个特殊的键<code>_rintf</code>设置为<code>True</code>，即把上面的代码改成<code>data=&#123;&quot;process&quot;: self.process, &quot;_rintf&quot;: True&#125;</code>。<br>（3）在python插件中解码<code>base64</code>，并读取为numpy类型数组：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> imageio</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">base64_to_image</span>(<span class="params">base64_string, <span class="built_in">format</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;This function takes a base64 string as input</span></span><br><span class="line"><span class="string">    and decode it into an numpy array image</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    base64_string = re.sub(<span class="string">&quot;^data:image/.+;base64,&quot;</span>, <span class="string">&quot;&quot;</span>, base64_string)</span><br><span class="line">    image_file = io.BytesIO(base64.b64decode(base64_string.encode(<span class="string">&#x27;ascii&#x27;</span>)))</span><br><span class="line">    <span class="keyword">return</span> imageio.imread(image_file, <span class="built_in">format</span>)</span><br></pre></td></tr></table></figure></p><p>（4）在python插件中编写图像处理算法：<br>这里仍然使用的是opencv，不过要用的是它的python版本：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;requirements&quot;</span>: [<span class="string">&quot;opencv-python&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_image</span>(<span class="params">src</span>):</span></span><br><span class="line">    dst = cv2.cvtColor(src, cv2.COLOR_RGBA2GRAY)</span><br><span class="line">    <span class="keyword">return</span> dst</span><br></pre></td></tr></table></figure><br>（5）将numpy数组类型的处理结果编码为<code>base64</code>并返回：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image_to_base64</span>(<span class="params">image_array</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;This function takes a numpy image array as input</span></span><br><span class="line"><span class="string">    and encode it into a base64 string</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    buf = io.BytesIO()</span><br><span class="line">    imageio.imwrite(buf, image_array, <span class="string">&quot;PNG&quot;</span>)</span><br><span class="line">    buf.seek(<span class="number">0</span>)</span><br><span class="line">    img_bytes = buf.getvalue()</span><br><span class="line">    base64_string = base64.b64encode(img_bytes).decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;data:image/png;base64,&#x27;</span> + base64_string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, base64string</span>):</span></span><br><span class="line">    img = base64_to_image(base64string)</span><br><span class="line">    dst = process_image(img)</span><br><span class="line">    base64dst = image_to_base64(dst)</span><br><span class="line">    <span class="keyword">return</span> base64dst</span><br></pre></td></tr></table></figure><br>（6）在JS插件中接收<code>base64</code>编码，并在画布中显示为图像：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// draw a `base64` encoded image to the canvas</span></span><br><span class="line"><span class="keyword">const</span> drawImage = <span class="function">(<span class="params">canvas, base64Image</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">        img.crossOrigin = <span class="string">&quot;anonymous&quot;</span></span><br><span class="line">        img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">            canvas.width = <span class="built_in">Math</span>.min(<span class="built_in">this</span>.width, <span class="number">512</span>);</span><br><span class="line">            canvas.height= <span class="built_in">Math</span>.min(<span class="built_in">this</span>.height, <span class="built_in">parseInt</span>(<span class="number">512</span>*<span class="built_in">this</span>.height/<span class="built_in">this</span>.width), <span class="number">1024</span>);</span><br><span class="line">            <span class="comment">// draw the img into canvas</span></span><br><span class="line">            ctx.drawImage(<span class="built_in">this</span>, <span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line">            resolve(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">        img.onerror = reject;</span><br><span class="line">        img.src = base64Image;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>整个插件的处理逻辑如上，结果与完全JS作为前端和后端的结果相同，如下图：<br><img src="https://user-images.githubusercontent.com/6218739/146639355-669e3cac-2134-4171-ba21-19884d536abb.png" alt="pythonbackend"></p><p>完整代码如下：<br>对于UI插件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">&lt;config lang=<span class="string">&quot;json&quot;</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Image Viewer&quot;</span>,</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;window&quot;</span>,</span><br><span class="line">  <span class="string">&quot;tags&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;ui&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.1.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;cover&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;This is a demo plugin for displaying image&quot;</span>,</span><br><span class="line">  <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;extension&quot;</span>,</span><br><span class="line">  <span class="string">&quot;inputs&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;outputs&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;api_version&quot;</span>: <span class="string">&quot;0.1.8&quot;</span>,</span><br><span class="line">  <span class="string">&quot;env&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;permissions&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;requirements&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;https://cdn.jsdelivr.net/npm/bulma@0.9.1/css/bulma.min.css&quot;</span>, </span><br><span class="line">    <span class="string">&quot;https://use.fontawesome.com/releases/v5.14.0/js/all.js&quot;</span>],</span><br><span class="line">  <span class="string">&quot;dependencies&quot;</span>: []</span><br><span class="line">&#125;</span><br><span class="line">&lt;/config&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=<span class="string">&quot;javascript&quot;</span>&gt;</span><br><span class="line"><span class="keyword">const</span> drawImage = <span class="function">(<span class="params">canvas, base64Image</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">        img.crossOrigin = <span class="string">&quot;anonymous&quot;</span></span><br><span class="line">        img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">            canvas.width = <span class="built_in">Math</span>.min(<span class="built_in">this</span>.width, <span class="number">512</span>);</span><br><span class="line">            canvas.height= <span class="built_in">Math</span>.min(<span class="built_in">this</span>.height, <span class="built_in">parseInt</span>(<span class="number">512</span>*<span class="built_in">this</span>.height/<span class="built_in">this</span>.width), <span class="number">1024</span>);</span><br><span class="line">            <span class="comment">// draw the img into canvas</span></span><br><span class="line">            ctx.drawImage(<span class="built_in">this</span>, <span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line">            resolve(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">        img.onerror = reject;</span><br><span class="line">        img.src = base64Image;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> readImageFile = <span class="function">(<span class="params">file</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> U = <span class="built_in">window</span>.URL || <span class="built_in">window</span>.webkitURL;</span><br><span class="line">        <span class="keyword">if</span>(U.createObjectURL)&#123;</span><br><span class="line">            resolve(U.createObjectURL(file))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> fr = <span class="keyword">new</span> FileReader();</span><br><span class="line">            fr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">                resolve(e.target.result)</span><br><span class="line">            &#125;;</span><br><span class="line">            fr.onerror = reject</span><br><span class="line">            fr.readAsDataURL(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImJoyPlugin</span></span>&#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> fileInput = <span class="built_in">document</span>.getElementById(<span class="string">&quot;file-input&quot;</span>);</span><br><span class="line">        <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;input-canvas&quot;</span>);</span><br><span class="line">        <span class="keyword">const</span> outputcanvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;output-canvas&quot;</span>);</span><br><span class="line">        fileInput.addEventListener(<span class="string">&quot;change&quot;</span>, <span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">        <span class="keyword">const</span> img = <span class="keyword">await</span> readImageFile(fileInput.files[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">await</span> drawImage(canvas, img);</span><br><span class="line">        &#125;, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">await</span> api.log(<span class="string">&quot;plugin initialized&quot;</span>)</span><br><span class="line">        <span class="keyword">const</span> selectButton = <span class="built_in">document</span>.getElementById(<span class="string">&quot;select-button&quot;</span>);</span><br><span class="line">        selectButton.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">        fileInput.click()</span><br><span class="line">        &#125;, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">run</span>(<span class="params">ctx</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ctx.data &amp;&amp; ctx.data.process)&#123;</span><br><span class="line">            <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;input-canvas&quot;</span>);</span><br><span class="line">            <span class="keyword">const</span> outputcanvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;output-canvas&quot;</span>);</span><br><span class="line">            <span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;process-button&#x27;</span>)</span><br><span class="line">            btn.disabled = <span class="literal">false</span>;</span><br><span class="line">            btn.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">                <span class="keyword">const</span> base64String = canvas.toDataURL()</span><br><span class="line">                <span class="keyword">const</span> base64dst = <span class="keyword">await</span> ctx.data.process(base64String)</span><br><span class="line">                <span class="keyword">await</span> drawImage(outputcanvas, base64dst)</span><br><span class="line">            &#125;, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">api.export(<span class="keyword">new</span> ImJoyPlugin())</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="built_in">window</span>&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;input  id=<span class="string">&quot;file-input&quot;</span> accept=<span class="string">&quot;image/*&quot;</span> capture=<span class="string">&quot;camera&quot;</span> type=<span class="string">&quot;file&quot;</span>/&gt;</span><br><span class="line">        &lt;nav <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;panel&quot;</span>&gt;</span><br><span class="line">        &lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;panel-heading&quot;</span>&gt;</span><br><span class="line">            &lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;fas fa-eye&quot;</span> aria-hidden=<span class="string">&quot;true&quot;</span>&gt;&lt;/i&gt; My Image Viewer <span class="keyword">with</span> Python backend</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;panel-block&quot;</span>&gt;</span><br><span class="line">            &lt;button id=<span class="string">&quot;select-button&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;button is-link is-outlined is-fullwidth&quot;</span>&gt;</span><br><span class="line">            Open an image</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">            &lt;button id=<span class="string">&quot;process-button&quot;</span> disabled <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;button is-link is-outlined is-fullwidth&quot;</span>&gt;</span><br><span class="line">            RGB to Gray</span><br><span class="line">            &lt;/button&gt;            </span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;panel-block&quot;</span>&gt;</span><br><span class="line">            &lt;canvas id=<span class="string">&quot;input-canvas&quot;</span> style=<span class="string">&quot;width: 100%; object-fit: cover;&quot;</span>&gt;&lt;/canvas&gt;</span><br><span class="line">            &lt;canvas id=<span class="string">&quot;output-canvas&quot;</span> style=<span class="string">&quot;width: 100%; object-fit: cover;&quot;</span>&gt;&lt;/canvas&gt;</span><br><span class="line">        &lt;/div&gt; </span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;panel-block&quot;</span>&gt;</span><br><span class="line">            &lt;button id=<span class="string">&quot;predict-button&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;button is-link is-outlined is-fullwidth&quot;</span>&gt;</span><br><span class="line">            Predict</span><br><span class="line">            &lt;/button&gt;        </span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/<span class="built_in">window</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">#file-input&#123;</span><br><span class="line">    display: none;</span><br><span class="line">&#125;</span><br><span class="line">h1&#123;</span><br><span class="line">    color: pink;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><br>对于compute插件：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&lt;config lang=<span class="string">&quot;json&quot;</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;type&quot;</span>: <span class="string">&quot;native-python&quot;</span>,</span><br><span class="line"> <span class="string">&quot;name&quot;</span>: <span class="string">&quot;my-python-plugin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;id&quot;</span>: <span class="string">&quot;9l3fewe7l&quot;</span>,</span><br><span class="line"> <span class="string">&quot;namespace&quot;</span>: <span class="string">&quot;9l3fewe7l&quot;</span>,</span><br><span class="line"> <span class="string">&quot;lang&quot;</span>: <span class="string">&quot;python&quot;</span>,</span><br><span class="line"> <span class="string">&quot;window_id&quot;</span>: <span class="string">&quot;code_9l3fewe7l&quot;</span>,</span><br><span class="line"> <span class="string">&quot;api_version&quot;</span>: <span class="string">&quot;0.1.8&quot;</span>,</span><br><span class="line"> <span class="string">&quot;description&quot;</span>: <span class="string">&quot;[TODO: describe this plugin with one sentence.]&quot;</span>,</span><br><span class="line"> <span class="string">&quot;tags&quot;</span>: [],</span><br><span class="line"> <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.1.0&quot;</span>,</span><br><span class="line"> <span class="string">&quot;ui&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"> <span class="string">&quot;cover&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"> <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;extension&quot;</span>,</span><br><span class="line"> <span class="string">&quot;inputs&quot;</span>: null,</span><br><span class="line"> <span class="string">&quot;outputs&quot;</span>: null,</span><br><span class="line"> <span class="string">&quot;env&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"> <span class="string">&quot;permissions&quot;</span>: [],</span><br><span class="line"> <span class="string">&quot;requirements&quot;</span>: [<span class="string">&quot;opencv-python&quot;</span>],</span><br><span class="line"> <span class="string">&quot;dependencies&quot;</span>: []</span><br><span class="line">&#125;</span><br><span class="line">&lt;/config&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=<span class="string">&quot;python&quot;</span>&gt;</span><br><span class="line"><span class="keyword">from</span> imjoy <span class="keyword">import</span> api</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> imageio</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image_to_base64</span>(<span class="params">image_array</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;This function takes a numpy image array as input</span></span><br><span class="line"><span class="string">    and encode it into a base64 string</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    buf = io.BytesIO()</span><br><span class="line">    imageio.imwrite(buf, image_array, <span class="string">&quot;PNG&quot;</span>)</span><br><span class="line">    buf.seek(<span class="number">0</span>)</span><br><span class="line">    img_bytes = buf.getvalue()</span><br><span class="line">    base64_string = base64.b64encode(img_bytes).decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;data:image/png;base64,&#x27;</span> + base64_string</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">base64_to_image</span>(<span class="params">base64_string, <span class="built_in">format</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;This function takes a base64 string as input</span></span><br><span class="line"><span class="string">    and decode it into an numpy array image</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    base64_string = re.sub(<span class="string">&quot;^data:image/.+;base64,&quot;</span>, <span class="string">&quot;&quot;</span>, base64_string)</span><br><span class="line">    image_file = io.BytesIO(base64.b64decode(base64_string.encode(<span class="string">&#x27;ascii&#x27;</span>)))</span><br><span class="line">    <span class="keyword">return</span> imageio.imread(image_file, <span class="built_in">format</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_image</span>(<span class="params">src</span>):</span></span><br><span class="line">    dst = cv2.cvtColor(src, cv2.COLOR_RGBA2GRAY)</span><br><span class="line">    <span class="keyword">return</span> dst</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImJoyPlugin</span>():</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">setup</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, base64string</span>):</span></span><br><span class="line">        img = base64_to_image(base64string)</span><br><span class="line">        dst = process_image(img)</span><br><span class="line">        base64dst = image_to_base64(dst)</span><br><span class="line">        <span class="keyword">return</span> base64dst</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, ctx</span>):</span></span><br><span class="line">        <span class="keyword">await</span> api.createWindow(</span><br><span class="line">            <span class="built_in">type</span>=<span class="string">&quot;Image Viewer&quot;</span>, </span><br><span class="line">            data=&#123;</span><br><span class="line">                <span class="string">&quot;process&quot;</span>: self.process,</span><br><span class="line">                <span class="string">&quot;_rintf&quot;</span>: <span class="literal">True</span>&#125;)</span><br><span class="line"></span><br><span class="line">api.export(ImJoyPlugin())</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><br>在调试上述插件时，因为涉及到了<code>base64</code>的编码和解码，我频繁用到了如下debug方法，推荐尝试：<br>（1）使用<code>api.log(base64string)</code>将base64编码结果显示在控制台中；<br>（2）使用这个网站<a href="https://base64.guru/converter/decode/image">Base64 to Image</a>将base64编码可视化，以查看结果正不正确。</p><h1 id="使用python深度学习库"><a href="#使用python深度学习库" class="headerlink" title="使用python深度学习库"></a>使用python深度学习库</h1><p>如上，我们使用了opencv-python进行了简单的图像处理，验证了native python插件的可行性。<br>而除了opencv-python，python背后还有着更为广阔的深度学习生态，如tensorflow、pytorch、mxnet、paddlepaddle等深度学习框架，以及这些框架可调用的GPU资源，因此可以说整个python计算生态都可以被ImJoy的native python插件所调用，这就提供了非常广阔的应用空间。<br>该部分不再介绍native python怎样调用python深度学习库，而是在后面的具体应用中详细解析。</p>]]></content>
    
    
    <summary type="html">上一篇着重介绍了如何使用JavaScript库来编写插件的前端UI和后端计算逻辑，这一节会介绍如何将计算后端切换为python语言，即计算逻辑完全使用python编写，充分利用python庞大的计算生态。
使用python开发计算插件有两种：
（1）web-python：即python运行在浏览器中，其原理实际是应用了Pyodide这一工具，将python代码编译在浏览器中，但其缺点也很明显，首先是加载速度非常慢，因为第一次运行时需要将所用的python库都下载下来；然后其也无法应用整个python深度学习生态。
（2）native-python：该类型插件会链接一个本地的jupyter插件引</summary>
    
    
    
    <category term="computer vision" scheme="http://qixinbo.github.io/categories/computer-vision/"/>
    
    
    <category term="ImJoy" scheme="http://qixinbo.github.io/tags/ImJoy/"/>
    
  </entry>
  
</feed>
