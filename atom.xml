<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>数字旗手</title>
  
  <subtitle>电气化、自动化、数字化、智能化、智慧化</subtitle>
  <link href="http://qixinbo.github.io/atom.xml" rel="self"/>
  
  <link href="http://qixinbo.github.io/"/>
  <updated>2022-05-23T03:17:06.840Z</updated>
  <id>http://qixinbo.github.io/</id>
  
  <author>
    <name>Xin-Bo Qi(亓欣波)</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>开源深度学习计算平台ImJoy解析：13 -- Kaibu应用</title>
    <link href="http://qixinbo.github.io/2022/05/22/ImJoy_13/"/>
    <id>http://qixinbo.github.io/2022/05/22/ImJoy_13/</id>
    <published>2022-05-21T16:00:00.000Z</published>
    <updated>2022-05-23T03:17:06.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>ImJoy有一个很有用的插件或独立应用，叫做<a href="https://kaibu.org/">Kaibu</a>，它可以展示并标注普通的位图、矢量图及vtk、stl等3D格式的数据。<br>比如如下展示：<br><img src="https://user-images.githubusercontent.com/6218739/158537518-a3583f3e-4b06-494b-928a-3904f6b29fb2.png" alt="kaibu"><br>其就是位图（png格式）、矢量图（json格式）、3D模型（stl格式）的一个叠加。</p><p>Kaibu主要用了两个JS库，一个是<a href="https://openlayers.org/">OpenLayers</a>，一个是<a href="https://kitware.github.io/itk-vtk-viewer/docs/">ITK-VTK</a>，前者用于展示矢量图形、普通位图等数据，且对地图的展示异常强大，后者用于展示在医疗及科学计算中常用的3D图像、网格、点集等。</p><p>这一篇主要分析一下Kaibu的运行机理。</p><p>从script标签开始，看其运行过程。</p><h1 id="导入组件"><a href="#导入组件" class="headerlink" title="导入组件"></a>导入组件</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> layerComponents <span class="keyword">from</span> <span class="string">&quot;@/components/layers&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> widgetComponents <span class="keyword">from</span> <span class="string">&quot;@/components/widgets&quot;</span>;</span><br></pre></td></tr></table></figure><p>导入自定义的各种layers和widgets。<br>这里的layers即是Kaibu能承载的数据类型，其概念就是“图层”的含义，即不同类型的图层叠加起来，就能展示复杂的图像。具体有2D图像层ImageLayer、矢量层VectorLayer和3D模型层ItkVtkLayer。<br>这里的widgets即是Kaibu自定义的各种控件，比如树形控件TreeWidget、表单控件FormWidget、列表控件ListWidget等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> components = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> layerTypes = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">in</span> layerComponents) &#123;</span><br><span class="line">  components[layerComponents[c].name] = layerComponents[c];</span><br><span class="line">  layerTypes[layerComponents[c].type] = layerComponents[c];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;components = &#x27;</span>, components)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;layerTypes = &#x27;</span>, layerTypes)</span><br></pre></td></tr></table></figure><p>将不同的layers根据name和type分别提取到两个变量中，即components存储了以layer名称为键的图层组件，layerTypes中存储了以layer类型为键的图层组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> widgetTypes = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">in</span> widgetComponents) &#123;</span><br><span class="line">  components[widgetComponents[c].name] = widgetComponents[c];</span><br><span class="line">  widgetTypes[widgetComponents[c].type] = widgetComponents[c];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;components = &#x27;</span>, components)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;widgetTypes = &#x27;</span>, widgetTypes)</span><br></pre></td></tr></table></figure><p>将不同的widgets根据name和type分别提取到两个变量中，即之前的components中又接收了以widgets名称为键的控件组件，widgetTypes则存储了以widget类型为键的控件组件。</p><h1 id="挂载生命周期钩子"><a href="#挂载生命周期钩子" class="headerlink" title="挂载生命周期钩子"></a>挂载生命周期钩子</h1><p>Kaibu定义了很多计算属性和方法，可以先从mounted挂载这一生命周期钩子看其怎么调用的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.init();</span><br><span class="line">  <span class="built_in">this</span>.sortableOptions.layer_configs = <span class="built_in">this</span>.layer_configs;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, <span class="built_in">this</span>.updateSize);</span><br><span class="line">  <span class="built_in">window</span>.dispatchEvent(<span class="keyword">new</span> Event(<span class="string">&quot;resize&quot;</span>));</span><br><span class="line">  <span class="built_in">this</span>.openSidebar(<span class="literal">true</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><br>可以看出，挂载后第一步是初始化，它也是最重要的一步。下面对这一步进行详细的解析。</p><h2 id="创建Map"><a href="#创建Map" class="headerlink" title="创建Map"></a>创建Map</h2><p>因为Kaibu用的是OpenLayers进行渲染，因此首先创建一个OpenLayers的Map实例对象是至关重要的，即它作为画布。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> extent = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1024</span>, <span class="number">968</span>];</span><br><span class="line"><span class="keyword">const</span> projection = <span class="keyword">new</span> Projection(&#123;</span><br><span class="line">  code: <span class="string">&quot;xkcd-image&quot;</span>,</span><br><span class="line">  units: <span class="string">&quot;pixels&quot;</span>,</span><br><span class="line">  extent: extent</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(&#123;</span><br><span class="line">  interactions: defaults(&#123;</span><br><span class="line">    altShiftDragRotate: <span class="literal">false</span>,</span><br><span class="line">    pinchRotate: <span class="literal">false</span></span><br><span class="line">  &#125;),</span><br><span class="line">  target: <span class="string">&quot;map&quot;</span>,  <span class="comment">// 这里就是与template里id为map的div标签进行绑定</span></span><br><span class="line">  layers: [],</span><br><span class="line">  view: <span class="keyword">new</span> View(&#123;</span><br><span class="line">    projection: projection,</span><br><span class="line">    center: getCenter(extent),</span><br><span class="line">    zoom: <span class="number">2</span>,</span><br><span class="line">    maxZoom: <span class="number">8</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">this</span>.$store.commit(<span class="string">&quot;setMap&quot;</span>, map);</span><br></pre></td></tr></table></figure><br>这样新建了一个Map实例对象map，并且传给了vuex状态管理器。</p><h2 id="添加图层事件"><a href="#添加图层事件" class="headerlink" title="添加图层事件"></a>添加图层事件</h2><p>接下来就是添加具体的图层。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="built_in">this</span>.addLayer(&#123;</span><br><span class="line">  type: <span class="string">&quot;vector&quot;</span>,</span><br><span class="line">  name: <span class="string">&quot;shape vectors&quot;</span>,</span><br><span class="line">  data:</span><br><span class="line">    <span class="string">&quot;https://gist.githubusercontent.com/oeway/7c62128939a7f9b1701e2bbd72b809dc/raw/example_shape_vectors.json&quot;</span>,</span><br><span class="line">  predefined_tags: [<span class="string">&quot;nuclei&quot;</span>, <span class="string">&quot;cell&quot;</span>],</span><br><span class="line">  only_predefined_tags: <span class="literal">true</span>,</span><br><span class="line">  single_tag_mode: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>如上就是增加Vector图层的代码。它调用了addLayer这个方法，明显地，它接收上面的配置对象作为参数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">addLayer</span>(<span class="params">config</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    config.id = randId(); <span class="comment">// 对配置对象添加id属性</span></span><br><span class="line">    <span class="built_in">this</span>.$store.dispatch(<span class="string">&quot;addLayer&quot;</span>, config); <span class="comment">// 触发vuex共享状态</span></span><br><span class="line">    config._add_layer_promise = &#123; resolve, reject &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><br>可以看出，它首先对上面接收的配置对象config添加了一个随机的id，然后触发vuex共享状态的addLayer这个action（Vuex通过Vue的插件系统将store实例从根组件中“注入”到所有的子组件里。且子组件能通过<code>this.$store</code>访问到）。<br>详细看一下共享状态的这些事件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    layers: &#123;&#125;,</span><br><span class="line">    widgets: &#123;&#125;,</span><br><span class="line">    layer_configs: [],</span><br><span class="line">    currentLayer: <span class="literal">null</span>,</span><br><span class="line">    currentLayerWidget: <span class="literal">null</span>,</span><br><span class="line">    standaloneWidgets: &#123;&#125;,</span><br><span class="line">    map: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    <span class="function"><span class="title">addLayer</span>(<span class="params">context, config</span>)</span> &#123;</span><br><span class="line">      context.commit(<span class="string">&quot;addLayer&quot;</span>, config);</span><br><span class="line">      Vue.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (config.init) &#123;</span><br><span class="line">          config</span><br><span class="line">            .init()</span><br><span class="line">            .then(<span class="function"><span class="params">layer</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (!layer) &#123;</span><br><span class="line">                <span class="keyword">if</span> (config._add_layer_promise) &#123;</span><br><span class="line">                  config._add_layer_promise.reject(</span><br><span class="line">                    <span class="string">&quot;Failed to create layer for &quot;</span> + config.name</span><br><span class="line">                  );</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              layer.config = config;</span><br><span class="line">              layer.setVisible(config.visible);</span><br><span class="line">              layer.getLayerAPI = layer.getLayerAPI || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">              context.commit(<span class="string">&quot;initialized&quot;</span>, layer);</span><br><span class="line">              context.commit(<span class="string">&quot;setCurrentLayer&quot;</span>, layer.config);</span><br><span class="line">              context.commit(<span class="string">&quot;sortLayers&quot;</span>);</span><br><span class="line">              <span class="keyword">if</span> (config._add_layer_promise) &#123;</span><br><span class="line">                config._add_layer_promise.resolve(layer);</span><br><span class="line">                <span class="keyword">delete</span> config._add_layer_promise;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (config._add_layer_promise) &#123;</span><br><span class="line">                config._add_layer_promise.reject(e);</span><br><span class="line">                <span class="keyword">delete</span> config._add_layer_promise;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.error(e);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">debugger</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="function"><span class="title">addLayer</span>(<span class="params">state, config</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (config.visible === <span class="literal">undefined</span>) config.visible = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> config.index === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> index = config.index;</span><br><span class="line">        state.layer_configs.splice(index, <span class="number">0</span>, config);</span><br><span class="line">        <span class="keyword">delete</span> config.index;</span><br><span class="line">      &#125; <span class="keyword">else</span> state.layer_configs.push(config);</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><br>即，上面通过dispatch触发addLayer这个action后，在该action里又通过commit触发了addLayer这个mutation。在这个mutation中，会将配置对象config推入共享状态state的<code>layer_configs</code>属性中。<br>接下来就是非常tricky的一个操作。<br>先看store的action的这段：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">addLayer</span>(<span class="params">context, config</span>)</span> &#123;</span><br><span class="line">  context.commit(<span class="string">&quot;addLayer&quot;</span>, config);</span><br><span class="line">  Vue.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (config.init) &#123;</span><br><span class="line">      config</span><br><span class="line">        .init()</span><br></pre></td></tr></table></figure><br>如上所述，这个addLayer会通过commit触发mutations中的addLayer，从而对state的<code>layer_configs</code>属性进行更新。注意，此时的config还是非常普通的配置对象，就是上面的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: <span class="string">&quot;vector&quot;</span>,</span><br><span class="line">  name: <span class="string">&quot;shape vectors&quot;</span>,</span><br><span class="line">  data:</span><br><span class="line">    <span class="string">&quot;https://gist.githubusercontent.com/oeway/7c62128939a7f9b1701e2bbd72b809dc/raw/example_shape_vectors.json&quot;</span>,</span><br><span class="line">  predefined_tags: [<span class="string">&quot;nuclei&quot;</span>, <span class="string">&quot;cell&quot;</span>],</span><br><span class="line">  only_predefined_tags: <span class="literal">true</span>,</span><br><span class="line">  single_tag_mode: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但是，接下来<code>Vue.nextTick()</code>一执行后，该config就会根据添加的layer的不同，变成特有的config，如下所示：<br><img src="https://user-images.githubusercontent.com/6218739/163119092-4e401f8a-aac1-44cb-8912-6bafb11115dc.png" alt="config"></p><p>这是为什么呢？<br>经过一番仔细的定位，发现奥妙如下，非常巧妙（同时好难懂。。。）。<br>前面已经说了，在mutations中会对<code>state.layer_configs</code>进行更新，而在Kaibu的主组件ImageViewer里有该状态的映射，因此组件的<code>layer_configs</code>也会有更新：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...mapState(&#123;</span><br><span class="line">  layers: <span class="function"><span class="params">state</span> =&gt;</span> state.layers,</span><br><span class="line">  layer_configs: <span class="function"><span class="params">state</span> =&gt;</span> state.layer_configs,</span><br><span class="line">  standaloneWidgets: <span class="function"><span class="params">state</span> =&gt;</span> state.standaloneWidgets,</span><br><span class="line">  currentLayer: <span class="function"><span class="params">state</span> =&gt;</span> state.currentLayer,</span><br><span class="line">  currentLayerWidget: <span class="function"><span class="params">state</span> =&gt;</span> state.currentLayerWidget,</span><br><span class="line">  map: <span class="function"><span class="params">state</span> =&gt;</span> state.map</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>而该计算属性的更新会引起组件的模板中如下部分的变化：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;b-menu-list label=<span class="string">&quot;Properties&quot;</span>&gt;</span><br><span class="line">  &lt;component</span><br><span class="line">    v-<span class="keyword">for</span>=<span class="string">&quot;layer in layer_configs&quot;</span></span><br><span class="line">    v-show=<span class="string">&quot;currentLayer === layer&quot;</span></span><br><span class="line">    @update-extent=<span class="string">&quot;updateExtent&quot;</span></span><br><span class="line">    :ref=<span class="string">&quot;&#x27;layer_&#x27; + layer.id&quot;</span></span><br><span class="line">    :key=<span class="string">&quot;layer.id&quot;</span></span><br><span class="line">    :is=<span class="string">&quot;layerTypes[layer.type]&quot;</span></span><br><span class="line">    @loading=<span class="string">&quot;loading = $event&quot;</span></span><br><span class="line">    :selected=<span class="string">&quot;layer.selected&quot;</span></span><br><span class="line">    :visible=<span class="string">&quot;layer.visible&quot;</span></span><br><span class="line">    :map=<span class="string">&quot;map&quot;</span></span><br><span class="line">    :config=<span class="string">&quot;layer&quot;</span></span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/b-menu-list&gt;</span><br></pre></td></tr></table></figure><br>这个地方用到了Vue的component标签（标签，注意不是组件），它可以动态绑定组件，即根据不同的数据来显示不同的组件。<br>其通过<code>is</code>的值来确定哪个组件被渲染。<br>一个教程见<a href="https://www.cnblogs.com/yjiangling/p/12794933.html">这里</a>。<br>具体到这个例子中，因为传入的config的type键的值是<code>vector</code>，所以它会找到VectorLayer这个组件（即该文最开始的layerTypes中存储了以layer类型为键的图层组件）。<br>然后将<code>layer_configs</code>中遍历的layer（实际就是上面的config）作为config参数（注意这里是config参数标识）从ImageViewer父组件中传给VectorLayer这个子组件（子组件中会通过props属性进行接收）。换句话说，子组件中的config参数就是父组件传入的layer变量，也就是之前的普通的config对象（因为这个config对象被放入<code>layer_configs</code>中，在遍历时被称为layer）。<br>但是这个地方有一个不合常规的做法，即父组件和子组件通过props传递参数，常规是单向数据流，即子组件不能修改父组件的值。这里明显违背了这一原则，而且Vue没有报错。<br>这是因为config是个对象，而不是诸如字符串、数字等非引用类型数据，所以它不会报错，但也造成了理解的困难。<br>下面这两篇解析很好：<br><a href="https://nekolr.github.io/2020/04/26/Vue%20%E4%B9%8B%E5%9C%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B8%AD%E6%94%B9%E5%8F%98%E7%88%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E7%8A%B6%E6%80%81/"> Vue 之在子组件中改变父组件的状态 </a><br><a href="https://segmentfault.com/q/1010000008525755">vue2.0中，子组件修改父组件传递过来得props，该怎么解决？</a><br>可以说是，这里正好应用了这一特性，使得可以特定的子组件可以对config有特定的改变。即在子组件中会对这个config属性进行针对性地加工，比如将该组件地<code>init</code>方法传给它：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.config.init = <span class="built_in">this</span>.init;</span><br></pre></td></tr></table></figure></p><p>上面那部分模板更新后，意味着DOM更新了，此时Vue地nextTick执行，那么这时候的config就是“被特定子组件修饰过”的config。</p><h2 id="初始化图层"><a href="#初始化图层" class="headerlink" title="初始化图层"></a>初始化图层</h2><p>前面已说过，config被特定组件修饰后，就有了该组件或该图层的特性，下面就是调用特定组件的初始化方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">      Vue.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (config.init) &#123;</span><br><span class="line">          config</span><br><span class="line">            .init()</span><br><span class="line">            .then(<span class="function"><span class="params">layer</span> =&gt;</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">即`</span>config.init()<span class="string">`方法调用。</span></span><br><span class="line"><span class="string">以上面的VectorLayer这个组件为例，看一下它的初始化方法：</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.layer = <span class="keyword">await</span> <span class="built_in">this</span>.setupLayer();</span><br><span class="line">      <span class="built_in">this</span>.map.addLayer(<span class="built_in">this</span>.layer);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.config.select_enable &amp;&amp; !<span class="built_in">this</span>.config.draw_enable) &#123;</span><br><span class="line">        <span class="built_in">this</span>.enableSelectInteraction();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.updateDrawInteraction();</span><br><span class="line">      <span class="built_in">this</span>.$forceUpdate();</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.layer;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><br>其他组件也大同小异，就是在该组件中进行一系列的操作，最终是返回<code>this.layer</code>这样的特定的对象。</p><h2 id="更新共享状态"><a href="#更新共享状态" class="headerlink" title="更新共享状态"></a>更新共享状态</h2><p>特定组件初始化成功后，就会接着调用<code>then</code>方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Vue.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (config.init) &#123;</span><br><span class="line">    config</span><br><span class="line">      .init()</span><br><span class="line">      .then(<span class="function"><span class="params">layer</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;layer = &#x27;</span>, layer)</span><br><span class="line">        layer.config = config;</span><br><span class="line">        layer.setVisible(config.visible);</span><br><span class="line">        layer.getLayerAPI = layer.getLayerAPI || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">        context.commit(<span class="string">&quot;initialized&quot;</span>, layer);</span><br><span class="line">        context.commit(<span class="string">&quot;setCurrentLayer&quot;</span>, layer.config);</span><br><span class="line">        context.commit(<span class="string">&quot;sortLayers&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (config._add_layer_promise) &#123;</span><br><span class="line">          config._add_layer_promise.resolve(layer);</span><br><span class="line">          <span class="keyword">delete</span> config._add_layer_promise;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure><br>可以看出，会对上一步返回的layer对象进行一些加工后，再依次调用共享状态store中的一些mutations对共享状态进行更新：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">initialized</span>(<span class="params">state, layer</span>)</span> &#123;</span><br><span class="line">  state.layers[layer.config.id] = layer;</span><br><span class="line">  layer.setZIndex(state.layer_configs.length - <span class="number">1</span>);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">setCurrentLayer</span>(<span class="params">state, layer</span>)</span> &#123;</span><br><span class="line">  layer = state.layer_configs.filter(<span class="function"><span class="params">l</span> =&gt;</span> l.id === layer.id)[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (state.currentLayer === layer) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (state.currentLayer) &#123;</span><br><span class="line">    state.currentLayer.selected = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  state.currentLayer = layer;</span><br><span class="line">  layer.selected = <span class="literal">true</span>;</span><br><span class="line">  state.currentLayerWidget = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> <span class="built_in">Object</span>.keys(state.widgets)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      state.currentLayer.name &amp;&amp;</span><br><span class="line">      state.widgets[k].attach_to == state.currentLayer.name</span><br><span class="line">    ) &#123;</span><br><span class="line">      state.currentLayerWidget = state.widgets[k];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">sortLayers</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; state.layer_configs.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (state.layers[state.layer_configs[i].id])</span><br><span class="line">      state.layers[state.layer_configs[i].id].setZIndex(i);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(<span class="string">&quot;Layer not ready&quot;</span>, state.layer_configs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><br>主要是对state中的属性进行更新，比如<code>layers</code>信息、<code>currentLayer</code>信息等，更新后的共享状态state如下：<br><img src="https://user-images.githubusercontent.com/6218739/163129381-2a30e9dd-2c30-4ff0-a4a8-75495236656c.png" alt="state"></p><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>前面已说到，kaibu有三个非常重要的组件，用于承载不同的图层数据，分别是2D图像层ImageLayer、矢量层VectorLayer和3D模型层ItkVtkLayer。<br>2D图像层使用的是OpenLayers的<code>static image</code>，矢量层使用的是OpenLayers的<code>Vector</code>，对于3D模型层，则是使用的<a href="https://kitware.github.io/itk-vtk-viewer/docs/">ITk/Vtk Viewer</a>。</p><h2 id="ImageLayer"><a href="#ImageLayer" class="headerlink" title="ImageLayer"></a>ImageLayer</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;image-layer&quot;</span>&gt;</span><br><span class="line">    &lt;!-- 通过组件的layer属性切换是否显示 --&gt;</span><br><span class="line">    &lt;section v-<span class="keyword">if</span>=<span class="string">&quot;layer&quot;</span>&gt;</span><br><span class="line">      &lt;b-field label=<span class="string">&quot;opacity&quot;</span>&gt;</span><br><span class="line">        &lt;!-- 该组件在模板中只有一个滑动条 --&gt;</span><br><span class="line">        &lt;b-slider</span><br><span class="line">          v-model=<span class="string">&quot;config.opacity&quot;</span></span><br><span class="line">          @input=<span class="string">&quot;updateOpacity&quot;</span></span><br><span class="line">          :min=<span class="string">&quot;0&quot;</span></span><br><span class="line">          :max=<span class="string">&quot;1.0&quot;</span></span><br><span class="line">          :step=<span class="string">&quot;0.1&quot;</span></span><br><span class="line">        &gt;&lt;/b-slider&gt;</span><br><span class="line">      &lt;/b-field&gt;</span><br><span class="line">      &lt;!-- <span class="xml"><span class="tag">&lt;<span class="name">b-field</span> <span class="attr">v-if</span>=<span class="string">&quot;config.climit&quot;</span> <span class="attr">label</span>=<span class="string">&quot;contrast limit&quot;</span>&gt;</span></span></span><br><span class="line">        &lt;b-slider v-model=&quot;config.climit&quot; :min=&quot;1&quot; :max=&quot;255&quot; :step=&quot;0.5&quot; ticks&gt;</span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">b-slider</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">b-field</span>&gt;</span></span> --&gt;</span><br><span class="line">    &lt;/section&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">// 从openlayers中导入必要的包</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="built_in">Map</span> &#125; <span class="keyword">from</span> <span class="string">&quot;ol&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Static <span class="keyword">from</span> <span class="string">&quot;ol/source/ImageStatic&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ImageLayer <span class="keyword">from</span> <span class="string">&quot;ol/layer/Image&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Projection <span class="keyword">from</span> <span class="string">&quot;ol/proj/Projection&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将File对象转为base64编码的对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">file2base64</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">    reader.onload = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(url2base64(event.target.result));</span><br><span class="line">    &#125;;</span><br><span class="line">    reader.onerror = <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;;</span><br><span class="line">    reader.readAsDataURL(file);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将图片url转为base64编码的对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">url2base64</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">    img.crossOrigin = <span class="string">&quot;anonymous&quot;</span>;</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line">      <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">      canvas.width = img.width;</span><br><span class="line">      canvas.height = img.height;</span><br><span class="line">      ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      resolve(&#123;</span><br><span class="line">        url: canvas.toDataURL(<span class="string">&quot;image/png&quot;</span>),</span><br><span class="line">        w: img.width,</span><br><span class="line">        h: img.height</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    img.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">      reject(<span class="string">&quot;image load error:&quot;</span> + <span class="built_in">String</span>(e));</span><br><span class="line">    &#125;;</span><br><span class="line">    img.src = url;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将无符号的整型数组转化为base64编码的对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">array2rgba</span>(<span class="params">imageArr, ch, w, h</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line">  canvas.width = w;</span><br><span class="line">  canvas.height = h;</span><br><span class="line">  <span class="keyword">const</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> canvas_img = ctx.getImageData(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line">  <span class="keyword">const</span> canvas_img_data = canvas_img.data;</span><br><span class="line">  <span class="keyword">const</span> count = w * h;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> raw = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(imageArr.buffer);</span><br><span class="line">  <span class="keyword">if</span> (imageArr <span class="keyword">instanceof</span> <span class="built_in">Uint8Array</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ch === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span>] = raw[i];</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span> + <span class="number">1</span>] = raw[i];</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span> + <span class="number">2</span>] = raw[i];</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span> + <span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span>] = raw[i * <span class="number">2</span>];</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span> + <span class="number">1</span>] = raw[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span> + <span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span> + <span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span>] = raw[i * <span class="number">3</span>];</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span> + <span class="number">1</span>] = raw[i * <span class="number">3</span> + <span class="number">1</span>];</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span> + <span class="number">2</span>] = raw[i * <span class="number">3</span> + <span class="number">2</span>];</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span> + <span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span>] = raw[i * <span class="number">3</span>];</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span> + <span class="number">1</span>] = raw[i * <span class="number">3</span> + <span class="number">1</span>];</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span> + <span class="number">2</span>] = raw[i * <span class="number">3</span> + <span class="number">2</span>];</span><br><span class="line">        canvas_img_data[i * <span class="number">4</span> + <span class="number">3</span>] = raw[i * <span class="number">4</span> + <span class="number">3</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;unsupported array type&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.putImageData(canvas_img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    url: canvas.toDataURL(<span class="string">&quot;image/png&quot;</span>),</span><br><span class="line">    w: w,</span><br><span class="line">    h: h</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&quot;image-layer&quot;</span>,</span><br><span class="line">  type: <span class="string">&quot;2d-image&quot;</span>,</span><br><span class="line">  show: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 从父组件中接收参数</span></span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// map也是从父组件中传过来的存放于vuex中的map属性</span></span><br><span class="line">    map: &#123;</span><br><span class="line">      type: <span class="built_in">Map</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    selected: &#123;</span><br><span class="line">      type: <span class="built_in">Boolean</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    visible: &#123;</span><br><span class="line">      type: <span class="built_in">Boolean</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 这里的config会修改父组件中的config</span></span><br><span class="line">    config: &#123;</span><br><span class="line">      type: <span class="built_in">Object</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      layer: <span class="literal">null</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    visible: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.layer.setVisible(newVal);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.config.climit = [<span class="number">4</span>, <span class="number">50</span>];</span><br><span class="line">    <span class="built_in">this</span>.config.opacity = <span class="number">1.0</span>;</span><br><span class="line">    <span class="built_in">this</span>.config.init = <span class="built_in">this</span>.init;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">beforeDestroy</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.layer) &#123;</span><br><span class="line">      <span class="built_in">this</span>.map.removeLayer(<span class="built_in">this</span>.layer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// init初始化函数非常重要，它在vuex状态管理中被调用</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.layer = <span class="keyword">await</span> <span class="built_in">this</span>.setupLayer();</span><br><span class="line">      <span class="built_in">this</span>.map.addLayer(<span class="built_in">this</span>.layer);</span><br><span class="line">      <span class="built_in">this</span>.$forceUpdate();</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.layer;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">updateOpacity</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.layer) <span class="built_in">this</span>.layer.setOpacity(<span class="built_in">this</span>.config.opacity);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">selectLayer</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里就是对this.layer进行加工的详细过程了</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">setupLayer</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> imgObj;</span><br><span class="line">      <span class="keyword">const</span> data = <span class="built_in">this</span>.config.data;</span><br><span class="line">      <span class="comment">// 根据data的类型，进行不同的转换</span></span><br><span class="line">      <span class="comment">// 如果data是个字符串，比如是个图片路径</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> data === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用url2base64函数将其转化成base64编码格式</span></span><br><span class="line">        imgObj = <span class="keyword">await</span> url2base64(<span class="built_in">this</span>.config.data);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data <span class="keyword">instanceof</span> File) &#123; <span class="comment">// 如果是File对象实例，则调用file2base64</span></span><br><span class="line">        imgObj = <span class="keyword">await</span> file2base64(<span class="built_in">this</span>.config.data);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="comment">// 如果不是上面两种格式，就应该是无符号的整型数组及一些尺寸属性</span></span><br><span class="line">        data &amp;&amp;</span><br><span class="line">        data.imageType &amp;&amp;</span><br><span class="line">        data.size &amp;&amp;</span><br><span class="line">        data.imageType.componentType &amp;&amp;</span><br><span class="line">        data.data</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.imageType.componentType !== <span class="string">&quot;uint8_t&quot;</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="string">`Unsupported data type: <span class="subst">$&#123;data.imageType.componentType&#125;</span>`</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data.imageType.components &lt; <span class="number">1</span> &amp;&amp; data.imageType.components &gt; <span class="number">4</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="string">`Unsupported components number: <span class="subst">$&#123;data.imageType.components&#125;</span>`</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data.imageType.dimension !== <span class="number">2</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="string">`Dimension must be 2`</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data.imageType.pixelType !== <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="string">`Pixel type must be 1`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        imgObj = array2rgba(</span><br><span class="line">          data.data,</span><br><span class="line">          data.imageType.components,</span><br><span class="line">          data.size[<span class="number">0</span>],</span><br><span class="line">          data.size[<span class="number">1</span>]</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        imgObj = &#123;</span><br><span class="line">          url: <span class="string">&quot;https://images.proteinatlas.org/19661/221_G2_1_red_green.jpg&quot;</span>,</span><br><span class="line">          w: <span class="number">2048</span>,</span><br><span class="line">          h: <span class="number">2048</span></span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> extent = [<span class="number">0</span>, <span class="number">0</span>, imgObj.w, imgObj.h];</span><br><span class="line">      <span class="comment">// Map总是需要一个projection，这里只是想把图像坐标系映射到地图坐标系中，所以直接使用以像素为单位的图像内容来创建projection</span></span><br><span class="line">      <span class="keyword">const</span> projection = <span class="keyword">new</span> Projection(&#123;</span><br><span class="line">        code: <span class="string">&quot;image&quot;</span>,</span><br><span class="line">        units: <span class="string">&quot;pixels&quot;</span>,</span><br><span class="line">        extent: extent</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 创建一个static对象来作为下面ImageLayer的source</span></span><br><span class="line">      <span class="keyword">const</span> image_source = <span class="keyword">new</span> Static(&#123;</span><br><span class="line">        url: imgObj.url,</span><br><span class="line">        projection: projection,</span><br><span class="line">        imageExtent: extent</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 新建一个ImageLayer图层</span></span><br><span class="line">      <span class="keyword">const</span> image_layer = <span class="keyword">new</span> ImageLayer(&#123;</span><br><span class="line">        source: image_source</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 向父组件发射消息，使其能够监听到自定义事件，目前看主要是影响了显示中心位置</span></span><br><span class="line">      <span class="built_in">this</span>.$emit(<span class="string">&quot;update-extent&quot;</span>, &#123; <span class="attr">id</span>: <span class="built_in">this</span>.config.id, <span class="attr">extent</span>: extent &#125;);</span><br><span class="line">      <span class="keyword">return</span> image_layer;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Add <span class="string">&quot;scoped&quot;</span> attribute to limit CSS to <span class="built_in">this</span> component only --&gt;</span><br><span class="line">&lt;style&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="作为Imjoy插件时的API"><a href="#作为Imjoy插件时的API" class="headerlink" title="作为Imjoy插件时的API"></a>作为Imjoy插件时的API</h2><p>Kaibu作为ImJoy的插件使用时，有许多api可以调用，如<br>（1）<code>view_image</code>可以增加一个2D图像、itk/vtk 3D模型等，<br>（2）<code>add_shapes</code>可以增加一个矢量图层、<br>（3）<code>add_widgets</code>可以增加按钮、文件树等控件。<br>具体的api文档见<a href="https://kaibu.org/docs/#/api?id=kaibu-api">这里</a>，而相应源代码见<a href="https://github.com/imjoy-team/kaibu/blob/master/src/imjoyAPI.js">这里</a>。<br>其实细细研究源码可知，这些api是对原来的imageviewer这个组件中的<code>AddLayer</code>、<code>addWidget</code>等方法的二次封装。<br>所以如果不作为ImJoy插件使用时，可以直接看imageviewer这个组件中的这些方法。</p><h2 id="原生API"><a href="#原生API" class="headerlink" title="原生API"></a>原生API</h2><p>我们就以上面添加的矢量图层这个例子看看kaibu的原生API。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将通过AddLayer添加的矢量图层接收到一个变量中</span></span><br><span class="line"><span class="built_in">this</span>.shape_layer = <span class="keyword">await</span> <span class="built_in">this</span>.addLayer(&#123;</span><br><span class="line">  type: <span class="string">&quot;vector&quot;</span>,</span><br><span class="line">  name: <span class="string">&quot;shape vectors&quot;</span>,</span><br><span class="line">  data:</span><br><span class="line">    <span class="string">&quot;https://gist.githubusercontent.com/oeway/7c62128939a7f9b1701e2bbd72b809dc/raw/example_shape_vectors.json&quot;</span>,</span><br><span class="line">  predefined_tags: [<span class="string">&quot;nuclei&quot;</span>, <span class="string">&quot;cell&quot;</span>],</span><br><span class="line">  only_predefined_tags: <span class="literal">true</span>,</span><br><span class="line">  single_tag_mode: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>此时<code>this.shape_layer</code>上会有<code>getLayerAPI</code>这个方法，里面有若干适用于矢量层的API，比如<code>add_feature</code>、<code>add_features</code>、<code>get_features</code>等。<br>具体api可以见<a href="https://github.com/imjoy-team/kaibu/blob/master/src/components/layers/VectorLayer.vue">这里</a>，搜<code>getLayerAPI</code>函数。<br>除了上述API，该<code>this.shape_layer</code>也会天然地拥有openlayers库中对于它所赋予的函数，详见<a href="https://openlayers.org/en/latest/apidoc/module-ol_layer_Vector-VectorLayer.html">这里</a>。</p>]]></content>
    
    
    <summary type="html">简介
ImJoy有一个很有用的插件或独立应用，叫做Kaibu，它可以展示并标注普通的位图、矢量图及vtk、stl等3D格式的数据。
比如如下展示：

其就是位图（png格式）、矢量图（json格式）、3D模型（stl格式）的一个叠加。

Kaibu主要用了两个JS库，一个是OpenLayers，一个是ITK-VTK，前者用于展示矢量图形、普通位图等数据，且对地图的展示异常强大，后者用于展示在医疗及科学计算中常用的3D图像、网格、点集等。

这一篇主要分析一下Kaibu的运行机理。

从script标签开始，看其运行过程。

导入组件
1
2


import * as layerCompone</summary>
    
    
    
    <category term="computer vision" scheme="http://qixinbo.github.io/categories/computer-vision/"/>
    
    
    <category term="ImJoy" scheme="http://qixinbo.github.io/tags/ImJoy/"/>
    
  </entry>
  
  <entry>
    <title>FastAPI用户指南</title>
    <link href="http://qixinbo.github.io/2022/05/08/fastapi/"/>
    <id>http://qixinbo.github.io/2022/05/08/fastapi/</id>
    <published>2022-05-07T16:00:00.000Z</published>
    <updated>2022-05-13T03:58:58.584Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献：<br><a href="https://fastapi.tiangolo.com/">FastAPI官方文档</a><br><a href="https://fastapi.tiangolo.com/zh/">中文翻译</a><br>（注意，当前2022年5月8日的中文翻译有一些错误）</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>FastAPI 是一个用于构建 API 的现代、快速（高性能）的 web 框架，使用 Python 3.6+ 并基于标准的 Python 类型提示。<br>FastAPI 站在以下巨人的肩膀之上：</p><ul><li><a href="https://www.starlette.io/">Starlette</a>负责 web 部分。</li><li><a href="https://pydantic-docs.helpmanual.io/">Pydantic</a>负责数据部分。</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install fastapi</span><br></pre></td></tr></table></figure><p>还需要一个 ASGI 服务器，生产环境可以使用<a href="https://www.uvicorn.org/">Uvicorn</a>或者<a href="https://gitlab.com/pgjones/hypercorn">Hypercorn</a>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install uvicorn[standard]</span><br></pre></td></tr></table></figure></p><h1 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h1><h2 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h2><p>创建一个<code>main.py</code>文件并写入以下内容:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_root</span>():</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;Hello&quot;</span>: <span class="string">&quot;World&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_item</span>(<span class="params">item_id: <span class="built_in">int</span>, q: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;q&quot;</span>: q&#125;</span><br></pre></td></tr></table></figure></p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uvicorn main:app --reload</span><br></pre></td></tr></table></figure><p>uvicorn main:app 命令含义如下:</p><ul><li><code>main</code>：main.py 文件（一个 Python “模块”）。</li><li><code>app</code>：在 main.py 文件中通过 app = FastAPI() 创建的对象。</li><li><code>--reload</code>：让服务器在更新代码后重新启动。仅在开发时使用该选项。</li></ul><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p>使用浏览器访问<a href="http://127.0.0.1:8000/items/5?q=somequery">http://127.0.0.1:8000/items/5?q=somequery</a>。<br>将会看到如下 JSON 响应：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;item_id&quot;</span>:<span class="number">5</span>,<span class="string">&quot;q&quot;</span>:<span class="string">&quot;somequery&quot;</span>&#125;</span><br></pre></td></tr></table></figure><br>这里已经创建了一个具有以下功能的 API：</p><ul><li>通过路径 <code>/</code> 和 <code>/items/&#123;item_id&#125;</code> 接受 HTTP 请求。</li><li>以上路径 都接受 GET 操作（也被称为 HTTP 方法）。</li><li><code>/items/&#123;item_id&#125;</code> 路径 有一个路径参数 <code>item_id</code> 并且应该为<code>int</code>类型。</li><li><code>/items/&#123;item_id&#125;</code> 路径 有一个可选的<code>str</code>类型的查询参数 <code>q</code>。</li></ul><h2 id="交互式API文档"><a href="#交互式API文档" class="headerlink" title="交互式API文档"></a>交互式API文档</h2><p>现在访问<a href="http://127.0.0.1:8000/docs">http://127.0.0.1:8000/docs</a>。<br>会看到自动生成的交互式 API 文档（由 <a href="https://github.com/swagger-api/swagger-ui">Swagger UI</a>生成）。</p><h2 id="可选的API文档"><a href="#可选的API文档" class="headerlink" title="可选的API文档"></a>可选的API文档</h2><p>访问<a href="http://127.0.0.1:8000/redoc">http://127.0.0.1:8000/redoc</a>。<br>会看到另一个自动生成的文档（由<a href="http://127.0.0.1:8000/redoc">ReDoc</a>生成）。<br>Redoc也很有用，尤其有时它检测到的请求体格式要比Swagger的准确。</p><h1 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h1><p>现在修改<code>main.py</code>文件来从<code>PUT</code>请求中接收请求体。<br>以及借助<code>Pydantic</code>来使用标准的 Python 类型声明请求体。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    is_offer: <span class="type">Optional</span>[<span class="built_in">bool</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_root</span>():</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;Hello&quot;</span>: <span class="string">&quot;World&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_item</span>(<span class="params">item_id: <span class="built_in">int</span>, q: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;q&quot;</span>: q&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.put(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params">item_id: <span class="built_in">int</span>, item: Item</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;item_name&quot;</span>: item.name, <span class="string">&quot;item_id&quot;</span>: item_id&#125;</span><br></pre></td></tr></table></figure><br>请求体是一个JSON格式的数据体。</p><p>对于上面的代码，FastAPI 将会：</p><ul><li>校验<code>GET</code>和<code>PUT</code>请求的路径中是否含有<code>item_id</code></li><li>校验<code>GET</code>和<code>PUT</code>请求中的<code>item_id</code>是否为<code>int</code>类型：如果不是，客户端将会收到清晰有用的错误信息。</li><li>检查<code>GET</code>请求中是否有命名为<code>q</code>的可选查询参数：因为<code>q</code>被声明为<code>= None</code>，所以它是可选的；如果没有<code>None</code>它将会是必需的 (如<code>PUT</code>例子中的请求体)。</li><li>对于访问<code>/items/&#123;item_id&#125;</code>的<code>PUT</code>请求，将请求体读取为 JSON 并：检查是否有必需属性<code>name</code>并且值为<code>str</code>类型 、检查是否有必需属性<code>price</code>并且值为 <code>float</code>类型、检查是否有可选属性<code>is_offer</code>， 如果有的话值应该为<code>bool</code>类型；以上过程对于多层嵌套的 JSON 对象同样也会执行。</li><li>自动对 JSON 进行转换或转换成 JSON。</li><li>通过 OpenAPI 文档来记录所有内容，可被用于：交互式文档系统和许多编程语言的客户端代码自动生成系统</li><li>直接提供 2 种交互式文档 web 界面。</li></ul><h1 id="Python类型提示"><a href="#Python类型提示" class="headerlink" title="Python类型提示"></a>Python类型提示</h1><p>Python 3.6+ 版本加入了对”类型提示”的支持。<br>这些”类型提示”是一种新的语法（在 Python 3.6 版本加入）用来声明一个变量的类型。<br>类型提示是如下这样的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first_name:<span class="built_in">str</span>,last_name:<span class="built_in">str</span></span><br></pre></td></tr></table></figure><br>这和声明默认值是不同的，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first_name=<span class="string">&quot;john&quot;</span>,last_name=<span class="string">&quot;doe&quot;</span></span><br></pre></td></tr></table></figure><br>我们用的是冒号（:），不是等号（=）。<br>而且添加类型提示一般不会改变原来的运行结果。</p><h2 id="简单类型"><a href="#简单类型" class="headerlink" title="简单类型"></a>简单类型</h2><p>不只是 <code>str</code>，你能够声明所有的标准 Python 类型。<br>比如以下类型：<code>int</code>、<code>float</code>、<code>bool</code>、<code>bytes</code>。</p><h2 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h2><p>有些容器数据结构可以包含其他的值，比如 <code>dict</code>、<code>list</code>、<code>set</code> 和 <code>tuple</code>。它们内部的值也会拥有自己的类型。<br>你可以使用 Python 的 <code>typing</code> 标准库来声明这些类型以及子类型，它专门用来支持这些类型提示。<br>（注意，<code>typing</code>支持3.6版本以上的所有python版本，如果是3.9以上的版本，甚至不需要<code>typing</code>即可实现这些容器结构的类型声明）</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>例如，让我们来定义一个由 <code>str</code> 组成的 <code>list</code> 变量。<br>从 <code>typing</code> 模块导入 <code>List</code>（注意是大写的 <code>L</code>）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_items</span>(<span class="params">items: <span class="type">List</span>[<span class="built_in">str</span>]</span>):</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure><br>同样以冒号（:）来声明这个变量。输入 <code>List</code> 作为类型。<br>由于列表是带有”子类型”的类型，所以把子类型<code>str</code>放在方括号中。这表示：”变量 <code>items</code> 是一个 <code>list</code>，并且这个列表里的每一个元素都是<code>str</code>“。</p><h3 id="元组和集合"><a href="#元组和集合" class="headerlink" title="元组和集合"></a>元组和集合</h3><p>声明<code>tuple</code> 和<code>set</code>的方法也是一样的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Set</span>, <span class="type">Tuple</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_items</span>(<span class="params">items_t: <span class="type">Tuple</span>[<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">str</span>], items_s: <span class="type">Set</span>[<span class="built_in">bytes</span>]</span>):</span></span><br><span class="line">    <span class="keyword">return</span> items_t, items_s</span><br></pre></td></tr></table></figure><br>这表示：<br>（1）变量<code>items_t</code> 是一个<code>tuple</code>，其有三个元素，依次是<code>int</code>类型、<code>init</code>类型和<code>str</code>类型。<br>（2）变量<code>items_s</code>是一个<code>set</code>，其中的每个元素都是<code>bytes</code>类型。</p><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>定义 <code>dict</code> 时，需要传入两个子类型，用逗号进行分隔。<br>第一个子类型声明 <code>dict</code> 的所有键，第二个子类型声明 <code>dict</code> 的所有值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_items</span>(<span class="params">prices: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">float</span>]</span>):</span></span><br><span class="line">    <span class="keyword">for</span> item_name, item_price <span class="keyword">in</span> prices.items():</span><br><span class="line">        <span class="built_in">print</span>(item_name)</span><br><span class="line">        <span class="built_in">print</span>(item_price)</span><br></pre></td></tr></table></figure><br>这表示，变量 prices 是一个 dict：这个 dict 的所有键为 <code>str</code> 类型（可以看作是字典内每个元素的名称），这个 dict 的所有值为 <code>float</code> 类型（可以看作是字典内每个元素的价格）。</p><h2 id="类作为类型"><a href="#类作为类型" class="headerlink" title="类作为类型"></a>类作为类型</h2><p>也可以将类声明为变量的类型。<br>假设你有一个名为 <code>Person</code> 的类，拥有 <code>name</code>属性，就可以如下这样将类声明为类型：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name: <span class="built_in">str</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_person_name</span>(<span class="params">one_person: Person</span>):</span></span><br><span class="line">    <span class="keyword">return</span> one_person.name</span><br></pre></td></tr></table></figure></p><h2 id="Pydantic模型"><a href="#Pydantic模型" class="headerlink" title="Pydantic模型"></a>Pydantic模型</h2><p>Pydantic 是一个用来用来执行数据校验的 Python 库。<br>你可以将数据的”结构”声明为带属性的类，然后每个属性都拥有类型。<br>接着可以用一些值来创建这个类的实例，这些值会被校验，并被转换为适当的类型（在需要的情况下），返回一个包含所有数据的对象。<br>一个例子如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入pydantic的BaseModel</span></span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承BaseModel，形成一个带属性的类，每个属性都可以声明类型，且有默认值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span></span><br><span class="line">    name = <span class="string">&quot;John Doe&quot;</span></span><br><span class="line">    signup_ts: <span class="type">Optional</span>[datetime] = <span class="literal">None</span></span><br><span class="line">    friends: <span class="type">List</span>[<span class="built_in">int</span>] = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">external_data = &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="string">&quot;123&quot;</span>,</span><br><span class="line">    <span class="string">&quot;signup_ts&quot;</span>: <span class="string">&quot;2017-06-01 12:22&quot;</span>,</span><br><span class="line">    <span class="string">&quot;friends&quot;</span>: [<span class="number">1</span>, <span class="string">&quot;2&quot;</span>, <span class="string">b&quot;3&quot;</span>],</span><br><span class="line">&#125;</span><br><span class="line">user = User(**external_data)</span><br><span class="line"><span class="built_in">print</span>(user)</span><br><span class="line"><span class="comment"># &gt; User id=123 name=&#x27;John Doe&#x27; signup_ts=datetime.datetime(2017, 6, 1, 12, 22) friends=[1, 2, 3]</span></span><br><span class="line"><span class="built_in">print</span>(user.<span class="built_in">id</span>)</span><br><span class="line"><span class="comment"># &gt; 123</span></span><br></pre></td></tr></table></figure></p><h2 id="FastAPI-中的类型提示"><a href="#FastAPI-中的类型提示" class="headerlink" title="FastAPI 中的类型提示"></a>FastAPI 中的类型提示</h2><p>FastAPI 利用这些类型提示来做下面几件事。<br>使用 FastAPI 时用类型提示声明参数可以获得：<br>（1）编辑器支持，<br>（2）类型检查。<br>并且 FastAPI 还会用这些类型声明来：<br>（1）定义参数要求：声明对请求路径参数、查询参数、请求头、请求体、依赖等的要求。<br>（2）转换数据：将来自请求的数据转换为需要的类型。<br>（3）校验数据： 对于每一个请求：当数据校验失败时自动生成错误信息返回给客户端。<br>（4）使用 OpenAPI 记录 API，然后用于自动生成交互式文档的用户界面。</p><h1 id="并发和异步-等待"><a href="#并发和异步-等待" class="headerlink" title="并发和异步/等待"></a>并发和异步/等待</h1><p>如果使用的第三方库说了使用<code>await</code>来调用，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">results = <span class="keyword">await</span> some_library()</span><br></pre></td></tr></table></figure><br>那么就用<code>async def</code>声明路径操作函数，如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_results</span>():</span></span><br><span class="line">    results = <span class="keyword">await</span> some_library()</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><br>如果正在使用一个第三方库来与某些东西（数据库、API、文件系统等）进行通信，并且它不支持使用<code>await</code>（目前大多数数据库都是这种情况），那么就只需<code>def</code>声明路径操作，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">results</span>():</span></span><br><span class="line">    results = some_library()</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><br>如果你的应用程序（以某种方式）不必与其他任何东西通信并等待它响应，请使用<code>async def</code>。<br>如果你是啥都不知道，就直接使用普通<code>def</code>。</p><p>注意：可以根据需要混合使用<code>def</code>和<code>async def</code>。FastAPI 会对它们做正确的事情。<br>无论如何，在上述任何情况下，FastAPI 仍将以异步方式工作并且非常快。<br>但是按照上面的步骤，它将能够进行一些性能优化。</p><h1 id="用户指南"><a href="#用户指南" class="headerlink" title="用户指南"></a>用户指南</h1><h2 id="OpenAPI"><a href="#OpenAPI" class="headerlink" title="OpenAPI"></a>OpenAPI</h2><p>FastAPI 使用OpenAPI标准将所有 API 转换成模式schema。</p><h3 id="模式Schema"><a href="#模式Schema" class="headerlink" title="模式Schema"></a>模式Schema</h3><p>模式是对事物的一种定义或描述。它并非具体的实现代码，而只是抽象的描述。</p><h3 id="API模式"><a href="#API模式" class="headerlink" title="API模式"></a>API模式</h3><p>此时所指的API模式就是API的规范，OpenAPI 就是一种规定如何定义 API 模式的规范。<br> OpenAPI定义的模式包括API 路径，以及它们可能使用的参数等等。</p><h3 id="数据模式"><a href="#数据模式" class="headerlink" title="数据模式"></a>数据模式</h3><p>模式这个术语也可能指的是某些数据比如 JSON 的结构。<br>在这种情况下，它可以表示 JSON 的属性及其具有的数据类型，等等。</p><h3 id="OpenAPI-和-JSON-Schema"><a href="#OpenAPI-和-JSON-Schema" class="headerlink" title="OpenAPI 和 JSON Schema"></a>OpenAPI 和 JSON Schema</h3><p>OpenAPI定义了 API 模式。该模式中包含了你API 发送和接收的数据的定义（或称为数据模式），这些定义通过 JSON Schema 这一JSON 数据模式标准所生成。</p><h3 id="查看-openapi-json"><a href="#查看-openapi-json" class="headerlink" title="查看 openapi.json"></a>查看 openapi.json</h3><p>如果你对原始的 OpenAPI 模式长什么样子感到好奇，FastAPI自动生成了它，它就是一个json文件，可以通过<a href="http://127.0.0.1:8000/openapi.json">http://127.0.0.1:8000/openapi.json</a>访问。</p><h3 id="OpenAPI的用途"><a href="#OpenAPI的用途" class="headerlink" title="OpenAPI的用途"></a>OpenAPI的用途</h3><p>驱动 FastAPI 内置的 2 个交互式文档系统的正是 OpenAPI 模式。<br>并且还有数十种替代方案，它们全部都基于 OpenAPI。你可以轻松地将这些替代方案中的任何一种添加到使用 FastAPI 构建的应用程序中。<br>你还可以使用它自动生成与你的 API 进行通信的客户端代码。例如 web 前端，移动端或物联网嵌入程序。</p><h2 id="路径参数"><a href="#路径参数" class="headerlink" title="路径参数"></a>路径参数</h2><p>这里的路径指的是 URL 中从第一个 <code>/</code> 起的后半部分。<br>路径也通常被称为端点或路由。<br>开发 API 时，「路径」是用来分离「关注点」和「资源」的主要手段。<br>举例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_item</span>(<span class="params">item_id</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;item_id&quot;</span>: item_id&#125;</span><br></pre></td></tr></table></figure><br>路径参数 <code>item_id</code> 的值将作为参数 <code>item_id</code> 传递给你的函数。</p><h3 id="有类型的路径参数"><a href="#有类型的路径参数" class="headerlink" title="有类型的路径参数"></a>有类型的路径参数</h3><p>可以使用标准的 Python 类型标注为函数中的路径参数声明类型。<br>比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_item</span>(<span class="params">item_id: <span class="built_in">int</span></span>):</span> <span class="comment"># 声明item_id为int型</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;item_id&quot;</span>: item_id&#125;</span><br></pre></td></tr></table></figure></p><h3 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h3><p>如果你运行示例并打开浏览器访问<a href="http://127.0.0.1:8000/items/3">http://127.0.0.1:8000/items/3</a>，那么将得到如下返回：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;item_id&quot;</span>:<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><br>注意函数接收（并返回）的值为 3，是一个 Python <code>int</code> 值，而不是字符串 <code>&quot;3&quot;</code>。<br>所以，FastAPI 通过上面的类型声明提供了对请求的自动”解析”。</p><h3 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h3><p>但如果你通过浏览器访问<a href="http://127.0.0.1:8000/items/foo">http://127.0.0.1:8000/items/foo</a>，你会看到一个清晰可读的 HTTP 错误：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;detail&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;loc&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;path&quot;</span>,</span><br><span class="line">                <span class="string">&quot;item_id&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;value is not a valid integer&quot;</span>,</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;type_error.integer&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>所以，通过同样的 Python 类型声明，FastAPI 提供了数据校验功能。<br>注意上面的错误同样清楚地指出了校验未通过的具体原因。<br>在开发和调试与你的 API 进行交互的代码时，这非常有用。</p><h3 id="路径的顺序"><a href="#路径的顺序" class="headerlink" title="路径的顺序"></a>路径的顺序</h3><p>在创建路径操作时，会发现有些情况下路径是固定的。<br>比如 <code>/users/me</code>，我们假设它用来获取关于当前用户的数据，然后，还可以使用路径 <code>/users/&#123;user_id&#125;</code> 来通过用户 ID 获取关于特定用户的数据。<br>由于路径操作是按顺序依次运行的，需要确保路径 <code>/users/me</code> 声明在路径 <code>/users/&#123;user_id&#125;</code>之前。否则，<code>/users/&#123;user_id&#125;</code> 的路径还将与 <code>/users/me</code> 相匹配，”认为”自己正在接收一个值为 <code>&quot;me&quot;</code> 的 <code>user_id</code> 参数。 </p><h3 id="预设值"><a href="#预设值" class="headerlink" title="预设值"></a>预设值</h3><p>如果有一个接收路径参数的路径操作，但希望预先设定可能的有效参数值，则可以使用标准的 Python Enum 类型。<br>比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入 Enum 并创建一个继承自 str 和 Enum 的子类。</span></span><br><span class="line"><span class="comment"># 通过从 str 继承，API 文档将能够知道这些值必须为 string 类型并且能够正确地展示出来。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelName</span>(<span class="params"><span class="built_in">str</span>, Enum</span>):</span></span><br><span class="line">    <span class="comment"># 然后创建具有固定值的类属性，这些固定值将是可用的有效值：</span></span><br><span class="line">    alexnet = <span class="string">&quot;alexnet&quot;</span></span><br><span class="line">    resnet = <span class="string">&quot;resnet&quot;</span></span><br><span class="line">    lenet = <span class="string">&quot;lenet&quot;</span></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/models/&#123;model_name&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># 使用你定义的枚举类（ModelName）创建一个带有类型标注的路径参数：</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_model</span>(<span class="params">model_name: ModelName</span>):</span></span><br><span class="line">    <span class="comment"># 路径参数的值是一个枚举成员</span></span><br><span class="line">    <span class="comment"># 可以将它与你创建的枚举类 ModelName 中的枚举成员进行比较</span></span><br><span class="line">    <span class="keyword">if</span> model_name == ModelName.alexnet:</span><br><span class="line">        <span class="comment"># 可以返回枚举成员，即使嵌套在 JSON 结构中（例如一个 dict 中）。</span></span><br><span class="line">        <span class="comment"># 在返回给客户端之前，它们将被转换为对应的值：</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;model_name&quot;</span>: model_name, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Deep Learning FTW!&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可以使用 model_name.value 或通常来说 your_enum_member.value 来获取实际的值（在这个例子中它是一个字符串str）</span></span><br><span class="line">    <span class="comment"># 也可以通过 ModelName.lenet.value 来获取值 &quot;lenet&quot;。</span></span><br><span class="line">    <span class="keyword">if</span> model_name.value == <span class="string">&quot;lenet&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;model_name&quot;</span>: model_name, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;LeCNN all the images&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;model_name&quot;</span>: model_name, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;Have some residuals&quot;</span>&#125;</span><br></pre></td></tr></table></figure></p><h3 id="包含路径的路径参数"><a href="#包含路径的路径参数" class="headerlink" title="包含路径的路径参数"></a>包含路径的路径参数</h3><p>假设有一个路径操作，它的路径为 <code>/files/&#123;file_path&#125;</code>。<br>但是你需要 <code>file_path</code> 自身也包含路径，比如 <code>home/johndoe/myfile.txt</code>。<br>因此，该文件的URL将类似于这样：<code>/files/home/johndoe/myfile.txt</code>。</p><p>OpenAPI 不支持这样的声明路径参数以在其内部包含路径，因为这可能会导致难以测试和定义的情况出现。<br>不过，你仍然可以通过 Starlette 的一个内部工具在 FastAPI 中实现它。<br>而且文档依旧可以使用，但是不会添加任何文档，来说明该参数应包含路径。<br>可以使用直接来自 Starlette 的选项来声明一个包含路径的路径参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/files/&#123;file_path:path&#125;</span><br></pre></td></tr></table></figure><br>在这种情况下，参数的名称为 <code>file_path</code>，结尾部分的 <code>:path</code> 说明该参数应匹配任意的路径。<br>因此，可以这样使用它：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 你可能会需要参数包含 /home/johndoe/myfile.txt，以斜杠（/）开头。</span></span><br><span class="line"><span class="comment"># 在这种情况下，URL 将会是 /files//home/johndoe/myfile.txt，在files 和 home 之间有一个双斜杠（//）。</span></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/files/&#123;file_path:path&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_file</span>(<span class="params">file_path: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;file_path&quot;</span>: file_path&#125;</span><br></pre></td></tr></table></figure></p><h3 id="额外校验"><a href="#额外校验" class="headerlink" title="额外校验"></a>额外校验</h3><p>可以使用Path为路径参数声明一些元数据及进行数值校验。<br>（1）声明元数据<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 fastapi 导入 Path（有关Query的用法参见下节的查询参数的校验）</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Path, Query</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 声明路径参数 item_id的 title 元数据值</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 路径参数总是必需的，因为它必须是路径的一部分。所以，你应该在声明时使用 ... 将其标记为必需参数。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 然而，即使你使用 None 声明路径参数或设置一个其他默认值也不会有任何影响，它依然会是必需参数。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    item_id: <span class="built_in">int</span> = Path(<span class="params">..., title=<span class="string">&quot;The ID of the item to get&quot;</span></span>),</span></span></span><br><span class="line"><span class="function"><span class="params">    q: <span class="type">Optional</span>[<span class="built_in">str</span>] = Query(<span class="params"><span class="literal">None</span>, alias=<span class="string">&quot;item-query&quot;</span></span>),</span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id&#125;</span><br><span class="line">    <span class="keyword">if</span> q:</span><br><span class="line">        results.update(&#123;<span class="string">&quot;q&quot;</span>: q&#125;)</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><br>（2）按需对参数排序<br>（2.1）FastAPI通过参数的名称、类型和默认值声明（Query、Path 等）来检测参数，而不在乎参数的顺序。<br>比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Path</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    q: <span class="built_in">str</span>, item_id: <span class="built_in">int</span> = Path(<span class="params">..., title=<span class="string">&quot;The ID of the item to get&quot;</span></span>)</span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id&#125;</span><br><span class="line">    <span class="keyword">if</span> q:</span><br><span class="line">        results.update(&#123;<span class="string">&quot;q&quot;</span>: q&#125;)</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><br>（2.2）另外一种排序方式<br>如果声明查询参数<code>q</code>时既不想使用Query，也不想使用默认值，与此同时，使用 Path 声明路径参数 item_id，并使它们的顺序与上面不同，Python 对此有一些特殊的语法。即传递 <code>*</code>星号 作为函数的第一个参数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Path</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># Python 不会对该 * 做任何事情，但是它将知道之后的所有参数都应作为关键字参数（键值对），也被称为 kwargs，来调用。即使它们没有默认值。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    *, item_id: <span class="built_in">int</span> = Path(<span class="params">..., title=<span class="string">&quot;The ID of the item to get&quot;</span></span>), q: <span class="built_in">str</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id&#125;</span><br><span class="line">    <span class="keyword">if</span> q:</span><br><span class="line">        results.update(&#123;<span class="string">&quot;q&quot;</span>: q&#125;)</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><br>（3）数值校验<br>使用 Query 和 Path（以及你将在后面看到的其他类）可以声明字符串约束，但也可以声明数值约束。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Path, Query</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 添加 ge=1 后，item_id 将必须是一个大于（greater than）或等于（equal）1 的整数。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># gt：大于（greater than）</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># le：小于等于（less than or equal）</span></span></span></span><br><span class="line"><span class="function"><span class="params">    *, </span></span></span><br><span class="line"><span class="function"><span class="params">    item_id: <span class="built_in">int</span> = Path(<span class="params">..., title=<span class="string">&quot;The ID of the item to get&quot;</span>, ge=<span class="number">1</span>, le=<span class="number">1000</span></span>), </span></span></span><br><span class="line"><span class="function"><span class="params">    q: <span class="built_in">str</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 数值校验同样适用于 float 值。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    size: <span class="built_in">float</span> = Query(<span class="params">..., gt=<span class="number">0</span>, lt=<span class="number">10.5</span></span>)</span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id&#125;</span><br><span class="line">    <span class="keyword">if</span> q:</span><br><span class="line">        results.update(&#123;<span class="string">&quot;q&quot;</span>: q&#125;)</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure></p><h2 id="查询参数"><a href="#查询参数" class="headerlink" title="查询参数"></a>查询参数</h2><p>声明不属于路径参数的其他函数参数时，它们将被自动解释为”查询字符串”参数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line">fake_items_db = [&#123;<span class="string">&quot;item_name&quot;</span>: <span class="string">&quot;Foo&quot;</span>&#125;, &#123;<span class="string">&quot;item_name&quot;</span>: <span class="string">&quot;Bar&quot;</span>&#125;, &#123;<span class="string">&quot;item_name&quot;</span>: <span class="string">&quot;Baz&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_item</span>(<span class="params">skip: <span class="built_in">int</span> = <span class="number">0</span>, limit: <span class="built_in">int</span> = <span class="number">10</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> fake_items_db[skip : skip + limit]</span><br></pre></td></tr></table></figure><br>查询字符串是键值对的集合，这些键值对位于 URL 的 <code>?</code> 之后，并以 <code>&amp;</code> 符号分隔。<br>比如以下URL：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8000/items/?skip=0&amp;limit=10</span><br></pre></td></tr></table></figure><br>查询参数为：<br>（1）skip：对应的值为 0<br>（2）limit：对应的值为 10<br>由于它们是 URL 的一部分，因此它们的”原始值”是字符串。<br>但是，当你为它们声明了 Python 类型（在上面的示例中为 <code>int</code>）时，它们将转换为该类型并针对该类型进行校验。<br>应用于路径参数的所有相同过程也适用于查询参数，包括编辑器支持、数据”解析”、数据校验、自动生成文档。</p><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>由于查询参数不是路径的固定部分，因此它们可以是可选的，并且可以有默认值。<br>在上面的示例中，它们具有 <code>skip=0</code> 和 <code>limit=10</code> 的默认值。</p><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>通过同样的方式，你可以将它们的默认值设置为 None 来声明可选查询参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_item</span>(<span class="params">item_id: <span class="built_in">str</span>, q: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> q:</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;q&quot;</span>: q&#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;item_id&quot;</span>: item_id&#125;</span><br></pre></td></tr></table></figure></p><h3 id="多个路径和查询参数"><a href="#多个路径和查询参数" class="headerlink" title="多个路径和查询参数"></a>多个路径和查询参数</h3><p>可以同时声明多个路径参数和查询参数，FastAPI 能够识别它们。<br>而且不需要以任何特定的顺序来声明。<br>它们将通过名称被检测到：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/users/&#123;user_id&#125;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_user_item</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    user_id: <span class="built_in">int</span>, item_id: <span class="built_in">str</span>, q: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>, short: <span class="built_in">bool</span> = <span class="literal">False</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br><span class="line">    item = &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;owner_id&quot;</span>: user_id&#125;</span><br><span class="line">    <span class="keyword">if</span> q:</span><br><span class="line">        item.update(&#123;<span class="string">&quot;q&quot;</span>: q&#125;)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> short:</span><br><span class="line">        item.update(</span><br><span class="line">            &#123;<span class="string">&quot;description&quot;</span>: <span class="string">&quot;This is an amazing item that has a long description&quot;</span>&#125;</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure></p><h3 id="必需查询参数"><a href="#必需查询参数" class="headerlink" title="必需查询参数"></a>必需查询参数</h3><p>当你为非路径参数（目前而言，我们所知道的仅有查询参数）声明了默认值时，则该参数不是必需的。<br>如果你不想添加一个特定的值，而只是想使该参数成为可选的，则将默认值设置为 None。<br>但当你想让一个查询参数成为必需的，不声明任何默认值就可以：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_user_item</span>(<span class="params">item_id: <span class="built_in">str</span>, needy: <span class="built_in">str</span></span>):</span></span><br><span class="line">    item = &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;needy&quot;</span>: needy&#125;</span><br><span class="line">    <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure></p><h3 id="额外校验-1"><a href="#额外校验-1" class="headerlink" title="额外校验"></a>额外校验</h3><p>FastAPI 允许你为参数声明额外的信息和校验，方法是使用Query。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 fastapi 导入 Query</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Query</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># 添加约束条件：即使 q 是可选的，但只要提供了该参数，则该参数值不能超过50个字符的长度。</span></span><br><span class="line"><span class="comment"># 方法就是将 Query 用作查询参数的默认值，并将它的 max_length 参数设置为 50</span></span><br><span class="line"><span class="comment"># 必须用 Query(None) 替换默认值 None，Query 的第一个参数同样也是用于定义默认值。</span></span><br><span class="line"><span class="comment"># max_length 参数将会校验数据，在数据无效时展示清晰的错误信息，并在 OpenAPI 模式的路径操作中记录该参数。</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params">q: <span class="type">Optional</span>[<span class="built_in">str</span>] = Query(<span class="params"><span class="literal">None</span>, max_length=<span class="number">50</span></span>)</span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;items&quot;</span>: [&#123;<span class="string">&quot;item_id&quot;</span>: <span class="string">&quot;Foo&quot;</span>&#125;, &#123;<span class="string">&quot;item_id&quot;</span>: <span class="string">&quot;Bar&quot;</span>&#125;]&#125;</span><br><span class="line">    <span class="keyword">if</span> q:</span><br><span class="line">        results.update(&#123;<span class="string">&quot;q&quot;</span>: q&#125;)</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 min_length 参数等更多校验，以及正则表达式</span></span><br><span class="line"><span class="comment"># @app.get(&quot;/items/&quot;)</span></span><br><span class="line"><span class="comment"># async def read_items(</span></span><br><span class="line"><span class="comment">#     q: Optional[str] = Query(None, min_length=3, max_length=50, regex=&quot;^fixedquery$&quot;)</span></span><br><span class="line"><span class="comment"># ):</span></span><br><span class="line"><span class="comment">#     results = &#123;&quot;items&quot;: [&#123;&quot;item_id&quot;: &quot;Foo&quot;&#125;, &#123;&quot;item_id&quot;: &quot;Bar&quot;&#125;]&#125;</span></span><br><span class="line"><span class="comment">#     if q:</span></span><br><span class="line"><span class="comment">#         results.update(&#123;&quot;q&quot;: q&#125;)</span></span><br><span class="line"><span class="comment">#     return results</span></span><br></pre></td></tr></table></figure></p><p>以上参数<code>q</code>默认值是<code>None</code>，所以它是可选的。<br>一般情形下不声明默认值就表明<code>q</code>是必需参数，但此时正在用 Query 声明它，因此，需要点特殊写法。<br>当在使用 Query 且需要声明一个值是必需的时，可以将 <code>...</code> 用作第一个参数值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Query</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params">q: <span class="built_in">str</span> = Query(<span class="params">..., min_length=<span class="number">3</span></span>)</span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;items&quot;</span>: [&#123;<span class="string">&quot;item_id&quot;</span>: <span class="string">&quot;Foo&quot;</span>&#125;, &#123;<span class="string">&quot;item_id&quot;</span>: <span class="string">&quot;Bar&quot;</span>&#125;]&#125;</span><br><span class="line">    <span class="keyword">if</span> q:</span><br><span class="line">        results.update(&#123;<span class="string">&quot;q&quot;</span>: q&#125;)</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><br>这将使 FastAPI 知道此查询参数是必需的。</p><h3 id="查询参数列表或多个值"><a href="#查询参数列表或多个值" class="headerlink" title="查询参数列表或多个值"></a>查询参数列表或多个值</h3><p>要声明类型为 list 的查询参数，需要显式地使用 Query，否则该参数将被解释为请求体。<br>即当你使用 Query 显式地定义查询参数时，还可以声明它去接收一组值，或换句话来说，接收多个值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Query</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params">q: <span class="type">Optional</span>[<span class="type">List</span>[<span class="built_in">str</span>]] = Query(<span class="params"><span class="literal">None</span></span>)</span>):</span></span><br><span class="line">    query_items = &#123;<span class="string">&quot;q&quot;</span>: q&#125;</span><br><span class="line">    <span class="keyword">return</span> query_items</span><br></pre></td></tr></table></figure><br>然后输入网址为:<a href="http://127.0.0.1:8000/items/?q=foo&amp;q=bar">http://127.0.0.1:8000/items/?q=foo&amp;q=bar</a><br>那么会在路径操作函数的函数参数 <code>q</code> 中以一个 Python list 的形式接收到查询参数 <code>q</code> 的多个值（<code>foo</code> 和 <code>bar</code>）。<br>也可以对多个值配置默认值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Query</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params">q: <span class="type">List</span>[<span class="built_in">str</span>] = Query(<span class="params">[<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>]</span>)</span>):</span></span><br><span class="line">    query_items = &#123;<span class="string">&quot;q&quot;</span>: q&#125;</span><br><span class="line">    <span class="keyword">return</span> query_items</span><br></pre></td></tr></table></figure></p><h3 id="Query的更多用法"><a href="#Query的更多用法" class="headerlink" title="Query的更多用法"></a>Query的更多用法</h3><p>（1）声明更多元数据<br>你可以添加更多有关该参数的信息，比如增加title和description。<br>这些信息将包含在生成的 OpenAPI 模式中，并由文档用户界面和外部工具所使用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Query</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    q: <span class="type">Optional</span>[<span class="built_in">str</span>] = Query(<span class="params"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        <span class="literal">None</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        title=<span class="string">&quot;Query string&quot;</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        description=<span class="string">&quot;Query string for the items to search in the database that have a good match&quot;</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        min_length=<span class="number">3</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    </span>)</span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;items&quot;</span>: [&#123;<span class="string">&quot;item_id&quot;</span>: <span class="string">&quot;Foo&quot;</span>&#125;, &#123;<span class="string">&quot;item_id&quot;</span>: <span class="string">&quot;Bar&quot;</span>&#125;]&#125;</span><br><span class="line">    <span class="keyword">if</span> q:</span><br><span class="line">        results.update(&#123;<span class="string">&quot;q&quot;</span>: q&#125;)</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><br>（2）别名参数<br>比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Query</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params">q: <span class="type">Optional</span>[<span class="built_in">str</span>] = Query(<span class="params"><span class="literal">None</span>, alias=<span class="string">&quot;item-query&quot;</span></span>)</span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;items&quot;</span>: [&#123;<span class="string">&quot;item_id&quot;</span>: <span class="string">&quot;Foo&quot;</span>&#125;, &#123;<span class="string">&quot;item_id&quot;</span>: <span class="string">&quot;Bar&quot;</span>&#125;]&#125;</span><br><span class="line">    <span class="keyword">if</span> q:</span><br><span class="line">        results.update(&#123;<span class="string">&quot;q&quot;</span>: q&#125;)</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><br>（3）弃用参数<br>现在假设你不再喜欢此参数。<br>你不得不将其保留一段时间，因为有些客户端正在使用它，但你希望文档清楚地将其展示为已弃用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Query</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    q: <span class="type">Optional</span>[<span class="built_in">str</span>] = Query(<span class="params"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        <span class="literal">None</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        alias=<span class="string">&quot;item-query&quot;</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        title=<span class="string">&quot;Query string&quot;</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        description=<span class="string">&quot;Query string for the items to search in the database that have a good match&quot;</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        min_length=<span class="number">3</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        max_length=<span class="number">50</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        regex=<span class="string">&quot;^fixedquery$&quot;</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        <span class="comment"># 配置该参数deprecated=True</span></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        deprecated=<span class="literal">True</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    </span>)</span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;items&quot;</span>: [&#123;<span class="string">&quot;item_id&quot;</span>: <span class="string">&quot;Foo&quot;</span>&#125;, &#123;<span class="string">&quot;item_id&quot;</span>: <span class="string">&quot;Bar&quot;</span>&#125;]&#125;</span><br><span class="line">    <span class="keyword">if</span> q:</span><br><span class="line">        results.update(&#123;<span class="string">&quot;q&quot;</span>: q&#125;)</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure></p><h2 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h2><p>当需要将数据从客户端（例如浏览器）发送给 API 时，需要将其作为“请求体”发送。<br>请求体request body是客户端发送给 API 的数据。响应体response body是 API 发送给客户端的数据。<br>你的 API 几乎总是要发送响应体。但是客户端并不总是需要发送请求体。<br>FastAPI使用 Pydantic 模型来声明请求体。<br>注意：不能使用 GET 操作（HTTP 方法）发送请求体。要发送数据，必须使用下列方法之一：POST（较常见）、PUT、DELETE 或 PATCH。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="comment"># 从 pydantic 中导入 BaseModel</span></span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将你的数据模型声明为继承自 BaseModel 的类</span></span><br><span class="line"><span class="comment"># 使用标准的 Python 类型来声明所有属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    <span class="comment"># 和声明查询参数时一样，当一个模型属性具有默认值时，它不是必需的。否则它是一个必需属性。将默认值设为 None 可使其成为可选属性。</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用与声明路径和查询参数的相同方式声明请求体，即可将其添加到「路径操作」中</span></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_item</span>(<span class="params">item: Item</span>):</span></span><br><span class="line">    <span class="comment"># 在函数内部，你可以直接访问模型对象的所有属性</span></span><br><span class="line">    item_dict = item.<span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">if</span> item.tax:</span><br><span class="line">        price_with_tax = item.price + item.tax</span><br><span class="line">        item_dict.update(&#123;<span class="string">&quot;price_with_tax&quot;</span>: price_with_tax&#125;)</span><br><span class="line">    <span class="keyword">return</span> item_dict</span><br></pre></td></tr></table></figure><br>可以看出，仅仅使用了 Python 类型声明，FastAPI 将会：<br>（1）将请求体作为 JSON 读取。<br>（2）转换为相应的类型（在需要时）。<br>（3）校验数据：如果数据无效，将返回一条清晰易读的错误信息，指出不正确数据的确切位置和内容。<br>（4）将接收的数据赋值到参数 item 中：由于已经在函数中将它声明为 Item 类型，还将获得对于所有属性及其类型的一切编辑器支持（代码补全等）。<br>（5）为模型生成 JSON 模式 定义，这些模式将成为生成的 OpenAPI 模式的一部分，并且被自动化文档 UI 所使用。</p><h3 id="请求体-路径参数-查询参数"><a href="#请求体-路径参数-查询参数" class="headerlink" title="请求体 + 路径参数 + 查询参数"></a>请求体 + 路径参数 + 查询参数</h3><p>还可以同时声明请求体、路径参数和查询参数。<br>FastAPI 会识别它们中的每一个，并从正确的位置获取数据。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.put(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_item</span>(<span class="params">item_id: <span class="built_in">int</span>, item: Item, q: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span>):</span></span><br><span class="line">    result = &#123;<span class="string">&quot;item_id&quot;</span>: item_id, **item.<span class="built_in">dict</span>()&#125;</span><br><span class="line">    <span class="keyword">if</span> q:</span><br><span class="line">        result.update(&#123;<span class="string">&quot;q&quot;</span>: q&#125;)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><br>函数参数将依次按如下规则进行识别：<br>（1）如果在路径中也声明了该参数，它将被用作路径参数。<br>（2）如果参数属于单一类型（比如 int、float、str、bool 等）它将被解释为查询参数。<br>（3）如果参数的类型被声明为一个 Pydantic 模型，它将被解释为请求体。</p><h3 id="可选请求体"><a href="#可选请求体" class="headerlink" title="可选请求体"></a>可选请求体</h3><p>可以通过将默认值设置为 None 来将请求体参数声明为可选参数。</p><h3 id="多个请求体参数"><a href="#多个请求体参数" class="headerlink" title="多个请求体参数"></a>多个请求体参数</h3><p>可以添加多个请求体参数到路径操作函数中，即使一个请求只能有一个请求体。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    username: <span class="built_in">str</span></span><br><span class="line">    full_name: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.put(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># FastAPI 将注意到该函数中有多个请求体参数（两个 Pydantic 模型参数）。</span></span><br><span class="line"><span class="comment"># 它将使用参数名称作为请求体中的键（字段名称），并期望一个类似于以下内容的请求体</span></span><br><span class="line"><span class="comment"># &#123;</span></span><br><span class="line"><span class="comment">#     &quot;item&quot;: &#123;</span></span><br><span class="line"><span class="comment">#         &quot;name&quot;: &quot;Foo&quot;,</span></span><br><span class="line"><span class="comment">#         &quot;description&quot;: &quot;The pretender&quot;,</span></span><br><span class="line"><span class="comment">#         &quot;price&quot;: 42.0,</span></span><br><span class="line"><span class="comment">#         &quot;tax&quot;: 3.2</span></span><br><span class="line"><span class="comment">#     &#125;,</span></span><br><span class="line"><span class="comment">#     &quot;user&quot;: &#123;</span></span><br><span class="line"><span class="comment">#         &quot;username&quot;: &quot;dave&quot;,</span></span><br><span class="line"><span class="comment">#         &quot;full_name&quot;: &quot;Dave Grohl&quot;</span></span><br><span class="line"><span class="comment">#     &#125;</span></span><br><span class="line"><span class="comment"># &#125;</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params">item_id: <span class="built_in">int</span>, item: Item, user: User</span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;item&quot;</span>: item, <span class="string">&quot;user&quot;</span>: user&#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure></p><h3 id="请求体中的单一值"><a href="#请求体中的单一值" class="headerlink" title="请求体中的单一值"></a>请求体中的单一值</h3><p>与使用 Query 和 Path 为查询参数和路径参数定义额外数据的方式相同，FastAPI 提供了一个同等的 Body。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Body, FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    username: <span class="built_in">str</span></span><br><span class="line">    full_name: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.put(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 例如，为了扩展先前的模型，你可能决定除了 item 和 user 之外，还想在同一请求体中具有另一个键 importance。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 如果就按原样声明它，因为它是一个单一值，FastAPI 将假定它是一个查询参数。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 但是可以使用 Body 指示 FastAPI 将其作为请求体的另一个键进行处理。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># Body 同样具有与 Query、Path 以及其他后面将看到的类完全相同的额外校验和元数据参数。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    item_id: <span class="built_in">int</span>, item: Item, user: User, importance: <span class="built_in">int</span> = Body(<span class="params">...</span>)</span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;item&quot;</span>: item, <span class="string">&quot;user&quot;</span>: user, <span class="string">&quot;importance&quot;</span>: importance&#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure></p><h3 id="单个请求体参数嵌入一个键中"><a href="#单个请求体参数嵌入一个键中" class="headerlink" title="单个请求体参数嵌入一个键中"></a>单个请求体参数嵌入一个键中</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Body, FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.put(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    item_id: <span class="built_in">int</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 假设只有一个来自 Pydantic 模型 Item 的请求体参数 item。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 默认情况下，FastAPI 将直接期望这样的请求体。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 但是，如果希望它拥有 item 键，就像在声明额外的请求体参数时所做的那样</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 则可以使用一个特殊的 Body 参数 embed。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 在这种情况下，FastAPI 将期望像这样的请求体：</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">#     &quot;item&quot;: &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">#         &quot;name&quot;: &quot;Foo&quot;,</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">#         &quot;description&quot;: &quot;The pretender&quot;,</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">#         &quot;price&quot;: 42.0,</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">#         &quot;tax&quot;: 3.2</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">#     &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 而不是：</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">#     &quot;name&quot;: &quot;Foo&quot;,</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">#     &quot;description&quot;: &quot;The pretender&quot;,</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">#     &quot;price&quot;: 42.0,</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment">#     &quot;tax&quot;: 3.2</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params">    item: Item = Body(<span class="params">..., embed=<span class="literal">True</span></span>)</span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;item&quot;</span>: item&#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><h3 id="请求体中的字段校验"><a href="#请求体中的字段校验" class="headerlink" title="请求体中的字段校验"></a>请求体中的字段校验</h3><p>与使用 Query、Path 和 Body 在路径操作函数中声明额外的校验和元数据的方式相同，可以使用 Pydantic 的 Field 在 Pydantic 模型内部声明校验和元数据。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Body, FastAPI</span><br><span class="line"><span class="comment"># 注意，Field 是直接从 pydantic 导入的，而不是像其他的（Query，Path，Body 等）都从 fastapi 导入。</span></span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, Field</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    <span class="comment"># 对模型属性使用 Field</span></span><br><span class="line">    <span class="comment"># Field 的工作方式和 Query、Path 和 Body 相同，包括它们的参数等等也完全相同。</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = Field(</span><br><span class="line">        <span class="literal">None</span>, title=<span class="string">&quot;The description of the item&quot;</span>, max_length=<span class="number">300</span></span><br><span class="line">    )</span><br><span class="line">    price: <span class="built_in">float</span> = Field(..., gt=<span class="number">0</span>, description=<span class="string">&quot;The price must be greater than zero&quot;</span>)</span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.put(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params">item_id: <span class="built_in">int</span>, item: Item = Body(<span class="params">..., embed=<span class="literal">True</span></span>)</span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;item&quot;</span>: item&#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure></p><h3 id="嵌套模型"><a href="#嵌套模型" class="headerlink" title="嵌套模型"></a>嵌套模型</h3><p>（1）普通python类型作为嵌套<br>使用 FastAPI，你可以定义、校验、记录文档并使用任意深度嵌套的模型（归功于Pydantic）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 将一个属性定义为拥有子元素的类型，比如list</span></span><br><span class="line">    <span class="comment"># 这将使 tags 成为一个由元素组成的列表。不过它没有声明每个元素的类型。</span></span><br><span class="line">    <span class="comment"># tags: list = []</span></span><br><span class="line">    <span class="comment"># 但是 Python 有一种特定的方法来声明具有子类型的列表：</span></span><br><span class="line">    tags: <span class="type">List</span>[<span class="built_in">str</span>] = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.put(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params">item_id: <span class="built_in">int</span>, item: Item</span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;item&quot;</span>: item&#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><br>但是随后我们考虑了一下，意识到标签不应该重复，它们很大可能会是唯一的字符串。<br>Python 具有一种特殊的数据类型来保存一组唯一的元素，即 set。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span>, <span class="type">Set</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line">    tags: <span class="type">Set</span>[<span class="built_in">str</span>] = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.put(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params">item_id: <span class="built_in">int</span>, item: Item</span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;item&quot;</span>: item&#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><br>这样，即使你收到带有重复数据的请求，这些数据也会被转换为一组唯一项。<br>而且，每当你输出该数据时，即使源数据有重复，它们也将作为一组唯一项输出。<br>并且还会被相应地标注 / 记录文档。</p><p>（2）Pydantic模型作为嵌套<br>Pydantic 模型的每个属性都具有类型。<br>但是这个类型本身可以是另一个 Pydantic 模型。<br>因此，你可以声明拥有特定属性名称、类型和校验的深度嵌套的 JSON 对象。<br>上述这些都可以任意的嵌套。<br>比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span>, <span class="type">Set</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    url: <span class="built_in">str</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line">    tags: <span class="type">Set</span>[<span class="built_in">str</span>] = []</span><br><span class="line">    <span class="comment"># 将子模型用作类型</span></span><br><span class="line">    <span class="comment"># 这意味着 FastAPI 将期望类似于以下内容的请求体：</span></span><br><span class="line">    <span class="comment"># &#123;</span></span><br><span class="line">    <span class="comment">#     &quot;name&quot;: &quot;Foo&quot;,</span></span><br><span class="line">    <span class="comment">#     &quot;description&quot;: &quot;The pretender&quot;,</span></span><br><span class="line">    <span class="comment">#     &quot;price&quot;: 42.0,</span></span><br><span class="line">    <span class="comment">#     &quot;tax&quot;: 3.2,</span></span><br><span class="line">    <span class="comment">#     &quot;tags&quot;: [&quot;rock&quot;, &quot;metal&quot;, &quot;bar&quot;],</span></span><br><span class="line">    <span class="comment">#     &quot;image&quot;: &#123;</span></span><br><span class="line">    <span class="comment">#         &quot;url&quot;: &quot;http://example.com/baz.jpg&quot;,</span></span><br><span class="line">    <span class="comment">#         &quot;name&quot;: &quot;The Foo live&quot;</span></span><br><span class="line">    <span class="comment">#     &#125;</span></span><br><span class="line">    <span class="comment"># &#125;</span></span><br><span class="line"></span><br><span class="line">    image: <span class="type">Optional</span>[Image] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.put(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params">item_id: <span class="built_in">int</span>, item: Item</span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;item&quot;</span>: item&#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><br>（3）特殊类型及其校验<br>除了普通的单一值类型（如 str、int、float 等）外，还可以使用其他的更复杂的单一值类型。<br>要了解所有的可用选项，请查看关于 <a href="https://pydantic-docs.helpmanual.io/usage/types/">Pydantic字段类型</a> 的文档。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span>, <span class="type">Set</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, HttpUrl</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    <span class="comment"># 例如，在 Image 模型中我们有一个 url 字段，我们可以把它声明为 Pydantic 的 HttpUrl，而不是 str。</span></span><br><span class="line">   <span class="comment"># 该字符串将被检查是否为有效的 URL，并在 JSON Schema / OpenAPI 文档中进行记录。</span></span><br><span class="line">    url: HttpUrl</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line">    tags: <span class="type">Set</span>[<span class="built_in">str</span>] = <span class="built_in">set</span>()</span><br><span class="line">    image: <span class="type">Optional</span>[Image] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.put(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params">item_id: <span class="built_in">int</span>, item: Item</span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;item&quot;</span>: item&#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><br>（4）深度嵌套模型<br>可以定义任意深度的嵌套模型：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span>, <span class="type">Set</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, HttpUrl</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    url: HttpUrl</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line">    tags: <span class="type">Set</span>[<span class="built_in">str</span>] = <span class="built_in">set</span>()</span><br><span class="line">    images: <span class="type">Optional</span>[<span class="type">List</span>[Image]] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Offer</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    items: <span class="type">List</span>[Item]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/offers/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_offer</span>(<span class="params">offer: Offer</span>):</span></span><br><span class="line">    <span class="keyword">return</span> offer</span><br></pre></td></tr></table></figure></p><h3 id="纯列表请求体"><a href="#纯列表请求体" class="headerlink" title="纯列表请求体"></a>纯列表请求体</h3><p>如果你期望的 JSON 请求体的最外层是一个 JSON <code>array</code>（即 Python <code>list</code>），则可以在路径操作函数的参数中声明此类型。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, HttpUrl</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    url: HttpUrl</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/images/multiple/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_multiple_images</span>(<span class="params">images: <span class="type">List</span>[Image]</span>):</span></span><br><span class="line">    <span class="keyword">return</span> images</span><br></pre></td></tr></table></figure></p><h3 id="任意dict构成的请求体"><a href="#任意dict构成的请求体" class="headerlink" title="任意dict构成的请求体"></a>任意dict构成的请求体</h3><p>也可以将请求体声明为使用某类型的key和其他类型的value的 dict。<br>无需事先知道有效的字段/属性（比如使用 Pydantic 模型的场景）是什么。<br>如果你想接收一些尚且未知的键，这将很有用。<br>还有一些奇葩的场景，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/index-weights/&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># 当你想要接收其他类型的键（键的类型通常都是str）时，例如 int。</span></span><br><span class="line"><span class="comment"># 请记住 JSON 仅支持将 str 作为键。</span></span><br><span class="line"><span class="comment"># 但是 Pydantic 具有自动转换数据的功能。</span></span><br><span class="line"><span class="comment"># 这意味着，即使你的 API 客户端只能将字符串作为键发送，只要这些字符串内容仅包含整数，Pydantic 就会对其进行转换并校验。</span></span><br><span class="line"><span class="comment"># 然后你接收的名为 weights 的 dict 实际上将具有 int 类型的键和 float 类型的值。</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_index_weights</span>(<span class="params">weights: <span class="type">Dict</span>[<span class="built_in">int</span>, <span class="built_in">float</span>]</span>):</span></span><br><span class="line">    <span class="keyword">return</span> weights</span><br></pre></td></tr></table></figure></p><h3 id="声明请求体的示例数据"><a href="#声明请求体的示例数据" class="headerlink" title="声明请求体的示例数据"></a>声明请求体的示例数据</h3><p>可以声明你想接收的数据的示例模样。<br>有几种方法可以做到：<br>（1）Pydantic schema_extra<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可以使用 Config 和 schema_extra 为Pydantic模型声明一个示例</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Config</span>:</span></span><br><span class="line">        schema_extra = &#123;</span><br><span class="line">            <span class="string">&quot;example&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Foo&quot;</span>,</span><br><span class="line">                <span class="string">&quot;description&quot;</span>: <span class="string">&quot;A very nice Item&quot;</span>,</span><br><span class="line">                <span class="string">&quot;price&quot;</span>: <span class="number">35.4</span>,</span><br><span class="line">                <span class="string">&quot;tax&quot;</span>: <span class="number">3.2</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.put(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params">item_id: <span class="built_in">int</span>, item: Item</span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;item&quot;</span>: item&#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><br>（2）Field 的附加参数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, Field</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    <span class="comment"># 在 Field, Path, Query, Body 和其他你之后将会看到的工厂函数中，</span></span><br><span class="line">    <span class="comment"># 可以通过给工厂函数传递其他的任意参数来给JSON模式声明额外信息，比如增加 example。</span></span><br><span class="line">    <span class="comment"># 请记住，传递的那些额外参数不会添加任何验证，只会添加注释，用于文档的目的。</span></span><br><span class="line">    name: <span class="built_in">str</span> = Field(..., example=<span class="string">&quot;Foo&quot;</span>)</span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = Field(<span class="literal">None</span>, example=<span class="string">&quot;A very nice Item&quot;</span>)</span><br><span class="line">    price: <span class="built_in">float</span> = Field(..., example=<span class="number">35.4</span>)</span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = Field(<span class="literal">None</span>, example=<span class="number">3.2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.put(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params">item_id: <span class="built_in">int</span>, item: Item</span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;item&quot;</span>: item&#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><br>（3）Body的额外参数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Body, FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.put(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    item_id: <span class="built_in">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    item: Item = Body(<span class="params"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        ...,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        example=&#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Foo&quot;</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">            <span class="string">&quot;description&quot;</span>: <span class="string">&quot;A very nice Item&quot;</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">            <span class="string">&quot;price&quot;</span>: <span class="number">35.4</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">            <span class="string">&quot;tax&quot;</span>: <span class="number">3.2</span>,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">        &#125;,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="params">    </span>),</span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br><span class="line">    results = &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;item&quot;</span>: item&#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure></p><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>（1）用<code>PUT</code>更新数据<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> fastapi.encoders <span class="keyword">import</span> jsonable_encoder</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line">    tax: <span class="built_in">float</span> = <span class="number">10.5</span></span><br><span class="line">    tags: <span class="type">List</span>[<span class="built_in">str</span>] = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">items = &#123;</span><br><span class="line">    <span class="string">&quot;foo&quot;</span>: &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Foo&quot;</span>, <span class="string">&quot;price&quot;</span>: <span class="number">50.2</span>&#125;,</span><br><span class="line">    <span class="string">&quot;bar&quot;</span>: &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Bar&quot;</span>, <span class="string">&quot;description&quot;</span>: <span class="string">&quot;The bartenders&quot;</span>, <span class="string">&quot;price&quot;</span>: <span class="number">62</span>, <span class="string">&quot;tax&quot;</span>: <span class="number">20.2</span>&#125;,</span><br><span class="line">    <span class="string">&quot;baz&quot;</span>: &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Baz&quot;</span>, <span class="string">&quot;description&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;price&quot;</span>: <span class="number">50.2</span>, <span class="string">&quot;tax&quot;</span>: <span class="number">10.5</span>, <span class="string">&quot;tags&quot;</span>: []&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span>, response_model=Item</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_item</span>(<span class="params">item_id: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> items[item_id]</span><br><span class="line"></span><br><span class="line"><span class="comment"># PUT 用于接收替换现有数据的数据。</span></span><br><span class="line"><span class="meta">@app.put(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span>, response_model=Item</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params">item_id: <span class="built_in">str</span>, item: Item</span>):</span></span><br><span class="line">    <span class="comment"># 把输入数据转换为以 JSON 格式存储的数据（比如，使用 NoSQL 数据库时），可以使用 jsonable_encoder。例如，把 datetime 转换为 str。</span></span><br><span class="line">    update_item_encoded = jsonable_encoder(item)</span><br><span class="line">    items[item_id] = update_item_encoded</span><br><span class="line">    <span class="keyword">return</span> update_item_encoded</span><br></pre></td></tr></table></figure><br>当使用如下请求体：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;bar111&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">  <span class="string">&quot;price&quot;</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>用<code>PUT</code>更新<code>bar</code>时，因为上述数据未包含已存储的属性 <code>&quot;tax&quot;: 20.2</code>，新的输入模型会把 <code>&quot;tax&quot;: 10.5</code> 作为默认值。<br>因此，本次操作把 <code>tax</code> 的值「更新」为 <code>10.5</code>。<br>（2）用<code>PATCH</code>进行部分更新<br>HTTP PATCH 操作用于更新 部分 数据。<br>即，只发送要更新的数据，其余数据保持不变。<br>PATCH 没有 PUT 知名，也怎么不常用。<br>很多人甚至只用 PUT 实现部分更新。<br>FastAPI 对此没有任何限制，可以随意互换使用这两种操作。<br>但本指南也会分别介绍这两种操作各自的用途。<br>仍然以上述请求体为例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> fastapi.encoders <span class="keyword">import</span> jsonable_encoder</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line">    tax: <span class="built_in">float</span> = <span class="number">10.5</span></span><br><span class="line">    tags: <span class="type">List</span>[<span class="built_in">str</span>] = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">items = &#123;</span><br><span class="line">    <span class="string">&quot;foo&quot;</span>: &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Foo&quot;</span>, <span class="string">&quot;price&quot;</span>: <span class="number">50.2</span>&#125;,</span><br><span class="line">    <span class="string">&quot;bar&quot;</span>: &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Bar&quot;</span>, <span class="string">&quot;description&quot;</span>: <span class="string">&quot;The bartenders&quot;</span>, <span class="string">&quot;price&quot;</span>: <span class="number">62</span>, <span class="string">&quot;tax&quot;</span>: <span class="number">20.2</span>&#125;,</span><br><span class="line">    <span class="string">&quot;baz&quot;</span>: &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Baz&quot;</span>, <span class="string">&quot;description&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;price&quot;</span>: <span class="number">50.2</span>, <span class="string">&quot;tax&quot;</span>: <span class="number">10.5</span>, <span class="string">&quot;tags&quot;</span>: []&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span>, response_model=Item</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_item</span>(<span class="params">item_id: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> items[item_id]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.patch(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span>, response_model=Item</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params">item_id: <span class="built_in">str</span>, item: Item</span>):</span></span><br><span class="line">    stored_item_data = items[item_id]</span><br><span class="line">    stored_item_model = Item(**stored_item_data)</span><br><span class="line">    <span class="comment"># 更新部分数据时，可以在 Pydantic 模型的 `.dict()` 中使用 `exclude_unset` 参数。</span></span><br><span class="line">    <span class="comment"># 如下代码生成的 dict 只包含创建 item 模型时显式设置的数据，而不包括默认值。</span></span><br><span class="line">    <span class="comment"># 即：update_data =  &#123;&#x27;name&#x27;: &#x27;bar111&#x27;, &#x27;description&#x27;: &#x27;string&#x27;, &#x27;price&#x27;: 0.0&#125;</span></span><br><span class="line">    <span class="comment"># 而不是</span></span><br><span class="line">    <span class="comment"># update_data =  &#123;&#x27;name&#x27;: &#x27;bar111&#x27;, &#x27;description&#x27;: &#x27;string&#x27;, &#x27;price&#x27;: 0.0, &#x27;tax&#x27;: 10.5, &#x27;tags&#x27;: []&#125;</span></span><br><span class="line">    update_data = item.<span class="built_in">dict</span>(exclude_unset=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 接下来，用 .copy() 为已有模型创建调用 update 参数的副本，该参数为包含更新数据的 dict。</span></span><br><span class="line">    updated_item = stored_item_model.copy(update=update_data)</span><br><span class="line">    items[item_id] = jsonable_encoder(updated_item)</span><br><span class="line">    <span class="keyword">return</span> updated_item</span><br></pre></td></tr></table></figure><br>实际上，HTTP <code>PUT</code> 也可以完成相同的操作。 但本节以 <code>PATCH</code> 为例的原因是，该操作就是为了这种用例创建的。</p><h2 id="其他数据类型"><a href="#其他数据类型" class="headerlink" title="其他数据类型"></a>其他数据类型</h2><p>到目前为止，一直在使用常见的数据类型，如:<code>int</code>、<code>float</code>、<code>str</code>、<code>bool</code>，但是也可以使用更复杂的数据类型。<br>在这些复杂数据类型上，也能有如下功能：编辑器支持、传入请求的数据转换、响应数据的转换、数据验证、自动补全和文档。<br>一些常用的复杂数据类型:<br>（1）<code>UUID</code>:<br>一种标准的 “通用唯一标识符” ，在许多数据库和系统中用作ID。<br>在请求和响应中将以 <code>str</code> 表示。<br>（2）<code>datetime.datetime</code>:<br>日期时间。<br>在请求和响应中将表示为 ISO 8601 格式的 str ，比如: <code>2008-09-15T15:53:00+05:00</code>.<br>（3）<code>datetime.date</code>:<br>日期。<br>在请求和响应中将表示为 ISO 8601 格式的 str ，比如: <code>2008-09-15</code>.<br>（4）<code>datetime.time</code>:<br>时间。<br>在请求和响应中将表示为 ISO 8601 格式的 str ，比如: <code>14:23:55.003</code>.<br>（5）<code>datetime.timedelta</code>:<br>时间间隔。<br>在请求和响应中将表示为 float 代表总秒数。<br>Pydantic 也允许将其表示为 “ISO 8601 时间差异编码”。<br>（6）<code>frozenset</code>:<br>在请求和响应中，作为 <code>set</code> 对待：<br>在请求中，列表将被读取，消除重复，并将其转换为一个 <code>set</code>。<br>在响应中 <code>set</code> 将被转换为 <code>list</code> 。<br>产生的schema将指定哪些<code>set</code> 的值是唯一的 (使用 JSON Schema的 <code>uniqueItems</code>)。<br>（7）bytes:<br>标准的 Python <code>bytes</code>。<br>在请求和响应中被当作 <code>str</code> 处理。<br>生成的schema将指定这个 <code>str</code> 是 <code>binary</code> “格式”。<br>（8）Decimal:<br>标准的 Python <code>Decimal</code>。<br>在请求和响应中被当做 <code>float</code> 一样处理。<br>（9）可以在这里检查所有有效的pydantic数据类型: <a href="https://pydantic-docs.helpmanual.io/usage/types/">Pydantic data types</a>。</p><h2 id="Cookie参数"><a href="#Cookie参数" class="headerlink" title="Cookie参数"></a>Cookie参数</h2><p>可以像定义 <code>Query</code> 参数和 <code>Path</code> 参数一样来定义 <code>Cookie</code> 参数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"><span class="comment"># 导入 Cookie</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Cookie, FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># 需要使用 Cookie 来声明 cookie 参数，否则参数将会被解释为查询参数。</span></span><br><span class="line"><span class="comment"># 声明 Cookie 参数的结构与声明 Query 参数和 Path 参数时相同。</span></span><br><span class="line"><span class="comment"># 第一个值是参数的默认值，同时也可以传递所有验证参数或注释参数，来校验参数</span></span><br><span class="line"><span class="comment"># Cookie 、Path 、Query是兄弟类，它们都继承自公共的 Param 类</span></span><br><span class="line"><span class="comment"># 但请记住，从 fastapi 导入的 Query、Path、Cookie 或其他参数声明函数，这些实际上是返回特殊类的函数。</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params">ads_id: <span class="type">Optional</span>[<span class="built_in">str</span>] = Cookie(<span class="params"><span class="literal">None</span></span>)</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;ads_id&quot;</span>: ads_id&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Header参数"><a href="#Header参数" class="headerlink" title="Header参数"></a>Header参数</h2><p>可以使用定义 <code>Query</code>, <code>Path</code> 和 <code>Cookie</code> 参数一样的方法定义 <code>Header</code> 参数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"><span class="comment"># 导入 Header</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Header</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># 为了声明headers， 需要使用Header, 否则参数将被解释为查询参数。</span></span><br><span class="line"><span class="comment"># 使用和Path, Query and Cookie 一样的结构定义 header 参数</span></span><br><span class="line"><span class="comment"># 第一个值是默认值，你可以传递所有的额外验证或注释参数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params">user_agent: <span class="type">Optional</span>[<span class="built_in">str</span>] = Header(<span class="params"><span class="literal">None</span></span>)</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;User-Agent&quot;</span>: user_agent&#125;</span><br></pre></td></tr></table></figure></p><h3 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h3><p>Header 在 Path、 Query 和 Cookie 提供的功能之上有一点额外的功能。<br>大多数标准的headers用 “连字符” 分隔，也称为 “减号” (-)。<br>但是像 <code>user-agent</code> 这样的变量在Python中是无效的。<br>因此, 默认情况下, Header 将把参数名称的字符从下划线 (_) 转换为连字符 (-) 来提取并记录 headers.<br>同时，HTTP headers 是大小写不敏感的，因此，因此可以使用标准Python样式(也称为 “<code>snake_case</code>“)声明它们。<br>因此，可以像通常在Python代码中那样使用 <code>user_agent</code> ，而不需要将首字母大写为 <code>User_Agent</code> 或类似的东西。<br>如果出于某些原因，需要禁用下划线到连字符的自动转换，设置Header的参数 <code>convert_underscores</code> 为 <code>False</code>（注意，一些HTTP代理和服务器不允许使用带有下划线的headers。）。</p><h3 id="重复的headers"><a href="#重复的headers" class="headerlink" title="重复的headers"></a>重复的headers</h3><p>有可能收到重复的headers。这意味着，相同的header具有多个值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Header</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># 可以在类型声明中使用一个list来定义这些情况。</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params">x_token: <span class="type">Optional</span>[<span class="type">List</span>[<span class="built_in">str</span>]] = Header(<span class="params"><span class="literal">None</span></span>)</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;X-Token values&quot;</span>: x_token&#125;</span><br></pre></td></tr></table></figure></p><h2 id="响应模型"><a href="#响应模型" class="headerlink" title="响应模型"></a>响应模型</h2><p>可以在任意的路径操作中使用 <code>response_model</code> 参数来声明用于响应的模型。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line">    tags: <span class="type">List</span>[<span class="built_in">str</span>] = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/items/&quot;</span>, response_model=Item</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_item</span>(<span class="params">item: Item</span>):</span></span><br><span class="line">    <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><br>注意，<code>response_model</code>是「装饰器」方法（<code>get</code>，<code>post</code> 等）的一个参数。不像之前的所有参数和请求体，它不属于路径操作函数。<br>它接收的类型与为 Pydantic 模型属性所声明的类型相同，因此它可以是一个 Pydantic 模型，但也可以是一个由 Pydantic 模型组成的 list，例如 <code>List[Item]</code>。<br>FastAPI 将使用此 <code>response_model</code> 来：<br>（1）将输出数据转换为其声明的类型。<br>（2）校验数据。<br>（3）在 OpenAPI 的路径操作中为响应添加一个 JSON Schema。<br>（4）并在自动生成文档系统中使用。<br>但最重要的是：<br>会将输出数据限制在该模型定义内。这一点非常重要。<br>（响应模型在参数中被声明，而不是作为函数返回类型标注，这是因为路径函数可能不会真正返回该响应模型，而是返回一个 dict、数据库对象或其他模型，然后再使用 <code>response_model</code> 来执行字段约束和序列化。）<br>比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, EmailStr</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个有明文密码的输入模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserIn</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    username: <span class="built_in">str</span></span><br><span class="line">    password: <span class="built_in">str</span></span><br><span class="line">    email: EmailStr</span><br><span class="line">    full_name: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个没有明文密码的输出模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserOut</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    username: <span class="built_in">str</span></span><br><span class="line">    email: EmailStr</span><br><span class="line">    full_name: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 response_model 声明为了不包含密码的 UserOut 模型</span></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/user/&quot;</span>, response_model=UserOut</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_user</span>(<span class="params">user: UserIn</span>):</span></span><br><span class="line">    <span class="comment"># 即便我们的路径操作函数将会返回包含密码的相同输入用户</span></span><br><span class="line">    <span class="comment"># FastAPI 将会负责过滤掉未在输出模型中声明的所有数据（使用 Pydantic）。</span></span><br><span class="line">    <span class="keyword">return</span> user</span><br></pre></td></tr></table></figure></p><h3 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    <span class="comment"># 响应模型可以具有默认值</span></span><br><span class="line">    <span class="comment"># 但如果它们并没有存储实际的值，你可能想从结果中忽略它们的默认值。</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="built_in">float</span> = <span class="number">10.5</span></span><br><span class="line">    tags: <span class="type">List</span>[<span class="built_in">str</span>] = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">items = &#123;</span><br><span class="line">    <span class="string">&quot;foo&quot;</span>: &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Foo&quot;</span>, <span class="string">&quot;price&quot;</span>: <span class="number">50.2</span>&#125;,</span><br><span class="line">    <span class="string">&quot;bar&quot;</span>: &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Bar&quot;</span>, <span class="string">&quot;description&quot;</span>: <span class="string">&quot;The bartenders&quot;</span>, <span class="string">&quot;price&quot;</span>: <span class="number">62</span>, <span class="string">&quot;tax&quot;</span>: <span class="number">20.2</span>&#125;,</span><br><span class="line">    <span class="string">&quot;baz&quot;</span>: &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Baz&quot;</span>, <span class="string">&quot;description&quot;</span>: <span class="literal">None</span>, <span class="string">&quot;price&quot;</span>: <span class="number">50.2</span>, <span class="string">&quot;tax&quot;</span>: <span class="number">10.5</span>, <span class="string">&quot;tags&quot;</span>: []&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以设置路径操作装饰器的 response_model_exclude_unset=True 参数</span></span><br><span class="line"><span class="comment"># 这样响应中将不会包含那些默认值，而是仅有实际设置的值，比如foo这个id</span></span><br><span class="line"><span class="comment"># 如果你的数据在具有默认值的模型字段中有实际的值，比如bar这个id，这些值将包含在响应中。</span></span><br><span class="line"><span class="comment"># 如果数据具有与默认值相同的值，例如 ID 为 baz 的项，它们将包含在 JSON 响应中。</span></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span>, response_model=Item, response_model_exclude_unset=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_item</span>(<span class="params">item_id: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> items[item_id]</span><br></pre></td></tr></table></figure><h3 id="多个模型"><a href="#多个模型" class="headerlink" title="多个模型"></a>多个模型</h3><p>从前面的示例继续，拥有多个相关的模型是很常见的。<br>对用户模型来说尤其如此，因为：<br>（1）输入模型需要拥有密码属性。<br>（2）输出模型不应该包含密码。<br>（3）数据库模型很可能需要保存密码的哈希值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, EmailStr</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserIn</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    username: <span class="built_in">str</span></span><br><span class="line">    password: <span class="built_in">str</span></span><br><span class="line">    email: EmailStr</span><br><span class="line">    full_name: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserOut</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    username: <span class="built_in">str</span></span><br><span class="line">    email: EmailStr</span><br><span class="line">    full_name: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInDB</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    username: <span class="built_in">str</span></span><br><span class="line">    hashed_password: <span class="built_in">str</span></span><br><span class="line">    email: EmailStr</span><br><span class="line">    full_name: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fake_password_hasher</span>(<span class="params">raw_password: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;supersecret&quot;</span> + raw_password</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fake_save_user</span>(<span class="params">user_in: UserIn</span>):</span></span><br><span class="line">    hashed_password = fake_password_hasher(user_in.password)</span><br><span class="line">    <span class="comment"># user_in 是一个 UserIn 类的 Pydantic 模型.</span></span><br><span class="line">    <span class="comment"># Pydantic 模型具有 .dict（） 方法，该方法返回一个拥有模型数据的 dict，暂时命名为user_dict。</span></span><br><span class="line">    <span class="comment"># 如果将该dict以 **user_dict 形式传递给一个函数（或类），Python将对其进行「解包」。它会将 user_dict 的键和值作为关键字参数直接传递。</span></span><br><span class="line">    <span class="comment"># 这样就获得了一个来自于其他 Pydantic 模型中的数据的 Pydantic 模型。</span></span><br><span class="line">    user_in_db = UserInDB(**user_in.<span class="built_in">dict</span>(), hashed_password=hashed_password)</span><br><span class="line">    <span class="comment"># 如下效果就是：</span></span><br><span class="line">    <span class="comment"># user_in_db = UserInDB(</span></span><br><span class="line">    <span class="comment">#     username = user_dict[&quot;username&quot;],</span></span><br><span class="line">    <span class="comment">#     password = user_dict[&quot;password&quot;],</span></span><br><span class="line">    <span class="comment">#     email = user_dict[&quot;email&quot;],</span></span><br><span class="line">    <span class="comment">#     full_name = user_dict[&quot;full_name&quot;],</span></span><br><span class="line">    <span class="comment">#     hashed_password = hashed_password,</span></span><br><span class="line">    <span class="comment"># )</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;User saved! ..not really&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> user_in_db</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/user/&quot;</span>, response_model=UserOut</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_user</span>(<span class="params">user_in: UserIn</span>):</span></span><br><span class="line">    user_saved = fake_save_user(user_in)</span><br><span class="line">    <span class="keyword">return</span> user_saved</span><br></pre></td></tr></table></figure></p><p>（1）减少重复<br>减少代码重复是 FastAPI 的核心思想之一。<br>因为代码重复会增加出现 bug、安全性问题、代码失步问题（当你在一个位置更新了代码但没有在其他位置更新）等的可能性。<br>上面的这些模型都共享了大量数据，并拥有重复的属性名称和类型。<br>我们可以声明一个 <code>UserBase</code> 模型作为其他模型的基类。然后可以创建继承该模型属性（类型声明，校验等）的子类。<br>所有的数据转换、校验、文档生成等仍将正常运行。<br>这样，可以仅声明模型之间的差异部分（具有明文的 <code>password</code>、具有 <code>hashed_password</code> 以及不包括密码）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, EmailStr</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserBase</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    username: <span class="built_in">str</span></span><br><span class="line">    email: EmailStr</span><br><span class="line">    full_name: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserIn</span>(<span class="params">UserBase</span>):</span></span><br><span class="line">    password: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserOut</span>(<span class="params">UserBase</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInDB</span>(<span class="params">UserBase</span>):</span></span><br><span class="line">    hashed_password: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fake_password_hasher</span>(<span class="params">raw_password: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;supersecret&quot;</span> + raw_password</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fake_save_user</span>(<span class="params">user_in: UserIn</span>):</span></span><br><span class="line">    hashed_password = fake_password_hasher(user_in.password)</span><br><span class="line">    user_in_db = UserInDB(**user_in.<span class="built_in">dict</span>(), hashed_password=hashed_password)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;User saved! ..not really&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> user_in_db</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/user/&quot;</span>, response_model=UserOut</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_user</span>(<span class="params">user_in: UserIn</span>):</span></span><br><span class="line">    user_saved = fake_save_user(user_in)</span><br><span class="line">    <span class="keyword">return</span> user_saved</span><br></pre></td></tr></table></figure><br>（2）Union 或者 anyOf<br>以将一个响应声明为两种类型的 <code>Union</code>，这意味着该响应将是两种类型中的任何一种。<br>这将在 OpenAPI 中使用 <code>anyOf</code> 进行定义。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseItem</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    description: <span class="built_in">str</span></span><br><span class="line">    <span class="built_in">type</span>: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarItem</span>(<span class="params">BaseItem</span>):</span></span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&quot;car&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlaneItem</span>(<span class="params">BaseItem</span>):</span></span><br><span class="line">    <span class="built_in">type</span> = <span class="string">&quot;plane&quot;</span></span><br><span class="line">    size: <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">items = &#123;</span><br><span class="line">    <span class="string">&quot;item1&quot;</span>: &#123;<span class="string">&quot;description&quot;</span>: <span class="string">&quot;All my friends drive a low rider&quot;</span>, <span class="string">&quot;type&quot;</span>: <span class="string">&quot;car&quot;</span>&#125;,</span><br><span class="line">    <span class="string">&quot;item2&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Music is my aeroplane, it&#x27;s my aeroplane&quot;</span>,</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;plane&quot;</span>,</span><br><span class="line">        <span class="string">&quot;size&quot;</span>: <span class="number">5</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个 Union 类型时，首先包括最详细的类型，然后是不太详细的类型。</span></span><br><span class="line"><span class="comment"># 在下面的示例中，更详细的 PlaneItem 位于 Union[PlaneItem，CarItem] 中的 CarItem 之前。</span></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span>, response_model=<span class="type">Union</span>[CarItem, PlaneItem]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_item</span>(<span class="params">item_id: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> items[item_id]</span><br></pre></td></tr></table></figure></p><p>（3）模型列表<br>可以用同样的方式声明由对象列表构成的响应。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">items = [</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Foo&quot;</span>, <span class="string">&quot;description&quot;</span>: <span class="string">&quot;There comes my hero&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Red&quot;</span>, <span class="string">&quot;description&quot;</span>: <span class="string">&quot;It&#x27;s my aeroplane&quot;</span>&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span>, response_model=<span class="type">List</span>[Item]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>():</span></span><br><span class="line">    <span class="keyword">return</span> items</span><br></pre></td></tr></table></figure><br>（4）任意dict构成的响应<br>还可以使用一个任意的普通 dict 声明响应，仅声明键和值的类型，而不使用 Pydantic 模型。<br>如果你事先不知道有效的字段/属性名称（对于 Pydantic 模型是必需的），这将很有用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/keyword-weights/&quot;</span>, response_model=<span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">float</span>]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_keyword_weights</span>():</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;foo&quot;</span>: <span class="number">2.3</span>, <span class="string">&quot;bar&quot;</span>: <span class="number">3.4</span>&#125;</span><br></pre></td></tr></table></figure></p><h2 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h2><p>与指定响应模型的方式相同，也可以在以下任意的路径操作中使用 <code>status_code</code> 参数来声明用于响应的 HTTP 状态码。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># status_code 参数接收一个表示 HTTP 状态码的数字。</span></span><br><span class="line"><span class="comment"># status_code 也能够接收一个 IntEnum 类型，比如 Python 的 http.HTTPStatus。</span></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/items/&quot;</span>, status_code=<span class="number">201</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_item</span>(<span class="params">name: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;name&quot;</span>: name&#125;</span><br></pre></td></tr></table></figure><br>注意，<code>status_code</code> 是「装饰器」方法（<code>get</code>，<code>post</code> 等）的一个参数。不像之前的所有参数和请求体，它不属于路径操作函数。<br>在 HTTP 协议中，将发送 3 位数的数字状态码作为响应的一部分。<br>这些状态码有一个识别它们的关联名称，但是重要的还是数字。<br>（1）100 及以上状态码用于「消息」响应。很少直接使用它们。具有这些状态代码的响应不能带有响应体。<br>（2）200 及以上状态码用于「成功」响应。这些是最常使用的。</p><ul><li>200 是默认状态代码，它表示一切「正常」。</li><li>201表示「已创建」。它通常在数据库中创建了一条新记录后使用。</li><li>204表示「无内容」。此响应在没有内容返回给客户端时使用，因此该响应不能包含响应体。</li></ul><p>（3）300 及以上状态码用于「重定向」。具有这些状态码的响应可能有或者可能没有响应体，但 304「未修改」是个例外，该响应不得含有响应体。<br>（4）400 及以上状态码用于「客户端错误」响应。这些可能是第二常用的类型。</p><ul><li>404，用于「未找到」响应。</li><li>对于来自客户端的一般错误，可以只使用 400。</li></ul><p>（5）500 及以上状态码用于服务器端错误。几乎永远不会直接使用它们。当你的应用程序代码或服务器中的某些部分出现问题时，它将自动返回这些状态代码之一。<br>要了解有关每个状态代码以及适用场景的更多信息，请查看<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">MDN 关于 HTTP 状态码的文档</a>。</p><h2 id="表单数据"><a href="#表单数据" class="headerlink" title="表单数据"></a>表单数据</h2><p>接收的不是 JSON，而是表单字段时，要使用 Form。<br>要使用表单，需预先安装<code>python-multipart</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install python-multipart</span><br></pre></td></tr></table></figure><br>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 fastapi 导入 Form</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Form</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/login/&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># 创建表单（Form）参数的方式与 Body 和 Query 一样</span></span><br><span class="line"><span class="comment"># OAuth2 规范的 &quot;密码流&quot; 模式规定要通过表单字段发送 username 和 password。</span></span><br><span class="line"><span class="comment"># 该规范要求字段必须命名为 username 和 password，并通过表单字段发送，不能用 JSON。</span></span><br><span class="line"><span class="comment"># 使用 Form 可以声明与 Body （及 Query、Path、Cookie）相同的元数据和验证。</span></span><br><span class="line"><span class="comment"># 声明表单体要显式使用 Form ，否则，FastAPI 会把该参数当作查询参数或请求体（JSON）参数。</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">username: <span class="built_in">str</span> = Form(<span class="params">...</span>), password: <span class="built_in">str</span> = Form(<span class="params">...</span>)</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;username&quot;</span>: username&#125;</span><br></pre></td></tr></table></figure></p><p>与 JSON 不同，HTML 表单（<code>&lt;form&gt;&lt;/form&gt;</code>）向服务器发送数据通常使用「特殊」的编码。<br>FastAPI 要确保从正确的位置读取数据，而不是读取 JSON。<br>表单数据的「媒体类型」编码一般为 <code>application/x-www-form-urlencoded</code>。<br>但包含文件的表单编码为 <code>multipart/form-data</code>。文件处理详见下节。</p><p>可在一个路径操作中声明多个 Form 参数，但不能同时声明要接收 JSON 的 Body 字段。因为此时请求体的编码是 <code>application/x-www-form-urlencoded</code>，不是 <code>application/json</code>。<br>这不是 FastAPI 的问题，而是 HTTP 协议的规定。</p><h2 id="请求文件"><a href="#请求文件" class="headerlink" title="请求文件"></a>请求文件</h2><p><code>File</code> 用于定义客户端的上传文件。<br>因为上传文件以「表单数据」形式发送。<br>所以接收上传文件，要预先安装 <code>python-multipart</code>。<br>有两种文件请求方式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 fastapi 导入 File 和 UploadFile</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, File, UploadFile</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/files/&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># 创建文件（File）参数的方式与 Body 和 Form 一样</span></span><br><span class="line"><span class="comment"># 声明文件体必须使用 File，否则，FastAPI 会把该参数当作查询参数或请求体（JSON）参数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果把路径操作函数参数的类型声明为 bytes，FastAPI 将以 bytes 形式读取和接收文件内容。</span></span><br><span class="line"><span class="comment"># 这种方式把文件的所有内容都存储在内存里，适用于小型文件。</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_file</span>(<span class="params">file: <span class="built_in">bytes</span> = File(<span class="params">...</span>)</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;file_size&quot;</span>: <span class="built_in">len</span>(file)&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/uploadfile/&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># 不过，很多情况下，UploadFile 更好用。</span></span><br><span class="line"><span class="comment"># 定义 File 参数时使用 UploadFile</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_upload_file</span>(<span class="params">file: UploadFile</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;filename&quot;</span>: file.filename&#125;</span><br></pre></td></tr></table></figure><br>UploadFile 与 bytes 相比有更多优势：<br>（1）使用 spooled 文件：存储在内存的文件超出最大上限时，FastAPI 会把文件存入磁盘；<br>（2）这种方式更适于处理图像、视频、二进制文件等大型文件，好处是不会占用所有内存；<br>（3）可获取上传文件的元数据；<br>（4）自带 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-file-like-object">file-like</a> <code>async</code> 接口；<br>（5）它暴露了一个 Python <code>SpooledTemporaryFile</code> 对象，可直接传递给其他想要<code>file-like</code>对象的库。</p><p>UploadFile 的属性如下：<br>（1）<code>filename</code>：上传文件的文件名字符串（str），例如<code>myimage.jpg</code>；<br>（2）<code>content_type</code>：内容的类型（MIME 类型 / 媒体类型）字符串（str），例如<code>image/jpeg</code>；<br>（3）<code>file</code>： <code>SpooledTemporaryFile</code>（一个<code>file-like</code> 对象）。该对象可直接传递给其他想要 <code>file-like</code> 对象的函数或库。</p><p>UploadFile 支持以下 <code>async</code> 方法，（使用内部 <code>SpooledTemporaryFile</code>）可调用如下方法。<br>（1）<code>write(data)</code>：把 <code>data</code> （<code>str</code> 或 <code>bytes</code>）写入文件；<br>（2）<code>read(size)</code>：按指定数量的字节或字符（<code>size (int)</code>）读取文件内容；<br>（3）<code>seek(offset)</code>：移动至文件<code>offset (int)</code> 字节处的位置；<br>例如，<code>await myfile.seek(0)</code>移动到文件开头；<br>执行 <code>await myfile.read()</code> 后，需再次读取已读取内容时，这种方法特别好用。<br>（4）<code>close()</code>：关闭文件。<br>因为上述方法都是 <code>async</code> 方法，要搭配<code>await</code>使用。<br>例如，在 <code>async</code> 路径操作函数 内，要用以下方式读取文件内容：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contents = <span class="keyword">await</span> myfile.read()</span><br></pre></td></tr></table></figure><br>在普通 <code>def</code> 路径操作函数 内，则可以直接访问<code>UploadFile.file</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contents = myfile.file.read()</span><br></pre></td></tr></table></figure></p><p>多文件上传：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, File, UploadFile</span><br><span class="line"><span class="keyword">from</span> fastapi.responses <span class="keyword">import</span> HTMLResponse</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/files/&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># 可用同一个「表单字段」发送含多个文件的「表单数据」。</span></span><br><span class="line"><span class="comment"># 上传多个文件时，要声明含 bytes 或 UploadFile 的列表（List）：</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_files</span>(<span class="params">files: <span class="type">List</span>[<span class="built_in">bytes</span>] = File(<span class="params">...</span>)</span>):</span></span><br><span class="line">    <span class="comment"># 接收的也是含 bytes 或 UploadFile 的列表（list）。</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;file_sizes&quot;</span>: [<span class="built_in">len</span>(file) <span class="keyword">for</span> file <span class="keyword">in</span> files]&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/uploadfiles/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_upload_files</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 也可以声明元数据</span></span></span></span><br><span class="line"><span class="function"><span class="params">    files: <span class="type">List</span>[UploadFile] = File(<span class="params">..., description=<span class="string">&quot;Multiple files as UploadFile&quot;</span></span>)</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;filenames&quot;</span>: [file.filename <span class="keyword">for</span> file <span class="keyword">in</span> files]&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    content = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;form action=&quot;/files/&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;input name=&quot;files&quot; type=&quot;file&quot; multiple&gt;</span></span><br><span class="line"><span class="string">&lt;input type=&quot;submit&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;form action=&quot;/uploadfiles/&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;input name=&quot;files&quot; type=&quot;file&quot; multiple&gt;</span></span><br><span class="line"><span class="string">&lt;input type=&quot;submit&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> HTMLResponse(content=content)</span><br></pre></td></tr></table></figure></p><h2 id="请求表单和文件"><a href="#请求表单和文件" class="headerlink" title="请求表单和文件"></a>请求表单和文件</h2><p>FastAPI 支持同时使用 <code>File</code> 和 <code>Form</code> 定义文件和表单字段。<br>在同一个请求中接收数据和文件时，应同时使用 File 和 Form。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, File, Form, UploadFile</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/files/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_file</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 创建文件和表单参数的方式与 Body 和 Query 一样</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 可在一个路径操作中声明多个 File 与 Form 参数，但不能同时声明要接收 JSON 的 Body 字段。因为此时请求体的编码为 multipart/form-data，不是 application/json。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 这不是 FastAPI 的问题，而是 HTTP 协议的规定。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    file: <span class="built_in">bytes</span> = File(<span class="params">...</span>), fileb: UploadFile = File(<span class="params">...</span>), token: <span class="built_in">str</span> = Form(<span class="params">...</span>)</span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;file_size&quot;</span>: <span class="built_in">len</span>(file),</span><br><span class="line">        <span class="string">&quot;token&quot;</span>: token,</span><br><span class="line">        <span class="string">&quot;fileb_content_type&quot;</span>: fileb.content_type,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h2><p>某些情况下，需要向客户端返回错误提示。<br>这里所谓的客户端包括前端浏览器、其他应用程序、物联网设备等。<br>需要向客户端返回错误提示的场景主要如下：<br>（1）客户端没有执行操作的权限<br>（2）客户端没有访问资源的权限<br>（3）客户端要访问的项目不存在<br>等等 …<br>遇到这些情况时，通常要返回 4XX（400 至 499）HTTP 状态码。</p><h3 id="使用HTTPException"><a href="#使用HTTPException" class="headerlink" title="使用HTTPException"></a>使用HTTPException</h3><p>向客户端返回 HTTP 错误响应，可以使用 <code>HTTPException</code>。<br>HTTPException 是一个常规 Python 异常，包含了和 API 有关的额外数据。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 HTTPException</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, HTTPException</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line">items = &#123;<span class="string">&quot;foo&quot;</span>: <span class="string">&quot;The Foo Wrestlers&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_item</span>(<span class="params">item_id: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> item_id <span class="keyword">not</span> <span class="keyword">in</span> items:</span><br><span class="line">        <span class="comment"># 因为是 Python 异常，所以不能 return，只能 raise。</span></span><br><span class="line">        <span class="comment"># 如在调用路径操作函数里的工具函数时，触发了 HTTPException，FastAPI 就不再继续执行路径操作函数中的后续代码，而是立即终止请求，并把 HTTPException 的 HTTP 错误发送至客户端。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 触发 HTTPException 时，可以用参数 detail 传递任何能转换为 JSON 的值，不仅限于 str。</span></span><br><span class="line">        <span class="comment"># 还支持传递 dict、list 等数据结构。</span></span><br><span class="line">        <span class="comment"># FastAPI 能自动处理这些数据，并将之转换为 JSON。</span></span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">404</span>, detail=<span class="string">&quot;Item not found&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;item&quot;</span>: items[item_id]&#125;</span><br></pre></td></tr></table></figure><br>有些场景下要为 HTTP 错误添加自定义响应头。例如，出于某些方面的安全需要。<br>一般情况下可能不会需要在代码中直接使用响应头。<br>但对于某些高级应用场景，还是需要添加自定义响应头：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, HTTPException</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line">items = &#123;<span class="string">&quot;foo&quot;</span>: <span class="string">&quot;The Foo Wrestlers&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items-header/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_item_header</span>(<span class="params">item_id: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> item_id <span class="keyword">not</span> <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(</span><br><span class="line">            status_code=<span class="number">404</span>,</span><br><span class="line">            detail=<span class="string">&quot;Item not found&quot;</span>,</span><br><span class="line">            headers=&#123;<span class="string">&quot;X-Error&quot;</span>: <span class="string">&quot;There goes my error&quot;</span>&#125;,</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;item&quot;</span>: items[item_id]&#125;</span><br></pre></td></tr></table></figure></p><h3 id="安装自定义异常处理器"><a href="#安装自定义异常处理器" class="headerlink" title="安装自定义异常处理器"></a>安装自定义异常处理器</h3><p>添加自定义处理器，要使用<a href="https://www.starlette.io/exceptions/">Starlette 的异常工具</a>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Request</span><br><span class="line"><span class="keyword">from</span> fastapi.responses <span class="keyword">import</span> JSONResponse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设要触发的自定义异常叫作 UnicornException。</span></span><br><span class="line"><span class="comment"># 且需要 FastAPI 实现全局处理该异常。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnicornException</span>(<span class="params">Exception</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name: <span class="built_in">str</span></span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以用 @app.exception_handler() 添加自定义异常控制器</span></span><br><span class="line"><span class="meta">@app.exception_handler(<span class="params">UnicornException</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">unicorn_exception_handler</span>(<span class="params">request: Request, exc: UnicornException</span>):</span></span><br><span class="line">    <span class="comment"># 接收到的错误信息清晰明了，HTTP 状态码为 418，JSON 内容如下：</span></span><br><span class="line">    <span class="keyword">return</span> JSONResponse(</span><br><span class="line">        status_code=<span class="number">418</span>,</span><br><span class="line">        content=&#123;<span class="string">&quot;message&quot;</span>: <span class="string">f&quot;Oops! <span class="subst">&#123;exc.name&#125;</span> did something. There goes a rainbow...&quot;</span>&#125;,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/unicorns/&#123;name&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_unicorn</span>(<span class="params">name: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="comment"># 请求 /unicorns/yolo 时，路径操作会触发 UnicornException。</span></span><br><span class="line">    <span class="comment"># 但该异常将会被 unicorn_exception_handler 处理。</span></span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">&quot;yolo&quot;</span>:</span><br><span class="line">        <span class="keyword">raise</span> UnicornException(name=name)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;unicorn_name&quot;</span>: name&#125;</span><br></pre></td></tr></table></figure></p><h3 id="覆盖默认异常处理器"><a href="#覆盖默认异常处理器" class="headerlink" title="覆盖默认异常处理器"></a>覆盖默认异常处理器</h3><p>FastAPI 自带了一些默认异常处理器。<br>触发 <code>HTTPException</code> 或请求无效数据时，这些处理器返回默认的 JSON 响应结果。<br>不过，也可以使用自定义处理器覆盖默认异常处理器。<br>（这部分内容太高阶，且一般情况下使用默认异常处理器即可。跳过本部分）</p><h2 id="路径操作配置"><a href="#路径操作配置" class="headerlink" title="路径操作配置"></a>路径操作配置</h2><p>路径操作装饰器支持多种配置参数。<br>通过传递参数给路径操作装饰器 ，即可轻松地配置路径操作、添加元数据。<br>注意：以下参数应直接传递给路径操作装饰器，不能传递给路径操作函数。</p><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p><code>status_code</code> 用于定义路径操作响应中的 HTTP 状态码。<br>可以直接传递 <code>int</code> 代码， 比如 404。<br>如果记不住数字码的涵义，也可以用 <code>status</code> 的快捷常量，如<code>status.HTTP_201_CREATED</code>。</p><h3 id="tags参数"><a href="#tags参数" class="headerlink" title="tags参数"></a>tags参数</h3><p>tags 参数的值是由 str 组成的 list （一般只有一个 str ），tags 用于为路径操作添加标签。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span>, <span class="type">Set</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line">    tags: <span class="type">Set</span>[<span class="built_in">str</span>] = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/items/&quot;</span>, response_model=Item, tags=[<span class="string">&quot;items&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_item</span>(<span class="params">item: Item</span>):</span></span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span>, tags=[<span class="string">&quot;items&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Foo&quot;</span>, <span class="string">&quot;price&quot;</span>: <span class="number">42</span>&#125;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/users/&quot;</span>, tags=[<span class="string">&quot;users&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_users</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;username&quot;</span>: <span class="string">&quot;johndoe&quot;</span>&#125;]</span><br></pre></td></tr></table></figure><br>OpenAPI schema会自动添加标签，供 API 文档接口使用。</p><h3 id="summary-和-description-参数"><a href="#summary-和-description-参数" class="headerlink" title="summary 和 description 参数"></a>summary 和 description 参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span>, <span class="type">Set</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line">    tags: <span class="type">Set</span>[<span class="built_in">str</span>] = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"></span></span></span><br><span class="line"><span class="meta"><span class="params">    <span class="string">&quot;/items/&quot;</span>,</span></span></span><br><span class="line"><span class="meta"><span class="params">    response_model=Item,</span></span></span><br><span class="line"><span class="meta"><span class="params">    <span class="comment"># 对api的概要</span></span></span></span><br><span class="line"><span class="meta"><span class="params">    summary=<span class="string">&quot;Create an item&quot;</span>,</span></span></span><br><span class="line"><span class="meta"><span class="params">    <span class="comment"># 详细说明，更复杂的说明可以使用下面的文档字符串</span></span></span></span><br><span class="line"><span class="meta"><span class="params">    description=<span class="string">&quot;Create an item with all the information, name, description, price, tax and a set of unique tags&quot;</span>,</span></span></span><br><span class="line"><span class="meta"><span class="params"></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_item</span>(<span class="params">item: Item</span>):</span></span><br><span class="line">    <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><h3 id="文档字符串"><a href="#文档字符串" class="headerlink" title="文档字符串"></a>文档字符串</h3><p>描述内容比较长且占用多行时，可以在函数的 docstring 中声明路径操作的描述，FastAPI 支持从文档字符串中读取描述内容。<br>文档字符串支持 Markdown，能正确解析和显示 Markdown 的内容，但要注意文档字符串的缩进。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span>, <span class="type">Set</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line">    tags: <span class="type">Set</span>[<span class="built_in">str</span>] = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/items/&quot;</span>, response_model=Item, summary=<span class="string">&quot;Create an item&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_item</span>(<span class="params">item: Item</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Create an item with all the information:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    - **name**: each item must have a name</span></span><br><span class="line"><span class="string">    - **description**: a long description</span></span><br><span class="line"><span class="string">    - **price**: required</span></span><br><span class="line"><span class="string">    - **tax**: if the item doesn&#x27;t have tax, you can omit this</span></span><br><span class="line"><span class="string">    - **tags**: a set of unique tag strings for this item</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure></p><h3 id="响应描述"><a href="#响应描述" class="headerlink" title="响应描述"></a>响应描述</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span>, <span class="type">Set</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    price: <span class="built_in">float</span></span><br><span class="line">    tax: <span class="type">Optional</span>[<span class="built_in">float</span>] = <span class="literal">None</span></span><br><span class="line">    tags: <span class="type">Set</span>[<span class="built_in">str</span>] = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"></span></span></span><br><span class="line"><span class="meta"><span class="params">    <span class="string">&quot;/items/&quot;</span>,</span></span></span><br><span class="line"><span class="meta"><span class="params">    response_model=Item,</span></span></span><br><span class="line"><span class="meta"><span class="params">    summary=<span class="string">&quot;Create an item&quot;</span>,</span></span></span><br><span class="line"><span class="meta"><span class="params">    <span class="comment"># response_description 参数用于定义响应的描述说明</span></span></span></span><br><span class="line"><span class="meta"><span class="params">    <span class="comment"># OpenAPI 规定每个路径操作都要有响应描述。</span></span></span></span><br><span class="line"><span class="meta"><span class="params">    <span class="comment"># 如果没有定义响应描述，FastAPI 则自动生成内容为 &quot;Successful response&quot; 的响应描述。</span></span></span></span><br><span class="line"><span class="meta"><span class="params">    response_description=<span class="string">&quot;The created item&quot;</span>,</span></span></span><br><span class="line"><span class="meta"><span class="params"></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">create_item</span>(<span class="params">item: Item</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Create an item with all the information:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    - **name**: each item must have a name</span></span><br><span class="line"><span class="string">    - **description**: a long description</span></span><br><span class="line"><span class="string">    - **price**: required</span></span><br><span class="line"><span class="string">    - **tax**: if the item doesn&#x27;t have tax, you can omit this</span></span><br><span class="line"><span class="string">    - **tags**: a set of unique tag strings for this item</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure><h3 id="弃用路径操作"><a href="#弃用路径操作" class="headerlink" title="弃用路径操作"></a>弃用路径操作</h3><p><code>deprecated</code> 参数可以把路径操作标记为弃用，无需直接删除。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span>, tags=[<span class="string">&quot;items&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Foo&quot;</span>, <span class="string">&quot;price&quot;</span>: <span class="number">42</span>&#125;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/users/&quot;</span>, tags=[<span class="string">&quot;users&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_users</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;username&quot;</span>: <span class="string">&quot;johndoe&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/elements/&quot;</span>, tags=[<span class="string">&quot;items&quot;</span>], deprecated=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_elements</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;item_id&quot;</span>: <span class="string">&quot;Foo&quot;</span>&#125;]</span><br></pre></td></tr></table></figure></p><h2 id="JSON兼容编码器"><a href="#JSON兼容编码器" class="headerlink" title="JSON兼容编码器"></a>JSON兼容编码器</h2><p>在某些情况下，可能需要将一个数据类型（如 Pydantic 模型）转换为与 JSON 兼容的类型（如<code>dict</code>、<code>list</code>等）。<br>比如想将该数据存储在数据库中。<br>为此，FastAPI提供了一个<code>jsonable_encoder()</code>功能。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="comment"># 导入jsonable_encoder</span></span><br><span class="line"><span class="keyword">from</span> fastapi.encoders <span class="keyword">import</span> jsonable_encoder</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设fake_db数据库只接收 JSON 兼容的数据。</span></span><br><span class="line"><span class="comment"># 例如，它不接收datetime对象，因为它们与 JSON 不兼容。</span></span><br><span class="line"><span class="comment"># 因此，datetime对象必须转换为包含ISO格式数据的str对象。</span></span><br><span class="line"><span class="comment"># 同样，该数据库不会接收 Pydantic 模型（具有属性的对象），只会接收dict.</span></span><br><span class="line">fake_db = &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    title: <span class="built_in">str</span></span><br><span class="line">    timestamp: datetime</span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.put(<span class="params"><span class="string">&quot;/items/&#123;id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params"><span class="built_in">id</span>: <span class="built_in">str</span>, item: Item</span>):</span></span><br><span class="line">    <span class="comment"># jsonable_encoder将 Pydantic 模型转换为一个dict，并将datetime转换为str。</span></span><br><span class="line">    <span class="comment"># 它不会返回一个大的str，里面包含JSON格式的数据（作为字符串）。</span></span><br><span class="line">    <span class="comment"># 而是返回一个Python标准数据结构（例如一个dict），其中的值和子值都与 JSON 兼容。</span></span><br><span class="line">    json_compatible_item_data = jsonable_encoder(item)</span><br><span class="line">    fake_db[<span class="built_in">id</span>] = json_compatible_item_data</span><br></pre></td></tr></table></figure></p><h2 id="依赖项"><a href="#依赖项" class="headerlink" title="依赖项"></a>依赖项</h2><p>FastAPI 提供了简单易用，但功能强大的依赖注入系统。<br>这个依赖系统设计的简单易用，可以让开发人员轻松地把组件集成至 FastAPI。</p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>编程中的「依赖注入」是声明代码（本文中为路径操作函数 ）运行所需的，或要使用的「依赖」的一种方式。<br>然后，由系统（本文中为 FastAPI）负责执行任意需要的逻辑，为代码提供这些依赖（「注入」依赖项）。<br>依赖注入常用于以下场景：<br>（1）共享业务逻辑（复用相同的代码逻辑）<br>（2）共享数据库连接<br>（3）实现安全、验证、角色权限<br>等……<br>上述场景均可以使用依赖注入，将代码重复最小化。<br>依赖注入系统支持构建集成和「插件」。但实际上，FastAPI 根本不需要创建「插件」，因为使用依赖项可以声明不限数量的、可用于路径操作函数的集成与交互。<br>创建依赖项非常简单、直观，并且还支持导入 Python 包。毫不夸张地说，只要几行代码就可以把需要的 Python 包与 API 函数集成在一起。</p><h3 id="FastAPI-兼容性"><a href="#FastAPI-兼容性" class="headerlink" title="FastAPI 兼容性"></a>FastAPI 兼容性</h3><p>依赖注入系统如此简洁的特性，让 FastAPI 可以与下列系统兼容：</p><ul><li>关系型数据库</li><li>NoSQL 数据库</li><li>外部支持库</li><li>外部 API</li><li>认证和鉴权系统</li><li>API 使用监控系统</li><li>响应数据注入系统<br>等等……</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"><span class="comment"># 导入 Depends</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Depends, FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建依赖项</span></span><br><span class="line"><span class="comment"># 依赖项函数的形式和结构与路径操作函数一样。</span></span><br><span class="line"><span class="comment"># 可以把依赖项当作没有「装饰器」（即，没有 @app.get(&quot;/some-path&quot;) ）的路径操作函数。</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">common_parameters</span>(<span class="params">q: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>, skip: <span class="built_in">int</span> = <span class="number">0</span>, limit: <span class="built_in">int</span> = <span class="number">100</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;q&quot;</span>: q, <span class="string">&quot;skip&quot;</span>: skip, <span class="string">&quot;limit&quot;</span>: limit&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明依赖项</span></span><br><span class="line"><span class="comment"># 与在路径操作函数参数中使用 Body、Query 的方式相同，声明依赖项需要使用 Depends 和一个新的参数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 虽然，在路径操作函数的参数中使用 Depends 的方式与 Body、Query 相同，但 Depends 的工作方式略有不同。</span></span><br><span class="line"><span class="comment"># 这里只能传给 Depends 一个参数。</span></span><br><span class="line"><span class="comment"># 且该参数必须是可调用对象，比如函数。</span></span><br><span class="line"><span class="comment"># 该函数接收的参数和路径操作函数的参数一样。</span></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params">commons: <span class="built_in">dict</span> = Depends(<span class="params">common_parameters</span>)</span>):</span></span><br><span class="line">    <span class="keyword">return</span> commons</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收到新的请求时，FastAPI 执行如下操作：</span></span><br><span class="line"><span class="comment"># （1）用正确的参数调用依赖项函数（「可依赖项」）</span></span><br><span class="line"><span class="comment"># （2）获取函数返回的结果</span></span><br><span class="line"><span class="comment"># （3）把函数返回的结果赋值给路径操作函数的参数</span></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/users/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_users</span>(<span class="params">commons: <span class="built_in">dict</span> = Depends(<span class="params">common_parameters</span>)</span>):</span></span><br><span class="line">    <span class="keyword">return</span> commons</span><br></pre></td></tr></table></figure><p>虽然，层级式依赖注入系统的定义与使用十分简单，但它却非常强大。<br>比如，可以定义依赖其他依赖项的依赖项。<br>最后，依赖项层级树构建后，依赖注入系统会处理所有依赖项及其子依赖项，并为每一步操作提供（注入）结果。</p><h3 id="类作为依赖项"><a href="#类作为依赖项" class="headerlink" title="类作为依赖项"></a>类作为依赖项</h3><p>上面例子中依赖项的声明是个函数，它的返回值是个字典。这种方式可行，但可以更好，比如此时编辑器就没法提供很好的支持，因为它不知道字典的键和值是什么。<br>函数并不是声明依赖关系的唯一方法（尽管它可能更常见）。关键因素是依赖项应该是“可调用的”。<br>Python 中的“可调用”是 Python 可以像函数一样“调用”的任何东西，比如类<code>class</code>也是可调用的。</p><p>FastAPI 实际检查的是它是“可调用的”（函数、类或其他任何东西）和定义的参数。<br>如果在FastAPI 中将“可调用”作为依赖项传递，它将分析该“可调用”的参数，并以与路径操作函数的参数相同的方式处理它们。包括子依赖。<br>这也适用于完全没有参数的可调用对象。与没有参数的路径操作函数相同。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Depends, FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_items_db = [&#123;<span class="string">&quot;item_name&quot;</span>: <span class="string">&quot;Foo&quot;</span>&#125;, &#123;<span class="string">&quot;item_name&quot;</span>: <span class="string">&quot;Bar&quot;</span>&#125;, &#123;<span class="string">&quot;item_name&quot;</span>: <span class="string">&quot;Baz&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将依赖项从上面的函数common_parameters更改为类CommonQueryParams</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonQueryParams</span>:</span></span><br><span class="line">    <span class="comment"># __init__用于创建类实例的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, q: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>, skip: <span class="built_in">int</span> = <span class="number">0</span>, limit: <span class="built_in">int</span> = <span class="number">100</span></span>):</span></span><br><span class="line">        self.q = q</span><br><span class="line">        self.skip = skip</span><br><span class="line">        self.limit = limit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># 使用这个类来声明依赖</span></span><br><span class="line"><span class="comment"># 这将创建该类的“实例”，并且该实例将作为参数传递commons给函数。</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params">commons: CommonQueryParams = Depends(<span class="params">CommonQueryParams</span>)</span>):</span></span><br><span class="line">    response = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> commons.q:</span><br><span class="line">        response.update(&#123;<span class="string">&quot;q&quot;</span>: commons.q&#125;)</span><br><span class="line">    items = fake_items_db[commons.skip : commons.skip + commons.limit]</span><br><span class="line">    response.update(&#123;<span class="string">&quot;items&quot;</span>: items&#125;)</span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure></p><h3 id="子依赖项"><a href="#子依赖项" class="headerlink" title="子依赖项"></a>子依赖项</h3><p>FastAPI 支持创建含子依赖项的依赖项。<br>并且，可以按需声明任意深度的子依赖项嵌套层级。<br>FastAPI 负责处理解析不同深度的子依赖项。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Cookie, Depends, FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建第一层依赖项</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query_extractor</span>(<span class="params">q: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建另一个依赖项函数，并同时再声明一个依赖项</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query_or_cookie_extractor</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    q: <span class="built_in">str</span> = Depends(<span class="params">query_extractor</span>), last_query: <span class="type">Optional</span>[<span class="built_in">str</span>] = Cookie(<span class="params"><span class="literal">None</span></span>)</span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> q:</span><br><span class="line">        <span class="keyword">return</span> last_query</span><br><span class="line">    <span class="keyword">return</span> q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_query</span>(<span class="params">query_or_default: <span class="built_in">str</span> = Depends(<span class="params">query_or_cookie_extractor</span>)</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;q_or_cookie&quot;</span>: query_or_default&#125;</span><br></pre></td></tr></table></figure><br>如果在同一个路径操作 多次声明了同一个依赖项，例如，多个依赖项共用一个子依赖项，FastAPI 在处理同一请求时，只调用一次该子依赖项。<br>FastAPI 不会为同一个请求多次调用同一个依赖项，而是把依赖项的返回值进行「缓存」，并把它传递给同一请求中所有需要使用该返回值的「依赖项」。<br>在高级使用场景中，如果不想使用「缓存」值，而是为需要在同一请求的每一步操作（多次）中都实际调用依赖项，可以把 Depends 的参数 <code>use_cache</code> 的值设置为 <code>False</code> :<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">needy_dependency</span>(<span class="params">fresh_value: <span class="built_in">str</span> = Depends(<span class="params">get_value, use_cache=<span class="literal">False</span></span>)</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;fresh_value&quot;</span>: fresh_value&#125;</span><br></pre></td></tr></table></figure></p><h3 id="路径操作装饰器中的依赖项"><a href="#路径操作装饰器中的依赖项" class="headerlink" title="路径操作装饰器中的依赖项"></a>路径操作装饰器中的依赖项</h3><p>有时，我们并不需要在路径操作函数中使用依赖项的返回值。或者说，有些依赖项不返回值。<br>但仍要执行或解析该依赖项。<br>对于这种情况，不必在声明路径操作函数的参数时使用 Depends，而是可以在路径操作装饰器中添加一个由 <code>dependencies</code> 组成的 <code>list</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Depends, FastAPI, Header, HTTPException</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">verify_token</span>(<span class="params">x_token: <span class="built_in">str</span> = Header(<span class="params">...</span>)</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x_token != <span class="string">&quot;fake-super-secret-token&quot;</span>:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">400</span>, detail=<span class="string">&quot;X-Token header invalid&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">verify_key</span>(<span class="params">x_key: <span class="built_in">str</span> = Header(<span class="params">...</span>)</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x_key != <span class="string">&quot;fake-super-secret-key&quot;</span>:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">400</span>, detail=<span class="string">&quot;X-Key header invalid&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> x_key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 路径操作装饰器支持可选参数dependencies。</span></span><br><span class="line"><span class="comment"># 该参数的值是由 Depends() 组成的 list</span></span><br><span class="line"><span class="comment"># 路径操作装饰器依赖项（以下简称为“路径装饰器依赖项”）的执行或解析方式和普通依赖项一样，但就算这些依赖项会返回值，它们的值也不会传递给路径操作函数。</span></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span>, dependencies=[Depends(<span class="params">verify_token</span>), Depends(<span class="params">verify_key</span>)]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;item&quot;</span>: <span class="string">&quot;Foo&quot;</span>&#125;, &#123;<span class="string">&quot;item&quot;</span>: <span class="string">&quot;Bar&quot;</span>&#125;]</span><br></pre></td></tr></table></figure></p><h3 id="全局依赖项"><a href="#全局依赖项" class="headerlink" title="全局依赖项"></a>全局依赖项</h3><p>有时，我们要为整个应用添加依赖项。<br>通过与定义路径装饰器依赖项 类似的方式，可以把依赖项添加至整个 FastAPI 应用。<br>这样一来，就可以为所有路径操作应用该依赖项。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Depends, FastAPI, Header, HTTPException</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">verify_token</span>(<span class="params">x_token: <span class="built_in">str</span> = Header(<span class="params">...</span>)</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x_token != <span class="string">&quot;fake-super-secret-token&quot;</span>:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">400</span>, detail=<span class="string">&quot;X-Token header invalid&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">verify_key</span>(<span class="params">x_key: <span class="built_in">str</span> = Header(<span class="params">...</span>)</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x_key != <span class="string">&quot;fake-super-secret-key&quot;</span>:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">400</span>, detail=<span class="string">&quot;X-Key header invalid&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> x_key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局依赖项</span></span><br><span class="line"><span class="comment"># 路径装饰器依赖项一节的思路均适用于全局依赖项</span></span><br><span class="line">app = FastAPI(dependencies=[Depends(verify_token), Depends(verify_key)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;item&quot;</span>: <span class="string">&quot;Portal Gun&quot;</span>&#125;, &#123;<span class="string">&quot;item&quot;</span>: <span class="string">&quot;Plumbus&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/users/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_users</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;username&quot;</span>: <span class="string">&quot;Rick&quot;</span>&#125;, &#123;<span class="string">&quot;username&quot;</span>: <span class="string">&quot;Morty&quot;</span>&#125;]</span><br></pre></td></tr></table></figure></p><h3 id="有yield的依赖项"><a href="#有yield的依赖项" class="headerlink" title="有yield的依赖项"></a>有yield的依赖项</h3><p>FastAPI 支持在完成后执行一些额外步骤的依赖项。<br>为此，请使用<code>yield</code>代替<code>return</code>，并在之后编写额外的步骤。<br>确保使用<code>yield</code>一次。<br>一个典型例子是想在发送请求时创建一个数据库对话，然后发送完成后就关闭它。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># async或普通函数都可以</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_db</span>():</span></span><br><span class="line">    <span class="comment"># 只有在yield之前和包含yield那行代码会在发送请求前执行</span></span><br><span class="line">    db = DBSession()</span><br><span class="line">    <span class="keyword">try</span>: <span class="comment">#使用try能收到异常</span></span><br><span class="line">        <span class="comment"># yield的值会注入到路径操作中，或其他依赖中</span></span><br><span class="line">        <span class="keyword">yield</span> db</span><br><span class="line">    <span class="comment"># 在yield之后的代码会在发送响应后再执行</span></span><br><span class="line">    <span class="keyword">finally</span>: <span class="comment"># 使用finally来确保执行退出步骤，无论是否有异常。</span></span><br><span class="line">        db.close()</span><br></pre></td></tr></table></figure></p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>有许多方法可以处理安全性、身份认证和授权等问题。<br>而且这通常是一个复杂而「困难」的话题。<br>在许多框架和系统中，仅处理安全性和身份认证就会花费大量的精力和代码（在许多情况下，可能占编写的所有代码的 50％ 或更多）。<br>FastAPI 提供了多种工具，可帮助你以标准的方式轻松、快速地处理安全性，而无需研究和学习所有的安全规范。</p><h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><p>（1）OAuth2<br>OAuth2是一个规范，它定义了几种处理身份认证和授权的方法。<br>它是一个相当广泛的规范，涵盖了一些复杂的使用场景。<br>它包括了使用「第三方」进行身份认证的方法。这就是所有带有「使用 Facebook，Google，Twitter，GitHub 登录」的系统背后所使用的机制。<br>有一个 OAuth 1，它与 OAuth2 完全不同，并且更为复杂，因为它直接包含了有关如何加密通信的规范。<br>如今它已经不是很流行，没有被广泛使用了。<br>OAuth2 没有指定如何加密通信，它期望你为应用程序使用 HTTPS 进行通信。<br>（2）OpenID Connect<br>OpenID Connect 是另一个基于 OAuth2 的规范。<br>它只是扩展了 OAuth2，并明确了一些在 OAuth2 中相对模糊的内容，以尝试使其更具互操作性。<br>例如，Google 登录使用 OpenID Connect（底层使用OAuth2）。<br>但是 Facebook 登录不支持 OpenID Connect。它具有自己的 OAuth2 风格。<br>（3）OpenID（非「OpenID Connect」）<br>还有一个「OpenID」规范。它试图解决与 OpenID Connect 相同的问题，但它不是基于 OAuth2。<br>因此，它是一个完整的附加系统。<br>如今它已经不是很流行，没有被广泛使用了。<br>（4）OpenAPI<br>OpenAPI（以前称为 Swagger）是用于构建 API 的开放规范（现已成为 Linux Foundation 的一部分）。<br>FastAPI 基于 OpenAPI。<br>这就是使多个自动交互式文档界面，代码生成等成为可能的原因。<br>OpenAPI 有一种定义多个安全「方案」的方法。<br>通过使用它们，你可以利用所有这些基于标准的工具，包括这些交互式文档系统。<br>OpenAPI 定义了以下安全方案：<br>（4.1）<code>apiKey</code>：一个特定于应用程序的密钥，可以来自：查询参数、请求头、cookie。<br>（4.2）<code>http</code>：标准的 HTTP 身份认证系统，包括：</p><ul><li>bearer: 一个值为 Bearer 加令牌字符串的 Authorization 请求头。这是从 OAuth2 继承的。</li><li>HTTP Basic 认证方式。</li><li>HTTP Digest，等等。</li></ul><p>（4.3）<code>oauth2</code>：所有的 OAuth2 处理安全性的方式（称为「流程」）。<br>以下几种流程适合构建 OAuth 2.0 身份认证的提供者（例如 Google，Facebook，Twitter，GitHub 等）：<code>implicit</code>、<code>clientCredentials</code>、<code>authorizationCode</code>。<br>但是有一个特定的「流程」可以完美地用于直接在同一应用程序中处理身份认证：<code>password</code>：接下来的几章将介绍它的示例。<br>（4.4）<code>openIdConnect</code>：提供了一种定义如何自动发现 OAuth2 身份认证数据的方法。此自动发现机制是 OpenID Connect 规范中定义的内容。</p><h3 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h3><p>假设在某个域中拥有后端API。并且在另一个域或同一域的不同路径中（或在移动应用程序中）有一个前端。<br>此时希望有一种方法让前端使用<code>username</code>和<code>password</code>与后端进行身份验证。<br>我们可以使用FastAPI提供的<code>OAuth2</code>构建它。<br>（注意，需要首先安装<code>python-multipart</code>，这是因为OAuth2使用“表单数据”来发送<code>username</code>和<code>password</code>。）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Depends, FastAPI</span><br><span class="line"><span class="comment"># FastAPI提供了多种不同抽象级别的工具来实现安全功能。</span></span><br><span class="line"><span class="comment"># 在此示例中，将使用OAuth2，配合Password流和Bearer令牌。</span></span><br><span class="line"><span class="comment"># 具体地，使用OAuth2PasswordBearer类来做到这一点。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bearer令牌不是唯一的选择。但它是该用例的最佳选择。</span></span><br><span class="line"><span class="comment"># 对于大多数用例来说，它可能是最好的，除非你是 OAuth2 专家并且确切地知道为什么有另一个选项更适合需求。</span></span><br><span class="line"><span class="keyword">from</span> fastapi.security <span class="keyword">import</span> OAuth2PasswordBearer</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当创建OAuth2PasswordBearer类的实例时，传入tokenUrl参数。</span></span><br><span class="line"><span class="comment"># 此参数包含客户端（在用户浏览器中运行的前端）用于发送username和password以获取令牌的URL。</span></span><br><span class="line"><span class="comment"># 这里的tokenUrl=&quot;token&quot;指的是一个相对URL，所以它相当于./token，不过该URL还尚未创建。</span></span><br><span class="line"><span class="comment"># 因为使用的是相对 URL，如果API位于https://example.com/，那么它将引用https://example.com/token。</span></span><br><span class="line"><span class="comment"># 但如果API 位于https://example.com/api/v1/，那么它就是https://example.com/api/v1/token.</span></span><br><span class="line"><span class="comment"># 使用相对 URL 非常重要，可以确保应用程序即使在像代理服务器后面这样的高级用例中也能正常工作。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tokenUrl=&quot;token&quot;不会创建该路径操作，但声明了/token这个URL将是客户端应该用来获取令牌的URL。该信息在 OpenAPI 中使用，然后在交互式 API 文档系统中使用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># oauth2_scheme变量是OAuth2PasswordBearer的一个实例，但它也是“可调用的”。</span></span><br><span class="line"><span class="comment"># 因此它可被Depends使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 它将查看请求中的Authorization这个header，检查该值是否是Bearer以及一些令牌，并返回str类型的令牌.</span></span><br><span class="line"><span class="comment"># 如果它没有看到Authorization标头，或者该值没有Bearer标记，它将直接返回 401状态代码错误(UNAUTHORIZED)。</span></span><br><span class="line">oauth2_scheme = OAuth2PasswordBearer(tokenUrl=<span class="string">&quot;token&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="comment"># 这个依赖将提供一个str赋值给token这个参数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params">token: <span class="built_in">str</span> = Depends(<span class="params">oauth2_scheme</span>)</span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;token&quot;</span>: token&#125;</span><br></pre></td></tr></table></figure><br>以上只是一个基本框架，还没有实际功能。</p><h3 id="完整功能"><a href="#完整功能" class="headerlink" title="完整功能"></a>完整功能</h3><p>在查看真正的具有安全功能的代码时，需要用到JWT令牌和哈希密码。<br>（1）JWT令牌<br>JWT 表示 「JSON Web Tokens」。<br>它是一个将 JSON 对象编码为密集且没有空格的长字符串的标准。字符串看起来像这样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span><br></pre></td></tr></table></figure><br>它没有被加密，因此任何人都可以从字符串内容中还原数据。<br>但它经过了签名。因此，当你收到一个由你发出的令牌时，可以校验令牌是否真的由你发出。<br>通过这种方式，你可以创建一个有效期为 1 周的令牌。然后当用户第二天使用令牌重新访问时，你知道该用户仍然处于登入状态。<br>一周后令牌将会过期，用户将不会通过认证，必须再次登录才能获得一个新令牌。而且如果用户（或第三方）试图修改令牌以篡改过期时间，你将因为签名不匹配而能够发觉。</p><p>对JWT令牌进行签名，实际就是一个密钥。要生成一个安全的随机密钥，可使用openssl。<br>windows版的openssl可以用别人编译好的，在<a href="https://slproweb.com/products/Win32OpenSSL.html">这里</a>。<br>在终端中使用以下命令：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rand -<span class="built_in">hex</span> <span class="number">32</span></span><br></pre></td></tr></table></figure></p><p>需要安装 python-jose 以在 Python 中生成和校验 JWT 令牌（Python-jose 需要一个额外的加密后端。这里推荐：pyca/cryptography。）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install python-jose[cryptography]</span><br></pre></td></tr></table></figure></p><p>（2）哈希密码<br>「哈希」的意思是：将某些内容（在本例中为密码）转换为看起来像乱码的字节序列（只是一个字符串）。<br>每次你传入完全相同的内容（完全相同的密码）时，你都会得到完全相同的乱码。<br>但是你不能从乱码转换回密码。<br>PassLib 是一个用于处理哈希密码的很棒的 Python 包。<br>它支持许多安全哈希算法以及配合算法使用的实用程序。<br>推荐的算法是 「Bcrypt」。<br>因此，安装附带 Bcrypt 的 PassLib：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install passlib[bcrypt]</span><br></pre></td></tr></table></figure></p><p>完整实例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Depends, FastAPI, HTTPException, status</span><br><span class="line"><span class="comment"># 将使用 FastAPI 的安全性实用工具来获取 username 和 password。</span></span><br><span class="line"><span class="comment"># OAuth2 规定在使用「password 流程」时，客户端/用户必须将 username 和 password 字段作为表单数据发送（因此，此处不能使用 JSON）。</span></span><br><span class="line"><span class="comment"># 而且规范明确了字段必须这样命名。因此 user-name 或 email 是行不通的。</span></span><br><span class="line"><span class="comment"># 不过不用担心，你可以在前端按照你的想法将它展示给最终用户。</span></span><br><span class="line"><span class="comment"># 而且你的数据库模型也可以使用你想用的任何其他名称。</span></span><br><span class="line"><span class="comment"># 但是对于登录路径操作，我们需要使用这些名称来与规范兼容（以具备例如使用集成的 API 文档系统的能力）。</span></span><br><span class="line"><span class="comment"># 具体地，导入 OAuth2PasswordRequestForm</span></span><br><span class="line"><span class="keyword">from</span> fastapi.security <span class="keyword">import</span> OAuth2PasswordBearer, OAuth2PasswordRequestForm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 passlib 导入我们需要的工具。</span></span><br><span class="line"><span class="keyword">from</span> passlib.context <span class="keyword">import</span> CryptContext</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入jwt相关模块</span></span><br><span class="line"><span class="keyword">from</span> jose <span class="keyword">import</span> JWTError, jwt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line"><span class="comment">#################################### JWT相关功能 #####################################</span></span><br><span class="line"><span class="comment"># 在终端中使用openssl rand -hex 32生成如下key</span></span><br><span class="line">SECRET_KEY = <span class="string">&quot;cda3c6e86b29270b741c9e1c62d052f5593921f26ae0badc4027b856f53d679f&quot;</span></span><br><span class="line"><span class="comment"># 创建用于设定 JWT 令牌签名算法的变量 「ALGORITHM」，并将其设置为 &quot;HS256&quot;。</span></span><br><span class="line">ALGORITHM = <span class="string">&quot;HS256&quot;</span></span><br><span class="line"><span class="comment"># 创建一个设置令牌过期时间的变量。</span></span><br><span class="line">ACCESS_TOKEN_EXPIRE_MINUTES = <span class="number">30</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个将在令牌端点中用于响应的 Pydantic 模型。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Token</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    access_token: <span class="built_in">str</span></span><br><span class="line">    token_type: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TokenData</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    username: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个生成新的访问令牌的工具函数。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_access_token</span>(<span class="params">data: <span class="built_in">dict</span>, expires_delta: <span class="type">Optional</span>[timedelta] = <span class="literal">None</span></span>):</span></span><br><span class="line">    to_encode = data.copy()</span><br><span class="line">    <span class="keyword">if</span> expires_delta:</span><br><span class="line">        expire = datetime.utcnow() + expires_delta</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        expire = datetime.utcnow() + timedelta(minutes=<span class="number">15</span>)</span><br><span class="line">    to_encode.update(&#123;<span class="string">&quot;exp&quot;</span>: expire&#125;)</span><br><span class="line">    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)</span><br><span class="line">    <span class="keyword">return</span> encoded_jwt</span><br><span class="line"></span><br><span class="line"><span class="comment">#################################### 数据库相关功能 #####################################</span></span><br><span class="line"><span class="comment"># 假的用户数据库</span></span><br><span class="line">fake_users_db = &#123;</span><br><span class="line">    <span class="string">&quot;johndoe&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: <span class="string">&quot;johndoe&quot;</span>,</span><br><span class="line">        <span class="string">&quot;full_name&quot;</span>: <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">        <span class="string">&quot;email&quot;</span>: <span class="string">&quot;johndoe@example.com&quot;</span>,</span><br><span class="line">        <span class="comment"># 哈希密码，不明文存储，如下是明文密目&quot;secret&quot;的哈希，所以登录时要用secret登录</span></span><br><span class="line">        <span class="string">&quot;hashed_password&quot;</span>: <span class="string">&quot;$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW&quot;</span>,</span><br><span class="line">        <span class="string">&quot;disabled&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个用户 Pydantic 模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    username: <span class="built_in">str</span></span><br><span class="line">    email: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    full_name: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">    disabled: <span class="type">Optional</span>[<span class="built_in">bool</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInDB</span>(<span class="params">User</span>):</span></span><br><span class="line">    hashed_password: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line">oauth2_scheme = OAuth2PasswordBearer(tokenUrl=<span class="string">&quot;token&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#################################### 哈希密码相关功能 #####################################</span></span><br><span class="line"><span class="comment"># 创建一个 PassLib 「上下文」。这将用于哈希和校验密码。</span></span><br><span class="line">pwd_context = CryptContext(schemes=[<span class="string">&quot;bcrypt&quot;</span>], deprecated=<span class="string">&quot;auto&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个工具函数以哈希来自用户的密码。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_password_hash</span>(<span class="params">password</span>):</span></span><br><span class="line">    <span class="keyword">return</span> pwd_context.<span class="built_in">hash</span>(password)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建另一个工具函数，用于校验接收的密码是否与存储的哈希值匹配。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verify_password</span>(<span class="params">plain_password, hashed_password</span>):</span></span><br><span class="line">    <span class="keyword">return</span> pwd_context.verify(plain_password, hashed_password)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_user</span>(<span class="params">db, username: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> username <span class="keyword">in</span> db:</span><br><span class="line">        user_dict = db[username]</span><br><span class="line">        <span class="keyword">return</span> UserInDB(**user_dict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建另一个工具函数用于认证并返回用户。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">authenticate_user</span>(<span class="params">fake_db, username: <span class="built_in">str</span>, password: <span class="built_in">str</span></span>):</span></span><br><span class="line">    user = get_user(fake_db, username)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> user:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> verify_password(password, user.hashed_password):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> user</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 get_current_user 依赖项</span></span><br><span class="line"><span class="comment"># get_current_user将具有一个之前所创建的同一个 oauth2_scheme 作为依赖项。</span></span><br><span class="line"><span class="comment"># 与之前直接在路径操作中所做的相同，新的依赖项 get_current_user 将从子依赖项 oauth2_scheme 中接收一个 str 类型的 token，具体地，就是一个JWT令牌</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_current_user</span>(<span class="params">token: <span class="built_in">str</span> = Depends(<span class="params">oauth2_scheme</span>)</span>):</span></span><br><span class="line">    credentials_exception = HTTPException(</span><br><span class="line">        status_code=status.HTTP_401_UNAUTHORIZED,</span><br><span class="line">        detail=<span class="string">&quot;Could not validate credentials&quot;</span>,</span><br><span class="line">        headers=&#123;<span class="string">&quot;WWW-Authenticate&quot;</span>: <span class="string">&quot;Bearer&quot;</span>&#125;,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 解码接收到的令牌，对其进行校验</span></span><br><span class="line">        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])</span><br><span class="line">        <span class="comment"># JWT 的规范中有一个 sub 键，值为该令牌的主题。</span></span><br><span class="line">        <span class="comment"># 使用它并不是必须的，但这是放置用户标识的地方，所以在示例中使用了它。</span></span><br><span class="line">        username: <span class="built_in">str</span> = payload.get(<span class="string">&quot;sub&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> username <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> credentials_exception</span><br><span class="line">        token_data = TokenData(username=username)</span><br><span class="line">    <span class="comment"># 如果令牌无效，立即返回一个 HTTP 错误。</span></span><br><span class="line">    <span class="keyword">except</span> JWTError:</span><br><span class="line">        <span class="keyword">raise</span> credentials_exception</span><br><span class="line">    <span class="comment"># 然后返回当前用户</span></span><br><span class="line">    user = get_user(fake_users_db, username=token_data.username)</span><br><span class="line">    <span class="keyword">if</span> user <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> credentials_exception</span><br><span class="line">    <span class="keyword">return</span> user</span><br><span class="line"></span><br><span class="line"><span class="comment"># 想要仅当此用户处于启用状态时才能获取 current_user。</span></span><br><span class="line"><span class="comment"># 因此，创建了一个额外的依赖项 get_current_active_user，而该依赖项又以 get_current_user 作为依赖项。</span></span><br><span class="line"><span class="comment"># 如果用户不存在或处于未启用状态，则这两个依赖项都将返回 HTTP 错误。</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_current_active_user</span>(<span class="params">current_user: User = Depends(<span class="params">get_current_user</span>)</span>):</span></span><br><span class="line">    <span class="keyword">if</span> current_user.disabled:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">400</span>, detail=<span class="string">&quot;Inactive user&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> current_user</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在token的路径操作中通过Depends将OAuth2PasswordRequestForm作为依赖项使用</span></span><br><span class="line"><span class="comment"># OAuth2PasswordRequestForm 是一个类依赖项，声明了如下的请求表单：</span></span><br><span class="line"><span class="comment"># - username。</span></span><br><span class="line"><span class="comment"># - password。</span></span><br><span class="line"><span class="comment"># - 一个可选的 scope 字段，但实际上它是一个由空格分隔的「作用域」组成的长字符串。每个「作用域」只是一个字符串（中间没有空格）。它们通常用于声明特定的安全权限，例如：users:read 或者 users:write 是常见的例子。类依赖项 OAuth2PasswordRequestForm 的实例不会有用空格分隔的长字符串属性 scope，而是具有一个 scopes 属性，该属性将包含实际被发送的每个作用域字符串组成的列表。</span></span><br><span class="line"><span class="comment"># - 一个可选的 grant_type.</span></span><br><span class="line"><span class="comment"># - 一个可选的 client_id（该示例不需要它）。</span></span><br><span class="line"><span class="comment"># - 一个可选的 client_secret（该示例不需要它）。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/token&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">login_for_access_token</span>(<span class="params">form_data: OAuth2PasswordRequestForm = Depends(<span class="params"></span>)</span>):</span> <span class="comment">#这个是一个快捷方式</span></span><br><span class="line">    <span class="comment"># 使用表单字段中的 username 从（伪）数据库中获取用户数据。 </span></span><br><span class="line">    <span class="comment"># 如果没有这个用户，我们将返回一个错误消息，提示「用户名或密码错误」。</span></span><br><span class="line">    user = authenticate_user(fake_users_db, form_data.username, form_data.password)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> user:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(</span><br><span class="line">            status_code=status.HTTP_401_UNAUTHORIZED,</span><br><span class="line">            detail=<span class="string">&quot;Incorrect username or password&quot;</span>,</span><br><span class="line">            headers=&#123;<span class="string">&quot;WWW-Authenticate&quot;</span>: <span class="string">&quot;Bearer&quot;</span>&#125;,</span><br><span class="line">        )</span><br><span class="line">    <span class="comment"># 创建一个真实的 JWT 访问令牌 </span></span><br><span class="line">    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)</span><br><span class="line">    access_token = create_access_token(</span><br><span class="line">        data=&#123;<span class="string">&quot;sub&quot;</span>: user.username&#125;, expires_delta=access_token_expires</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># token 端点的响应必须是一个 JSON 对象，里面包含有：</span></span><br><span class="line">    <span class="comment"># （1）token_type字段：在该例中，由于我们使用的是「Bearer」令牌，因此令牌类型应为「bearer」。</span></span><br><span class="line">    <span class="comment"># （2）access_token字段：它是一个包含我们的访问令牌的字符串。</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;access_token&quot;</span>: access_token, <span class="string">&quot;token_type&quot;</span>: <span class="string">&quot;bearer&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意声明响应模型</span></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/users/me/&quot;</span>, response_model=User</span>)</span></span><br><span class="line"><span class="comment"># 在路径操作中使用 get_current_active_user 作为 Depends</span></span><br><span class="line"><span class="comment"># 注意我们将 current_user 的类型声明为 Pydantic 模型 User。</span></span><br><span class="line"><span class="comment"># 这将帮助我们在函数内部使用所有的代码补全和类型检查。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在这个端点中，只有当用户存在，身份认证通过且处于启用状态时，我们才能获得该用户</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_users_me</span>(<span class="params">current_user: User = Depends(<span class="params">get_current_active_user</span>)</span>):</span></span><br><span class="line">    <span class="keyword">return</span> current_user</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/users/me/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_own_items</span>(<span class="params">current_user: User = Depends(<span class="params">get_current_active_user</span>)</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;item_id&quot;</span>: <span class="string">&quot;Foo&quot;</span>, <span class="string">&quot;owner&quot;</span>: current_user.username&#125;]</span><br></pre></td></tr></table></figure></p><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>可以向 FastAPI 应用添加中间件.<br>“中间件”是一个函数,它在每个请求被特定的路径操作处理之前,以及在每个响应返回之前工作.</p><ul><li>它接收你的应用程序的每一个请求.</li><li>然后它可以对这个请求做一些事情或者执行任何需要的代码.</li><li>然后它将请求传递给应用程序的其他部分 (通过某种路径操作).</li><li>然后它获取应用程序生产的响应 (通过某种路径操作).</li><li>它可以对该响应做些什么或者执行任何需要的代码.</li><li>然后它返回这个响应。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Request</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要创建中间件你可以在函数的顶部使用装饰器 @app.middleware(&quot;http&quot;).</span></span><br><span class="line"><span class="comment"># 中间件参数接收如下参数:</span></span><br><span class="line">- request.</span><br><span class="line">- call_next函数：它将接收 request 作为参数.</span><br><span class="line">（<span class="number">1</span>）这个函数将 request 传递给相应的 路径操作.</span><br><span class="line">（<span class="number">2</span>）然后它将返回由相应的路径操作生成的 response.</span><br><span class="line">（<span class="number">3</span>）然后你可以在返回 response 前进一步修改它.</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.middleware(<span class="params"><span class="string">&quot;http&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">add_process_time_header</span>(<span class="params">request: Request, call_next</span>):</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    response = <span class="keyword">await</span> call_next(request)</span><br><span class="line">    process_time = time.time() - start_time</span><br><span class="line">    <span class="comment"># 可以 用&#x27;X-&#x27; 前缀添加专有自定义请求头.</span></span><br><span class="line">    <span class="comment"># 但是如果你想让浏览器中的客户端看到你的自定义请求头, 你需要把它们加到 CORS 配置 (CORS (Cross-Origin Resource Sharing)) 的 expose_headers 参数中</span></span><br><span class="line">    response.headers[<span class="string">&quot;X-Process-Time&quot;</span>] = <span class="built_in">str</span>(process_time)</span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><h2 id="CORS跨域资源共享"><a href="#CORS跨域资源共享" class="headerlink" title="CORS跨域资源共享"></a>CORS跨域资源共享</h2><p>CORS 或者「跨域资源共享」 指浏览器中运行的前端拥有与后端通信的 JavaScript 代码，而后端处于与前端不同的「源」的情况。<br>源origin是协议（<code>http</code>，<code>https</code>）、域（<code>myapp.com</code>，<code>localhost</code>，<code>localhost.tiangolo.com</code>）以及端口（<code>80</code>、<code>443</code>、<code>8080</code>）的组合。</p><p>因此，这些都是不同的源：<code>http://localhost</code>、<code>https://localhost</code>、<code>http://localhost:8080</code>。<br>即使它们都在 localhost 中，但是它们使用不同的协议或者端口，所以它们都是不同的「源」。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>假设你的浏览器中有一个前端运行在<code>http://localhost:8080</code>，并且它的 JavaScript 正在尝试与运行在<code>http://localhost</code>的后端通信（因为我们没有指定端口，浏览器会采用默认的端口<code>80</code>）。<br>然后，浏览器会向后端发送一个 <code>HTTP OPTIONS</code> 请求，如果后端发送适当的 <code>headers</code> 来授权来自这个不同源（<code>http://localhost:8080</code>）的通信，浏览器将允许前端的 JavaScript 向后端发送请求。<br>为此，后端必须有一个「允许的源」列表。<br>在这种情况下，它必须包含<code>http://localhost:8080</code>，前端才能正常工作。</p><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>也可以使用 “*”（一个「通配符」）声明这个列表，表示全部都是允许的。<br>但这仅允许某些类型的通信，不包括所有涉及凭据的内容：像 Cookies 以及那些使用 Bearer 令牌的授权 headers 等。<br>因此，为了一切都能正常工作，最好显式地指定允许的源。</p><h3 id="使用CORSMiddleware"><a href="#使用CORSMiddleware" class="headerlink" title="使用CORSMiddleware"></a>使用CORSMiddleware</h3><p>可以在 FastAPI 应用中使用 CORSMiddleware 来配置它。<br>（1）导入 CORSMiddleware。<br>（2）创建一个允许的源列表（由字符串组成）。<br>（3）将其作为「中间件」添加到你的 FastAPI 应用中。</p><p>也可以指定后端是否允许：<br>（1）凭证（授权 headers，Cookies 等）。<br>（2）特定的 HTTP 方法（POST，PUT）或者使用通配符 “<em>“ 允许所有方法。<br>（3）特定的 HTTP headers 或者使用通配符 “</em>“ 允许所有 headers。</p><p>默认情况下，这个 CORSMiddleware 实现所使用的默认参数较为保守，所以你需要显式地启用特定的源、方法或者 headers，以便浏览器能够在跨域上下文中使用它们。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> fastapi.middleware.cors <span class="keyword">import</span> CORSMiddleware</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line">origins = [</span><br><span class="line">    <span class="string">&quot;http://localhost.tiangolo.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://localhost.tiangolo.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://localhost&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://localhost:8080&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">app.add_middleware(</span><br><span class="line">    CORSMiddleware,</span><br><span class="line">    <span class="comment"># allow_origins：一个允许跨域请求的源列表。例如 [&#x27;https://example.org&#x27;, &#x27;https://www.example.org&#x27;]。可以使用 [&#x27;*&#x27;] 允许任何源。</span></span><br><span class="line">    allow_origins=origins,</span><br><span class="line">    <span class="comment"># allow_credentials：指示跨域请求支持 cookies。默认是 False。另外，允许凭证时 allow_origins 不能设定为 [&#x27;*&#x27;]，必须指定源。</span></span><br><span class="line">    allow_credentials=<span class="literal">True</span>,</span><br><span class="line">    <span class="comment"># allow_methods：一个允许跨域请求的 HTTP 方法列表。默认为 [&#x27;GET&#x27;]。你可以使用 [&#x27;*&#x27;] 来允许所有标准方法。</span></span><br><span class="line">    allow_methods=[<span class="string">&quot;*&quot;</span>],</span><br><span class="line">    <span class="comment"># allow_headers：一个允许跨域请求的 HTTP 请求头列表。默认为 []。你可以使用 [&#x27;*&#x27;] 允许所有的请求头。</span></span><br><span class="line">    <span class="comment"># Accept、Accept-Language、Content-Language 以及 Content-Type 请求头总是允许 CORS 请求。</span></span><br><span class="line">    allow_headers=[<span class="string">&quot;*&quot;</span>],</span><br><span class="line">    <span class="comment"># 还有其他，比如：</span></span><br><span class="line">    <span class="comment"># allow_origin_regex：一个正则表达式字符串，匹配的源允许跨域请求。例如 &#x27;https://.*\.example\.org&#x27;。</span></span><br><span class="line">    <span class="comment"># expose_headers：指示可以被浏览器访问的响应头。默认为 []。</span></span><br><span class="line">    <span class="comment"># max_age：设定浏览器缓存 CORS 响应的最长时间，单位是秒。默认为 600。</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello World&quot;</span>&#125;</span><br></pre></td></tr></table></figure><br>中间件响应两种特定类型的 HTTP 请求：<br>（1）CORS 预检请求<br>这是些带有 Origin 和 Access-Control-Request-Method 请求头的 OPTIONS 请求。<br>在这种情况下，中间件将拦截传入的请求并进行响应，出于提供信息的目的返回一个使用了适当的 CORS headers 的 200 或 400 响应。<br>（2）简单请求<br>任何带有 Origin 请求头的请求。在这种情况下，中间件将像平常一样传递请求，但是在响应中包含适当的 CORS headers。</p><h2 id="SQL数据库"><a href="#SQL数据库" class="headerlink" title="SQL数据库"></a>SQL数据库</h2><p>FastAPI不要求使用 SQL（关系）数据库。不过可以使用任何想要的关系数据库（通过SQLAlchemy实现）。<br>在下面示例中，将使用SQLite，因为它使用单个文件并且 Python 具有集成支持。对于大的生产应用程序，可能希望使用像PostgreSQL这样的数据库服务器。<br><a href="https://github.com/tiangolo/full-stack-fastapi-postgresql">这里</a>有一个带有FastAPI和PostgreSQL的官方项目生成器，全部基于Docker，包括前端和更多工具。</p><p>首先需要安装SQLAlchemy：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install SQLAlchemy</span><br></pre></td></tr></table></figure></p><p>文件结构：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── sql_app</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    ├── crud.py</span><br><span class="line">    ├── database.py</span><br><span class="line">    ├── main.py</span><br><span class="line">    ├── models.py</span><br><span class="line">    └── schemas.py</span><br></pre></td></tr></table></figure><br>（1）对于database.py文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 SQLAlchemy 部件</span></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为 SQLAlchemy 创建数据库 URL</span></span><br><span class="line">SQLALCHEMY_DATABASE_URL = <span class="string">&quot;sqlite:///./sql_app.db&quot;</span></span><br><span class="line"><span class="comment"># SQLALCHEMY_DATABASE_URL = &quot;postgresql://user:password@postgresserver/db&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 SQLAlchemy engine</span></span><br><span class="line">engine = create_engine(</span><br><span class="line">    <span class="comment"># connect_args仅用于SQLite. 其他数据库不需要它</span></span><br><span class="line">    <span class="comment"># 默认情况下，SQLite只允许一个线程与其通信，假设每个线程将处理一个独立的请求。</span></span><br><span class="line">    <span class="comment"># 这是为了防止意外地为不同的事物（不同的请求）共享相同的连接。</span></span><br><span class="line">    <span class="comment"># 但是在 FastAPI 中，使用普通函数 ( def) 多个线程可以为同一个请求与数据库交互，因此我们需要让 SQLite 知道它应该允许这个connect_args=&#123;&quot;check_same_thread&quot;: False&#125;</span></span><br><span class="line">    <span class="comment"># 此外，我们将确保每个请求获得自己的数据库连接会话，因此不需要该默认机制。</span></span><br><span class="line">    SQLALCHEMY_DATABASE_URL, connect_args=&#123;<span class="string">&quot;check_same_thread&quot;</span>: <span class="literal">False</span>&#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 创建一个SessionLocal类</span></span><br><span class="line"><span class="comment"># SessionLocal类的每一个实例都是一个数据库会话。该类本身并不是数据库会话。</span></span><br><span class="line">SessionLocal = sessionmaker(autocommit=<span class="literal">False</span>, autoflush=<span class="literal">False</span>, bind=engine)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用declarative_base()返回一个类。</span></span><br><span class="line"><span class="comment"># 稍后将从这个类继承来创建每个数据库模型或类（ORM 模型）：</span></span><br><span class="line">Base = declarative_base()</span><br></pre></td></tr></table></figure><br>（2）对于models.py文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Boolean, Column, ForeignKey, Integer, String</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> relationship</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从database.py文件中导入Base类</span></span><br><span class="line"><span class="keyword">from</span> .database <span class="keyword">import</span> Base</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Base的子类，这些类都是SQLAlchemy模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">Base</span>):</span></span><br><span class="line">    <span class="comment"># __tablename__属性告诉SQLAlchemy这些模型在数据库中的文件</span></span><br><span class="line">    __tablename__ = <span class="string">&quot;users&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建模型字段，每个字段在数据库中都是一列Column，也就是数据表的字段</span></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>, index=<span class="literal">True</span>)</span><br><span class="line">    email = Column(String, unique=<span class="literal">True</span>, index=<span class="literal">True</span>)</span><br><span class="line">    hashed_password = Column(String)</span><br><span class="line">    is_active = Column(Boolean, default=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建数据表之间的关系</span></span><br><span class="line">    items = relationship(<span class="string">&quot;Item&quot;</span>, back_populates=<span class="string">&quot;owner&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">Base</span>):</span></span><br><span class="line">    __tablename__ = <span class="string">&quot;items&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>, index=<span class="literal">True</span>)</span><br><span class="line">    title = Column(String, index=<span class="literal">True</span>)</span><br><span class="line">    description = Column(String, index=<span class="literal">True</span>)</span><br><span class="line">    owner_id = Column(Integer, ForeignKey(<span class="string">&quot;users.id&quot;</span>))</span><br><span class="line"></span><br><span class="line">    owner = relationship(<span class="string">&quot;User&quot;</span>, back_populates=<span class="string">&quot;items&quot;</span>)</span><br></pre></td></tr></table></figure><br>（3）对于schemas.py文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了不搞混SQLAlchemy模型和Pydantic模型，就用models.py存放SQLAlchemy模型，而该文件schemas.py存放Pydantic模型</span></span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建ItemBase这一Pydantic模型，作为一个盛放关于item统一属性的模型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ItemBase</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    title: <span class="built_in">str</span></span><br><span class="line">    description: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ItemCreate</span>(<span class="params">ItemBase</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>(<span class="params">ItemBase</span>):</span></span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span></span><br><span class="line">    owner_id: <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用config属性对Pydantic模型进行配置</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Config</span>:</span></span><br><span class="line">        <span class="comment"># orm_mode参数告诉Pydantic模型读取数据，即使它不是一个dict，而是一个ORM模型（或其他任意带属性的对象）</span></span><br><span class="line">        <span class="comment"># 此时它会尝试通过id = data.id这样获取属性的方式来读取数据，</span></span><br><span class="line">        <span class="comment"># 而不是id = data[&#x27;id&#x27;]这样字典读key的方法</span></span><br><span class="line">        <span class="comment"># 这样Pydantic模型就与ORM模型可以兼容，</span></span><br><span class="line">        <span class="comment"># 在路径操作中也可使用response_model来声明</span></span><br><span class="line">        orm_mode = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserBase</span>(<span class="params">BaseModel</span>):</span></span><br><span class="line">    email: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserCreate</span>(<span class="params">UserBase</span>):</span></span><br><span class="line">    password: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">UserBase</span>):</span></span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">int</span></span><br><span class="line">    is_active: <span class="built_in">bool</span></span><br><span class="line">    items: <span class="type">List</span>[Item] = []</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Config</span>:</span></span><br><span class="line">        orm_mode = <span class="literal">True</span></span><br></pre></td></tr></table></figure></p><p>（4）对于crud.py文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 该文件就是对数据库的操作，即增删改查</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从SQLAlchemy.orm中导入Session，这将允许对下面的db参数进行类型声明，从而有类型检查和补全功能</span></span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> Session</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入SQLAlchemy模型和Pydantic模型</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> models, schemas</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建几个工具函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># （1）通过id读取单个用户</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_user</span>(<span class="params">db: Session, user_id: <span class="built_in">int</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> db.query(models.User).<span class="built_in">filter</span>(models.User.<span class="built_in">id</span> == user_id).first()</span><br><span class="line"><span class="comment"># （2）通过邮箱读取单个用户</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_user_by_email</span>(<span class="params">db: Session, email: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> db.query(models.User).<span class="built_in">filter</span>(models.User.email == email).first()</span><br><span class="line"></span><br><span class="line"><span class="comment"># （3）读取多个用户</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_users</span>(<span class="params">db: Session, skip: <span class="built_in">int</span> = <span class="number">0</span>, limit: <span class="built_in">int</span> = <span class="number">100</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> db.query(models.User).offset(skip).limit(limit).<span class="built_in">all</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># （4）创建一个用户</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_user</span>(<span class="params">db: Session, user: schemas.UserCreate</span>):</span></span><br><span class="line">    fake_hashed_password = user.password + <span class="string">&quot;notreallyhashed&quot;</span></span><br><span class="line">    db_user = models.User(email=user.email, hashed_password=fake_hashed_password)</span><br><span class="line">    <span class="comment"># add添加实例对象</span></span><br><span class="line">    db.add(db_user)</span><br><span class="line">    <span class="comment"># commit提交更改</span></span><br><span class="line">    db.commit()</span><br><span class="line">    <span class="comment"># refresh刷新以获得最新数据</span></span><br><span class="line">    db.refresh(db_user)</span><br><span class="line">    <span class="keyword">return</span> db_user</span><br><span class="line"></span><br><span class="line"><span class="comment"># （5）读取多个items</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_items</span>(<span class="params">db: Session, skip: <span class="built_in">int</span> = <span class="number">0</span>, limit: <span class="built_in">int</span> = <span class="number">100</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> db.query(models.Item).offset(skip).limit(limit).<span class="built_in">all</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># （6）创建一个item</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_user_item</span>(<span class="params">db: Session, item: schemas.ItemCreate, user_id: <span class="built_in">int</span></span>):</span></span><br><span class="line">    <span class="comment"># **是用来解包，并且附加另一个参数</span></span><br><span class="line">    db_item = models.Item(**item.<span class="built_in">dict</span>(), owner_id=user_id)</span><br><span class="line">    db.add(db_item)</span><br><span class="line">    db.commit()</span><br><span class="line">    db.refresh(db_item)</span><br><span class="line">    <span class="keyword">return</span> db_item</span><br></pre></td></tr></table></figure></p><p>（5）对于main.py文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Depends, FastAPI, HTTPException</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> Session</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> crud, models, schemas</span><br><span class="line"><span class="keyword">from</span> .database <span class="keyword">import</span> SessionLocal, engine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据库的数据表</span></span><br><span class="line"><span class="comment"># 通常，可能会使用Alembic初始化数据库（创建表等）。</span></span><br><span class="line"><span class="comment"># 还可以使用 Alembic 进行“迁移”（这是它的主要工作）。</span></span><br><span class="line"><span class="comment"># “迁移”是每当更改 SQLAlchemy 模型的结构、添加新属性等以在数据库中复制这些更改、添加新列、新表等时所需的一组步骤。</span></span><br><span class="line"><span class="comment"># 可以在Project Generation - Template的模板中找到一个 FastAPI 项目中的 Alembic 示例。</span></span><br><span class="line">models.Base.metadata.create_all(bind=engine)</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个依赖项</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_db</span>():</span></span><br><span class="line">    <span class="comment"># 每个请求都有一个独立的会话，请求结束后就关闭它</span></span><br><span class="line">    <span class="comment"># 但所有会话都是同一个</span></span><br><span class="line">    db = SessionLocal()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># yield的用法可以参考之前部分</span></span><br><span class="line">        <span class="keyword">yield</span> db</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        db.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/users/&quot;</span>, response_model=schemas.User</span>)</span></span><br><span class="line"><span class="comment"># 在路径操作中都使用上述依赖</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_user</span>(<span class="params">user: schemas.UserCreate, db: Session = Depends(<span class="params">get_db</span>)</span>):</span></span><br><span class="line">    db_user = crud.get_user_by_email(db, email=user.email)</span><br><span class="line">    <span class="keyword">if</span> db_user:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">400</span>, detail=<span class="string">&quot;Email already registered&quot;</span>)</span><br><span class="line">    <span class="comment"># 返回的是SQLAlchemy模型，但是因为设置了orm_mode，就能与响应模型兼容</span></span><br><span class="line">    <span class="keyword">return</span> crud.create_user(db=db, user=user)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/users/&quot;</span>, response_model=<span class="type">List</span>[schemas.User]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_users</span>(<span class="params">skip: <span class="built_in">int</span> = <span class="number">0</span>, limit: <span class="built_in">int</span> = <span class="number">100</span>, db: Session = Depends(<span class="params">get_db</span>)</span>):</span></span><br><span class="line">    users = crud.get_users(db, skip=skip, limit=limit)</span><br><span class="line">    <span class="keyword">return</span> users</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/users/&#123;user_id&#125;&quot;</span>, response_model=schemas.User</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_user</span>(<span class="params">user_id: <span class="built_in">int</span>, db: Session = Depends(<span class="params">get_db</span>)</span>):</span></span><br><span class="line">    db_user = crud.get_user(db, user_id=user_id)</span><br><span class="line">    <span class="keyword">if</span> db_user <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">404</span>, detail=<span class="string">&quot;User not found&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> db_user</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/users/&#123;user_id&#125;/items/&quot;</span>, response_model=schemas.Item</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_item_for_user</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    user_id: <span class="built_in">int</span>, item: schemas.ItemCreate, db: Session = Depends(<span class="params">get_db</span>)</span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br><span class="line">    <span class="keyword">return</span> crud.create_user_item(db=db, item=item, user_id=user_id)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span>, response_model=<span class="type">List</span>[schemas.Item]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_items</span>(<span class="params">skip: <span class="built_in">int</span> = <span class="number">0</span>, limit: <span class="built_in">int</span> = <span class="number">100</span>, db: Session = Depends(<span class="params">get_db</span>)</span>):</span></span><br><span class="line">    items = crud.get_items(db, skip=skip, limit=limit)</span><br><span class="line">    <span class="keyword">return</span> items</span><br></pre></td></tr></table></figure></p><p>运行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uvicorn sql_app.main:app --reload</span><br></pre></td></tr></table></figure><br>注意得在包外面，按如上方式运行。因为文件内有相对路径导入。</p><p>查看SQLite数据，可以使用在线工具，如<a href="https://inloop.github.io/sqlite-viewer/">https://inloop.github.io/sqlite-viewer/</a>。</p><h2 id="大型项目的文件组织"><a href="#大型项目的文件组织" class="headerlink" title="大型项目的文件组织"></a>大型项目的文件组织</h2><p>如果正在开发一个应用程序或 Web API，很少会将所有的内容都放在一个文件中。<br>FastAPI 提供了一个方便的工具，可以在保持所有灵活性的同时构建你的应用程序。<br>如果你来自 Flask，那这将相当于 Flask 的 Blueprints。</p><p>文件结构：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── app                  <span class="comment"># 「app」是一个 Python 包</span></span><br><span class="line">│   ├── __init__.py      <span class="comment"># 这个文件使「app」成为一个 Python 包</span></span><br><span class="line">│   ├── main.py          <span class="comment"># 「main」模块，例如 import app.main</span></span><br><span class="line">│   ├── dependencies.py  <span class="comment"># 「dependencies」模块，例如 import app.dependencies</span></span><br><span class="line">│   └── routers          <span class="comment"># 「routers」是一个「Python 子包」</span></span><br><span class="line">│   │   ├── __init__.py  <span class="comment"># 使「routers」成为一个「Python 子包」</span></span><br><span class="line">│   │   ├── items.py     <span class="comment"># 「items」子模块，例如 import app.routers.items</span></span><br><span class="line">│   │   └── users.py     <span class="comment"># 「users」子模块，例如 import app.routers.users</span></span><br><span class="line">│   └── internal         <span class="comment"># 「internal」是一个「Python 子包」</span></span><br><span class="line">│       ├── __init__.py  <span class="comment"># 使「internal」成为一个「Python 子包」</span></span><br><span class="line">│       └── admin.py     <span class="comment"># 「admin」子模块，例如 import app.internal.admin</span></span><br></pre></td></tr></table></figure></p><h3 id="APIRouter路由"><a href="#APIRouter路由" class="headerlink" title="APIRouter路由"></a>APIRouter路由</h3><p>APIRouter可以使得对于不同对象的路径操作写在不同文件中，以使其井井有条。<br>（1）专门用于处理用户逻辑的文件是位于 <code>/app/routers/users.py</code> 的子模块<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 专门处理用户逻辑的路由文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入 APIRouter</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> APIRouter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过与 FastAPI 类相同的方式创建一个「实例」</span></span><br><span class="line">router = APIRouter()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以将 APIRouter 视为一个「迷你 FastAPI」类。</span></span><br><span class="line"><span class="comment"># 所有相同的选项都得到支持。</span></span><br><span class="line"><span class="comment"># 所有相同的 parameters、responses、dependencies、tags 等等。</span></span><br><span class="line"><span class="meta">@router.get(<span class="params"><span class="string">&quot;/users/&quot;</span>, tags=[<span class="string">&quot;users&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_users</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;username&quot;</span>: <span class="string">&quot;Rick&quot;</span>&#125;, &#123;<span class="string">&quot;username&quot;</span>: <span class="string">&quot;Morty&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@router.get(<span class="params"><span class="string">&quot;/users/me&quot;</span>, tags=[<span class="string">&quot;users&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_user_me</span>():</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;username&quot;</span>: <span class="string">&quot;fakecurrentuser&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@router.get(<span class="params"><span class="string">&quot;/users/&#123;username&#125;&quot;</span>, tags=[<span class="string">&quot;users&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_user</span>(<span class="params">username: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;username&quot;</span>: username&#125;</span><br></pre></td></tr></table></figure><br>（2）专门用于处理应用程序中「项目」的路由操作：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> APIRouter, Depends, HTTPException</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ..dependencies <span class="keyword">import</span> get_token_header</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此模块中的所有路径操作都有相同的：</span></span><br><span class="line">    <span class="comment"># 路径 prefix：/items。</span></span><br><span class="line">    <span class="comment"># tags：（仅有一个 items 标签）。</span></span><br><span class="line">    <span class="comment"># 额外的 responses。</span></span><br><span class="line">    <span class="comment"># dependencies：它们都需要我们创建的 X-Token 依赖项。</span></span><br><span class="line"><span class="comment"># 因此，我们可以将其添加到 APIRouter 中，而不是将其添加到每个路径操作中。</span></span><br><span class="line">router = APIRouter(</span><br><span class="line">    prefix=<span class="string">&quot;/items&quot;</span>,</span><br><span class="line">    tags=[<span class="string">&quot;items&quot;</span>],</span><br><span class="line">    dependencies=[Depends(get_token_header)],</span><br><span class="line">    responses=&#123;<span class="number">404</span>: &#123;<span class="string">&quot;description&quot;</span>: <span class="string">&quot;Not found&quot;</span>&#125;&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_items_db = &#123;<span class="string">&quot;plumbus&quot;</span>: &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Plumbus&quot;</span>&#125;, <span class="string">&quot;gun&quot;</span>: &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Portal Gun&quot;</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@router.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>():</span></span><br><span class="line">    <span class="keyword">return</span> fake_items_db</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@router.get(<span class="params"><span class="string">&quot;/&#123;item_id&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_item</span>(<span class="params">item_id: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> item_id <span class="keyword">not</span> <span class="keyword">in</span> fake_items_db:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">404</span>, detail=<span class="string">&quot;Item not found&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;name&quot;</span>: fake_items_db[item_id][<span class="string">&quot;name&quot;</span>], <span class="string">&quot;item_id&quot;</span>: item_id&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@router.put(<span class="params"></span></span></span><br><span class="line"><span class="meta"><span class="params">    <span class="string">&quot;/&#123;item_id&#125;&quot;</span>,</span></span></span><br><span class="line"><span class="meta"><span class="params">    <span class="comment"># 仍然可以添加更多将会应用于特定的路径操作的tags，以及一些特定于该路径操作的额外 responses</span></span></span></span><br><span class="line"><span class="meta"><span class="params">    <span class="comment"># 最后的这个路径操作将包含标签的组合：[&quot;items&quot;，&quot;custom&quot;]。</span></span></span></span><br><span class="line"><span class="meta"><span class="params">    <span class="comment"># 并且在文档中也会有两个响应，一个用于 404，一个用于 403。</span></span></span></span><br><span class="line"><span class="meta"><span class="params">    tags=[<span class="string">&quot;custom&quot;</span>],</span></span></span><br><span class="line"><span class="meta"><span class="params">    responses=&#123;<span class="number">403</span>: &#123;<span class="string">&quot;description&quot;</span>: <span class="string">&quot;Operation forbidden&quot;</span>&#125;&#125;,</span></span></span><br><span class="line"><span class="meta"><span class="params"></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_item</span>(<span class="params">item_id: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> item_id != <span class="string">&quot;plumbus&quot;</span>:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(</span><br><span class="line">            status_code=<span class="number">403</span>, detail=<span class="string">&quot;You can only update the item: plumbus&quot;</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;item_id&quot;</span>: item_id, <span class="string">&quot;name&quot;</span>: <span class="string">&quot;The great Plumbus&quot;</span>&#125;</span><br></pre></td></tr></table></figure></p><p>也可以在另一个 APIRouter 中包含 APIRouter，通过：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.include_router(other_router)</span><br></pre></td></tr></table></figure><br>请确保在你将 <code>router</code> 包含到 FastAPI 应用程序之前进行此操作，以便 <code>other_router</code> 中的路径操作也能被包含进来。</p><p>（3）现在，假设你的组织为你提供了 <code>app/internal/admin.py</code> 文件。<br>它包含一个带有一些由你的组织在多个项目之间共享的管理员路径操作的 <code>APIRouter</code>。<br>对于此示例，它将非常简单。但是假设由于它是与组织中的其他项目所共享的，因此我们无法对其进行修改，以及直接在 APIRouter 中添加 <code>prefix</code>、<code>dependencies</code>、<code>tags</code> 等：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> APIRouter</span><br><span class="line"></span><br><span class="line">router = APIRouter()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@router.post(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">update_admin</span>():</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Admin getting schwifty&quot;</span>&#125;</span><br></pre></td></tr></table></figure><br>但是我们仍然希望在包含 APIRouter 时设置一个自定义的 <code>prefix</code>，以便其所有路径操作以 <code>/admin</code> 开头，我们希望使用本项目已经有的 <code>dependencies</code> 保护它，并且我们希望它包含自定义的 <code>tags</code> 和 <code>responses</code>。<br>这些将在主体文件<code>main.py</code>中实现。</p><h3 id="依赖项-1"><a href="#依赖项-1" class="headerlink" title="依赖项"></a>依赖项</h3><p>我们将需要一些在应用程序的好几个地方所使用的依赖项。<br>因此，将它们放在 <code>dependencies</code> 模块（<code>app/dependencies.py</code>）中。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Header, HTTPException</span><br><span class="line"><span class="comment"># 我们正在使用虚构的请求首部来简化此示例。</span></span><br><span class="line"><span class="comment"># 但在实际情况下，使用集成的安全性实用工具会得到更好的效果。</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_token_header</span>(<span class="params">x_token: <span class="built_in">str</span> = Header(<span class="params">...</span>)</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x_token != <span class="string">&quot;fake-super-secret-token&quot;</span>:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">400</span>, detail=<span class="string">&quot;X-Token header invalid&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_query_token</span>(<span class="params">token: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> token != <span class="string">&quot;jessica&quot;</span>:</span><br><span class="line">        <span class="keyword">raise</span> HTTPException(status_code=<span class="number">400</span>, detail=<span class="string">&quot;No Jessica token provided&quot;</span>)</span><br></pre></td></tr></table></figure><br>所有的这些路径操作都将在自身之前计算/执行 dependencies 列表。</p><ul><li>如果你还在一个具体的路径操作中声明了依赖项，它们也会被执行。</li><li>路由器的依赖项最先执行，然后是装饰器中的 dependencies，再然后是普通的参数依赖项。</li><li>你还可以添加具有 scopes 的 Security 依赖项。</li></ul><h3 id="主体"><a href="#主体" class="headerlink" title="主体"></a>主体</h3><p><code>app/main.py</code>模块导入并使用 FastAPI 类。<br>这将是你的应用程序中将所有内容联结在一起的主文件。<br>并且由于你的大部分逻辑现在都存在于其自己的特定模块中，因此主文件的内容将非常简单。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Depends, FastAPI</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .dependencies <span class="keyword">import</span> get_query_token, get_token_header</span><br><span class="line"><span class="keyword">from</span> .internal <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> .routers <span class="keyword">import</span> items, users</span><br><span class="line"></span><br><span class="line"><span class="comment"># 甚至可以声明全局依赖项，它会和每个 APIRouter 的依赖项组合在一起：</span></span><br><span class="line">app = FastAPI(dependencies=[Depends(get_query_token)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含来自 users 和 items 子模块的 router。</span></span><br><span class="line"><span class="comment"># 使用 app.include_router()，我们可以将每个 APIRouter 添加到主 FastAPI 应用程序中。</span></span><br><span class="line">app.include_router(users.router)</span><br><span class="line">app.include_router(items.router)</span><br><span class="line"><span class="comment"># 通过将以下这些参数传递给 app.include_router() 来完成所有的声明，而不必修改原始的 APIRouter</span></span><br><span class="line"><span class="comment"># 这样，原始的APIRouter将保持不变，因此我们仍然可以与组织中的其他项目共享相同的 app/internal/admin.py 文件。</span></span><br><span class="line"><span class="comment"># 但这只会影响我们应用中的 APIRouter，而不会影响使用它的任何其他代码。</span></span><br><span class="line"><span class="comment"># 因此，举例来说，其他项目能够以不同的身份认证方法使用相同的 APIRouter。</span></span><br><span class="line">app.include_router(</span><br><span class="line">    admin.router,</span><br><span class="line">    prefix=<span class="string">&quot;/admin&quot;</span>,</span><br><span class="line">    tags=[<span class="string">&quot;admin&quot;</span>],</span><br><span class="line">    dependencies=[Depends(get_token_header)],</span><br><span class="line">    responses=&#123;<span class="number">418</span>: &#123;<span class="string">&quot;description&quot;</span>: <span class="string">&quot;I&#x27;m a teapot&quot;</span>&#125;&#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以直接将路径操作添加到 FastAPI 应用中</span></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">root</span>():</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello Bigger Applications!&quot;</span>&#125;</span><br></pre></td></tr></table></figure></p><h2 id="后台任务"><a href="#后台任务" class="headerlink" title="后台任务"></a>后台任务</h2><p>可以定义在返回响应后运行的后台任务。<br>这对于需要在请求之后发生的操作很有用，但客户端实际上不必在接收响应之前等待操作完成。<br>这包括，例如：<br>（1）执行操作后发送的电子邮件通知： 由于连接到电子邮件服务器并发送电子邮件往往“慢”（几秒钟），可以立即返回响应并在后台发送电子邮件通知。<br>（2）处理数据：例如，假设您收到一个必须经过缓慢处理的文件，您可以返回“已接受”（HTTP 202）的响应并在后台处理它。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入BackgroundTasks</span></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> BackgroundTasks, FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个作为后台任务运行的函数。</span></span><br><span class="line"><span class="comment"># 它是一个可以接收参数的标准函数。</span></span><br><span class="line"><span class="comment"># 它可以是一个async def或普通def函数，FastAPI会知道如何正确处理它。</span></span><br><span class="line"><span class="comment"># 该例中任务函数将写入文件（模拟发送电子邮件的场景）。</span></span><br><span class="line"><span class="comment"># 并且由于写操作不使用async和await，我们用 normal 定义函数def：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_notification</span>(<span class="params">email: <span class="built_in">str</span>, message=<span class="string">&quot;&quot;</span></span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;log.txt&quot;</span>, mode=<span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> email_file:</span><br><span class="line">        content = <span class="string">f&quot;notification for <span class="subst">&#123;email&#125;</span>: <span class="subst">&#123;message&#125;</span>&quot;</span></span><br><span class="line">        email_file.write(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/send-notification/&#123;email&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">send_notification</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    email: <span class="built_in">str</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 定义一个参数，其类型声明为：BackgroundTasks </span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># FastAPI将为您创建类型的对象BackgroundTasks并将其作为该参数传递。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    background_tasks: BackgroundTasks</span>):</span></span><br><span class="line">    <span class="comment"># 在路径操作函数内部，使用以下方法将任务函数传递给后台任务对象</span></span><br><span class="line">    background_tasks.add_task(write_notification, email, message=<span class="string">&quot;some notification&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Notification sent in the background&quot;</span>&#125;</span><br></pre></td></tr></table></figure></p><p>注意：<br>如果需要执行繁重的后台计算并且不一定需要它由同一进程运行（例如，不需要共享内存、变量等），可能会受益于使用其他更大的工具，例如Celery。<br>它们往往需要更复杂的配置，消息/作业队列管理器，如 RabbitMQ 或 Redis，但它们允许在多个进程中运行后台任务，尤其是在多个服务器中。<br>要查看示例，请查看Project Generators，它们都包含已配置的 Celery。<br>但是，如您需要从同一个FastAPI应用程序访问变量和对象，或者需要执行小型后台任务（例如发送电子邮件通知），只需使用BackgroundTasks.</p><h3 id="依赖注入-1"><a href="#依赖注入-1" class="headerlink" title="依赖注入"></a>依赖注入</h3><p><code>BackgroundTasks</code>也适用于依赖注入系统。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> BackgroundTasks, Depends, FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_log</span>(<span class="params">message: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;log.txt&quot;</span>, mode=<span class="string">&quot;a&quot;</span>) <span class="keyword">as</span> log:</span><br><span class="line">        log.write(message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_query</span>(<span class="params">background_tasks: BackgroundTasks, q: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> q:</span><br><span class="line">        message = <span class="string">f&quot;found query: <span class="subst">&#123;q&#125;</span>\n&quot;</span></span><br><span class="line">        background_tasks.add_task(write_log, message)</span><br><span class="line">    <span class="keyword">return</span> q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/send-notification/&#123;email&#125;&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">send_notification</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 在此示例中，消息将在发送响应后写入文件log.txt。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 如果请求中有查询，它将在后台任务中写入日志。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="comment"># 然后在路径操作函数处生成的另一个后台任务将使用email路径参数写入一条消息。</span></span></span></span><br><span class="line"><span class="function"><span class="params">    email: <span class="built_in">str</span>, background_tasks: BackgroundTasks, q: <span class="built_in">str</span> = Depends(<span class="params">get_query</span>)</span></span></span><br><span class="line"><span class="function"><span class="params"></span>):</span></span><br><span class="line">    message = <span class="string">f&quot;message to <span class="subst">&#123;email&#125;</span>\n&quot;</span></span><br><span class="line">    background_tasks.add_task(write_log, message)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Message sent&quot;</span>&#125;</span><br></pre></td></tr></table></figure></p><h2 id="元数据和文档URL"><a href="#元数据和文档URL" class="headerlink" title="元数据和文档URL"></a>元数据和文档URL</h2><p>可以在 FastAPI 应用中自定义几个元数据配置。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">description = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">ChimichangApp API helps you do awesome stuff. 🚀</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Items</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">You can **read items**.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Users</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">You will be able to:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* **Create users** (_not implemented_).</span></span><br><span class="line"><span class="string">* **Read users** (_not implemented_).</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">app = FastAPI(</span><br><span class="line">    <span class="comment"># Title：在 OpenAPI 和自动 API 文档用户界面中作为 API 的标题/名称使用。</span></span><br><span class="line">    title=<span class="string">&quot;ChimichangApp&quot;</span>,</span><br><span class="line">    <span class="comment"># Description：在 OpenAPI 和自动 API 文档用户界面中用作 API 的描述。</span></span><br><span class="line">    description=description,</span><br><span class="line">    <span class="comment"># Version：API 版本，例如 v2 或者 2.5.0。</span></span><br><span class="line">    version=<span class="string">&quot;0.0.1&quot;</span>,</span><br><span class="line">    terms_of_service=<span class="string">&quot;http://example.com/terms/&quot;</span>,</span><br><span class="line">    contact=&#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Deadpoolio the Amazing&quot;</span>,</span><br><span class="line">        <span class="string">&quot;url&quot;</span>: <span class="string">&quot;http://x-force.example.com/contact/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;email&quot;</span>: <span class="string">&quot;dp@x-force.example.com&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    license_info=&#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Apache 2.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;url&quot;</span>: <span class="string">&quot;https://www.apache.org/licenses/LICENSE-2.0.html&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Katana&quot;</span>&#125;]</span><br></pre></td></tr></table></figure></p><h3 id="标签元数据"><a href="#标签元数据" class="headerlink" title="标签元数据"></a>标签元数据</h3><p>也可以使用参数 <code>openapi_tags</code>，为用于分组路径操作的不同标签添加额外的元数据。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接受一个列表，这个列表包含每个标签对应的一个字典。</span></span><br><span class="line"><span class="comment"># 每个标签元数据字典的顺序也定义了在文档用户界面显示的顺序。</span></span><br><span class="line">tags_metadata = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"># name（必要）：一个 str，它与路径操作和 APIRouter 中使用的 tags 参数有相同的标签名。</span></span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;users&quot;</span>,</span><br><span class="line">        <span class="comment"># description：一个用于简短描述标签的 str。它支持 Markdown 并且会在文档用户界面中显示。</span></span><br><span class="line">        <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Operations with users. The **login** logic is also here.&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;items&quot;</span>,</span><br><span class="line">        <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Manage items. So _fancy_ they have their own docs.&quot;</span>,</span><br><span class="line">        <span class="comment"># externalDocs：一个描述外部文档的 dict：</span></span><br><span class="line">            <span class="comment"># description：用于简短描述外部文档的 str。</span></span><br><span class="line">            <span class="comment"># url（必要）：外部文档的 URL str。</span></span><br><span class="line">        <span class="string">&quot;externalDocs&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Items external docs&quot;</span>,</span><br><span class="line">            <span class="string">&quot;url&quot;</span>: <span class="string">&quot;https://fastapi.tiangolo.com/&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">app = FastAPI(openapi_tags=tags_metadata)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 tags 参数和路径操作（以及 APIRouter）一起使用，将其分配给不同的标签</span></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/users/&quot;</span>, tags=[<span class="string">&quot;users&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_users</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Harry&quot;</span>&#125;, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Ron&quot;</span>&#125;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span>, tags=[<span class="string">&quot;items&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_items</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;wand&quot;</span>&#125;, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;flying broom&quot;</span>&#125;]</span><br></pre></td></tr></table></figure></p><h3 id="文档URL"><a href="#文档URL" class="headerlink" title="文档URL"></a>文档URL</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="comment"># 可以配置两个文档用户界面，包括：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     Swagger UI：服务于 /docs。</span></span><br><span class="line"><span class="comment">#         可以使用参数 docs_url 设置它的 URL。</span></span><br><span class="line"><span class="comment">#         可以通过设置 docs_url=None 禁用它。</span></span><br><span class="line"><span class="comment">#     ReDoc：服务于 /redoc。</span></span><br><span class="line"><span class="comment">#         可以使用参数 redoc_url 设置它的 URL。</span></span><br><span class="line"><span class="comment">#         可以通过设置 redoc_url=None 禁用它。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 例如，设置 Swagger UI 服务于 /documentation 并禁用 ReDoc：</span></span><br><span class="line">app = FastAPI(docs_url=<span class="string">&quot;/documentation&quot;</span>, redoc_url=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/items/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_items</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Foo&quot;</span>&#125;]</span><br></pre></td></tr></table></figure><h2 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h2><p>可以使用<code>StaticFiles</code>来挂载静态文件。</p><h2 id="测试客户端"><a href="#测试客户端" class="headerlink" title="测试客户端"></a>测试客户端</h2><p>基于Starlette，测试FastAPI应用程序变得简单而愉快。具体地，它基于Requests，因此非常熟悉和直观。<br>有了它，可以直接将pytest与FastAPI一起使用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="comment"># 导入TestClient</span></span><br><span class="line"><span class="keyword">from</span> fastapi.testclient <span class="keyword">import</span> TestClient</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">read_main</span>():</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;Hello World&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client = TestClient(app)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_read_main</span>():</span></span><br><span class="line">    response = client.get(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">    <span class="keyword">assert</span> response.status_code == <span class="number">200</span></span><br><span class="line">    <span class="keyword">assert</span> response.json() == &#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;Hello World&quot;</span>&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">参考文献：
FastAPI官方文档
中文翻译
（注意，当前2022年5月8日的中文翻译有一些错误）

介绍
FastAPI 是一个用于构建 API 的现代、快速（高性能）的 web 框架，使用 Python 3.6+ 并基于标准的 Python 类型提示。
FastAPI 站在以下巨人的肩膀之上：

 * Starlette负责 web 部分。
 * Pydantic负责数据部分。

安装
1


pip install fastapi


还需要一个 ASGI 服务器，生产环境可以使用Uvicorn或者Hypercorn。
1


pip install uvicorn[standard]
</summary>
    
    
    
    <category term="coding" scheme="http://qixinbo.github.io/categories/coding/"/>
    
    
    <category term="FastAPI" scheme="http://qixinbo.github.io/tags/FastAPI/"/>
    
  </entry>
  
  <entry>
    <title>Docker知识点</title>
    <link href="http://qixinbo.github.io/2022/04/20/docker/"/>
    <id>http://qixinbo.github.io/2022/04/20/docker/</id>
    <published>2022-04-19T16:00:00.000Z</published>
    <updated>2022-04-20T13:22:18.326Z</updated>
    
    <content type="html"><![CDATA[<p>参考文献：<br><a href="https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">Docker 入门教程</a><br><a href="https://yeasy.gitbook.io/docker_practice/">Docker —— 从入门到实践</a><br><a href="https://www.bilibili.com/video/BV1og4y1q7M4">【狂神说Java】Docker最新超详细版教程通俗易懂</a></p><h1 id="为什么要用Docker"><a href="#为什么要用Docker" class="headerlink" title="为什么要用Docker"></a>为什么要用Docker</h1><p>Docker解决的问题是将软件连带其环境一起安装。</p><h2 id="虚拟机与容器"><a href="#虚拟机与容器" class="headerlink" title="虚拟机与容器"></a>虚拟机与容器</h2><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。<br>虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。<br>（1）资源占用多<br>虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。<br>（2）冗余步骤多<br>虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。<br>（3）启动慢<br>启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。</p><h3 id="Linux容器"><a href="#Linux容器" class="headerlink" title="Linux容器"></a>Linux容器</h3><p>由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。<br>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。<br>由于容器是进程级别的，相比虚拟机有很多优势。<br>（1）启动快<br>容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。<br>（2）资源占用少<br>容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。<br>（3）体积小<br>容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。<br>总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。<br>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。<br>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p><h1 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h1><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>首先安装一下Docker，然后实操起来看看什么是Docker。<br>参考官方教程，在<a href="https://docs.docker.com/engine/install/">这里</a>或<a href="https://yeasy.gitbook.io/docker_practice/install">该教程</a>。<br>以ubuntu为例：<br>（1）卸载旧版本<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure><br>（2）安装依赖包<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ca-certificates curl gnupg lsb-release</span><br></pre></td></tr></table></figure><br>（3）添加官方的key<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSLhttps://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor-o/usr/share/keyrings/docker-archive-keyring.gpg</span><br></pre></td></tr></table></figure><br>（4）配置仓库<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">&quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu  $(lsb_release -cs) stable&quot;</span>| sudo tee /etc/apt/sources.<span class="built_in">list</span>.d/docker.<span class="built_in">list</span> &gt;/dev/null</span><br></pre></td></tr></table></figure><br>注意这个地方是特用于ubuntu的。如果是基于ubuntu的再次发行版，比如Linux Mint，需要将自动探测版本那块的代码改成确定的ubuntu的版本，否则会报找不到包的错误。<br>比如改成：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">&quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu  bionic stable&quot;</span>| sudo tee /etc/apt/sources.<span class="built_in">list</span>.d/docker.<span class="built_in">list</span> &gt;/dev/null</span><br></pre></td></tr></table></figure><br>（5）安装Docker Engine<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure></p><p>安装完成后，使用下面命令验证是否安装成功：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure></p><h2 id="配置权限"><a href="#配置权限" class="headerlink" title="配置权限"></a>配置权限</h2><p>Docker 是服务器——客户端架构。命令行运行docker命令的时候，需要本机有 Docker 服务。如果这项服务没有启动，可以用下面其中一个命令启动：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo service docker start</span><br><span class="line">或</span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure></p><p>Docker 需要用户具有 sudo 权限，为了避免每次命令都输入sudo，可以把用户加入 Docker 用户组：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><br>添加后需要重新启动系统。</p><h2 id="镜像文件"><a href="#镜像文件" class="headerlink" title="镜像文件"></a>镜像文件</h2><p>Docker 把应用程序及其依赖，打包在 image 镜像文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。<br>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。<br>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本机的所有 image 文件。</span></span><br><span class="line">$ docker image ls</span><br><span class="line"><span class="comment"># 删除 image 文件</span></span><br><span class="line">$ docker image rm [imageName]</span><br></pre></td></tr></table></figure><br>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库，用于集中的存储、分发镜像，Docker Registry 就是这样的服务。<br>一个 Docker Registry 中可以包含多个 仓库（Repository）；每个仓库可以包含多个 标签（Tag）；每个标签对应一个镜像。<br>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。<br>仓库名经常以 两段式路径 形式出现，比如 jwilder/nginx-proxy，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。<br>最常使用的 Registry 公开服务是官方的 Docker Hub，这也是默认的 Registry，并拥有大量的高质量的官方镜像。<br>如果在使用过程中发现拉取 Docker 镜像十分缓慢，可以配置 Docker<a href="https://yeasy.gitbook.io/docker_practice/install/mirror">国内镜像加速</a>。<br>从docker官方拉取hello-world镜像：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull hello-world</span><br></pre></td></tr></table></figure></p><h2 id="容器文件"><a href="#容器文件" class="headerlink" title="容器文件"></a>容器文件</h2><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。<br>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。</p><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。<br>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p><p>生成容器：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run IMAGE</span><br></pre></td></tr></table></figure><br>run命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。<br>当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p><pre><code>- 检查本地是否存在指定的镜像，不存在就从公有仓库下载- 利用镜像创建并启动一个容器- 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层- 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去- 从地址池配置一个 ip 地址给容器- 执行用户指定的应用程序- 执行完毕后容器被终止</code></pre><p>如果希望重复使用容器，就要使用start命令，它用来启动已经生成、已经停止运行的容器文件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start IMAGE</span><br></pre></td></tr></table></figure><br>image 文件生成的容器实例，本身也是一个文件，称为容器文件。也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本机正在运行的容器</span></span><br><span class="line">$ docker container ls</span><br><span class="line"><span class="comment"># 列出本机所有容器，包括终止运行的容器</span></span><br><span class="line">$ docker container ls --<span class="built_in">all</span></span><br></pre></td></tr></table></figure></p><p>终止运行的容器文件，依然会占据硬盘空间，可以使用以下命令删除。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rm [containerID]</span><br></pre></td></tr></table></figure></p><h1 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令"></a>镜像相关命令</h1><p>列出镜像：<code>docker images</code>，REPOSITORY/TAG指明了一个具体镜像<br>查看镜像详细信息：<code>docker inspect</code><br>删除镜像：<code>docker rmi</code> 镜像名或ID，如果是镜像名，可能只删除了某个tag，如果是ID，则将这个镜像完全删除。</p><p>搜索镜像：<code>docker search</code>，也可以通过官网搜索，在<a href="https://hub.docker.com/search">https://hub.docker.com/search</a>。<br>拉取镜像：<code>docker pull</code>，可以修改<code>/etc/default/docker</code>文件，添加镜像源。<br>推送镜像：<code>docker push</code></p><p>构建镜像的作用：<br>（1）保存对容器的修改，并再次使用；<br>（2）自定义镜像的能力；<br>（3）以软件的形式打包并分发服务及其运行环境<br>构建镜像的方式：<br>（1）通过容器构建：<code>docker commit</code><br>（2）通过Dockerfile文件构建：<code>docker build</code></p><p>Dockerfile指令格式：INSTRUCTION argument。常用指令的有趣解释如下：<br><img src="https://user-images.githubusercontent.com/6218739/164161578-bf4e791f-8351-4f38-b353-986324ceabb9.png" alt="dockerfile"></p><p><code>FROM &lt;image&gt;</code>或<code>FROM &lt;image&gt;:&lt;tag&gt;</code><br><code>MAINTAINER &lt;name&gt;</code>指定镜像的作者信息，包含镜像的所有者和联系信息<br><code>RUN &lt;command&gt;</code> 或 <code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>指定当前构建过程中运行的命令，前者是shell模式，后者是exec模式。<br><code>EXPOSE &lt;port&gt; [&lt;port&gt;…]</code> 指定运行该镜像的容器使用的端口<br><code>CMD command param1 param2</code> 或 <code>CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> 或 <code>CMD [&quot;param1&quot;, &quot;param2&quot;]</code> 指定容器运行时的默认行为，即如果<code>docker run</code>时指定了命令，它会将这里的命令覆盖。第一种是shell模式，第二种是exec模式，第三种是作为EXTRYPOINT指令的默认参数。<br><code>ENTRYPOINT command param1 param2</code> 或 <code>ENTRYPOINT [&quot;exectable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> 与CMD指令类似，但ENTRYPOINT指令不会被<code>docker run</code>中的命令所覆盖，只能使用<code>docker run --entrypoint</code>来覆盖。<br><code>ADD &lt;src&gt; … &lt;dst&gt;</code> 或 <code>ADD [&quot;&lt;src&gt;&quot;… &quot;&lt;dst&gt;&quot;]</code> 复制文件，且ADD包含类似tar的解压功能，来源路径是构建路径中的相对路径，目标路径必须是镜像中的绝对路径，后者适用于文件路径中有空格的情况<br><code>COPY &lt;src&gt; … &lt;dst&gt;</code> 或 <code>COPY [&quot;&lt;src&gt;&quot;… &quot;&lt;dst&gt;&quot;]</code> 单纯复制文件推荐使用COPY指令<br><code>WORKDIR /path/to/workdir</code> 指定工作目录，一般为绝对路径，若为相对路径，则路径会传递。<br><code>ENV &lt;key&gt; &lt;value&gt;</code>或<code>ENV &lt;key&gt;=&lt;value&gt;</code> 指定环境变量，构建过程中或容器运行中都有效<br><code>USER user</code> 指定镜像以什么用户运行，若不指定，则默认使用root运行。<br><code>ONBUILD [INSTRUCTION]</code> 为镜像添加触发器，当该镜像被其他镜像作为基础镜像时运行</p><p>Dockerfile构建过程（docker build会删除中间的容器，但不会删除中间的镜像，所以可以利用中间层镜像进行调试）：<br>（1）从基础镜像运行一个容器；<br>（2）执行一条指令，对容器做出修改；<br>（3）执行类似docker commit的操作，提交一个新的镜像层；<br>（4）再基于刚提交的镜像运行一个新容器；<br>（5）指定Dockerfile中的下一条指令，直至所有指令执行完毕。</p><p><code>docker history</code> 查看镜像构建过程。</p><h1 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h1><p>启动容器：<code>docker run IMAGE [command] [args]</code><br>启动交互式容器： <code>docker run -i -t IMAGE [command] [args]</code> （-i —interactive -t —tty），比如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure><br>退出容器就是<code>exit</code>。</p><p>自定义容器名：加上<code>--name</code>选项<br>查看容器：<br>（1）<code>docker ps [-a] [-l]</code> （列出当前正在运行的容器，加上<code>-a</code>就是列出所有）<br>（2）<code>docker inspect NameOfContainer</code>查看容器的元数据，包括主机配置、ip地址等。<br>重新启动已经停止的容器：<code>docker start [-i] NameOfContainer</code><br>删除已经停止的容器：<code>docker rm</code> （加上<code>-f</code>可以强制删除正在运行的容器）</p><p>守护式容器：（1）能够长期运行；（2）没有交互式会话；（3）适合运行应用程序和服务<br>启动守护式容器的两种方式：<br>（1）将容器以交互式方式启动后，<code>Ctrl+P Ctrl+Q</code>即可进入守护模式，然后附加到正在运行的容器：<code>docker attach</code><br>（2）<code>docker run -d</code><br>查看容器中的日志：<code>docker logs [-f] [-t] [--tail] NameOfContainer</code> （-f —follow -t —timestamps）<br>查看容器中的进程：<code>docker top</code><br>在运行中的容器内启动新进程：<code>decker exec [-d] [-i] [-t] 容器名 [COMMAND] [args]</code>，比如进入这个容器：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it ubuntu /bin/bash</span><br></pre></td></tr></table></figure></p><p>停止守护式容器：<br><code>docker stop</code> 发送一个停止信号，等待停止；<br><code>docker kill</code> 直接杀死容器</p><p>设置容器的端口映射：<br><code>docker run [-P] [-p]</code><br>-P —publish-all=true | false，为容器暴露的所有端口进行映射<br>-p 指定特定的端口，可以单独指定容器端口、宿主机端口和容器端口、ip地址+容器端口、ip地址+宿主机端口和容器端口</p><p>对于端口映射这块，额外补充个知识点。因为我主机是Windows系统，然后通过Virtualbox虚拟了一个Linux Mint系统，而docker是放在Linux虚拟机中的，所以需要外面的Windows系统能访问到Linux系统，此时可以通过在Virtualbox中设置端口转发，来建立两者之间的联系，这样就是涉及了三个端口，一个是主机windows的端口，一个是linux的端口，一个是docker容器的端口，三者之间要建立好映射。<br>一篇很好的教程见：<br><a href="https://www.cnblogs.com/Reyzal/p/7743747.html">VirtualBox主机和虚拟机互相通信</a></p><p><code>-v 主机目录:容器内目录</code>：容器数据卷，实现容器数据的持久化和同步。</p><p><code>docker port</code> 查看容器到宿主机的端口映射<br><code>docker cp</code> 拷贝容器内的文件到主机</p><p>常用命令图谱：<br><img src="https://user-images.githubusercontent.com/6218739/164161697-fdf5da26-5f65-406d-9cc1-687c32e7b76a.png" alt="cmd"></p><h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><p>Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。<br>在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。<br>Compose 恰好满足了这样的需求。它允许用户通过一个单独的<code>docker-compose.yml</code>模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。<br>Compose 中有两个重要的概念：<br>（1）服务 (service)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。<br>（2）项目 (project)：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。<br>Compose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>（1）下载安装包<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L<span class="string">&quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span>-o/usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><br>（2）对二进制包添加权限<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s/usr/<span class="built_in">local</span>/bin/docker-compose /usr/bin/docker-compose</span><br></pre></td></tr></table></figure><br>测试是否安装成功：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">参考文献：
Docker 入门教程
Docker —— 从入门到实践
【狂神说Java】Docker最新超详细版教程通俗易懂

为什么要用Docker
Docker解决的问题是将软件连带其环境一起安装。

虚拟机与容器
虚拟机
虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。
虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个</summary>
    
    
    
    <category term="coding" scheme="http://qixinbo.github.io/categories/coding/"/>
    
    
    <category term="Docker" scheme="http://qixinbo.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>开源深度学习计算平台ImJoy解析：12 -- 基于web的绘图库OpenLayers</title>
    <link href="http://qixinbo.github.io/2022/03/16/ImJoy_12/"/>
    <id>http://qixinbo.github.io/2022/03/16/ImJoy_12/</id>
    <published>2022-03-15T16:00:00.000Z</published>
    <updated>2022-03-16T07:26:31.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>ImJoy有一个很有用的插件或独立应用，叫做<a href="https://kaibu.org/">Kaibu</a>，它可以展示普通的位图、矢量图及vtk、stl等3D格式的数据。<br>比如如下展示：<br><img src="https://user-images.githubusercontent.com/6218739/158537518-a3583f3e-4b06-494b-928a-3904f6b29fb2.png" alt="kaibu"><br>其就是位图（png格式）、矢量图（json格式）、3D模型（stl格式）的一个叠加。</p><p>Kaibu主要用了两个JS库，一个是<a href="https://openlayers.org/">OpenLayers</a>，一个是<a href="https://kitware.github.io/itk-vtk-viewer/docs/">ITK-VTK</a>，前者用于展示矢量图形、普通位图等数据，且对地图的展示异常强大，后者用于展示在医疗及科学计算中常用的3D图像、网格、点集等。</p><p>这一篇主要介绍OpenLayers的相关知识。</p><h1 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h1><p>从<a href="https://github.com/openlayers/workshop/releases">OpenLayers workshop releases</a>里下载最新的资料包。<br>安装依赖：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><br>启动：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><br>这会启动一个开发服务器。可以通过<code>http://localhost:1234</code>查看一个“欢迎”的弹出窗口，以及<code>http://localhost:1234/doc/</code>查看说明文档。</p><h1 id="开发入门"><a href="#开发入门" class="headerlink" title="开发入门"></a>开发入门</h1><p>这一部分会通过OpenLayers map来创建一个简单的web页面。<br>在OpenLayers中，一个map是在web页面中被渲染的一系列“层”layers的集合。OpenLayers支持很多种layers：<br>（1）针对平铺光栅切片数据的Tile layer；<br>（2）针对位图图像的Image layer；<br>（3）针对矢量数据的Vector layer；<br>（4）针对平铺矢量切片数据的Vector tile layer。<br>除了这些layers，一个map还可以通过一系列的控制（即在map上面的UI元素）和交互（即与map进行交互反馈的部件）来进行配置。<br>为了创建一个map，需要通过HTML中的元素来创建（如一个<code>&lt;div&gt;</code>元素），以及一些样式来指定合适的尺寸。</p><h2 id="HTML页面"><a href="#HTML页面" class="headerlink" title="HTML页面"></a>HTML页面</h2><p>将项目根目录中的<code>index.html</code>里的内容替换为如下代码（注释写在了代码中）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;OpenLayers&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      <span class="comment">/*引入OpenLayers的样式*/</span></span><br><span class="line">      @<span class="keyword">import</span> <span class="string">&quot;node_modules/ol/ol.css&quot;</span>;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      <span class="comment">/*该部分样式使得map容器完全充满整个页面*/</span></span><br><span class="line">      html, body, #map-container &#123;</span><br><span class="line">        margin: <span class="number">0</span>;</span><br><span class="line">        height: <span class="number">100</span>%;</span><br><span class="line">        width: <span class="number">100</span>%;</span><br><span class="line">        font-family: sans-serif;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;!-- 该div标签是map的渲染容器 --&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;map-container&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;!-- 引入相关的js代码 --&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;./main.js&quot;</span> type=<span class="string">&quot;module&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h2 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h2><p>将项目根目录中的<code>main.js</code>里的内容替换为如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从OpenLayers中导入必要的模块</span></span><br><span class="line"><span class="keyword">import</span> OSM <span class="keyword">from</span> <span class="string">&#x27;ol/source/OSM&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> TileLayer <span class="keyword">from</span> <span class="string">&#x27;ol/layer/Tile&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="built_in">Map</span>, View&#125; <span class="keyword">from</span> <span class="string">&#x27;ol&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;fromLonLat&#125; <span class="keyword">from</span> <span class="string">&#x27;ol/proj&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Map对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>(&#123;</span><br><span class="line">  <span class="comment">// 目标是HTML中的那个div元素</span></span><br><span class="line">  target: <span class="string">&#x27;map-container&#x27;</span>,</span><br><span class="line">  layers: [</span><br><span class="line">    <span class="comment">// 具体的layer是使用了Tile Layer</span></span><br><span class="line">    <span class="keyword">new</span> TileLayer(&#123;</span><br><span class="line">      source: <span class="keyword">new</span> OSM(),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// view定义了初始的中心点和缩放比例</span></span><br><span class="line">  view: <span class="keyword">new</span> View(&#123;</span><br><span class="line">    <span class="comment">// 中心点的指定是通过fromLonLat函数获取地理坐标</span></span><br><span class="line">    center: fromLonLat([<span class="number">0</span>, <span class="number">0</span>]),</span><br><span class="line">    zoom: <span class="number">2</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>此时打开<code>http://localhost:1234</code>，会看到世界地图：<br><img src="https://user-images.githubusercontent.com/6218739/158340705-a8876d2b-035e-4764-9c77-229e722be721.png" alt="basic"></p><h1 id="矢量数据"><a href="#矢量数据" class="headerlink" title="矢量数据"></a>矢量数据</h1><p>在这一部分，将会创建一个可以操作矢量数据的编辑器，使得用户可以导入数据、绘制形状、修改已有形状及导出结果等。<br>本部分会使用<a href="https://geojson.org/">GeoJSON</a>数据，不过OpenLayers支持其他大量的矢量数据格式。</p><h2 id="渲染GeoJSON"><a href="#渲染GeoJSON" class="headerlink" title="渲染GeoJSON"></a>渲染GeoJSON</h2><p>在开发编辑功能之前，先看一下基本的对矢量数据的渲染功能。<br>在项目的data路径下有一个名为<code>countries.json</code>的GeoJSON文件，这里将加载该数据并在地图上渲染出来。<br>首先，编辑一下刚才的<code>index.html</code>，这里新加一行控制背景颜色的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;OpenLayers&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      @<span class="keyword">import</span> <span class="string">&quot;node_modules/ol/ol.css&quot;</span>;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      html, body, #map-container &#123;</span><br><span class="line">        margin: <span class="number">0</span>;</span><br><span class="line">        height: <span class="number">100</span>%;</span><br><span class="line">        width: <span class="number">100</span>%;</span><br><span class="line">        font-family: sans-serif;</span><br><span class="line">        <span class="comment">/*新加了这一行来控制背景颜色*/</span></span><br><span class="line">        background-color: #04041b;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;map-container&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;./main.js&quot;</span> type=<span class="string">&quot;module&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><br>然后将<code>main.js</code>中的内容替换为如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入GeoJSON包来读写该格式的数据</span></span><br><span class="line"><span class="keyword">import</span> GeoJSON <span class="keyword">from</span> <span class="string">&#x27;ol/format/GeoJSON&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="built_in">Map</span> <span class="keyword">from</span> <span class="string">&#x27;ol/Map&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorLayer <span class="keyword">from</span> <span class="string">&#x27;ol/layer/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorSource <span class="keyword">from</span> <span class="string">&#x27;ol/source/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> View <span class="keyword">from</span> <span class="string">&#x27;ol/View&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>(&#123;</span><br><span class="line">  target: <span class="string">&#x27;map-container&#x27;</span>,</span><br><span class="line">  layers: [</span><br><span class="line">    <span class="comment">// layer使用的是处理和渲染矢量数据的VectorLayer</span></span><br><span class="line">    <span class="keyword">new</span> VectorLayer(&#123;</span><br><span class="line">      <span class="comment">// VectorSource用来获取GeoJSON数据，并管理空间索引</span></span><br><span class="line">      source: <span class="keyword">new</span> VectorSource(&#123;</span><br><span class="line">        format: <span class="keyword">new</span> GeoJSON(),</span><br><span class="line">        <span class="comment">// 导入data目录下的JSON文件</span></span><br><span class="line">        url: <span class="string">&#x27;./data/countries.json&#x27;</span>,</span><br><span class="line">      &#125;),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  view: <span class="keyword">new</span> View(&#123;</span><br><span class="line">    center: [<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    zoom: <span class="number">2</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>效果如下：<br><img src="https://user-images.githubusercontent.com/6218739/158343566-6f7fa033-d8ec-4741-b50f-5e65ce122485.png" alt="json"></p><p>因为我们会重载这个页面很多次，目前代码下每次重载页面都会回到初始的view方式，即初始的中心点和缩放大小。如果能每次重载都能保持map在相同的位置就能节省很多人力。<br>此时可以借助<code>ol-hashed</code>包实现，修改代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> GeoJSON <span class="keyword">from</span> <span class="string">&#x27;ol/format/GeoJSON&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="built_in">Map</span> <span class="keyword">from</span> <span class="string">&#x27;ol/Map&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorLayer <span class="keyword">from</span> <span class="string">&#x27;ol/layer/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorSource <span class="keyword">from</span> <span class="string">&#x27;ol/source/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> View <span class="keyword">from</span> <span class="string">&#x27;ol/View&#x27;</span>;</span><br><span class="line"><span class="comment">// 导入ol-hashed包</span></span><br><span class="line"><span class="keyword">import</span> sync <span class="keyword">from</span> <span class="string">&#x27;ol-hashed&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Map对象分配到一个变量上</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(&#123;</span><br><span class="line">  target: <span class="string">&#x27;map-container&#x27;</span>,</span><br><span class="line">  layers: [</span><br><span class="line">    <span class="keyword">new</span> VectorLayer(&#123;</span><br><span class="line">      source: <span class="keyword">new</span> VectorSource(&#123;</span><br><span class="line">        format: <span class="keyword">new</span> GeoJSON(),</span><br><span class="line">        url: <span class="string">&#x27;./data/countries.json&#x27;</span>,</span><br><span class="line">      &#125;),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  view: <span class="keyword">new</span> View(&#123;</span><br><span class="line">    center: [<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    zoom: <span class="number">2</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将上面的变量传递给sync函数</span></span><br><span class="line">sync(map);</span><br></pre></td></tr></table></figure><br>此时，你会发现，将地图移动和缩放到某一特定程度后，下次重新载入代码仍然保持该视角不变。</p><h2 id="拖放"><a href="#拖放" class="headerlink" title="拖放"></a>拖放</h2><p>对于要实现的编辑器，想要允许用户能够导入自己的数据进行编辑。为此，这里将添加<code>DragAndDrop</code>功能。<br>跟以前一样，这里仍只处理GeoJSON这种数据，不过该交互也支持其他类型的数据格式。<br>修改<code>main.js</code>为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> GeoJSON <span class="keyword">from</span> <span class="string">&#x27;ol/format/GeoJSON&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="built_in">Map</span> <span class="keyword">from</span> <span class="string">&#x27;ol/Map&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorLayer <span class="keyword">from</span> <span class="string">&#x27;ol/layer/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorSource <span class="keyword">from</span> <span class="string">&#x27;ol/source/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> View <span class="keyword">from</span> <span class="string">&#x27;ol/View&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> sync <span class="keyword">from</span> <span class="string">&#x27;ol-hashed&#x27;</span>;</span><br><span class="line"><span class="comment">// 导入DragAndDrop包</span></span><br><span class="line"><span class="keyword">import</span> DragAndDrop <span class="keyword">from</span> <span class="string">&#x27;ol/interaction/DragAndDrop&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个Map对象，只指定它的目标和视图</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(&#123;</span><br><span class="line">  target: <span class="string">&#x27;map-container&#x27;</span>,</span><br><span class="line">  view: <span class="keyword">new</span> View(&#123;</span><br><span class="line">    center: [<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    zoom: <span class="number">2</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sync(map);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建数据源VectorSource，但是里面没有任何数据</span></span><br><span class="line"><span class="keyword">const</span> source = <span class="keyword">new</span> VectorSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建VectorLayer，里面的source传入上面定义的空的source</span></span><br><span class="line"><span class="keyword">const</span> layer = <span class="keyword">new</span> VectorLayer(&#123;</span><br><span class="line">  source: source,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 将layer添加到map中</span></span><br><span class="line">map.addLayer(layer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对map添加拖放交互</span></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> DragAndDrop(&#123;</span><br><span class="line">    <span class="comment">// 将拖放动作作用在Vector Source上</span></span><br><span class="line">    source: source,</span><br><span class="line">    <span class="comment">// 指定GeoJSON格式</span></span><br><span class="line">    formatConstructors: [GeoJSON],</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>此时就能将GeoJSON文件拖放到该页面上，从而进行渲染。</p><h2 id="修改特征"><a href="#修改特征" class="headerlink" title="修改特征"></a>修改特征</h2><p>现在可以将数据拖放到编辑器中，下面是添加“修改”功能。<br>实现方式是使用<code>Modify</code>交互。<br>修改<code>main.js</code>为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> DragAndDrop <span class="keyword">from</span> <span class="string">&#x27;ol/interaction/DragAndDrop&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> GeoJSON <span class="keyword">from</span> <span class="string">&#x27;ol/format/GeoJSON&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="built_in">Map</span> <span class="keyword">from</span> <span class="string">&#x27;ol/Map&#x27;</span>;</span><br><span class="line"><span class="comment">// 导入Modify包</span></span><br><span class="line"><span class="keyword">import</span> Modify <span class="keyword">from</span> <span class="string">&#x27;ol/interaction/Modify&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorLayer <span class="keyword">from</span> <span class="string">&#x27;ol/layer/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorSource <span class="keyword">from</span> <span class="string">&#x27;ol/source/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> View <span class="keyword">from</span> <span class="string">&#x27;ol/View&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> sync <span class="keyword">from</span> <span class="string">&#x27;ol-hashed&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(&#123;</span><br><span class="line">  target: <span class="string">&#x27;map-container&#x27;</span>,</span><br><span class="line">  view: <span class="keyword">new</span> View(&#123;</span><br><span class="line">    center: [<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    zoom: <span class="number">2</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sync(map);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source = <span class="keyword">new</span> VectorSource();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> layer = <span class="keyword">new</span> VectorLayer(&#123;</span><br><span class="line">  source: source,</span><br><span class="line">&#125;);</span><br><span class="line">map.addLayer(layer);</span><br><span class="line"></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> DragAndDrop(&#123;</span><br><span class="line">    source: source,</span><br><span class="line">    formatConstructors: [GeoJSON],</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在map上添加Modify交互，并配置交互对象</span></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> Modify(&#123;</span><br><span class="line">    source: source,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br>此时就可以拖动顶点来修改特征。也可以使用<code>Alt+Click</code>来删除顶点。</p><h2 id="绘制特征"><a href="#绘制特征" class="headerlink" title="绘制特征"></a>绘制特征</h2><p>接下来添加<code>Draw</code>交互来使得用户可以绘制新的特征，并添加到数据中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> DragAndDrop <span class="keyword">from</span> <span class="string">&#x27;ol/interaction/DragAndDrop&#x27;</span>;</span><br><span class="line"><span class="comment">// 导入Draw包</span></span><br><span class="line"><span class="keyword">import</span> Draw <span class="keyword">from</span> <span class="string">&#x27;ol/interaction/Draw&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> GeoJSON <span class="keyword">from</span> <span class="string">&#x27;ol/format/GeoJSON&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="built_in">Map</span> <span class="keyword">from</span> <span class="string">&#x27;ol/Map&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Modify <span class="keyword">from</span> <span class="string">&#x27;ol/interaction/Modify&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorLayer <span class="keyword">from</span> <span class="string">&#x27;ol/layer/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorSource <span class="keyword">from</span> <span class="string">&#x27;ol/source/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> View <span class="keyword">from</span> <span class="string">&#x27;ol/View&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> sync <span class="keyword">from</span> <span class="string">&#x27;ol-hashed&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(&#123;</span><br><span class="line">  target: <span class="string">&#x27;map-container&#x27;</span>,</span><br><span class="line">  view: <span class="keyword">new</span> View(&#123;</span><br><span class="line">    center: [<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    zoom: <span class="number">2</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sync(map);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source = <span class="keyword">new</span> VectorSource();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> layer = <span class="keyword">new</span> VectorLayer(&#123;</span><br><span class="line">  source: source,</span><br><span class="line">&#125;);</span><br><span class="line">map.addLayer(layer);</span><br><span class="line"></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> DragAndDrop(&#123;</span><br><span class="line">    source: source,</span><br><span class="line">    formatConstructors: [GeoJSON],</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> Modify(&#123;</span><br><span class="line">    source: source,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在map上添加Draw交互</span></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> Draw(&#123;</span><br><span class="line">    <span class="comment">// 指定绘制形状，该值可以是任意的GeoJSON的几何形状</span></span><br><span class="line">    type: <span class="string">&#x27;Polygon&#x27;</span>,</span><br><span class="line">    <span class="comment">// 配置交互对象</span></span><br><span class="line">    source: source,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h2 id="自动吸附"><a href="#自动吸附" class="headerlink" title="自动吸附"></a>自动吸附</h2><p>上面的绘制功能添加后，可以发现，当绘制图形时，很难沿着之前的图形进行精确绘制。<br>此时可以添加<code>snap</code>功能，当鼠标移动到某个像素一定范围内时，就能自动吸附到该像素，从而完成精确绘制。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> DragAndDrop <span class="keyword">from</span> <span class="string">&#x27;ol/interaction/DragAndDrop&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Draw <span class="keyword">from</span> <span class="string">&#x27;ol/interaction/Draw&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> GeoJSON <span class="keyword">from</span> <span class="string">&#x27;ol/format/GeoJSON&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> GeometryType <span class="keyword">from</span> <span class="string">&#x27;ol/geom/GeometryType&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="built_in">Map</span> <span class="keyword">from</span> <span class="string">&#x27;ol/Map&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Modify <span class="keyword">from</span> <span class="string">&#x27;ol/interaction/Modify&#x27;</span>;</span><br><span class="line"><span class="comment">// 添加Snap包</span></span><br><span class="line"><span class="keyword">import</span> Snap <span class="keyword">from</span> <span class="string">&#x27;ol/interaction/Snap&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorLayer <span class="keyword">from</span> <span class="string">&#x27;ol/layer/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorSource <span class="keyword">from</span> <span class="string">&#x27;ol/source/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> View <span class="keyword">from</span> <span class="string">&#x27;ol/View&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> sync <span class="keyword">from</span> <span class="string">&#x27;ol-hashed&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(&#123;</span><br><span class="line">  target: <span class="string">&#x27;map-container&#x27;</span>,</span><br><span class="line">  view: <span class="keyword">new</span> View(&#123;</span><br><span class="line">    center: [<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    zoom: <span class="number">2</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sync(map);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source = <span class="keyword">new</span> VectorSource();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> layer = <span class="keyword">new</span> VectorLayer(&#123;</span><br><span class="line">  source: source,</span><br><span class="line">&#125;);</span><br><span class="line">map.addLayer(layer);</span><br><span class="line"></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> DragAndDrop(&#123;</span><br><span class="line">    source: source,</span><br><span class="line">    formatConstructors: [GeoJSON],</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> Modify(&#123;</span><br><span class="line">    source: source,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> Draw(&#123;</span><br><span class="line">    source: source,</span><br><span class="line">    type: GeometryType.POLYGON,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在map上添加Snap交互</span></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> Snap(&#123;</span><br><span class="line">    <span class="comment">// 配置作用对象</span></span><br><span class="line">    source: source,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h2 id="下载特征"><a href="#下载特征" class="headerlink" title="下载特征"></a>下载特征</h2><p>当上传数据，且对其编辑后，希望能下载特征。<br>为了能实现这个功能，这里将特征数据序列化为GeoJSON数据，然后创建一个带<code>download</code>属性的<code>&lt;a&gt;</code>元素，这样就能触发浏览器的文件保存对话框。<br>同时，在map上添加一个按钮，可以使得用户清除现在的特征，重新绘制。<br>修改<code>index.html</code>为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;OpenLayers&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      @<span class="keyword">import</span> <span class="string">&quot;node_modules/ol/ol.css&quot;</span>;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">      html, body, #map-container &#123;</span><br><span class="line">        margin: <span class="number">0</span>;</span><br><span class="line">        height: <span class="number">100</span>%;</span><br><span class="line">        width: <span class="number">100</span>%;</span><br><span class="line">        font-family: sans-serif;</span><br><span class="line">        background-color: #04041b;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*对id为tools的div进行样式设定*/</span></span><br><span class="line">      #tools &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 1rem;</span><br><span class="line">        right: 1rem;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*对id为tools中的两个后代a元素设定样式*/</span></span><br><span class="line">      <span class="comment">/*css语法可以参见这里：*/</span></span><br><span class="line">      <span class="comment">/*https://www.runoob.com/css/css-combinators.html*/</span></span><br><span class="line">      #tools a &#123;</span><br><span class="line">        display: inline-block;</span><br><span class="line">        padding: <span class="number">0.</span>5rem;</span><br><span class="line">        background: white;</span><br><span class="line">        cursor: pointer;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*! [tools] */</span></span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;map-container&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;./main.js&quot;</span> type=<span class="string">&quot;module&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!-- 新增一个div元素，里面包含了两个a元素 --&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;tools&quot;</span>&gt;</span><br><span class="line">      &lt;a id=<span class="string">&quot;clear&quot;</span>&gt;Clear&lt;/a&gt;</span><br><span class="line">      &lt;a id=<span class="string">&quot;download&quot;</span> download=<span class="string">&quot;features.json&quot;</span>&gt;Download&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><br>修改<code>main.js</code>为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> GeoJSON <span class="keyword">from</span> <span class="string">&#x27;ol/format/GeoJSON&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> GeometryType <span class="keyword">from</span> <span class="string">&#x27;ol/geom/GeometryType&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="built_in">Map</span> <span class="keyword">from</span> <span class="string">&#x27;ol/Map&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorLayer <span class="keyword">from</span> <span class="string">&#x27;ol/layer/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorSource <span class="keyword">from</span> <span class="string">&#x27;ol/source/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> View <span class="keyword">from</span> <span class="string">&#x27;ol/View&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> sync <span class="keyword">from</span> <span class="string">&#x27;ol-hashed&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;DragAndDrop, Draw, Modify, Snap&#125; <span class="keyword">from</span> <span class="string">&#x27;ol/interaction&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(&#123;</span><br><span class="line">  target: <span class="string">&#x27;map-container&#x27;</span>,</span><br><span class="line">  view: <span class="keyword">new</span> View(&#123;</span><br><span class="line">    center: [<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    zoom: <span class="number">2</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sync(map);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source = <span class="keyword">new</span> VectorSource();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> layer = <span class="keyword">new</span> VectorLayer(&#123;</span><br><span class="line">  source: source,</span><br><span class="line">&#125;);</span><br><span class="line">map.addLayer(layer);</span><br><span class="line"></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> DragAndDrop(&#123;</span><br><span class="line">    source: source,</span><br><span class="line">    formatConstructors: [GeoJSON],</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> Modify(&#123;</span><br><span class="line">    source: source,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> Draw(&#123;</span><br><span class="line">    source: source,</span><br><span class="line">    type: GeometryType.POLYGON,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> Snap(&#123;</span><br><span class="line">    source: source,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现清除功能</span></span><br><span class="line"><span class="comment">// 首先通过DOM选取clear按钮</span></span><br><span class="line"><span class="keyword">const</span> clear = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;clear&#x27;</span>);</span><br><span class="line"><span class="comment">// 对该按钮添加鼠标事件</span></span><br><span class="line">clear.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  source.clear();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现下载功能</span></span><br><span class="line"><span class="comment">// 这里序列化数据为GeoJSON格式</span></span><br><span class="line"><span class="keyword">const</span> format = <span class="keyword">new</span> GeoJSON(&#123;<span class="attr">featureProjection</span>: <span class="string">&#x27;EPSG:3857&#x27;</span>&#125;);</span><br><span class="line"><span class="comment">// 通过DOM获取download按钮</span></span><br><span class="line"><span class="keyword">const</span> download = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;download&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为这里是期望随时都能下载最新的数据，所以将数据获取及序列化的工作绑定在source的change事件上</span></span><br><span class="line"><span class="comment">// 即，只要source改变，download按钮所能获得的数据就是最新的source</span></span><br><span class="line">source.on(<span class="string">&#x27;change&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获得特征</span></span><br><span class="line">  <span class="keyword">const</span> features = source.getFeatures();</span><br><span class="line">  <span class="comment">// 序列化特征</span></span><br><span class="line">  <span class="keyword">const</span> json = format.writeFeatures(features);</span><br><span class="line">  <span class="comment">// 这里将原json字符串转换成URI组成部分，将附加到下载按钮的href中</span></span><br><span class="line">  download.href =</span><br><span class="line">    <span class="string">&#x27;data:application/json;charset=utf-8,&#x27;</span> + <span class="built_in">encodeURIComponent</span>(json);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>效果如下：<br><img src="https://user-images.githubusercontent.com/6218739/158392776-41d856f4-1c85-43e2-a129-380ab1131356.png" alt="download"></p><h2 id="配置绘图样式"><a href="#配置绘图样式" class="headerlink" title="配置绘图样式"></a>配置绘图样式</h2><p>前面的编辑功能都是使用了默认样式，这里增加更多的属性来使得编辑功能更加强大，比如设置画笔宽度、设置填充颜色等。</p><h3 id="静态样式"><a href="#静态样式" class="headerlink" title="静态样式"></a>静态样式</h3><p>如果单纯想将样式都调成一个模样，那么可以直接简单地将样式固定即可，如下面代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> layer = <span class="keyword">new</span> VectorLayer(&#123;</span><br><span class="line">  source: source,</span><br><span class="line">  style: <span class="keyword">new</span> Style(&#123;</span><br><span class="line">    fill: <span class="keyword">new</span> Fill(&#123;</span><br><span class="line">      color: <span class="string">&#x27;red&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    stroke: <span class="keyword">new</span> Stroke(&#123;</span><br><span class="line">      color: <span class="string">&#x27;white&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>即都填充成红色，笔画都是白色。</p><h3 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h3><p>更多情况下，动态样式使用得更多，即按照一定的规则自动设置样式。<br>如下面：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">constlayer = newVectorLayer(&#123;</span><br><span class="line">  source: source,</span><br><span class="line">  style: <span class="function"><span class="keyword">function</span>(<span class="params">feature, resolution</span>) </span>&#123;</span><br><span class="line">    constname = feature.get(<span class="string">&#x27;name&#x27;</span>).toUpperCase();</span><br><span class="line">    returnname &lt; <span class="string">&quot;N&quot;</span>? style1 : style2; <span class="comment">// assuming these are created elsewhere&#125;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>就是根据feature的name来设置样式，如果是<code>A-M</code>，就用style1，如果是<code>N-Z</code>，则使用style2。<br>所以设定好规则非常重要。<br>下面将展示如何根据几何区域设定样式。<br>修改<code>main.js</code>为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> DragAndDrop <span class="keyword">from</span> <span class="string">&#x27;ol/interaction/DragAndDrop&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Draw <span class="keyword">from</span> <span class="string">&#x27;ol/interaction/Draw&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> GeoJSON <span class="keyword">from</span> <span class="string">&#x27;ol/format/GeoJSON&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> GeometryType <span class="keyword">from</span> <span class="string">&#x27;ol/geom/GeometryType&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="built_in">Map</span> <span class="keyword">from</span> <span class="string">&#x27;ol/Map&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Modify <span class="keyword">from</span> <span class="string">&#x27;ol/interaction/Modify&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Snap <span class="keyword">from</span> <span class="string">&#x27;ol/interaction/Snap&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorLayer <span class="keyword">from</span> <span class="string">&#x27;ol/layer/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VectorSource <span class="keyword">from</span> <span class="string">&#x27;ol/source/Vector&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> View <span class="keyword">from</span> <span class="string">&#x27;ol/View&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> sync <span class="keyword">from</span> <span class="string">&#x27;ol-hashed&#x27;</span>;</span><br><span class="line"><span class="comment">// 导入必要的样式库</span></span><br><span class="line"><span class="keyword">import</span> &#123;Fill, Stroke, Style&#125; <span class="keyword">from</span> <span class="string">&#x27;ol/style&#x27;</span>;</span><br><span class="line"><span class="comment">// 导入colormap包</span></span><br><span class="line"><span class="keyword">import</span> colormap <span class="keyword">from</span> <span class="string">&#x27;colormap&#x27;</span>;</span><br><span class="line"><span class="comment">// 从OpenLayers导入getArea包</span></span><br><span class="line"><span class="keyword">import</span> &#123;getArea&#125; <span class="keyword">from</span> <span class="string">&#x27;ol/sphere&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 根据面积计算颜色：开始 ----</span></span><br><span class="line"><span class="keyword">const</span> min = <span class="number">1e8</span>; <span class="comment">// the smallest area</span></span><br><span class="line"><span class="keyword">const</span> max = <span class="number">2e13</span>; <span class="comment">// the biggest area</span></span><br><span class="line"><span class="keyword">const</span> steps = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">const</span> ramp = colormap(&#123;</span><br><span class="line">  colormap: <span class="string">&#x27;blackbody&#x27;</span>,</span><br><span class="line">  nshades: steps,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clamp</span>(<span class="params">value, low, high</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(low, <span class="built_in">Math</span>.min(value, high));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params">feature</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> area = getArea(feature.getGeometry());</span><br><span class="line">  <span class="keyword">const</span> f = <span class="built_in">Math</span>.pow(clamp((area - min) / (max - min), <span class="number">0</span>, <span class="number">1</span>), <span class="number">1</span> / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> index = <span class="built_in">Math</span>.round(f * (steps - <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> ramp[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// --- 根据面积计算颜色：结束 ----</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(&#123;</span><br><span class="line">  target: <span class="string">&#x27;map-container&#x27;</span>,</span><br><span class="line">  view: <span class="keyword">new</span> View(&#123;</span><br><span class="line">    center: [<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    zoom: <span class="number">2</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sync(map);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source = <span class="keyword">new</span> VectorSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加样式</span></span><br><span class="line"><span class="keyword">const</span> layer = <span class="keyword">new</span> VectorLayer(&#123;</span><br><span class="line">  source: source,</span><br><span class="line">  style: <span class="function"><span class="keyword">function</span> (<span class="params">feature</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Style(&#123;</span><br><span class="line">      fill: <span class="keyword">new</span> Fill(&#123;</span><br><span class="line">        color: getColor(feature),</span><br><span class="line">      &#125;),</span><br><span class="line">      stroke: <span class="keyword">new</span> Stroke(&#123;</span><br><span class="line">        color: <span class="string">&#x27;rgba(255,255,255,0.8)&#x27;</span>,</span><br><span class="line">      &#125;),</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">map.addLayer(layer);</span><br><span class="line"></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> DragAndDrop(&#123;</span><br><span class="line">    source: source,</span><br><span class="line">    formatConstructors: [GeoJSON],</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> Modify(&#123;</span><br><span class="line">    source: source,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> Draw(&#123;</span><br><span class="line">    source: source,</span><br><span class="line">    type: GeometryType.POLYGON,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">map.addInteraction(</span><br><span class="line">  <span class="keyword">new</span> Snap(&#123;</span><br><span class="line">    source: source,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clear = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;clear&#x27;</span>);</span><br><span class="line">clear.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  source.clear();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> format = <span class="keyword">new</span> GeoJSON(&#123;<span class="attr">featureProjection</span>: <span class="string">&#x27;EPSG:3857&#x27;</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> download = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;download&#x27;</span>);</span><br><span class="line">source.on(<span class="string">&#x27;change&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> features = source.getFeatures();</span><br><span class="line">  <span class="keyword">const</span> json = format.writeFeatures(features);</span><br><span class="line">  download.href = <span class="string">&#x27;data:text/json;charset=utf-8,&#x27;</span> + json;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>效果如下：<br><img src="https://user-images.githubusercontent.com/6218739/158398065-704634ef-a6dc-4d17-a4a6-a87edc51c8f1.png" alt="style"></p><h1 id="移动端地图和数据集成"><a href="#移动端地图和数据集成" class="headerlink" title="移动端地图和数据集成"></a>移动端地图和数据集成</h1><p>这一部分将创建一个移动端的地图来展示用户的GPS位置和朝向。该项目的目的是为了展示怎样将OpenLayers与浏览器的API及第三方工具进行集成。<br>具体地，仅使用几行代码即可调用浏览器的关于地理位置的API，从而得到GPS位置，以及使用<a href="https://www.npmjs.com/package/kompas">kompas</a>库通过设备的陀螺仪获得朝向。然后，通过使用Vector Layer，就能很轻易地在地图上显示结果。</p><p>因为这一部分需要移动端的配合，不再具体分析。</p><p>更多用法留坑待填。</p>]]></content>
    
    
    <summary type="html">简介
ImJoy有一个很有用的插件或独立应用，叫做Kaibu，它可以展示普通的位图、矢量图及vtk、stl等3D格式的数据。
比如如下展示：

其就是位图（png格式）、矢量图（json格式）、3D模型（stl格式）的一个叠加。

Kaibu主要用了两个JS库，一个是OpenLayers，一个是ITK-VTK，前者用于展示矢量图形、普通位图等数据，且对地图的展示异常强大，后者用于展示在医疗及科学计算中常用的3D图像、网格、点集等。

这一篇主要介绍OpenLayers的相关知识。

配置环境
从OpenLayers workshop releases里下载最新的资料包。
安装依赖：
1


n</summary>
    
    
    
    <category term="computer vision" scheme="http://qixinbo.github.io/categories/computer-vision/"/>
    
    
    <category term="ImJoy" scheme="http://qixinbo.github.io/tags/ImJoy/"/>
    
  </entry>
  
  <entry>
    <title>用Python开发web应用——Streamlit框架解析：3 -- 组件</title>
    <link href="http://qixinbo.github.io/2022/03/11/streamlit_3/"/>
    <id>http://qixinbo.github.io/2022/03/11/streamlit_3/</id>
    <published>2022-03-10T16:00:00.000Z</published>
    <updated>2022-03-11T08:46:28.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Streamlit的组件Components是一系列第三方的Python模块，其极大地扩展了Streamlit的功能。<br>Components带来了无穷的想象力和可能性，比如与React、Vue等前端框架联动、创建自定义风格和行为的新部件、以及增加新的可视化图表类型等。</p><h1 id="使用组件"><a href="#使用组件" class="headerlink" title="使用组件"></a>使用组件</h1><h2 id="查找可用组件"><a href="#查找可用组件" class="headerlink" title="查找可用组件"></a>查找可用组件</h2><p>查找组件有两个常用的途径：<br>一是<a href="https://streamlit.io/components">Component Gallery</a>，这是官方挑选出来的特色组件；<br>二是<a href="https://discuss.streamlit.io/t/streamlit-components-community-tracker/4634">Streamlit Components - Community Tracker</a>这个论坛帖子，里面搜集了很多社区成员创建的组件。</p><h2 id="安装组件"><a href="#安装组件" class="headerlink" title="安装组件"></a>安装组件</h2><p>安装这些组件，只需：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install some_cool_component</span><br></pre></td></tr></table></figure><br>以<a href="https://github.com/PablocFonseca/streamlit-aggrid">AgGrid</a>组件为例，安装命令为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install streamlit-aggrid</span><br></pre></td></tr></table></figure></p><h2 id="使用组件-1"><a href="#使用组件-1" class="headerlink" title="使用组件"></a>使用组件</h2><p>查看组件的使用文档，还是以AgGrid为例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> st_aggrid <span class="keyword">import</span> AgGrid</span><br><span class="line">AgGrid(my_dataframe)</span><br></pre></td></tr></table></figure></p><h1 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h1><p>如果已有的组件不满足自己的需求，还可以自己创建组件。<br>先来看一下插件的类型：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"></span><br><span class="line">x = st.slider(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">st.markdown(<span class="string">f&#x27;`<span class="subst">&#123;x&#125;</span>` squared is `<span class="subst">&#123;x * x&#125;</span>`&#x27;</span>)</span><br></pre></td></tr></table></figure><br>如上代码中有两种组件：<br>（1）静态组件static components，即<code>st.markdown</code>，它是无状态的，仅向浏览器发送和渲染数据；<br>（2）双向组件bidirectional components，即<code>st.slider</code>，它有内部状态，会从浏览器中返回数据，也可以向浏览器发送和渲染数据，即在后台Python代码和前端JavaScript代码之间交换数据。</p><p>对于组件开发，Streamlit提供了<code>streamlit.components.v1</code>这个包：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">importstreamlit.components.v1 <span class="keyword">as</span> components</span><br></pre></td></tr></table></figure><br>这个略显冗长的导入声明对组件API明确地指明了版本号，这样以后升级后就不会破坏已有的组件。</p><p>具体地，对于静态组件，有两种方法可供使用：<br>（1）<code>html(...)</code>可以基于HTML、JavaScript和CSS来创建组件；<br>（2）<code>iframe(...)</code>可以嵌入外部网站。<br>对于双向组件：<br><code>declare_component(...)</code>可以创建在Streamlit和浏览器之间双向交换数据的动态部件。</p><h2 id="创建静态组件"><a href="#创建静态组件" class="headerlink" title="创建静态组件"></a>创建静态组件</h2><p>如果创建的组件目的是为了仅仅展示HTML代码或从Python可视化库中渲染图表，那么可以有两种很简单的方法实现<code>components.html()</code>和<code>components.iframe()</code>。</p><h3 id="示例1：Gist代码段"><a href="#示例1：Gist代码段" class="headerlink" title="示例1：Gist代码段"></a>示例1：Gist代码段</h3><p>比如想在页面中嵌入如下这种Github Gist代码段：<br><img src="https://user-images.githubusercontent.com/6218739/157794777-0778762a-cb06-437e-98bc-6f63cc6f4a11.png" alt="gist"><br>那么，可以这样写：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"><span class="keyword">import</span> streamlit.components.v1 <span class="keyword">as</span> components</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">github_gist</span>(<span class="params">gist_creator, gist_id, height=<span class="number">600</span>, scrolling=<span class="literal">True</span></span>):</span></span><br><span class="line">    components.html(</span><br><span class="line">        <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      &lt;script src=&quot;https://gist.github.com/<span class="subst">&#123;gist_creator&#125;</span>/<span class="subst">&#123;gist_id&#125;</span>.js&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;/script&gt;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>,</span><br><span class="line">        height=height,</span><br><span class="line">        scrolling=scrolling,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">github_gist(<span class="string">&#x27;gwen001&#x27;</span>, <span class="string">&#x27;6843c83d878ff22783bd573ac48a2c93&#x27;</span>, height=<span class="number">600</span>)</span><br></pre></td></tr></table></figure><br>可以看出，在<code>components.html()</code>可以方便地嵌入和调用javascript脚本。</p><h3 id="示例2：boostrap"><a href="#示例2：boostrap" class="headerlink" title="示例2：boostrap"></a>示例2：boostrap</h3><p>如下例子是使用bootstrap库创建自定义按钮。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"><span class="keyword">import</span> streamlit.components.v1 <span class="keyword">as</span> components</span><br><span class="line"></span><br><span class="line"><span class="comment"># bootstrap 4 collapse example</span></span><br><span class="line">components.html(</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css&quot; integrity=&quot;sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm&quot; crossorigin=&quot;anonymous&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;script src=&quot;https://code.jquery.com/jquery-3.2.1.slim.min.js&quot; integrity=&quot;sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script src=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js&quot; integrity=&quot;sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;div id=&quot;accordion&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;div class=&quot;card&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;card-header&quot; id=&quot;headingOne&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;h5 class=&quot;mb-0&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;button class=&quot;btn btn-link&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#collapseOne&quot; aria-expanded=&quot;true&quot; aria-controls=&quot;collapseOne&quot;&gt;</span></span><br><span class="line"><span class="string">            Collapsible Group Item #1</span></span><br><span class="line"><span class="string">            &lt;/button&gt;</span></span><br><span class="line"><span class="string">          &lt;/h5&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div id=&quot;collapseOne&quot; class=&quot;collapse show&quot; aria-labelledby=&quot;headingOne&quot; data-parent=&quot;#accordion&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;div class=&quot;card-body&quot;&gt;</span></span><br><span class="line"><span class="string">            Collapsible Group Item #1 content</span></span><br><span class="line"><span class="string">          &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;div class=&quot;card&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;div class=&quot;card-header&quot; id=&quot;headingTwo&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;h5 class=&quot;mb-0&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;button class=&quot;btn btn-link collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#collapseTwo&quot; aria-expanded=&quot;false&quot; aria-controls=&quot;collapseTwo&quot;&gt;</span></span><br><span class="line"><span class="string">            Collapsible Group Item #2</span></span><br><span class="line"><span class="string">            &lt;/button&gt;</span></span><br><span class="line"><span class="string">          &lt;/h5&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;div id=&quot;collapseTwo&quot; class=&quot;collapse&quot; aria-labelledby=&quot;headingTwo&quot; data-parent=&quot;#accordion&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;div class=&quot;card-body&quot;&gt;</span></span><br><span class="line"><span class="string">            Collapsible Group Item #2 content</span></span><br><span class="line"><span class="string">          &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>,</span><br><span class="line">    height=<span class="number">600</span>,</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>效果如下：<br><img src="https://user-images.githubusercontent.com/6218739/157795147-df1b82ca-51b5-4d86-97ba-d1c3c608da06.png" alt="bootstrap"><br>可以看出，可以嵌入任意的HTML、CSS和JavaScript代码。<br>同时，因为Component运行在由一个<code>iframe</code>创建的沙盒sandbox中，不用担心安全问题。</p><h3 id="示例3：嵌入外部网站"><a href="#示例3：嵌入外部网站" class="headerlink" title="示例3：嵌入外部网站"></a>示例3：嵌入外部网站</h3><p><code>components.iframe</code>与<code>components.html</code>功能类似，只是它的输入是URL地址，这样就能轻松地将外部网站嵌入到Streamlit app中。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"><span class="keyword">import</span> streamlit.components.v1 <span class="keyword">as</span> components</span><br><span class="line"></span><br><span class="line"><span class="comment"># embed streamlit docs in a streamlit app</span></span><br><span class="line">st.title(<span class="string">&quot;Embed external website&quot;</span>)</span><br><span class="line">components.iframe(<span class="string">&quot;http://www.bing.com/&quot;</span>, height=<span class="number">600</span>, width=<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><br>效果如下：<br><img src="https://user-images.githubusercontent.com/6218739/157796219-22acc939-89b1-49aa-ad11-e67803a14446.png" alt="iframe"></p><h2 id="创建双向组件"><a href="#创建双向组件" class="headerlink" title="创建双向组件"></a>创建双向组件</h2><p>双向组件由两部分构成：<br>（1）一个前端frontend：基于HTML或任意web技术栈（JS技术，React、Vue等框架）构建，然后在Streamlit app中通过一个<code>iframe</code>标签所渲染；<br>（2）一个Python API：使得app可以实例化，并与前端交流数据。</p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>要创建双向组件，需要先安装如下环境：<br>（1）Python3.7-python3.9<br>（2）Streamlit 0.63+<br>（3）nodejs<br>（4）npm或yarn</p><h3 id="下载模板"><a href="#下载模板" class="headerlink" title="下载模板"></a>下载模板</h3><p>可以使用任意web技术来构建组件，Streamlit官方提供了基于React.js前端和纯TypeScript的开发模板，见<a href="https://github.com/streamlit/component-template">这个仓库</a>。<br>也可以使用Vue.js及其他技术。这里以一个社区成员提供的<a href="https://github.com/andfanilo/streamlit-component-template-vue">Vue3模板</a>为例，下载该模板：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:andfanilo/streamlit-component-template-vue.git</span><br></pre></td></tr></table></figure></p><h3 id="安装依赖并运行模板"><a href="#安装依赖并运行模板" class="headerlink" title="安装依赖并运行模板"></a>安装依赖并运行模板</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd my_component/frontend</span><br><span class="line">$ npm install    <span class="comment"># Install npm dependencies</span></span><br><span class="line">$ npm run serve  <span class="comment"># Start the Webpack dev server</span></span><br></pre></td></tr></table></figure><p>注意这里是使用了开发服务器来运行前端代码，好处是开发阶段，每次代码的变动都能直接起效。<br>在实际上线过程中，使用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><br>来进行打包。具体详情可查看“发布组件”一节。</p><h3 id="运行app"><a href="#运行app" class="headerlink" title="运行app"></a>运行app</h3><p>另开一个终端，然后运行该模板所对应的app：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">streamlit run my_component/__init__.py  <span class="comment"># run the example</span></span><br></pre></td></tr></table></figure></p><p>效果如下：<br><img src="https://user-images.githubusercontent.com/6218739/157813585-17353496-5ccf-4126-8073-5b16ea5fc70b.png" alt="vue"></p><p>这个例子展示了双向交流数据是怎样进行的。Streamlit Component展示一个按钮（<code>python-&gt;JavaScript</code>），然后终端用户可以点击按钮。每次按钮被点击后，JavaScript前端就增加计算器数值，然后把它传递回Python（<code>JavaScript-&gt;Python</code>），然后Streamlit又再次渲染展示（<code>Python-&gt;JavaScript</code>）。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="数据交换过程"><a href="#数据交换过程" class="headerlink" title="数据交换过程"></a>数据交换过程</h4><p>（1）Python到JavaScript<br>基于Vue的前端在<code>my_component/frontend/src/MyComponent.vue</code>文件中。Python脚本传来的参数可以在<code>args</code>属性中获得：<br>以此例来说，在Python脚本中定义的函数及其参数为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_component_func = components.declare_component(</span><br><span class="line">    <span class="string">&quot;my_component&quot;</span>,</span><br><span class="line">    url=<span class="string">&quot;http://localhost:3001&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_component</span>(<span class="params">name, key=<span class="literal">None</span></span>):</span></span><br><span class="line">    component_value = _component_func(name=name, key=key, default=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> component_value</span><br><span class="line"></span><br><span class="line">num_clicks = my_component(<span class="string">&quot;World&quot;</span>)</span><br></pre></td></tr></table></figure><br>然后在前端Vue模板中可以这样接收和使用：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;span&gt;</span><br><span class="line">    Hello, &#123;&#123; args.name &#125;&#125;! &amp;nbsp;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><br>（2）JavaScript到Python<br>在前端中通过<code>Streamlit.setComponentValue()</code>向Python脚本传递数据：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Streamlit.setComponentValue(numClicks.value)</span><br></pre></td></tr></table></figure><br>在Python脚本中获得如上数值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num_clicks = my_component(<span class="string">&quot;World&quot;</span>)</span><br><span class="line">st.markdown(<span class="string">&quot;You&#x27;ve clicked %s times!&quot;</span> % <span class="built_in">int</span>(num_clicks))</span><br></pre></td></tr></table></figure><br>当调用<code>Streamlit.setComponentValue(new_value)</code>时，这个新的数值就会传给Streamlit，其就会从上到下重新运行Python脚本，当脚本重新运行后，对<code>my_component(...)</code>的调用就会返回新的数值。</p><h4 id="数据序列化"><a href="#数据序列化" class="headerlink" title="数据序列化"></a>数据序列化</h4><p>（1）Python到JavaScript<br>如前所述，可以在Python的<code>my_component</code>函数中传递数据，从而在JavaScript中获取。可以传递的数据有：</p><ul><li>任何可序列化为JSON的数据</li><li><code>numpy.array</code></li><li><code>pandas.DataFrame</code></li></ul><p>第一种任何可序列化为JSON的数据都会被序列化为JSON字符串，然后在JavaScript中反序列化。<br>第二种和第三种都是通过<a href="https://arrow.apache.org/">Apache Arrow</a>序列化，然后被反序列化为<code>ArrowType</code>，它是Arrow自定义的一种数据格式，提供了非常简便的API供调用。<br>（2）JavaScript到Python<br>如前所述，可以在JavaScript的<code>Streamlit.setComponentValue()</code>函数中传递数据给Python。不像是前面Python到JavaScript那样可以传递参数并解析参数，这个函数仅能传递一个数值。如果想传递多个数值，需要将它们封装成<code>Array</code>或<code>Object</code>。<br>从JavaScript到Python，可以传递可序列化为JSON的数据，以及<code>ArrowTable</code>这种能表示data frame的数据结构。</p><h1 id="发布组件"><a href="#发布组件" class="headerlink" title="发布组件"></a>发布组件</h1><p>新的组件创建好后，可以将其打包发布到PyPI上，供其他Python用户使用。即使不是为了公开自己的组件，对于双向组件，也是需要将前端部分进行生产环境下的打包。<br>对于静态组件的发布，以及上传PyPI，这些操作在这里都不再详述，具体可以参考<a href="https://docs.streamlit.io/library/components/publish">这里</a>。<br>这一部分主要看双向组件的配置，因为其既还有Python代码，也有JS和HTML代码，需要将这些前端代码编译成静态文件。<br>双向组件的配置基于前面的template。<br>（1）命名组件<br>首先，将<code>template/my_component/</code>文件夹重命名为<code>template/&lt;component name&gt;/</code>；<br>然后，将组件名字传入<code>declare_component()</code>的第一个参数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> _RELEASE:</span><br><span class="line">    _component_func = components.declare_component(</span><br><span class="line">        <span class="string">&quot;hello_world&quot;</span>,</span><br><span class="line">        url=<span class="string">&quot;http://localhost:3001&quot;</span>,</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    parent_dir = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">    build_dir = os.path.join(parent_dir, <span class="string">&quot;frontend/dist&quot;</span>)</span><br><span class="line">    _component_func = components.declare_component(</span><br><span class="line">        <span class="string">&quot;hello_world&quot;</span>, path=build_dir)</span><br></pre></td></tr></table></figure><br>（2）打包前端文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd frontend</span><br><span class="line">$ npm run build</span><br></pre></td></tr></table></figure><br>即将Vue代码编译为HTML、CSS和JS文件。这将会新建一个<code>frontend/dist/</code>文件夹，里面存放了这些文件。<br>（3）更改Release模式<br>将Python脚本中的模式设为release模式：<code>_RELEASE = True</code>。</p><p>这样配置以后，就无需通过<code>npm run serve</code>开启一个开发服务器，直接使用一个终端运行<code>streamlit run</code>即可。</p>]]></content>
    
    
    <summary type="html">简介
Streamlit的组件Components是一系列第三方的Python模块，其极大地扩展了Streamlit的功能。
Components带来了无穷的想象力和可能性，比如与React、Vue等前端框架联动、创建自定义风格和行为的新部件、以及增加新的可视化图表类型等。

使用组件
查找可用组件
查找组件有两个常用的途径：
一是Component Gallery，这是官方挑选出来的特色组件；
二是Streamlit Components - Community Tracker这个论坛帖子，里面搜集了很多社区成员创建的组件。

安装组件
安装这些组件，只需：
1


pip install </summary>
    
    
    
    <category term="digitalization" scheme="http://qixinbo.github.io/categories/digitalization/"/>
    
    
    <category term="Streamlit" scheme="http://qixinbo.github.io/tags/Streamlit/"/>
    
  </entry>
  
  <entry>
    <title>用Python开发web应用——Streamlit框架解析：2 -- 会话状态</title>
    <link href="http://qixinbo.github.io/2022/03/10/streamlit_2/"/>
    <id>http://qixinbo.github.io/2022/03/10/streamlit_2/</id>
    <published>2022-03-09T16:00:00.000Z</published>
    <updated>2022-03-10T06:31:51.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在Streamlit中，与一个部件widget的交互会触发“重新运行”rerun，这样一来每次运行后代码中的变量都会被重新初始化。这可能会带来很麻烦的问题，比如实现一个简单的“累加计数按钮”，每次点击后都会清零，无法实现累加功能。<br>为了解决类似问题，Streamlit引入了一种新的特性：会话状态Session State，它是一种可以在rerun之间保存变量状态、配合使用回调函数处理部件上的事件、动态改变部件状态等等的功能（注意，这些功能发生在一个session中，一个session可以简单理解为用户通过浏览器的一个标签页来访问Streamlit）。其可以用在如下场景中：<br>（1）数据或图像标注<a href="https://github.com/streamlit/release-demos/blob/0.84/0.84/demos/labelling.py">code</a>；<br>（2）创建分页<a href="https://github.com/streamlit/release-demos/blob/0.84/0.84/demos/pagination.py">code</a>；<br>（3）基于其他部件来添加部件；<br>（4）创建简单的基于状态的小游戏，如井字棋<a href="https://github.com/streamlit/release-demos/blob/0.84/0.84/demos/tic_tac_toe.py">code</a>；<br>（5）待办事项清单<a href="https://github.com/streamlit/release-demos/blob/0.84/0.84/demos/todo_list.py">code</a>。</p><h1 id="累加计数例子"><a href="#累加计数例子" class="headerlink" title="累加计数例子"></a>累加计数例子</h1><p>比如最开头提到的“累加计数按钮”的实现，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"></span><br><span class="line">st.title(<span class="string">&#x27;Counter Example&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Streamlit runs from top to bottom on every iteraction so</span></span><br><span class="line"><span class="comment"># we check if `count` has already been initialized in st.session_state.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If no, then initialize count to 0</span></span><br><span class="line"><span class="comment"># If count is already initialized, don&#x27;t do anything</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;count&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> st.session_state:</span><br><span class="line">    st.session_state.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a button which will increment the counter</span></span><br><span class="line">increment = st.button(<span class="string">&#x27;Increment&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> increment:</span><br><span class="line">    st.session_state.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A button to decrement the counter</span></span><br><span class="line">decrement = st.button(<span class="string">&#x27;Decrement&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> decrement:</span><br><span class="line">    st.session_state.count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">st.write(<span class="string">&#x27;Count = &#x27;</span>, st.session_state.count)</span><br></pre></td></tr></table></figure></p><h1 id="配合回调函数更新会话状态"><a href="#配合回调函数更新会话状态" class="headerlink" title="配合回调函数更新会话状态"></a>配合回调函数更新会话状态</h1><p>首先看一下什么是回调函数，援引维基百科上的一张图：<br><img src="https://user-images.githubusercontent.com/6218739/157572549-24b73b56-bd8d-4f5b-8825-c66eb25e0449.svg" alt="Callback-notitle"><br>这张图说明了几个事情：<br>（1）底层有一个库函数，它被其他程序（这里是Main program这个程序）所调用<br>（2）这个库函数有脾气，它不能被简单调用，需要给它提前传一个函数（即回调函数），这样才能在合适的时候执行该函数<br>（3）这个回调函数与main program处于同一层级，是由main program来指定的。<br>可以这样记忆回调函数：从库函数的视角，你先给我这个函数，我回头再调用你。<br><a href="https://www.zhihu.com/question/19801131/answer/27459821">回调函数（callback）是什么？ - no.body的回答 - 知乎</a>挺好。</p><h2 id="使用回调函数更新会话状态"><a href="#使用回调函数更新会话状态" class="headerlink" title="使用回调函数更新会话状态"></a>使用回调函数更新会话状态</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"></span><br><span class="line">st.title(<span class="string">&#x27;Counter Example using Callbacks&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;count&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> st.session_state:</span><br><span class="line">    st.session_state.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">increment_counter</span>():</span></span><br><span class="line">    st.session_state.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">st.button(<span class="string">&#x27;Increment&#x27;</span>, on_click=increment_counter)</span><br><span class="line"></span><br><span class="line">st.write(<span class="string">&#x27;Count = &#x27;</span>, st.session_state.count)</span><br></pre></td></tr></table></figure><p>即可以在输入部件（比如按钮、滑块、文本框等）的<code>on_change</code>或<code>on_click</code>的事件上绑定回调函数。</p><h2 id="在回调函数中使用args和kwargs"><a href="#在回调函数中使用args和kwargs" class="headerlink" title="在回调函数中使用args和kwargs"></a>在回调函数中使用args和kwargs</h2><p>可以在回调函数中传入参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"></span><br><span class="line">st.title(<span class="string">&#x27;Counter Example using Callbacks with args&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;count&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> st.session_state:</span><br><span class="line">    st.session_state.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">increment_value = st.number_input(<span class="string">&#x27;Enter a value&#x27;</span>, value=<span class="number">0</span>, step=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">increment_counter</span>(<span class="params">increment_value</span>):</span></span><br><span class="line">    st.session_state.count += increment_value</span><br><span class="line"></span><br><span class="line">increment = st.button(<span class="string">&#x27;Increment&#x27;</span>, on_click=increment_counter,</span><br><span class="line">    args=(increment_value, ))</span><br><span class="line"></span><br><span class="line">st.write(<span class="string">&#x27;Count = &#x27;</span>, st.session_state.count)</span><br></pre></td></tr></table></figure><br>也可以传入字典类型的命名参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"></span><br><span class="line">st.title(<span class="string">&#x27;Counter Example using Callbacks with kwargs&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;count&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> st.session_state:</span><br><span class="line">    st.session_state.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">increment_counter</span>(<span class="params">increment_value=<span class="number">0</span></span>):</span></span><br><span class="line">    st.session_state.count += increment_value</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrement_counter</span>(<span class="params">decrement_value=<span class="number">0</span></span>):</span></span><br><span class="line">    st.session_state.count -= decrement_value</span><br><span class="line"></span><br><span class="line">st.button(<span class="string">&#x27;Increment&#x27;</span>, on_click=increment_counter,</span><br><span class="line">    kwargs=<span class="built_in">dict</span>(increment_value=<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">st.button(<span class="string">&#x27;Decrement&#x27;</span>, on_click=decrement_counter,</span><br><span class="line">    kwargs=<span class="built_in">dict</span>(decrement_value=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">st.write(<span class="string">&#x27;Count = &#x27;</span>, st.session_state.count)</span><br></pre></td></tr></table></figure></p><h2 id="在表单上绑定回调函数"><a href="#在表单上绑定回调函数" class="headerlink" title="在表单上绑定回调函数"></a>在表单上绑定回调函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">st.title(<span class="string">&#x27;Counter Example&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;count&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> st.session_state:</span><br><span class="line">    st.session_state.count = <span class="number">0</span></span><br><span class="line">    st.session_state.last_updated = datetime.time(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_counter</span>():</span></span><br><span class="line">    st.session_state.count += st.session_state.increment_value</span><br><span class="line">    st.session_state.last_updated = st.session_state.update_time</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> st.form(key=<span class="string">&#x27;my_form&#x27;</span>):</span><br><span class="line">    st.time_input(label=<span class="string">&#x27;Enter the time&#x27;</span>, value=datetime.datetime.now().time(), key=<span class="string">&#x27;update_time&#x27;</span>)</span><br><span class="line">    st.number_input(<span class="string">&#x27;Enter a value&#x27;</span>, value=<span class="number">0</span>, step=<span class="number">1</span>, key=<span class="string">&#x27;increment_value&#x27;</span>)</span><br><span class="line">    submit = st.form_submit_button(label=<span class="string">&#x27;Update&#x27;</span>, on_click=update_counter)</span><br><span class="line"></span><br><span class="line">st.write(<span class="string">&#x27;Current Count = &#x27;</span>, st.session_state.count)</span><br><span class="line">st.write(<span class="string">&#x27;Last Updated = &#x27;</span>, st.session_state.last_updated)</span><br></pre></td></tr></table></figure><p>在form中仅有<code>st.form_submit_button</code>可以设置回调函数，其他在form中的部件不允许有回调函数。</p><h1 id="变量状态和部件状态的关联"><a href="#变量状态和部件状态的关联" class="headerlink" title="变量状态和部件状态的关联"></a>变量状态和部件状态的关联</h1><p>Session State存储了变量的值，而部件widgets的状态也可以存储在Session State中，变量的状态与部件的状态就可以实现梦幻联动了，方法就是将变量名设置为部件的key值。<br>比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;celsius&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> st.session_state:</span><br><span class="line">    <span class="comment"># set the initial default value of the slider widget</span></span><br><span class="line">    st.session_state.celsius = <span class="number">50.0</span></span><br><span class="line"></span><br><span class="line">st.slider(</span><br><span class="line">    <span class="string">&quot;Temperature in Celsius&quot;</span>,</span><br><span class="line">    min_value=-<span class="number">100.0</span>,</span><br><span class="line">    max_value=<span class="number">100.0</span>,</span><br><span class="line">    key=<span class="string">&quot;celsius&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This will get the value of the slider widget</span></span><br><span class="line">st.write(st.session_state.celsius)</span><br></pre></td></tr></table></figure><br>但是，有两个例外，不能通过Session State的API来改变<code>st.button</code>、<code>st.download_button</code>和<code>st.file_uploader</code>部件的状态。<br>还需要注意的是Session State变量和部件初始化的顺序，如果先初始化了部件，再通过Session State的API来更改它的状态，此时就会报错，抛出<code>StreamlitAPIException</code>的错误。<br>所以，一定注意先在Session State中定义好变量。</p><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="初始化状态"><a href="#初始化状态" class="headerlink" title="初始化状态"></a>初始化状态</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Initialization</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;key&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> st.session_state:</span><br><span class="line">    st.session_state[<span class="string">&#x27;key&#x27;</span>] = <span class="string">&#x27;value&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Session State also supports attribute based syntax</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;key&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> st.session_state:</span><br><span class="line">    st.session_state.key = <span class="string">&#x27;value&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="读取和更新"><a href="#读取和更新" class="headerlink" title="读取和更新"></a>读取和更新</h2><p>读取Session State：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取某一个状态</span></span><br><span class="line">st.write(st.session_state.key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取所有状态</span></span><br><span class="line">st.write(st.session_state)</span><br><span class="line"></span><br><span class="line"><span class="comment"># With magic:</span></span><br><span class="line">st.session_state</span><br></pre></td></tr></table></figure><br>更新状态（有两种方式）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">st.session_state.key = <span class="string">&#x27;value2&#x27;</span>     <span class="comment"># Attribute API</span></span><br><span class="line">st.session_state[<span class="string">&#x27;key&#x27;</span>] = <span class="string">&#x27;value2&#x27;</span>  <span class="comment"># Dictionary like API</span></span><br></pre></td></tr></table></figure></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Delete a single key-value pair</span></span><br><span class="line"><span class="keyword">del</span> st.session_state[key]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Delete all the items in Session state</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> st.session_state.keys():</span><br><span class="line">    <span class="keyword">del</span> st.session_state[key]</span><br></pre></td></tr></table></figure><p>也可以通过在Settings中<code>Clear Cache</code>来删除，并rerun整个app。</p><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><p>使用Session State时需要注意以下几点：<br>（1）Session State的生命周期存在于浏览器的标签页打开且连接到server期间。一旦关闭标签页后，Session State中存储的东西都会丢失。<br>（2）Session State也不能持久化，一旦server关闭，其存储的东西也会被擦除。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.streamlit.io/session-state-for-streamlit/">Session State for Streamlit</a><br><a href="https://docs.streamlit.io/library/advanced-features/session-state">Add statefulness to apps</a><br><a href="https://docs.streamlit.io/library/api-reference/session-state">Session State</a></p>]]></content>
    
    
    <summary type="html">简介
在Streamlit中，与一个部件widget的交互会触发“重新运行”rerun，这样一来每次运行后代码中的变量都会被重新初始化。这可能会带来很麻烦的问题，比如实现一个简单的“累加计数按钮”，每次点击后都会清零，无法实现累加功能。
为了解决类似问题，Streamlit引入了一种新的特性：会话状态Session State，它是一种可以在rerun之间保存变量状态、配合使用回调函数处理部件上的事件、动态改变部件状态等等的功能（注意，这些功能发生在一个session中，一个session可以简单理解为用户通过浏览器的一个标签页来访问Streamlit）。其可以用在如下场景中：
（1）数据或图</summary>
    
    
    
    <category term="digitalization" scheme="http://qixinbo.github.io/categories/digitalization/"/>
    
    
    <category term="Streamlit" scheme="http://qixinbo.github.io/tags/Streamlit/"/>
    
  </entry>
  
  <entry>
    <title>用Python开发web应用——Streamlit框架解析：1 -- 上手</title>
    <link href="http://qixinbo.github.io/2022/03/08/streamlit_1/"/>
    <id>http://qixinbo.github.io/2022/03/08/streamlit_1/</id>
    <published>2022-03-07T16:00:00.000Z</published>
    <updated>2022-03-08T03:27:07.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://streamlit.io/">Streamlit</a>是一个开源Python库，其旨在为机器学习和数据科学领域简单快速地创建和分享美观的、定制化的web应用。使用Streamlit，用户仅仅几分钟即可创建和部署强大的数据应用。<br>截几张范例的界面图：<br><img src="https://user-images.githubusercontent.com/6218739/157160066-1781000e-b957-4fac-b0df-01d23b3c7f67.png" alt="gallery1"><br><img src="https://user-images.githubusercontent.com/6218739/157160339-5e34e7fc-8886-4bd9-bc18-3e94fff749ce.png" alt="g2"><br><img src="https://user-images.githubusercontent.com/6218739/157160476-7d64aa1a-4c92-4f80-8dd3-5e449fcc56be.png" alt="g3"></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>使用pip安装：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install streamlit</span><br></pre></td></tr></table></figure></p><p>测试一下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">streamlit hello</span><br></pre></td></tr></table></figure><br>此时浏览器会打开<code>http://localhost:8501/</code>，然后出现streamlit关于动画、动态绘图、地图、pandas绘图的四个demo。</p><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><h2 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">streamlit run your_script.py [-- script args]</span><br></pre></td></tr></table></figure><p>另外一种运行方式是通过Python模块运行（这对于使用IDE如pycharm有用）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Running</span></span><br><span class="line">$ python -m streamlit your_script.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># is equivalent to:</span></span><br><span class="line">$ streamlit run your_script.py</span><br></pre></td></tr></table></figure></p><h2 id="开启开发模式"><a href="#开启开发模式" class="headerlink" title="开启开发模式"></a>开启开发模式</h2><p>在开发阶段，最好是开启“开发模式”，这样只要保存代码后，Streamlit就能重新运行app。这会极大地提高开发效率。<br>开启方式是在右上角选择“Always rerun”。</p><h2 id="展示数据"><a href="#展示数据" class="headerlink" title="展示数据"></a>展示数据</h2><h3 id="使用“魔法”"><a href="#使用“魔法”" class="headerlink" title="使用“魔法”"></a>使用“魔法”</h3><p>魔法magic和<code>st.write()</code>可以用来展示很多数据类型，比如text、data、matplotlib图表、Altair图表。直接将这些数据传给<code>st.write()</code>或者magic即可，Streamlit可以自动识别。<br>这里魔法magic的意思是不用在代码里调用Streamlit的任何方法就可以直接展示数据，原因是当Streamlit看到在一行中只有一个变量名时，就会自动在这里加上<code>st.write()</code>。<br>比如下面代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># My first app</span></span><br><span class="line"><span class="string">Here&#x27;s our first attempt at using data to create a table:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame(&#123;</span><br><span class="line">  <span class="string">&#x27;first column&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  <span class="string">&#x27;second column&#x27;</span>: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">df</span><br></pre></td></tr></table></figure><br>它跟下面的代码效果是一样的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">st.write(pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&#x27;first column&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    <span class="string">&#x27;second column&#x27;</span>: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></p><h3 id="展示data-frame"><a href="#展示data-frame" class="headerlink" title="展示data frame"></a>展示data frame</h3><p>前面说了，<code>st.write()</code>或magic几乎能展示所有数据，但也有其他的与具体数据相关的函数，如<code>st.dataframe()</code>和<code>st.table()</code>等。<br>这里可能有一个问题：“为什么我不能全用<code>st.write()</code>呢”，原因如下：<br>（1）<code>st.write()</code>或magic能自动渲染数据，但有时你可能想用另外一种方式渲染。比如，如果你不想将dataframe数据渲染成一种可交互的表格，此时就需要使用<code>st.table(df)</code>将它渲染成静态表格；<br>（2）其他方法返回的对象可以被使用和修改，比如在上面增加数据或替换数据；<br>（3）对于其他方法，可以传递更多的参数来定制化行为。<br>比如下面的例子使用Pandas的styler来高亮化某些元素：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">dataframe = pd.DataFrame(</span><br><span class="line">    np.random.randn(<span class="number">10</span>, <span class="number">20</span>),</span><br><span class="line">    columns=(<span class="string">&#x27;col %d&#x27;</span> % i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>)))</span><br><span class="line"></span><br><span class="line">st.dataframe(dataframe.style.highlight_max(axis=<span class="number">0</span>))</span><br></pre></td></tr></table></figure><br>以及静态图表：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">dataframe = pd.DataFrame(</span><br><span class="line">    np.random.randn(<span class="number">10</span>, <span class="number">20</span>),</span><br><span class="line">    columns=(<span class="string">&#x27;col %d&#x27;</span> % i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>)))</span><br><span class="line">st.table(dataframe)</span><br></pre></td></tr></table></figure></p><h3 id="展示charts和maps"><a href="#展示charts和maps" class="headerlink" title="展示charts和maps"></a>展示charts和maps</h3><p>Streamlit支持很多流行的绘图库，如Matplotlib、Altair、deck.gl、plotly等等。一些demo见<a href="https://docs.streamlit.io/library/api-reference#chart-elements">这里</a>。<br>折线图举例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">chart_data = pd.DataFrame(</span><br><span class="line">     np.random.randn(<span class="number">20</span>, <span class="number">3</span>),</span><br><span class="line">     columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">st.line_chart(chart_data)</span><br></pre></td></tr></table></figure><br>地图举例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">map_data = pd.DataFrame(</span><br><span class="line">    np.random.randn(<span class="number">1000</span>, <span class="number">2</span>) / [<span class="number">50</span>, <span class="number">50</span>] + [<span class="number">37.76</span>, -<span class="number">122.4</span>],</span><br><span class="line">    columns=[<span class="string">&#x27;lat&#x27;</span>, <span class="string">&#x27;lon&#x27;</span>])</span><br><span class="line"></span><br><span class="line">st.<span class="built_in">map</span>(map_data)</span><br></pre></td></tr></table></figure></p><h2 id="部件"><a href="#部件" class="headerlink" title="部件"></a>部件</h2><p>当想要探索得到的数据或模型时，可以使用部件进行调节，比如滑块<code>st.slider()</code>、按钮<code>st.button</code>、下拉列表<code>st.selectbox</code>。<br>使用方法也很简单，就像将这些部件视作变量。</p><h3 id="滑块"><a href="#滑块" class="headerlink" title="滑块"></a>滑块</h3><p>常用来调节数值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line">x = st.slider(<span class="string">&#x27;x&#x27;</span>)  <span class="comment"># 👈 this is a widget</span></span><br><span class="line">st.write(x, <span class="string">&#x27;squared is&#x27;</span>, x * x)</span><br></pre></td></tr></table></figure></p><h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><p>常用来显示或关闭数据。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> st.checkbox(<span class="string">&#x27;Show dataframe&#x27;</span>):</span><br><span class="line">    chart_data = pd.DataFrame(</span><br><span class="line">       np.random.randn(<span class="number">20</span>, <span class="number">3</span>),</span><br><span class="line">       columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    chart_data</span><br></pre></td></tr></table></figure></p><h3 id="下拉列表"><a href="#下拉列表" class="headerlink" title="下拉列表"></a>下拉列表</h3><p>常用来选择数据<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&#x27;first column&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    <span class="string">&#x27;second column&#x27;</span>: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">option = st.selectbox(</span><br><span class="line">    <span class="string">&#x27;Which number do you like best?&#x27;</span>,</span><br><span class="line">     df[<span class="string">&#x27;first column&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;You selected: &#x27;</span>, option</span><br></pre></td></tr></table></figure></p><h3 id="部件的key"><a href="#部件的key" class="headerlink" title="部件的key"></a>部件的key</h3><p>如果对某一部件附加了一个独特的key，那么，部件的值可以通过key来获取，比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line">st.text_input(<span class="string">&quot;Your name&quot;</span>, key=<span class="string">&quot;name&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># You can access the value at any point with:</span></span><br><span class="line">st.session_state.name</span><br></pre></td></tr></table></figure><br>有key的部件会被自动添加到Session State中，从而可以在部件间传递数据。<br>详情查看<a href="https://docs.streamlit.io/library/api-reference/session-state">这里</a>。</p><h3 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h3><p>当一个app需要运行很长时间时，可以添加进度条部件<code>st.progress()</code>来显示进度。进度条不能添加key。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;Starting a long computation...&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a placeholder</span></span><br><span class="line">latest_iteration = st.empty()</span><br><span class="line">bar = st.progress(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">  <span class="comment"># Update the progress bar with each iteration.</span></span><br><span class="line">  latest_iteration.text(<span class="string">f&#x27;Iteration <span class="subst">&#123;i+<span class="number">1</span>&#125;</span>&#x27;</span>)</span><br><span class="line">  bar.progress(i + <span class="number">1</span>)</span><br><span class="line">  time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;...and now we\&#x27;re done!&#x27;</span></span><br></pre></td></tr></table></figure></p><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="sidebar"><a href="#sidebar" class="headerlink" title="sidebar"></a>sidebar</h3><p>Streamlit提供了一个左侧侧边栏<code>st.sidebar</code>来组织上面的部件。每一个传给该侧边栏的元素都被“钉”到左边，这样用户就能专注于自己的app内容上。<br>比如使用<code>st.sidebar.slider</code>替代<code>st.slider</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a selectbox to the sidebar:</span></span><br><span class="line">add_selectbox = st.sidebar.selectbox(</span><br><span class="line">    <span class="string">&#x27;How would you like to be contacted?&#x27;</span>,</span><br><span class="line">    (<span class="string">&#x27;Email&#x27;</span>, <span class="string">&#x27;Home phone&#x27;</span>, <span class="string">&#x27;Mobile phone&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a slider to the sidebar:</span></span><br><span class="line">add_slider = st.sidebar.slider(</span><br><span class="line">    <span class="string">&#x27;Select a range of values&#x27;</span>,</span><br><span class="line">    <span class="number">0.0</span>, <span class="number">100.0</span>, (<span class="number">25.0</span>, <span class="number">75.0</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h3 id="columns和expander"><a href="#columns和expander" class="headerlink" title="columns和expander"></a>columns和expander</h3><p>除了侧边栏，Streamlit还提供了其他控制布局的方式，如<code>st.columns</code>可以一列一列地排放部件，<code>st.expander</code>可以将大片的内容隐藏或展开。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"></span><br><span class="line">left_column, right_column = st.columns(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># You can use a column just like st.sidebar:</span></span><br><span class="line">left_column.button(<span class="string">&#x27;Press me!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Or even better, call Streamlit functions inside a &quot;with&quot; block:</span></span><br><span class="line"><span class="keyword">with</span> right_column:</span><br><span class="line">    chosen = st.radio(</span><br><span class="line">        <span class="string">&#x27;Sorting hat&#x27;</span>,</span><br><span class="line">        (<span class="string">&quot;Gryffindor&quot;</span>, <span class="string">&quot;Ravenclaw&quot;</span>, <span class="string">&quot;Hufflepuff&quot;</span>, <span class="string">&quot;Slytherin&quot;</span>))</span><br><span class="line">    st.write(<span class="string">f&quot;You are in <span class="subst">&#123;chosen&#125;</span> house!&quot;</span>)</span><br></pre></td></tr></table></figure></p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>Streamlit默认支持Light和Dark两种主题。可以通过Settings进行设置。也可以自定义主题。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>当从web上加载数据、操作大型数据集以及进行大规模计算时，对状态的缓存就非常重要，Streamlit缓存使得这些情况下app仍然快速执行。<br>Streamlit提供了一些缓存方案，如<code>@st.cache</code>、<code>@st.experimental_memo</code>、<code>@st.experimental_singleton</code>。<br>具体的用法可以参考<a href="https://docs.streamlit.io/library/advanced-features/experimental-cache-primitives">这里</a>。<br>以<code>@st.cache</code>为例，当指定需要使用缓存时，就用这个装饰器包装一下函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> streamlit <span class="keyword">as</span> st</span><br><span class="line"></span><br><span class="line"><span class="meta">@st.cache  </span><span class="comment"># 👈 This function will be cached</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_slow_function</span>(<span class="params">arg1, arg2</span>):</span></span><br><span class="line">    <span class="comment"># Do something really slow in here!</span></span><br><span class="line">    <span class="keyword">return</span> the_output</span><br></pre></td></tr></table></figure><br>这个装饰器告诉Streamlit，当该函数被调用时，它需要检查如下东西：<br>（1）该函数的输入参数；<br>（2）在函数内用到的任意外部变量；<br>（3）函数体；<br>（4）在该函数体内用到的其他函数体。<br>如果是Streamlit看到是这四个部分都是第一次以这些数值及其组合顺序运行，那么它就运行函数，然后将结果存储在局部缓存中。然后，当该缓存的函数下一次被调用时，如果上述四部分都没有改变，那么Streamlit就会跳过执行，而将上一次缓存的结果返回。</p><h2 id="运行机理"><a href="#运行机理" class="headerlink" title="运行机理"></a>运行机理</h2><p>知道了上面的零碎的知识，总结一下整体的运行机理：<br>（1）Streamlit的apps是从上到下执行的Python脚本；<br>（2）每次当一个用户打开浏览器，访问你的app后，上述脚本就会重新执行；<br>（3）当脚本执行时，Streamlit在浏览器渲染它的输出；<br>（4）脚本使用Streamlit缓存来避免重复执行昂贵的运算，所以结果更新会非常快；<br>（5）每次当用户与部件进行交互时，脚本就会重新运行，部件的返回值也会更新为最新状态。</p><h1 id="上手总结"><a href="#上手总结" class="headerlink" title="上手总结"></a>上手总结</h1><p>以上就是最基本的Streamlit用法，总体来看，确实极大地降低了开发web app的难度，可以使用原生python语法来做这件事是太香了。</p>]]></content>
    
    
    <summary type="html">简介
Streamlit是一个开源Python库，其旨在为机器学习和数据科学领域简单快速地创建和分享美观的、定制化的web应用。使用Streamlit，用户仅仅几分钟即可创建和部署强大的数据应用。
截几张范例的界面图：




安装
使用pip安装：
1


pip install streamlit




测试一下：
1


streamlit hello



此时浏览器会打开http://localhost:8501/，然后出现streamlit关于动画、动态绘图、地图、pandas绘图的四个demo。

核心概念
运行方式
1


streamlit run your_script.</summary>
    
    
    
    <category term="digitalization" scheme="http://qixinbo.github.io/categories/digitalization/"/>
    
    
    <category term="Streamlit" scheme="http://qixinbo.github.io/tags/Streamlit/"/>
    
  </entry>
  
  <entry>
    <title>开源深度学习计算平台ImJoy解析：11 -- ImJoy主站之主组件</title>
    <link href="http://qixinbo.github.io/2022/02/28/ImJoy_11/"/>
    <id>http://qixinbo.github.io/2022/02/28/ImJoy_11/</id>
    <published>2022-02-27T16:00:00.000Z</published>
    <updated>2022-03-04T07:19:56.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>前面讲了<a href="https://imjoy.io">ImJoy主站</a>的入口文件<code>main.js</code>，这一篇解析一下该主站的ImJoy组件，它也是整个app的“门面担当”，起到了统筹整个网站的作用。</p><p>为了便于分析，将很多高阶的暂时用不到的组件（比如工具栏、窗口管理、文件上传、连接后台Engine等）都删掉，留下最基本的能运行最小化imjoy插件的功能，截图如下：<br><img src="https://user-images.githubusercontent.com/6218739/156502647-18321726-6c25-4631-bcc4-b632eef39f23.png" alt="mini-imjoy"></p><p>这样便于分析整个组件的宏观结构和运行逻辑。<br>下面是对于该极小化组件的逐行代码分析。</p><h1 id="template代码"><a href="#template代码" class="headerlink" title="template代码"></a>template代码</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;imjoy noselect&quot;</span>&gt;</span><br><span class="line">    &lt;!-- 整个imjoy页面框架是通过vue material这个组件库的md-app进行组织的 --&gt;</span><br><span class="line">    &lt;!-- 它包括了md-app-toolbar工具栏、 md-app-drawer菜单栏和md-app-content内容区三部分 --&gt;</span><br><span class="line">    &lt;!-- 相关教程见：https:<span class="comment">//www.creative-tim.com/vuematerial/components/app --&gt;</span></span><br><span class="line">    &lt;md-app&gt;</span><br><span class="line">      &lt;!-- 工具栏就是最上面的横条，里面的内容直接全部删除了，仅保留架子 --&gt;</span><br><span class="line">      &lt;md-app-toolbar <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;md-dense app-toolbar&quot;</span> md-elevation=<span class="string">&quot;0&quot;</span>&gt;</span><br><span class="line">      &lt;/md-app-toolbar&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- 接下来就是左侧的菜单栏 --&gt;</span><br><span class="line">      &lt;!-- drawer的属性设置见：https:<span class="comment">//www.creative-tim.com/vuematerial/components/drawer# --&gt;</span></span><br><span class="line">      &lt;!-- 具体地： --&gt;</span><br><span class="line">      &lt;!-- (<span class="number">1</span>)菜单栏是否可见是通过md-active属性控制，其通过v-bind绑定到了menuVisible这个变量上 --&gt;</span><br><span class="line">      &lt;!-- (<span class="number">2</span>)菜单栏关闭和打开两个事件都通过v-on绑定到了wm.resizeAll()函数上 --&gt;</span><br><span class="line">      &lt;!-- (<span class="number">3</span>)菜单栏是否常驻md-persistent和菜单栏是否支持触屏下的swipe绑定到了screenWidth这个变量上 --&gt;</span><br><span class="line">      &lt;md-app-drawer</span><br><span class="line">        :md-active.sync=<span class="string">&quot;menuVisible&quot;</span></span><br><span class="line">        @md-closed=<span class="string">&quot;wm.resizeAll()&quot;</span></span><br><span class="line">        @md-opened=<span class="string">&quot;wm.resizeAll()&quot;</span></span><br><span class="line">        :md-persistent=<span class="string">&quot;screenWidth &gt; 800 ? &#x27;full&#x27; : null&quot;</span></span><br><span class="line">        :md-swipeable=<span class="string">&quot;screenWidth &gt; 600 ? false : true&quot;</span></span><br><span class="line">      &gt;</span><br><span class="line">        &lt;!-- 接下来是将上传文件,添加工作流,添加插件和插件列表都放在了一个card中 --&gt;</span><br><span class="line">        &lt;!-- 这个card的显示有两个判断语句,一个是用v-show判断plugin_loaded这个变量是否为<span class="literal">true</span> --&gt;</span><br><span class="line">        &lt;!-- 另一个是用v-<span class="keyword">if</span>判断pm这个变量是否为<span class="literal">true</span>, --&gt;</span><br><span class="line">        &lt;!-- v-<span class="keyword">if</span>和v-show看起来差不多,但有区别,见:https:<span class="comment">//cn.vuejs.org/v2/guide/conditional.html --&gt;</span></span><br><span class="line">        &lt;md-card id=<span class="string">&quot;plugin-menu&quot;</span> v-show=<span class="string">&quot;plugin_loaded&quot;</span> v-<span class="keyword">if</span>=<span class="string">&quot;pm&quot;</span>&gt;</span><br><span class="line">          &lt;!-- 将files,workflow和plugins都放在了card的header中, --&gt;</span><br><span class="line">          &lt;!-- 这里我们将files和workflow都删掉了,仅留plugins的代码 --&gt;</span><br><span class="line">          &lt;md-card-header&gt;</span><br><span class="line">            &lt;!-- 添加plugins就是一个按钮,其<span class="class"><span class="keyword">class</span>也是由<span class="title">v</span>-<span class="title">bind</span>绑定并判断 --&gt;</span></span><br><span class="line"><span class="class">            &lt;!-- 该按钮的点击时间用<span class="title">v</span>-<span class="title">on</span>绑定到了<span class="title">showPluginManagement</span>()函数上 --&gt;</span></span><br><span class="line">            &lt;!-- 当点击该按钮后, 从而执行该函数,其中有一个非常重要的变量:--&gt;</span><br><span class="line">            &lt;!-- <span class="built_in">this</span>.showAddPluginDialog会设为<span class="literal">true</span> --&gt;</span><br><span class="line">            &lt;!-- 从而会引发如下对话框的弹出:</span><br><span class="line">            &lt;md-dialog</span><br><span class="line">              <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;plugin-dialog&quot;</span></span><br><span class="line">              :md-active.sync=<span class="string">&quot;showAddPluginDialog&quot;</span></span><br><span class="line">              :md-click-outside-to-close=<span class="string">&quot;true&quot;</span></span><br><span class="line">            &gt; --&gt;</span><br><span class="line">            &lt;md-button</span><br><span class="line">              ref=<span class="string">&quot;add_plugin_button&quot;</span></span><br><span class="line">              :<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;pm.installed_plugins.length &gt; 0 ? &#x27;&#x27; : &#x27;md-primary&#x27;&quot;</span></span><br><span class="line">              @click=<span class="string">&quot;showPluginManagement()&quot;</span></span><br><span class="line">            &gt;</span><br><span class="line">              &lt;md-icon&gt;add&lt;/md-icon&gt;Plugins</span><br><span class="line">            &lt;/md-button&gt;</span><br><span class="line">          &lt;/md-card-header&gt;</span><br><span class="line"></span><br><span class="line">          &lt;!-- 接下来就是将插件列表放在card的content区域 --&gt;</span><br><span class="line">          &lt;md-card-content&gt;</span><br><span class="line">            &lt;!-- 使用v-<span class="keyword">for</span>来循环插件列表,并对每一项提供了key的身份 --&gt;</span><br><span class="line">            &lt;!-- v-<span class="keyword">for</span>的教程见:https:<span class="comment">//cn.vuejs.org/v2/guide/list.html --&gt;</span></span><br><span class="line">            &lt;div v-<span class="keyword">for</span>=<span class="string">&quot;plugin in sortedRunnablePlugins()&quot;</span> :key=<span class="string">&quot;plugin.name&quot;</span>&gt;</span><br><span class="line">              &lt;!-- 增加一个分割线 --&gt;</span><br><span class="line">              &lt;md-divider&gt;&lt;/md-divider&gt;</span><br><span class="line">              &lt;div style=<span class="string">&quot;display: flex;&quot;</span>&gt;</span><br><span class="line">                &lt;!-- 这里对每一个插件会包装一个badge徽章,用途是判断它需不需要升级 --&gt;</span><br><span class="line">                &lt;!-- 如果需要升级,会出现一个NEW的角标 --&gt;</span><br><span class="line">                &lt;md-badge</span><br><span class="line">                  :<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;plugin.update_available ? &#x27;&#x27; : &#x27;hide-badge&#x27;&quot;</span></span><br><span class="line">                  <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;md-square md-primary&quot;</span></span><br><span class="line">                  md-dense</span><br><span class="line">                  md-content=<span class="string">&quot;NEW&quot;</span></span><br><span class="line">                &gt;</span><br><span class="line">                  &lt;!-- 这里是对插件的icon按钮点击后会出现的菜单进行定义 --&gt;</span><br><span class="line">                  &lt;md-menu md-size=<span class="string">&quot;medium&quot;</span>&gt;</span><br><span class="line">                    &lt;!-- 触发菜单的icon按钮定义 --&gt;</span><br><span class="line">                    &lt;md-button</span><br><span class="line">                      <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;md-icon-button&quot;</span></span><br><span class="line">                      :<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;plugin.running ? &#x27;md-accent&#x27; : &#x27;&#x27;&quot;</span></span><br><span class="line">                      md-menu-trigger</span><br><span class="line">                    &gt;</span><br><span class="line">                      &lt;!-- 插件的加载状态 --&gt;</span><br><span class="line">                      &lt;md-progress-spinner</span><br><span class="line">                        v-<span class="keyword">if</span>=<span class="string">&quot;plugin.initializing || plugin.terminating&quot;</span></span><br><span class="line">                        <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;md-accent&quot;</span></span><br><span class="line">                        :md-diameter=<span class="string">&quot;20&quot;</span></span><br><span class="line">                        md-mode=<span class="string">&quot;indeterminate&quot;</span></span><br><span class="line">                      &gt;&lt;/md-progress-spinner&gt;</span><br><span class="line">                      &lt;!-- icon会判断该插件有没有提供自定义的图标,如果没有,则使用默认的extension图标 --&gt;</span><br><span class="line">                      &lt;!-- 这个地方调用的就是之前入口文件所全局注册的PluginIcon组件 --&gt;</span><br><span class="line">                      &lt;plugin-icon</span><br><span class="line">                        v-<span class="keyword">else</span></span><br><span class="line">                        :icon=<span class="string">&quot;plugin.config.icon&quot;</span></span><br><span class="line">                      &gt;&lt;/plugin-icon&gt;</span><br><span class="line">                      &lt;!-- 按钮的工具提示信息 --&gt;</span><br><span class="line">                      &lt;md-tooltip v-<span class="keyword">if</span>=<span class="string">&quot;screenWidth &gt; 500&quot;</span>&gt;&#123;&#123;</span><br><span class="line">                        plugin.name + <span class="string">&quot;: &quot;</span> + plugin.config.description</span><br><span class="line">                      &#125;&#125;&lt;/md-tooltip&gt;</span><br><span class="line">                    &lt;/md-button&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;!-- 点击icon按钮后弹出的菜单选项 --&gt;</span><br><span class="line">                    &lt;md-menu-content&gt;</span><br><span class="line">                      &lt;!-- Docs选项,绑定了showDoc方法 --&gt;</span><br><span class="line">                      &lt;md-menu-item @click=<span class="string">&quot;showDoc(plugin.id)&quot;</span>&gt;</span><br><span class="line">                        &lt;md-icon&gt;description&lt;/md-icon&gt;Docs</span><br><span class="line">                      &lt;/md-menu-item&gt;</span><br><span class="line">                      &lt;!-- Share选项,不一定会显示,有一个v-<span class="keyword">if</span>条件渲染 --&gt;</span><br><span class="line">                      &lt;md-menu-item</span><br><span class="line">                        v-<span class="keyword">if</span>=<span class="string">&quot;plugin.config.origin&quot;</span></span><br><span class="line">                        @click=<span class="string">&quot;sharePlugin(plugin.id)&quot;</span></span><br><span class="line">                      &gt;</span><br><span class="line">                        &lt;md-icon&gt;share&lt;/md-icon&gt;Share</span><br><span class="line">                      &lt;/md-menu-item&gt;</span><br><span class="line">                      &lt;!-- Export选项,绑定了downloadPlugin --&gt;</span><br><span class="line">                      &lt;md-menu-item @click=<span class="string">&quot;downloadPlugin(plugin.id)&quot;</span>&gt;</span><br><span class="line">                        &lt;md-icon&gt;cloud_download&lt;/md-icon&gt;Export</span><br><span class="line">                      &lt;/md-menu-item&gt;</span><br><span class="line">                      &lt;!-- Edit选项,绑定了editPlugin --&gt;</span><br><span class="line">                      &lt;md-menu-item @click=<span class="string">&quot;editPlugin(plugin.id)&quot;</span>&gt;</span><br><span class="line">                        &lt;md-icon&gt;edit&lt;/md-icon&gt;Edit</span><br><span class="line">                      &lt;/md-menu-item&gt;</span><br><span class="line">                      &lt;!-- Reload选项,绑定了reloadPlugin --&gt;</span><br><span class="line">                      &lt;md-menu-item @click=<span class="string">&quot;reloadPlugin(plugin.config)&quot;</span>&gt;</span><br><span class="line">                        &lt;md-icon&gt;autorenew&lt;/md-icon&gt;Reload</span><br><span class="line">                      &lt;/md-menu-item&gt;</span><br><span class="line">                      &lt;!-- Terminate选项,绑定了unloadPlugin --&gt;</span><br><span class="line">                      &lt;md-menu-item @click=<span class="string">&quot;unloadPlugin(plugin)&quot;</span>&gt;</span><br><span class="line">                        &lt;md-icon&gt;clear&lt;/md-icon&gt;Terminate</span><br><span class="line">                      &lt;/md-menu-item&gt;</span><br><span class="line">                      &lt;!-- Remove选项,绑定了removePlugin --&gt;</span><br><span class="line">                      &lt;md-menu-item</span><br><span class="line">                        <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;md-accent&quot;</span></span><br><span class="line">                        @click=<span class="string">&quot;removePlugin(plugin)&quot;</span></span><br><span class="line">                      &gt;</span><br><span class="line">                        &lt;md-icon&gt;delete_forever&lt;/md-icon&gt;Remove</span><br><span class="line">                      &lt;/md-menu-item&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;/md-menu-content&gt;</span><br><span class="line">                  &lt;/md-menu&gt;</span><br><span class="line">                &lt;/md-badge&gt;</span><br><span class="line"></span><br><span class="line">                &lt;!-- 接下来就是由插件的名称所形成的按钮 --&gt;</span><br><span class="line">                &lt;!-- 对于需要链接到engine的插件,还会检测其状态,如果没有链接到engine上,就会disable该按钮,从而无法运行. --&gt;</span><br><span class="line">                &lt;!-- 对于鼠标操作,也附加了鼠标按钮修饰符,防止误操作,教程见:https:<span class="comment">//cn.vuejs.org/v2/guide/events.html --&gt;</span></span><br><span class="line">                &lt;!-- 点击该按钮后就会运行runOp方法 --&gt;</span><br><span class="line">                &lt;md-button</span><br><span class="line">                  <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;joy-run-button&quot;</span></span><br><span class="line">                  :<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;</span></span><br><span class="line"><span class="string">                    plugin.running</span></span><br><span class="line"><span class="string">                      ? &#x27;busy-plugin&#x27;</span></span><br><span class="line"><span class="string">                      : plugin._disconnected &amp;&amp; plugin.engine</span></span><br><span class="line"><span class="string">                      ? &#x27;md-accent&#x27;</span></span><br><span class="line"><span class="string">                      : &#x27;md-primary&#x27;</span></span><br><span class="line"><span class="string">                  &quot;</span></span><br><span class="line">                  :disabled=<span class="string">&quot;plugin._disconnected &amp;&amp; !plugin.engine&quot;</span></span><br><span class="line">                  @click.exact=<span class="string">&quot;</span></span><br><span class="line"><span class="string">                    plugin._disconnected</span></span><br><span class="line"><span class="string">                      ? connectPlugin(plugin)</span></span><br><span class="line"><span class="string">                      : runOp(plugin.ops[plugin.name])</span></span><br><span class="line"><span class="string">                  &quot;</span></span><br><span class="line">                  @click.right.exact=<span class="string">&quot;logPlugin(plugin)&quot;</span></span><br><span class="line">                &gt;</span><br><span class="line">                  &#123;&#123; plugin.config.name + <span class="string">&quot; &quot;</span> + plugin.config.badges &#125;&#125;</span><br><span class="line">                &lt;/md-button&gt;</span><br><span class="line"></span><br><span class="line">              &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">              &lt;!-- 这个地方是ImJoy的核心!! --&gt;</span><br><span class="line">              &lt;!-- 此处也是ImJoy的名称的来源,即ImJoy来自于joy.js这个库 --&gt;</span><br><span class="line">              &lt;!-- 这个地方需要后面仔细研究机理 --&gt;</span><br><span class="line">              &lt;div</span><br><span class="line">                v-<span class="keyword">for</span>=<span class="string">&quot;op in plugin.ops&quot;</span></span><br><span class="line">                :key=<span class="string">&quot;op.plugin_id + op.name&quot;</span></span><br><span class="line">                v-show=<span class="string">&quot;true&quot;</span></span><br><span class="line">              &gt;</span><br><span class="line">                &lt;joy :config=<span class="string">&quot;op&quot;</span> :show=<span class="string">&quot;true&quot;</span>&gt;&lt;/joy&gt;</span><br><span class="line">              &lt;/div&gt;</span><br><span class="line">              &lt;md-divider&gt;&lt;/md-divider&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;md-divider&gt;&lt;/md-divider&gt;</span><br><span class="line">          &lt;/md-card-content&gt;</span><br><span class="line">        &lt;/md-card&gt;</span><br><span class="line">      &lt;/md-app-drawer&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- 接下来就是整个界面的第三部分,即内容区 --&gt;</span><br><span class="line">      &lt;md-app-content</span><br><span class="line">        :<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;workspace_dropping ? &#x27;file-dropping&#x27; : &#x27;&#x27;&quot;</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;whiteboard-content&quot;</span></span><br><span class="line">      &gt;</span><br><span class="line">        &lt;!-- 就是引用了whiteboard这个组件 --&gt;</span><br><span class="line">        &lt;whiteboard</span><br><span class="line">          v-<span class="keyword">if</span>=<span class="string">&quot;wm&quot;</span></span><br><span class="line">          id=<span class="string">&quot;whiteboard&quot;</span></span><br><span class="line">          @create=<span class="string">&quot;createWindow($event)&quot;</span></span><br><span class="line">          :mode=<span class="string">&quot;wm.window_mode&quot;</span></span><br><span class="line">          :<span class="built_in">window</span>-manager=<span class="string">&quot;wm&quot;</span></span><br><span class="line">        &gt;&lt;/whiteboard&gt;</span><br><span class="line">      &lt;/md-app-content&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 以上就是整个界面的布局 --&gt;</span><br><span class="line">    &lt;/md-app&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 这个是消息提醒对话框，当某处调用showAlert()函数时会触发，比如api.alert时--&gt;</span><br><span class="line">    &lt;md-dialog-alert</span><br><span class="line">      <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;api-dialog&quot;</span></span><br><span class="line">      :md-active.sync=<span class="string">&quot;alert_config.show&quot;</span></span><br><span class="line">      :md-title=<span class="string">&quot;alert_config.title&quot;</span></span><br><span class="line">      :md-content=<span class="string">&quot;alert_config.content&quot;</span></span><br><span class="line">      :md-confirm-text=<span class="string">&quot;alert_config.confirm_text&quot;</span></span><br><span class="line">    /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 这个是消息确认对话框，当某处调用showConfirm()函数时会触发，比如删除插件时 --&gt;</span><br><span class="line">    &lt;md-dialog-confirm</span><br><span class="line">      <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;api-dialog&quot;</span></span><br><span class="line">      :md-active.sync=<span class="string">&quot;confirm_config.show&quot;</span></span><br><span class="line">      :md-title=<span class="string">&quot;confirm_config.title&quot;</span></span><br><span class="line">      :md-content=<span class="string">&quot;confirm_config.content&quot;</span></span><br><span class="line">      :md-confirm-text=<span class="string">&quot;confirm_config.confirm_text&quot;</span></span><br><span class="line">      :md-cancel-text=<span class="string">&quot;confirm_config.canel_text&quot;</span></span><br><span class="line">      @md-confirm=<span class="string">&quot;confirm_config.confirm&quot;</span></span><br><span class="line">      @md-cancel=<span class="string">&quot;confirm_config.cancel&quot;</span></span><br><span class="line">    /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 前面已分析到，点击添加Plugins后会触发如下插件对话框的弹出 --&gt;</span><br><span class="line">    &lt;md-dialog</span><br><span class="line">      <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;plugin-dialog&quot;</span></span><br><span class="line">      :md-active.sync=<span class="string">&quot;showAddPluginDialog&quot;</span></span><br><span class="line">      :md-click-outside-to-close=<span class="string">&quot;true&quot;</span></span><br><span class="line">    &gt;</span><br><span class="line">      &lt;!-- 设置该对话框的标题 --&gt;</span><br><span class="line">      &lt;md-dialog-title</span><br><span class="line">        &gt;&#123;&#123;</span><br><span class="line">          plugin4install ? <span class="string">&quot;Plugin Installation&quot;</span> : <span class="string">&quot;ImJoy Plugin Management&quot;</span></span><br><span class="line">        &#125;&#125;</span><br><span class="line">        &lt;!-- 在标题栏添加一个关闭按钮 --&gt;</span><br><span class="line">        &lt;md-button</span><br><span class="line">          <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;md-accent&quot;</span></span><br><span class="line">          style=<span class="string">&quot;position:absolute; top:8px; right:5px;&quot;</span></span><br><span class="line">          @click=<span class="string">&quot;</span></span><br><span class="line"><span class="string">            showAddPluginDialog = false;</span></span><br><span class="line"><span class="string">            clearPluginUrl();</span></span><br><span class="line"><span class="string">          &quot;</span></span><br><span class="line">          &gt;<span class="xml"><span class="tag">&lt;<span class="name">md-icon</span>&gt;</span>clear<span class="tag">&lt;/<span class="name">md-icon</span>&gt;</span></span>&lt;/md-button</span><br><span class="line">        &gt;&lt;/md-dialog-title</span><br><span class="line">      &gt;</span><br><span class="line">      &lt;!-- 以下是对话框的内容部分 --&gt;</span><br><span class="line">      &lt;!-- 原来的插件对话框有三种添加插件的方式：（<span class="number">1</span>）通过插件模板template编写插件（<span class="number">2</span>）输入插件url地址安装（<span class="number">3</span>）通过插件商店store安装 --&gt;</span><br><span class="line">      &lt;!-- 这里我们为了代码精简，只保留了第一种，保证能运行一个最简单的插件即可 --&gt;</span><br><span class="line">      &lt;md-dialog-content&gt;</span><br><span class="line">        &lt;template v-<span class="keyword">if</span>=<span class="string">&quot;show_plugin_templates&quot;</span>&gt;</span><br><span class="line">          &lt;md-menu&gt;</span><br><span class="line">            &lt;!-- 通过模板template添加插件的按钮 --&gt;</span><br><span class="line">            &lt;md-button <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;md-primary md-raised&quot;</span> md-menu-trigger&gt;</span><br><span class="line">              &lt;md-icon&gt;add&lt;/md-icon&gt;Create a <span class="keyword">new</span> plugin</span><br><span class="line">              &lt;md-tooltip&gt;Create a <span class="keyword">new</span> plugin&lt;/md-tooltip&gt;</span><br><span class="line">            &lt;/md-button&gt;</span><br><span class="line">            &lt;!-- 点击上面按钮后弹出的菜单 --&gt;</span><br><span class="line">            &lt;md-menu-content&gt;</span><br><span class="line">              &lt;!-- 菜单项会对所有的模板进行遍历展示 --&gt;</span><br><span class="line">              &lt;!-- 每个菜单项也都会将鼠标点击事件绑定到newPlugin方法上 --&gt;</span><br><span class="line">              &lt;!-- 该方法会通过createWindow创建plugin-editor类型的窗口，即代码编辑器 --&gt;</span><br><span class="line">              &lt;md-menu-item</span><br><span class="line">                @click=<span class="string">&quot;</span></span><br><span class="line"><span class="string">                  newPlugin(template.code);</span></span><br><span class="line"><span class="string">                  showAddPluginDialog = false;</span></span><br><span class="line"><span class="string">                &quot;</span></span><br><span class="line">                v-<span class="keyword">for</span>=<span class="string">&quot;template in plugin_templates&quot;</span></span><br><span class="line">                :key=<span class="string">&quot;template.name&quot;</span></span><br><span class="line">              &gt;</span><br><span class="line">                &lt;md-icon&gt;&#123;&#123; template.icon &#125;&#125;&lt;/md-icon</span><br><span class="line">                &gt;&#123;&#123; template.name &#125;&#125;</span><br><span class="line">              &lt;/md-menu-item&gt;</span><br><span class="line">            &lt;/md-menu-content&gt;</span><br><span class="line">          &lt;/md-menu&gt;</span><br><span class="line">          &lt;br /&gt;</span><br><span class="line">          &lt;br /&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/md-dialog-content&gt;</span><br><span class="line">    &lt;/md-dialog&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h1 id="script代码"><a href="#script代码" class="headerlink" title="script代码"></a>script代码</h1><p>通过上述template文件的解析，发现插件被点击运行时执行的函数是runOp方法。<br>该代码解析留坑待填。</p>]]></content>
    
    
    <summary type="html">简介
前面讲了ImJoy主站的入口文件main.js，这一篇解析一下该主站的ImJoy组件，它也是整个app的“门面担当”，起到了统筹整个网站的作用。

为了便于分析，将很多高阶的暂时用不到的组件（比如工具栏、窗口管理、文件上传、连接后台Engine等）都删掉，留下最基本的能运行最小化imjoy插件的功能，截图如下：


这样便于分析整个组件的宏观结构和运行逻辑。
下面是对于该极小化组件的逐行代码分析。

template代码
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</summary>
    
    
    
    <category term="computer vision" scheme="http://qixinbo.github.io/categories/computer-vision/"/>
    
    
    <category term="ImJoy" scheme="http://qixinbo.github.io/tags/ImJoy/"/>
    
  </entry>
  
  <entry>
    <title>开源深度学习计算平台ImJoy解析：10 -- ImJoy主站之入口文件</title>
    <link href="http://qixinbo.github.io/2022/02/27/ImJoy_10/"/>
    <id>http://qixinbo.github.io/2022/02/27/ImJoy_10/</id>
    <published>2022-02-26T16:00:00.000Z</published>
    <updated>2022-03-02T02:46:40.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>前面讲了ImJoy的core库和rpc库作为函数库如何被集成调用，而基于这两个核心库有一个能开箱即用的完整网站，即<a href="https://imjoy.io">ImJoy主站</a>，使用它就可以无需了解上面的技术细节，直接加载各种函数插件即可（但也因为这样，你无法更改网站样貌，如果没有定制开发的需求，则直接使用该网站即可）。</p><p>从该文章开始，将尝试对ImJoy主站进行详细分析，看官方是怎样应用ImJoy的core和rpc库的。</p><h1 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h1><p>ImJoy主站是用vue.js前端框架写的，整个目录结构由vue脚手架vue-cli 4生成，所以首先要分析清楚vue脚手架生成的代码结构是怎样的，可以参考<a href="https://blog.csdn.net/weixin_43734095/article/details/106990775">这篇教程</a><br>截取其中的代码分析图：<br><img src="https://user-images.githubusercontent.com/6218739/155942379-aeaeb37b-f46f-4145-b488-4ef8ea82c446.png" alt="vue-cli"></p><p>理清楚代码结构后，从哪里开始分析呢？</p><h1 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h1><p><code>src/main.js</code>是程序执行的入口文件，所以最好是顺着代码的执行过程一步步分析。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br></pre></td></tr></table></figure><br>引入Vue函数，后面将实例化它，作为整个程度的总调度，即：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&quot;#imjoy-app&quot;</span>,</span><br><span class="line">  router,</span><br><span class="line">  data: &#123;</span><br><span class="line">    store: store,</span><br><span class="line">    router: router,</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">&quot;&lt;App/&gt;&quot;</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    App,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>可以看出，整个Vue实例绑定的是ID名为<code>imjoy-app</code>的html元素，而该元素是位于<code>public\index.html</code>文件中：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;imjoy-app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><br>即：<code>src/main.js</code>是程序执行的入口文件，<code>public\index.html</code>是网页显示的入口文件，至于这两个文件作为入口是vue的脚手架在后台指定好的。知道这两个入口文件后，就可以往后按图索骥般研究。<br>从上述代码还可以看出，该Vue实例管理了App这个根组件，由该根组件再统一去管理其他所有组件，即App根组件显示到<code>imjoy-app</code>这个html元素上。<br>新版的Vue脚手架对于vue2的实例化这块是这样书写的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><br>同样很简单地指明了Vue实例与App组件、app元素之间的关系。</p><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>在<code>src/main.js</code>里第二行就是路由的设置。<br>Vue.js 路由允许我们通过不同的 URL 访问不同的内容。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入路由</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&quot;./router&quot;</span>;</span><br></pre></td></tr></table></figure><br>路由的实现涉及很多文件，比如在如上<code>router.js</code>文件中定义路由的路径和组件（即key和value）的映射关系、在模板html文件中定义哪些元素触发路由跳转（如router-link）以及匹配到路由后组件在哪显示（router-view）、注册路由等。<br>推荐<a href="https://www.runoob.com/vue2/vue-routing.html">这篇教程</a>。<br>Imjoy定义了多个路由，如<code>/</code>、<code>/app</code>、<code>/about</code>等。</p><h1 id="前端UI"><a href="#前端UI" class="headerlink" title="前端UI"></a>前端UI</h1><h2 id="UI组件库"><a href="#UI组件库" class="headerlink" title="UI组件库"></a>UI组件库</h2><p>在<code>src/main.js</code>里第三行就是UI库的引入。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VueMaterial <span class="keyword">from</span> <span class="string">&quot;vue-material&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;vue-material/dist/vue-material.min.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;vue-material/dist/theme/default.css&quot;</span>;</span><br><span class="line">Vue.use(VueMaterial);</span><br></pre></td></tr></table></figure><br>ImJoy前端组件使用的是<a href="https://github.com/vuematerial/vue-material">Vue Material</a>这个组件库，其风格是Google开发的Material Design这种设计语言，即原生Android操作系统上的设计风格。<br>上述代码是使用了全局引入的方式。其组件的具体使用方式在<a href="https://www.creative-tim.com/vuematerial/components/app">这里</a>。</p><h2 id="栅格布局"><a href="#栅格布局" class="headerlink" title="栅格布局"></a>栅格布局</h2><p>接着引入了vue-grid-layout：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VueGridLayout <span class="keyword">from</span> <span class="string">&quot;vue-grid-layout&quot;</span>;</span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">&quot;grid-layout&quot;</span>, VueGridLayout.GridLayout);</span><br><span class="line">Vue.component(<span class="string">&quot;grid-item&quot;</span>, VueGridLayout.GridItem);</span><br></pre></td></tr></table></figure><br>vue-grid-layout是一个可拖拽、可调整大小的栅格布局系统，用于拖拽调整ImJoy各个程序运行窗口的显示位置等。 </p><h2 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h2><p>ImJoy写了很多的自定义的组件。<br>组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。组件系统让我们可以用独立可复用的小组件来构建大型应用。<br>组件的相关知识推荐<a href="https://www.runoob.com/vue2/vue-component.html">这篇教程</a>。<br>在<code>src/main.js</code>中ImJoy就引入了它写的很多组件，并进行了全局注册：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Imjoy组件，即https://imjoy.io/#/app这个链接所展示的页面。</span></span><br><span class="line"><span class="keyword">import</span> Imjoy <span class="keyword">from</span> <span class="string">&quot;@/components/Imjoy&quot;</span>;</span><br><span class="line"><span class="comment">// About组件，即http://localhost:8001/#/about所展示的页面</span></span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">&quot;@/components/About&quot;</span>;</span><br><span class="line"><span class="comment">// Whiteboard组件，即ImJoy中间的展示区，其在上面的Imjoy组件中被使用</span></span><br><span class="line"><span class="keyword">import</span> Whiteboard <span class="keyword">from</span> <span class="string">&quot;@/components/Whiteboard&quot;</span>;</span><br><span class="line"><span class="comment">// PluginList组件，即安装插件时从云端搜索并下载插件的窗口，在Imjoy组件中被使用</span></span><br><span class="line"><span class="keyword">import</span> PluginList <span class="keyword">from</span> <span class="string">&quot;@/components/PluginList&quot;</span>;</span><br><span class="line"><span class="comment">// PluginEditor组件，即代码编辑器，出现在Imjoy组件中查看插件代码时，以及PluginList组件中同样查看插件代码时。</span></span><br><span class="line"><span class="keyword">import</span> PluginEditor <span class="keyword">from</span> <span class="string">&quot;@/components/PluginEditor&quot;</span>;</span><br><span class="line"><span class="comment">// PluginIcon组件，即插件的图标，出现在插件列表最右侧，如果插件自定义了图标，则显示该图标；否则显示默认的extension图标</span></span><br><span class="line"><span class="keyword">import</span> PluginIcon <span class="keyword">from</span> <span class="string">&quot;@/components/PluginIcon&quot;</span>;</span><br><span class="line"><span class="comment">// FileItem组件，即文件列表</span></span><br><span class="line"><span class="keyword">import</span> FileItem <span class="keyword">from</span> <span class="string">&quot;@/components/FileItem&quot;</span>;</span><br><span class="line"><span class="comment">// FileDialog组件，即文件对话框</span></span><br><span class="line"><span class="keyword">import</span> FileDialog <span class="keyword">from</span> <span class="string">&quot;@/components/FileDialog&quot;</span>;</span><br><span class="line"><span class="comment">// Window组件，即代码编辑和程序运行窗口，在Imjoy组件中被使用</span></span><br><span class="line"><span class="keyword">import</span> Window <span class="keyword">from</span> <span class="string">&quot;@/components/Window&quot;</span>;</span><br><span class="line"><span class="comment">// EngineControlPanel组件，即ImJoy app右上角的小火箭图标菜单所对应的组件</span></span><br><span class="line"><span class="keyword">import</span> EngineControlPanel <span class="keyword">from</span> <span class="string">&quot;@/components/EngineControlPanel&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局注册以上组件</span></span><br><span class="line">Vue.component(<span class="string">&quot;imjoy&quot;</span>, Imjoy);</span><br><span class="line">Vue.component(<span class="string">&quot;about&quot;</span>, About);</span><br><span class="line">Vue.component(<span class="string">&quot;whiteboard&quot;</span>, Whiteboard);</span><br><span class="line">Vue.component(<span class="string">&quot;plugin-list&quot;</span>, PluginList);</span><br><span class="line">Vue.component(<span class="string">&quot;plugin-editor&quot;</span>, PluginEditor);</span><br><span class="line">Vue.component(<span class="string">&quot;plugin-icon&quot;</span>, PluginIcon);</span><br><span class="line">Vue.component(<span class="string">&quot;file-item&quot;</span>, FileItem);</span><br><span class="line">Vue.component(<span class="string">&quot;file-dialog&quot;</span>, FileDialog);</span><br><span class="line">Vue.component(<span class="string">&quot;window&quot;</span>, Window);</span><br><span class="line">Vue.component(<span class="string">&quot;engine-control-panel&quot;</span>, EngineControlPanel);</span><br></pre></td></tr></table></figure><br>还有一些组件没有被全局注册，只是被部分实例使用，如Home组件（即<a href="https://imjoy.io/#/">imjoy首页</a>展示的页面）。</p><h2 id="模态框插件"><a href="#模态框插件" class="headerlink" title="模态框插件"></a>模态框插件</h2><p>ImJoy引入了<a href="https://github.com/euvl/vue-js-modal">vue-js-modal模态框插件</a>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vmodal <span class="keyword">from</span> <span class="string">&quot;vue-js-modal&quot;</span>;</span><br><span class="line">Vue.use(vmodal);</span><br></pre></td></tr></table></figure><br>它的使用教程见<a href="https://euvl.github.io/vue-js-modal/Intro.html#static-modals">这里</a>。</p><h1 id="事件总线"><a href="#事件总线" class="headerlink" title="事件总线"></a>事件总线</h1><p>接着看<code>src/main.js</code>，接下来引入了事件总线库：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;./store.js&quot;</span>;</span><br><span class="line"></span><br><span class="line">在store.js中：</span><br><span class="line"><span class="keyword">import</span> Minibus <span class="keyword">from</span> <span class="string">&quot;minibus&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> event_bus = Minibus.create();</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  event_bus: event_bus,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>可以看出Imjoy引入了<a href="https://github.com/axelpale/minibus">minibus库</a>，实现在一个地方触发（发布）事件，然后通过事件中心通知所有订阅者（订阅）。<br>on发布订阅、once发布订阅(触发一次)、emit通知执行(触发事件)、off取消订阅。</p>]]></content>
    
    
    <summary type="html">简介
前面讲了ImJoy的core库和rpc库作为函数库如何被集成调用，而基于这两个核心库有一个能开箱即用的完整网站，即ImJoy主站，使用它就可以无需了解上面的技术细节，直接加载各种函数插件即可（但也因为这样，你无法更改网站样貌，如果没有定制开发的需求，则直接使用该网站即可）。

从该文章开始，将尝试对ImJoy主站进行详细分析，看官方是怎样应用ImJoy的core和rpc库的。

代码结构
ImJoy主站是用vue.js前端框架写的，整个目录结构由vue脚手架vue-cli 4生成，所以首先要分析清楚vue脚手架生成的代码结构是怎样的，可以参考这篇教程
截取其中的代码分析图：


理清楚代</summary>
    
    
    
    <category term="computer vision" scheme="http://qixinbo.github.io/categories/computer-vision/"/>
    
    
    <category term="ImJoy" scheme="http://qixinbo.github.io/tags/ImJoy/"/>
    
  </entry>
  
  <entry>
    <title>开源深度学习计算平台ImJoy解析：9 -- 集成</title>
    <link href="http://qixinbo.github.io/2022/02/12/ImJoy_9/"/>
    <id>http://qixinbo.github.io/2022/02/12/ImJoy_9/</id>
    <published>2022-02-11T16:00:00.000Z</published>
    <updated>2022-03-04T08:05:50.754Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>ImJoy设计的初衷就包括可以被集成使用。这意味着它可以根据需求以多种方式集成到一个项目中。<br>这里的“集成”有两个意思：<br>（1）将ImJoy的核心core库集成在自己的网站或web应用中，从而可以调用ImJoy生态中的各种插件；<br>（2）将ImJoy的运行时rpc库集成到自己的web应用中，从而将自己的web应用转换为ImJoy的一个插件，即被别人可调用和访问。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>集成ImJoy（无论是imjoy-core还是imjoy-rpc）主要有三种方式：<br>（1）在页面上以 CDN 包的形式导入。<br>（2）下载 JavaScript 文件并自行托管。<br>（3）使用 npm 安装它。<br>下面详细说明。</p><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>可以直接使用托管在CDN上的JS库（对于imjoy-core库和imjoy-rpc库都是引用这个js文件）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://lib.imjoy.io/imjoy-loader.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><br>可以看出，imjoy的核心库都在<a href="https://lib.imjoy.io">lib.imjoy.io</a>上进行了托管，可以直接使用，这里放的是最新的版本。<br>另外，在<a href="https://www.jsdelivr.com/?query=imjoy">jsdelivr</a>上也有托管。</p><h2 id="下载并自托管"><a href="#下载并自托管" class="headerlink" title="下载并自托管"></a>下载并自托管</h2><p>如果你想避免使用构建工具，但又无法在生产环境使用CDN，那么可以下载相关js文件并自行托管在自己的服务器上。然后可以通过script标签引入，与使用 CDN 的方法类似。<br>可以在<a href="https://github.com/imjoy-team/lib.imjoy.io">这个GitHub仓库</a>里直接下载那些js文件。</p><h3 id="自己打包"><a href="#自己打包" class="headerlink" title="自己打包"></a>自己打包</h3><p>这些打包好的链接库的源码在<a href="https://github.com/imjoy-team/imjoy-core">imjoy-core这个仓库</a>里，如果想对它的源码进行修改，可以克隆下来这个仓库，然后再自己打包，即：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/imjoy-team/imjoy-core.git</span></span><br><span class="line">cd imjoy-core</span><br><span class="line">npm run install</span><br><span class="line"></span><br><span class="line"># test</span><br><span class="line">npm run test</span><br><span class="line"></span><br><span class="line"># build</span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure><br>上面的命令对于linux和mac系统是适用的，如果是windows系统，可以直接：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><br>进行打包。</p><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>在用 imjoy 构建大型应用时推荐使用 npm 安装。npm能很好地和webpack等打包器配合使用。<br>对于imjoy-core库：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install imjoy-core</span><br></pre></td></tr></table></figure><br>对于imjoy-rpc库：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install imjoy-rpc</span><br></pre></td></tr></table></figure></p><h1 id="集成Imjoy-Core"><a href="#集成Imjoy-Core" class="headerlink" title="集成Imjoy Core"></a>集成Imjoy Core</h1><h2 id="直接引用"><a href="#直接引用" class="headerlink" title="直接引用"></a>直接引用</h2><h3 id="在线引用"><a href="#在线引用" class="headerlink" title="在线引用"></a>在线引用</h3><p>新建一个core-example.html的文件（这个文件在<a href="https://github.com/imjoy-team/imjoy-core/blob/master/src/core-example.html">这里</a>），写入以下内容：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;utf-8&quot;</span> /&gt;</span><br><span class="line">    &lt;title&gt;ImJoy Core Example&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;ImJoy Core Example&lt;/h1&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;https://lib.imjoy.io/imjoy-loader.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      loadImJoyCore().then(<span class="function"><span class="params">imjoyCore</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> imjoy = <span class="keyword">new</span> imjoyCore.ImJoy(&#123;</span><br><span class="line">          imjoy_api: &#123;&#125;,</span><br><span class="line">          <span class="comment">//imjoy core config</span></span><br><span class="line">        &#125;);</span><br><span class="line">        imjoy.start(&#123; <span class="attr">workspace</span>: <span class="literal">null</span> &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          alert(<span class="string">&quot;ImJoy Core started successfully!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><br>双击该页面会在浏览器中运行它，效果是呈现一个弹出框表明成功启动了ImJoy。</p><h3 id="本地托管引用"><a href="#本地托管引用" class="headerlink" title="本地托管引用"></a>本地托管引用</h3><p>上面例子是在线引用<a href="https://lib.imjoy.io/imjoy-loader.js">https://lib.imjoy.io/imjoy-loader.js</a>这个文件。<br>对于本地托管的文件，可以将上述页面的对应部分改为如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;/imjoy-loader.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  loadImJoyCore(</span><br><span class="line">    &#123;</span><br><span class="line">      base_url: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>即引用本地路径下的文件。<br>但这样改写后并不能直接运行该html文件，因为它现在是本地文件，需要将其放置在一个服务器上以http传输才行。<br>最简单的一个运行方式是在本地启用一个测试服务器，毕竟此处只是为了测试这个文件的运行。<br>如果使用python，可以使用如下命令：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server</span><br></pre></td></tr></table></figure><br>这样就可以在这个本地web服务器上查看该目录下的内容。<br>具体原理见<a href="https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/set_up_a_local_testing_server">如何设置一个本地测试服务器？</a></p><p>python的这个测试服务器功能非常弱，到了具体部署应用时，可以使用nginx来构建web服务器从而顺利找到这些文件。<br><a href="https://blog.csdn.net/vfsdfdsf/article/details/89354541">Windows环境利用nginx搭建web服务器</a></p><h2 id="npm包引用"><a href="#npm包引用" class="headerlink" title="npm包引用"></a>npm包引用</h2><p>如上所述，如果要开发大型程序，还是推荐使用npm包的形式进行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> imjoyCore <span class="keyword">from</span> <span class="string">&#x27;imjoy-core&#x27;</span></span><br><span class="line"><span class="keyword">const</span> imjoy = <span class="keyword">new</span> imjoyCore.ImJoy(&#123;</span><br><span class="line">    imjoy_api: &#123;&#125;,</span><br><span class="line">    <span class="comment">//imjoy config</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">imjoy.start(&#123;<span class="attr">workspace</span>: <span class="string">&#x27;default&#x27;</span>&#125;).then(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">    <span class="keyword">await</span> imjoy.api.alert(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><br>不过上面代码现在还没法直接运行。<br>因为ImJoy是基于浏览器的，它需要获取浏览器的window对象（即包含DOM文档的窗口），所以它得运行在前端，不能作为后端的包使用。<br>因此首先不能使用node.js来运行包含ImJoy的程序，与此同时，npm包这种编程引用方式还需要被浏览器认识，因此此时需要webpack这一类的打包工具来进行开发。<br>这里可以使用原生的webpack来打包开发，不过webpack的配置挺复杂的，这里推荐直接使用Vue.js来开发，这样既能方便地构建前端页面，也能借助Vue-cli脚手架来很方便的打包和部署（参考教程可以看下面的推荐链接）。</p><p>如果选择Vue.js进行开发，那么上面的代码可以直接放在某个Vue组件中，然后再通过：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run serve</span><br></pre></td></tr></table></figure><br>进行热部署即可运行查看。</p><h1 id="集成Imjoy-RPC"><a href="#集成Imjoy-RPC" class="headerlink" title="集成Imjoy RPC"></a>集成Imjoy RPC</h1><h2 id="直接引用-1"><a href="#直接引用-1" class="headerlink" title="直接引用"></a>直接引用</h2><h3 id="在线引用-1"><a href="#在线引用-1" class="headerlink" title="在线引用"></a>在线引用</h3><p>新建一个plugin-example.html的文件（这个demo文件在<a href="https://github.com/imjoy-team/imjoy-core/blob/master/src/plugin-example.html">这里</a>），写入以下内容：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>ImJoy Plugin Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>ImJoy Plugin Example<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://lib.imjoy.io/imjoy-loader.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      loadImJoyRPC().then(<span class="keyword">async</span> imjoyRPC =&gt; &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> api = <span class="keyword">await</span> imjoyRPC.setupRPC(&#123; <span class="attr">name</span>: <span class="string">&quot;My Awesome App&quot;</span> &#125;);</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">setup</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          api.alert(<span class="string">&quot;ImJoy RPC initialized. Hello!&quot;</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="comment">// define your api which can be called by other plugins in ImJoy</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">my_api_func</span>(<span class="params"></span>) </span>&#123;&#125;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// Importantly, you need to call `api.export(...)` in order to expose the api for your web application</span></span></span><br><span class="line">        api.export(&#123; setup: setup, my_api_func: my_api_func &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><br>但该文件并不能像上面的core-example.html那样可以直接双击运行，会报如下错误：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught (in promise) Error: imjoy-rpc should only run inside an iframe or a webworker.</span><br></pre></td></tr></table></figure><br>这是因为注入了ImJoy RPC运行时的web应用必须在ImJoy中作为一个插件使用。<code>这样做的目的是隔离运行环境，从而让插件支持任意web框架。</code>（来自ImJoy作者的交流指点，thanks）。<br>那么，为了让上面这个文件正常运行，需要进行如下操作：<br>（1）将它托管成为一个web app，得到它的使用链接。这里可以使用任意托管服务，比如上面的测试服务器、nginx服务器，以及Github pages等；<br>（2）在任意一个其他的ImJoy插件中，使用该web app。</p><p>为了简化演示，采用最简单的方法：<br>对于第一步，直接使用python的测试服务器；<br>对于第二步，修改上面的core-example.html文件为：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>ImJoy Core Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>ImJoy Core Example<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/imjoy-loader.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      loadImJoyCore().then(<span class="function"><span class="params">imjoyCore</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(imjoyCore);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> imjoy = <span class="keyword">new</span> imjoyCore.ImJoy(&#123;</span></span><br><span class="line">          imjoy_api: &#123;&#125;,</span><br><span class="line"><span class="javascript">          <span class="comment">//imjoy core config</span></span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">        imjoy.start(&#123; <span class="attr">workspace</span>: <span class="literal">null</span> &#125;).then(<span class="keyword">async</span> () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">          alert(<span class="string">&quot;ImJoy Core started successfully!&quot;</span>);</span></span><br><span class="line"><span class="javascript">          <span class="keyword">const</span> win = <span class="keyword">await</span> imjoy.api.createWindow(&#123;</span></span><br><span class="line"><span class="javascript">          type: <span class="string">&#x27;My Window&#x27;</span>,</span></span><br><span class="line"><span class="javascript">          src: <span class="string">&#x27;/plugin-example.html&#x27;</span>,</span></span><br><span class="line">          data: &#123; &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">        imjoy.event_bus.on(<span class="string">&quot;add_window&quot;</span>, <span class="function"><span class="params">w</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">const</span> container = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span></span><br><span class="line"><span class="javascript">          container.id = w.window_id; <span class="comment">// &lt;--- this is important</span></span></span><br><span class="line"><span class="javascript">          container.style.backgroundColor = <span class="string">&#x27;#ececec&#x27;</span>;</span></span><br><span class="line"><span class="javascript">          container.style.height = <span class="string">&quot;300px&quot;</span>;</span></span><br><span class="line"><span class="javascript">          container.style.width = <span class="string">&quot;100%&quot;</span>;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// Here we simply add to the body</span></span></span><br><span class="line"><span class="javascript">          <span class="comment">// but in reality, you can embed it into your UI</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">document</span>.body.appendChild(container)</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><br>现在，运行效果如下：<br><img src="https://user-images.githubusercontent.com/6218739/155644211-416c4dc6-2b49-4810-a1d5-c590a854e7b8.png" alt="rpc-demo"><br>即生成了一个窗口，里面运行了那个demo app。</p><h3 id="本地托管引用-1"><a href="#本地托管引用-1" class="headerlink" title="本地托管引用"></a>本地托管引用</h3><p>跟上面imjoy-core库的引用方式相同。</p><h2 id="npm包引用-1"><a href="#npm包引用-1" class="headerlink" title="npm包引用"></a>npm包引用</h2><p>引用方式也是类似于imjoy-core库：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; imjoyRPC &#125; <span class="keyword">from</span> <span class="string">&#x27;imjoy-rpc&#x27;</span>;</span><br><span class="line"></span><br><span class="line">imjoyRPC.setupRPC(&#123;<span class="attr">name</span>: <span class="string">&#x27;My Awesome App&#x27;</span>&#125;).then(<span class="function">(<span class="params">api</span>)=&gt;</span>&#123;</span><br><span class="line"> <span class="comment">// call api.export to expose your plugin api</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>然后也是在其他插件中使用该app才可以：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// as a new window</span></span><br><span class="line"><span class="keyword">const</span> win = <span class="keyword">await</span> api.createWindow(&#123;</span><br><span class="line">    type: <span class="string">&#x27;My Awesome App&#x27;</span>,</span><br><span class="line">    src: <span class="string">&#x27;https://my-awesome-app.com/&#x27;</span>,</span><br><span class="line">    data: &#123; &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// or, as a dialog</span></span><br><span class="line"><span class="keyword">const</span> win = <span class="keyword">await</span> api.showDialog(&#123;</span><br><span class="line">    type: <span class="string">&#x27;My Awesome App&#x27;</span>,</span><br><span class="line">    src: <span class="string">&#x27;https://my-awesome-app.com/&#x27;</span>,</span><br><span class="line">    data: &#123; &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// further interaction can be performed via `win` object</span></span><br></pre></td></tr></table></figure></p><h1 id="直接引用js的API"><a href="#直接引用js的API" class="headerlink" title="直接引用js的API"></a>直接引用js的API</h1><p>上面两种直接引用js文件的方式，其提供了三个主要的函数供调用：<br>（1）loadImJoyCore：加载ImJoy核心库，使得可以调用ImJoy的各种API<br>（2）loadImJoyRPC：加载ImJoy的rpc库，使得插件可以通信，注意仅在iframe里才能使用这个函数<br>（3）loadImJoyBasicApp：一个简易但功能完善的ImJoy最小化app。</p><p>对于这三个加载函数，可以选择性地传入以下配置对象：</p><ul><li>version: 指定imjoy-core或imjoy-rpc的版本</li><li>api_version: 仅适用于imjoy-rpc，限定RPC的api版本</li><li>debug: 加载imjoy-core未压缩过的包含调试信息的版本，开发阶段使用</li><li>base_url: 自定义加载这些库的路径（上面已演示过，可以设置这个参数来使用本地托管的库）</li></ul><p>对于loadImJoyBasicApp，还有其他额外的选项：</p><ul><li>process_url_query: 布尔值，是否处理url请求</li><li>show_window_title: 布尔值，是否显示窗口标题</li><li>show_progress_bar: 布尔值，是否显示进度条</li><li>show_empty_window: 布尔值，是否显示空白窗口</li><li>hide_about_imjoy: 布尔值，是否隐藏“关于”菜单</li><li>menu_style: Object, 菜单样式</li><li>window_style: Object, 窗口样式</li><li>main_container: String, 定义主容器的id</li><li>menu_container: String, 定义菜单容器的id</li><li>window_manager_container: String, 定义窗口管理器的id</li><li>imjoy_api: Object, 重载一些ImJoy API函数的实现</li></ul><p>这里是使用loadImJoyBasicApp编写的一个<a href="https://imjoy.io/lite">轻量化的ImJoy app</a>，源代码在<a href="https://github.com/imjoy-team/ImJoy/blob/master/web/public/lite.html">这里</a>。</p><h2 id="自动切换core和plugin"><a href="#自动切换core和plugin" class="headerlink" title="自动切换core和plugin"></a>自动切换core和plugin</h2><p>对于一个既可以作为插件plugin，又可以使用imjoy core的web app，ImJoy提供了一个函数来检测当前app，从而在两种模式间自动切换：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check if it&#x27;s inside an iframe</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.self !== <span class="built_in">window</span>.top)&#123;</span><br><span class="line">    loadImJoyRPC().then(<span class="function">(<span class="params">imjoyRPC</span>)=&gt;</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    loadImJoyCore().then(<span class="function">(<span class="params">imjoyCore</span>)=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>上面的技术需要用到的web知识：<br>（1）JavaScript语法：<br><a href="https://www.runoob.com/w3cnote/es6-module.html">ES6 模块</a><br><a href="https://www.runoob.com/js/js-async.html">JavaScript 异步编程</a><br><a href="https://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html">Javascript异步编程的4种方法</a><br><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023024413276544">Promise</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises">使用Promise</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Async_await">async和await:让异步编程更简单</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function">async函数</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await">await</a><br>（2）Webpack打包：<br><a href="https://www.jiangruitao.com/webpack/">Webpack 教程</a><br>（3）Node.js开发：<br><a href="https://segmentfault.com/q/1010000022020967">es6的import是不是也可以导入css和scss？</a><br><a href="https://www.zhihu.com/question/358026810">vue main.js中引入node_modules中的文件为什么路径不用写node_modules?</a><br><a href="https://github.com/SunshowerC/blog/issues/8">package.json 中 你还不清楚的 browser，module，main 字段优先级</a><br>（4）Vue.js开发：<br>视频教程推荐：<br><a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?from=search&amp;seid=396170412927101372">尚硅谷Vue2.0+Vue3.0全套教程丨vuejs从入门到精通</a><br>文字版的教程推荐：<br><a href="https://www.runoob.com/vue2/vue-tutorial.html">Vue.js菜鸟教程</a><br><a href="https://cn.vuejs.org/v2/guide/index.html">Vue.js官方教程</a></p>]]></content>
    
    
    <summary type="html">简介
ImJoy设计的初衷就包括可以被集成使用。这意味着它可以根据需求以多种方式集成到一个项目中。
这里的“集成”有两个意思：
（1）将ImJoy的核心core库集成在自己的网站或web应用中，从而可以调用ImJoy生态中的各种插件；
（2）将ImJoy的运行时rpc库集成到自己的web应用中，从而将自己的web应用转换为ImJoy的一个插件，即被别人可调用和访问。

安装
集成ImJoy（无论是imjoy-core还是imjoy-rpc）主要有三种方式：
（1）在页面上以 CDN 包的形式导入。
（2）下载 JavaScript 文件并自行托管。
（3）使用 npm 安装它。
下面详细说明。</summary>
    
    
    
    <category term="computer vision" scheme="http://qixinbo.github.io/categories/computer-vision/"/>
    
    
    <category term="ImJoy" scheme="http://qixinbo.github.io/tags/ImJoy/"/>
    
  </entry>
  
  <entry>
    <title>开源深度学习计算平台ImJoy解析：8 -- 使用python编写计算插件</title>
    <link href="http://qixinbo.github.io/2021/12/18/ImJoy_8/"/>
    <id>http://qixinbo.github.io/2021/12/18/ImJoy_8/</id>
    <published>2021-12-17T16:00:00.000Z</published>
    <updated>2021-12-19T11:11:14.984Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇着重介绍了如何使用JavaScript库来编写插件的前端UI和后端计算逻辑，这一节会介绍如何将计算后端切换为python语言，即计算逻辑完全使用python编写，充分利用python庞大的计算生态。<br>使用python开发计算插件有两种：<br>（1）web-python：即python运行在浏览器中，其原理实际是应用了<a href="https://pyodide.org/en/stable/">Pyodide</a>这一工具，将python代码编译在浏览器中，但其缺点也很明显，首先是加载速度非常慢，因为第一次运行时需要将所用的python库都下载下来；然后其也无法应用整个python深度学习生态。<br>（2）native-python：该类型插件会链接一个本地的jupyter插件引擎，可以充分发挥python的最大价值，本篇也将着重介绍该种插件的编写。</p><h1 id="web-python的hello-world"><a href="#web-python的hello-world" class="headerlink" title="web-python的hello world"></a>web-python的hello world</h1><p>先看一个使用web-python编写的hello world例子，它会完全在浏览器中运行Python代码。<br>注意，当运行以下插件时，会需要一段时间，因为它需要将python库加载到浏览器中：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;docs lang=<span class="string">&quot;markdown&quot;</span>&gt;</span><br><span class="line">[TODO: write documentation <span class="keyword">for</span> this plugin.]</span><br><span class="line">&lt;/docs&gt;</span><br><span class="line">&lt;config lang=<span class="string">&quot;json&quot;</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Untitled Plugin&quot;</span>,</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;web-python&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.1.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;[TODO: describe this plugin with one sentence.]&quot;</span>,</span><br><span class="line">  <span class="string">&quot;tags&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;ui&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;cover&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;inputs&quot;</span>: null,</span><br><span class="line">  <span class="string">&quot;outputs&quot;</span>: null,</span><br><span class="line">  <span class="string">&quot;flags&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;extension&quot;</span>,</span><br><span class="line">  <span class="string">&quot;api_version&quot;</span>: <span class="string">&quot;0.1.8&quot;</span>,</span><br><span class="line">  <span class="string">&quot;env&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;permissions&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;requirements&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;dependencies&quot;</span>: []</span><br><span class="line">&#125;</span><br><span class="line">&lt;/config&gt;</span><br><span class="line">&lt;script lang=<span class="string">&quot;python&quot;</span>&gt;</span><br><span class="line"><span class="keyword">from</span> imjoy <span class="keyword">import</span> api</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImJoyPlugin</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span>(<span class="params">self</span>):</span></span><br><span class="line">        api.log(<span class="string">&#x27;initialized&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, ctx</span>):</span></span><br><span class="line">        api.alert(<span class="string">&#x27;hello world.&#x27;</span>)</span><br><span class="line">api.export(ImJoyPlugin())</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><br>实测速度非常慢，所以并不推荐使用web-python这种方式来编写插件。</p><h1 id="native-python开发插件"><a href="#native-python开发插件" class="headerlink" title="native-python开发插件"></a>native-python开发插件</h1><p>如果想充分利用python的深度学习生态，唯一使用的方式就是native-python这种开发模式。<br>此模式的使用可以有三种组合方式：<br>（1）<a href="https://imjoy.io/#/app">ImJoy官方部署</a>+<a href="https://mybinder.org/">MyBinder</a>插件引擎；<br>（2）<a href="https://imjoy.io/#/app">ImJoy官方部署</a>+本地Jupyter插件引擎；<br>（3）本地部署+本地Jupyter插件引擎。<br>第一种因为使用MyBinder这一免费的Jupyter托管方案，其性能会较弱，通常只用于demo用途，因此不推荐；<br>第二种会使用ImJoy的官方web app来作为应用入口，因此可能会受限于其官网的可连接性，快速开发时推荐使用；<br>第三种web app和Jupyter都是在本地部署，因此有最大的灵活性。本部分将对第三种的环境搭建做一介绍。</p><h2 id="本地部署web-app"><a href="#本地部署web-app" class="headerlink" title="本地部署web app"></a>本地部署web app</h2><p>ImJoy的主web app程序也在GitHub上进行了开源，见<a href="https://github.com/imjoy-team/ImJoy">这里</a>。<br>（1）clone该仓库：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:imjoy-team/ImJoy.git</span><br></pre></td></tr></table></figure><br>（2）安装依赖包<br>进入<code>web</code>文件夹，然后：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><br>这一步需要安装nodejs，此处不详细介绍，可以移步<a href="https://nodejs.org/zh-cn/">这里</a>。<br>（3）编译运行：<br>有两种编译和运行方式，一种是开发模式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run serve</span><br></pre></td></tr></table></figure><br>或者生产模式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><br>（4）访问app：<br>上一步运行该app后，就会生成可访问的链接，通常是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:<span class="number">8001</span></span><br></pre></td></tr></table></figure></p><h2 id="搭建本地Jupyter插件引擎"><a href="#搭建本地Jupyter插件引擎" class="headerlink" title="搭建本地Jupyter插件引擎"></a>搭建本地Jupyter插件引擎</h2><p>搭建本地Jupyter插件引擎有两种方法：<br>（1）安装Jupyter notebook（通过<code>pip install jupyter</code>），然后安装<a href="https://github.com/imjoy-team/imjoy-jupyter-extension">imjoy-jupyter-extension</a>。<br>（2）可以通过 <code>pip install imjoy</code> 安装这个<a href="https://github.com/imjoy-team/imjoy-engine">ImJoy-Engine</a>库。<br>推荐使用后者，因为这样可以对Jupyter服务器做一些对ImJoy有用的设置，并且不需要单独安装imjoy-jupyter-extension。<br>具体的搭建流程如下：<br>（1）下载并安装conda环境：推荐使用python3.7版本的Anaconda。<br>（2）安装引擎：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U imjoy[jupyter]</span><br></pre></td></tr></table></figure><br>（3）启动引擎：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imjoy --jupyter</span><br></pre></td></tr></table></figure><br>然后在终端就会得到形如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8888/?token=caac2d7f2e8e0...ad871fe</span><br></pre></td></tr></table></figure><br>的链接。这就是插件引擎的地址。<br>（4）连接web app<br>在前面开启的web app页面上<code>http://localhost:8001/#/app</code>，点击右上角的小火箭图标，然后点击<code>Add Jupyter-Engine</code>，将上面插件引擎的地址填入即可。</p><h1 id="native-python的hello-world"><a href="#native-python的hello-world" class="headerlink" title="native-python的hello world"></a>native-python的hello world</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;docs lang=<span class="string">&quot;markdown&quot;</span>&gt;</span><br><span class="line">[TODO: write documentation <span class="keyword">for</span> this plugin.]</span><br><span class="line">&lt;/docs&gt;</span><br><span class="line">&lt;config lang=<span class="string">&quot;json&quot;</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Untitled Plugin&quot;</span>,</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;native-python&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.1.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;[TODO: describe this plugin with one sentence.]&quot;</span>,</span><br><span class="line">  <span class="string">&quot;tags&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;ui&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;cover&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;inputs&quot;</span>: null,</span><br><span class="line">  <span class="string">&quot;outputs&quot;</span>: null,</span><br><span class="line">  <span class="string">&quot;flags&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;extension&quot;</span>,</span><br><span class="line">  <span class="string">&quot;api_version&quot;</span>: <span class="string">&quot;0.1.8&quot;</span>,</span><br><span class="line">  <span class="string">&quot;env&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;permissions&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;requirements&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;dependencies&quot;</span>: []</span><br><span class="line">&#125;</span><br><span class="line">&lt;/config&gt;</span><br><span class="line">&lt;script lang=<span class="string">&quot;python&quot;</span>&gt;</span><br><span class="line"><span class="keyword">from</span> imjoy <span class="keyword">import</span> api</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImJoyPlugin</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span>(<span class="params">self</span>):</span></span><br><span class="line">        api.log(<span class="string">&#x27;initialized&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, ctx</span>):</span></span><br><span class="line">        api.alert(<span class="string">&#x27;hello world.&#x27;</span>)</span><br><span class="line">api.export(ImJoyPlugin())</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="用python写图像处理插件"><a href="#用python写图像处理插件" class="headerlink" title="用python写图像处理插件"></a>用python写图像处理插件</h1><p>这一部分尝试将<a href="https://qixinbo.info/2021/12/17/imjoy_7/">构建基于Web的图像分析插件</a>这一篇中的opencv.js功能用python版的opencv实现一遍。<br>在此例中，有<strong>两个插件</strong>：UI插件和compute插件。一般来说，有两种方法可以连接它们：<br>（1）首先用<code>api.createWindow(...)</code>从compute插件实例化UI插件，然后与返回的窗口对象进行交互；<br>（2）也可以直接启动UI插件，然后通过<code>api.getPlugin()</code>来获取compute插件提供的api。<br>两种方法到底用哪一种取决于应用程序的实际需要，这里推荐第一种方式用于Python插件的编写，因为它可以更轻松地在Jupyter笔记本中调试。</p><p>这里的插件是用Python重写计算功能、JavaScript仍然是前端，因此涉及到两种语言对图像格式的转译，需要进行编码和解码以使它们交叉兼容。最简单的方法是将图像编码为“base64”字符串。<br>因此，整个插件的流程为（本节末尾会给出所有代码，这里是将代码分解）：<br>（1）从UI插件（即图像查看器）的canvas画布中得到图像的<code>base64</code>编码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;canvas-id&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// get `base64` encoded image from a canvas</span></span><br><span class="line"><span class="keyword">const</span> base64String = canvas.toDataURL()</span><br></pre></td></tr></table></figure><br>（2）在UI插件中调用compute插件中的函数，并传递上面的<code>base64</code>编码：<br>UI插件能调用compute插件中的python函数，是通过插件中的<code>ctx</code>变量来得到它，形如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the run funciton of the image viewer</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">run</span>(<span class="params">ctx</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// check if there is a process function passed in</span></span><br><span class="line">    <span class="keyword">if</span>(ctx.data &amp;&amp; ctx.data.process)&#123;</span><br><span class="line">        <span class="comment">// show an additional &quot;Process in Python&quot; button</span></span><br><span class="line">        <span class="comment">// and set the call back to use this process function</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>相对应地，在Python插件中就可以执行<code>await api.createWindow(type=&quot;Image Viewer&quot;, data=&#123;&quot;process&quot;: self.process&#125;)</code>来传给JS插件（假设已经在插件中定义了一个名为 <code>process</code>的函数）。<br>在调用<code>api.createWindow</code> 时，有两种方法可以引用另一个窗口插件：<br>（a）将<code>type</code>键设置为窗口插件名称，例如如果UI插件名为<code>My Window Plugin</code>，就将其设置为<code>type</code>。注意，这个名称是从 <code>&lt;config&gt;</code> 块中的 <code>name</code> 定义中获得的。<br>（b）如果UI插件是源代码的形式或者由公共服务器提供，可以设置<code>src</code>作为插件源代码或者插件URL，比如<code>name=&quot;Kaibu&quot;,src=&quot;https://kaibu.org/#/app&quot;</code>。在这种情况下，插件将被动态填充。例如，它允许将窗口插件存储为Python中的字符串，甚至可以根据模板动态生成窗口插件。</p><p>另外一个需要注意的是，如果是使用<code>await api.createWindow(type=&quot;Image Viewer&quot;, data=&#123;&quot;process&quot;: self.process&#125;)</code>，此时会发现，如果第二次单击该按钮，它将不再起作用，并且如果转到浏览器控制台，将看到一条错误消息，提示<code>Callback function can only called once, if you want to call a function for multiple times, please make it as a plugin api function.</code>。这是因为在第一次调用后从窗口中删除了<code>process</code>函数。为了明确地告诉窗口保留<code>process</code>函数，可以将一个特殊的键<code>_rintf</code>设置为<code>True</code>，即把上面的代码改成<code>data=&#123;&quot;process&quot;: self.process, &quot;_rintf&quot;: True&#125;</code>。<br>（3）在python插件中解码<code>base64</code>，并读取为numpy类型数组：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> imageio</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">base64_to_image</span>(<span class="params">base64_string, <span class="built_in">format</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;This function takes a base64 string as input</span></span><br><span class="line"><span class="string">    and decode it into an numpy array image</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    base64_string = re.sub(<span class="string">&quot;^data:image/.+;base64,&quot;</span>, <span class="string">&quot;&quot;</span>, base64_string)</span><br><span class="line">    image_file = io.BytesIO(base64.b64decode(base64_string.encode(<span class="string">&#x27;ascii&#x27;</span>)))</span><br><span class="line">    <span class="keyword">return</span> imageio.imread(image_file, <span class="built_in">format</span>)</span><br></pre></td></tr></table></figure></p><p>（4）在python插件中编写图像处理算法：<br>这里仍然使用的是opencv，不过要用的是它的python版本：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;requirements&quot;</span>: [<span class="string">&quot;opencv-python&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_image</span>(<span class="params">src</span>):</span></span><br><span class="line">    dst = cv2.cvtColor(src, cv2.COLOR_RGBA2GRAY)</span><br><span class="line">    <span class="keyword">return</span> dst</span><br></pre></td></tr></table></figure><br>（5）将numpy数组类型的处理结果编码为<code>base64</code>并返回：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image_to_base64</span>(<span class="params">image_array</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;This function takes a numpy image array as input</span></span><br><span class="line"><span class="string">    and encode it into a base64 string</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    buf = io.BytesIO()</span><br><span class="line">    imageio.imwrite(buf, image_array, <span class="string">&quot;PNG&quot;</span>)</span><br><span class="line">    buf.seek(<span class="number">0</span>)</span><br><span class="line">    img_bytes = buf.getvalue()</span><br><span class="line">    base64_string = base64.b64encode(img_bytes).decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;data:image/png;base64,&#x27;</span> + base64_string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, base64string</span>):</span></span><br><span class="line">    img = base64_to_image(base64string)</span><br><span class="line">    dst = process_image(img)</span><br><span class="line">    base64dst = image_to_base64(dst)</span><br><span class="line">    <span class="keyword">return</span> base64dst</span><br></pre></td></tr></table></figure><br>（6）在JS插件中接收<code>base64</code>编码，并在画布中显示为图像：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// draw a `base64` encoded image to the canvas</span></span><br><span class="line"><span class="keyword">const</span> drawImage = <span class="function">(<span class="params">canvas, base64Image</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">        img.crossOrigin = <span class="string">&quot;anonymous&quot;</span></span><br><span class="line">        img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">            canvas.width = <span class="built_in">Math</span>.min(<span class="built_in">this</span>.width, <span class="number">512</span>);</span><br><span class="line">            canvas.height= <span class="built_in">Math</span>.min(<span class="built_in">this</span>.height, <span class="built_in">parseInt</span>(<span class="number">512</span>*<span class="built_in">this</span>.height/<span class="built_in">this</span>.width), <span class="number">1024</span>);</span><br><span class="line">            <span class="comment">// draw the img into canvas</span></span><br><span class="line">            ctx.drawImage(<span class="built_in">this</span>, <span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line">            resolve(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">        img.onerror = reject;</span><br><span class="line">        img.src = base64Image;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>整个插件的处理逻辑如上，结果与完全JS作为前端和后端的结果相同，如下图：<br><img src="https://user-images.githubusercontent.com/6218739/146639355-669e3cac-2134-4171-ba21-19884d536abb.png" alt="pythonbackend"></p><p>完整代码如下：<br>对于UI插件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">&lt;config lang=<span class="string">&quot;json&quot;</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Image Viewer&quot;</span>,</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;window&quot;</span>,</span><br><span class="line">  <span class="string">&quot;tags&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;ui&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.1.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;cover&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;This is a demo plugin for displaying image&quot;</span>,</span><br><span class="line">  <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;extension&quot;</span>,</span><br><span class="line">  <span class="string">&quot;inputs&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;outputs&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;api_version&quot;</span>: <span class="string">&quot;0.1.8&quot;</span>,</span><br><span class="line">  <span class="string">&quot;env&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;permissions&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;requirements&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;https://cdn.jsdelivr.net/npm/bulma@0.9.1/css/bulma.min.css&quot;</span>, </span><br><span class="line">    <span class="string">&quot;https://use.fontawesome.com/releases/v5.14.0/js/all.js&quot;</span>],</span><br><span class="line">  <span class="string">&quot;dependencies&quot;</span>: []</span><br><span class="line">&#125;</span><br><span class="line">&lt;/config&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=<span class="string">&quot;javascript&quot;</span>&gt;</span><br><span class="line"><span class="keyword">const</span> drawImage = <span class="function">(<span class="params">canvas, base64Image</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">        img.crossOrigin = <span class="string">&quot;anonymous&quot;</span></span><br><span class="line">        img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">            canvas.width = <span class="built_in">Math</span>.min(<span class="built_in">this</span>.width, <span class="number">512</span>);</span><br><span class="line">            canvas.height= <span class="built_in">Math</span>.min(<span class="built_in">this</span>.height, <span class="built_in">parseInt</span>(<span class="number">512</span>*<span class="built_in">this</span>.height/<span class="built_in">this</span>.width), <span class="number">1024</span>);</span><br><span class="line">            <span class="comment">// draw the img into canvas</span></span><br><span class="line">            ctx.drawImage(<span class="built_in">this</span>, <span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line">            resolve(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">        img.onerror = reject;</span><br><span class="line">        img.src = base64Image;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> readImageFile = <span class="function">(<span class="params">file</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> U = <span class="built_in">window</span>.URL || <span class="built_in">window</span>.webkitURL;</span><br><span class="line">        <span class="keyword">if</span>(U.createObjectURL)&#123;</span><br><span class="line">            resolve(U.createObjectURL(file))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> fr = <span class="keyword">new</span> FileReader();</span><br><span class="line">            fr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">                resolve(e.target.result)</span><br><span class="line">            &#125;;</span><br><span class="line">            fr.onerror = reject</span><br><span class="line">            fr.readAsDataURL(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImJoyPlugin</span></span>&#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> fileInput = <span class="built_in">document</span>.getElementById(<span class="string">&quot;file-input&quot;</span>);</span><br><span class="line">        <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;input-canvas&quot;</span>);</span><br><span class="line">        <span class="keyword">const</span> outputcanvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;output-canvas&quot;</span>);</span><br><span class="line">        fileInput.addEventListener(<span class="string">&quot;change&quot;</span>, <span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">        <span class="keyword">const</span> img = <span class="keyword">await</span> readImageFile(fileInput.files[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">await</span> drawImage(canvas, img);</span><br><span class="line">        &#125;, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">await</span> api.log(<span class="string">&quot;plugin initialized&quot;</span>)</span><br><span class="line">        <span class="keyword">const</span> selectButton = <span class="built_in">document</span>.getElementById(<span class="string">&quot;select-button&quot;</span>);</span><br><span class="line">        selectButton.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">        fileInput.click()</span><br><span class="line">        &#125;, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">run</span>(<span class="params">ctx</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ctx.data &amp;&amp; ctx.data.process)&#123;</span><br><span class="line">            <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;input-canvas&quot;</span>);</span><br><span class="line">            <span class="keyword">const</span> outputcanvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;output-canvas&quot;</span>);</span><br><span class="line">            <span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;process-button&#x27;</span>)</span><br><span class="line">            btn.disabled = <span class="literal">false</span>;</span><br><span class="line">            btn.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">                <span class="keyword">const</span> base64String = canvas.toDataURL()</span><br><span class="line">                <span class="keyword">const</span> base64dst = <span class="keyword">await</span> ctx.data.process(base64String)</span><br><span class="line">                <span class="keyword">await</span> drawImage(outputcanvas, base64dst)</span><br><span class="line">            &#125;, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">api.export(<span class="keyword">new</span> ImJoyPlugin())</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="built_in">window</span>&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;input  id=<span class="string">&quot;file-input&quot;</span> accept=<span class="string">&quot;image/*&quot;</span> capture=<span class="string">&quot;camera&quot;</span> type=<span class="string">&quot;file&quot;</span>/&gt;</span><br><span class="line">        &lt;nav <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;panel&quot;</span>&gt;</span><br><span class="line">        &lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;panel-heading&quot;</span>&gt;</span><br><span class="line">            &lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;fas fa-eye&quot;</span> aria-hidden=<span class="string">&quot;true&quot;</span>&gt;&lt;/i&gt; My Image Viewer <span class="keyword">with</span> Python backend</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;panel-block&quot;</span>&gt;</span><br><span class="line">            &lt;button id=<span class="string">&quot;select-button&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;button is-link is-outlined is-fullwidth&quot;</span>&gt;</span><br><span class="line">            Open an image</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">            &lt;button id=<span class="string">&quot;process-button&quot;</span> disabled <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;button is-link is-outlined is-fullwidth&quot;</span>&gt;</span><br><span class="line">            RGB to Gray</span><br><span class="line">            &lt;/button&gt;            </span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;panel-block&quot;</span>&gt;</span><br><span class="line">            &lt;canvas id=<span class="string">&quot;input-canvas&quot;</span> style=<span class="string">&quot;width: 100%; object-fit: cover;&quot;</span>&gt;&lt;/canvas&gt;</span><br><span class="line">            &lt;canvas id=<span class="string">&quot;output-canvas&quot;</span> style=<span class="string">&quot;width: 100%; object-fit: cover;&quot;</span>&gt;&lt;/canvas&gt;</span><br><span class="line">        &lt;/div&gt; </span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;panel-block&quot;</span>&gt;</span><br><span class="line">            &lt;button id=<span class="string">&quot;predict-button&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;button is-link is-outlined is-fullwidth&quot;</span>&gt;</span><br><span class="line">            Predict</span><br><span class="line">            &lt;/button&gt;        </span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/<span class="built_in">window</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">#file-input&#123;</span><br><span class="line">    display: none;</span><br><span class="line">&#125;</span><br><span class="line">h1&#123;</span><br><span class="line">    color: pink;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><br>对于compute插件：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&lt;config lang=<span class="string">&quot;json&quot;</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;type&quot;</span>: <span class="string">&quot;native-python&quot;</span>,</span><br><span class="line"> <span class="string">&quot;name&quot;</span>: <span class="string">&quot;my-python-plugin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;id&quot;</span>: <span class="string">&quot;9l3fewe7l&quot;</span>,</span><br><span class="line"> <span class="string">&quot;namespace&quot;</span>: <span class="string">&quot;9l3fewe7l&quot;</span>,</span><br><span class="line"> <span class="string">&quot;lang&quot;</span>: <span class="string">&quot;python&quot;</span>,</span><br><span class="line"> <span class="string">&quot;window_id&quot;</span>: <span class="string">&quot;code_9l3fewe7l&quot;</span>,</span><br><span class="line"> <span class="string">&quot;api_version&quot;</span>: <span class="string">&quot;0.1.8&quot;</span>,</span><br><span class="line"> <span class="string">&quot;description&quot;</span>: <span class="string">&quot;[TODO: describe this plugin with one sentence.]&quot;</span>,</span><br><span class="line"> <span class="string">&quot;tags&quot;</span>: [],</span><br><span class="line"> <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.1.0&quot;</span>,</span><br><span class="line"> <span class="string">&quot;ui&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"> <span class="string">&quot;cover&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"> <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;extension&quot;</span>,</span><br><span class="line"> <span class="string">&quot;inputs&quot;</span>: null,</span><br><span class="line"> <span class="string">&quot;outputs&quot;</span>: null,</span><br><span class="line"> <span class="string">&quot;env&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"> <span class="string">&quot;permissions&quot;</span>: [],</span><br><span class="line"> <span class="string">&quot;requirements&quot;</span>: [<span class="string">&quot;opencv-python&quot;</span>],</span><br><span class="line"> <span class="string">&quot;dependencies&quot;</span>: []</span><br><span class="line">&#125;</span><br><span class="line">&lt;/config&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=<span class="string">&quot;python&quot;</span>&gt;</span><br><span class="line"><span class="keyword">from</span> imjoy <span class="keyword">import</span> api</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> imageio</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image_to_base64</span>(<span class="params">image_array</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;This function takes a numpy image array as input</span></span><br><span class="line"><span class="string">    and encode it into a base64 string</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    buf = io.BytesIO()</span><br><span class="line">    imageio.imwrite(buf, image_array, <span class="string">&quot;PNG&quot;</span>)</span><br><span class="line">    buf.seek(<span class="number">0</span>)</span><br><span class="line">    img_bytes = buf.getvalue()</span><br><span class="line">    base64_string = base64.b64encode(img_bytes).decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;data:image/png;base64,&#x27;</span> + base64_string</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">base64_to_image</span>(<span class="params">base64_string, <span class="built_in">format</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;This function takes a base64 string as input</span></span><br><span class="line"><span class="string">    and decode it into an numpy array image</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    base64_string = re.sub(<span class="string">&quot;^data:image/.+;base64,&quot;</span>, <span class="string">&quot;&quot;</span>, base64_string)</span><br><span class="line">    image_file = io.BytesIO(base64.b64decode(base64_string.encode(<span class="string">&#x27;ascii&#x27;</span>)))</span><br><span class="line">    <span class="keyword">return</span> imageio.imread(image_file, <span class="built_in">format</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_image</span>(<span class="params">src</span>):</span></span><br><span class="line">    dst = cv2.cvtColor(src, cv2.COLOR_RGBA2GRAY)</span><br><span class="line">    <span class="keyword">return</span> dst</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImJoyPlugin</span>():</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">setup</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">process</span>(<span class="params">self, base64string</span>):</span></span><br><span class="line">        img = base64_to_image(base64string)</span><br><span class="line">        dst = process_image(img)</span><br><span class="line">        base64dst = image_to_base64(dst)</span><br><span class="line">        <span class="keyword">return</span> base64dst</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, ctx</span>):</span></span><br><span class="line">        <span class="keyword">await</span> api.createWindow(</span><br><span class="line">            <span class="built_in">type</span>=<span class="string">&quot;Image Viewer&quot;</span>, </span><br><span class="line">            data=&#123;</span><br><span class="line">                <span class="string">&quot;process&quot;</span>: self.process,</span><br><span class="line">                <span class="string">&quot;_rintf&quot;</span>: <span class="literal">True</span>&#125;)</span><br><span class="line"></span><br><span class="line">api.export(ImJoyPlugin())</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><br>在调试上述插件时，因为涉及到了<code>base64</code>的编码和解码，我频繁用到了如下debug方法，推荐尝试：<br>（1）使用<code>api.log(base64string)</code>将base64编码结果显示在控制台中；<br>（2）使用这个网站<a href="https://base64.guru/converter/decode/image">Base64 to Image</a>将base64编码可视化，以查看结果正不正确。</p><h1 id="使用python深度学习库"><a href="#使用python深度学习库" class="headerlink" title="使用python深度学习库"></a>使用python深度学习库</h1><p>如上，我们使用了opencv-python进行了简单的图像处理，验证了native python插件的可行性。<br>而除了opencv-python，python背后还有着更为广阔的深度学习生态，如tensorflow、pytorch、mxnet、paddlepaddle等深度学习框架，以及这些框架可调用的GPU资源，因此可以说整个python计算生态都可以被ImJoy的native python插件所调用，这就提供了非常广阔的应用空间。<br>该部分不再介绍native python怎样调用python深度学习库，而是在后面的具体应用中详细解析。</p>]]></content>
    
    
    <summary type="html">上一篇着重介绍了如何使用JavaScript库来编写插件的前端UI和后端计算逻辑，这一节会介绍如何将计算后端切换为python语言，即计算逻辑完全使用python编写，充分利用python庞大的计算生态。
使用python开发计算插件有两种：
（1）web-python：即python运行在浏览器中，其原理实际是应用了Pyodide这一工具，将python代码编译在浏览器中，但其缺点也很明显，首先是加载速度非常慢，因为第一次运行时需要将所用的python库都下载下来；然后其也无法应用整个python深度学习生态。
（2）native-python：该类型插件会链接一个本地的jupyter插件引</summary>
    
    
    
    <category term="computer vision" scheme="http://qixinbo.github.io/categories/computer-vision/"/>
    
    
    <category term="ImJoy" scheme="http://qixinbo.github.io/tags/ImJoy/"/>
    
  </entry>
  
  <entry>
    <title>开源深度学习计算平台ImJoy解析：7 -- 构建基于Web的图像分析插件（JavaScript实现）</title>
    <link href="http://qixinbo.github.io/2021/12/17/ImJoy_7/"/>
    <id>http://qixinbo.github.io/2021/12/17/ImJoy_7/</id>
    <published>2021-12-16T16:00:00.000Z</published>
    <updated>2021-12-18T12:28:53.161Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://imjoy.io/docs/#/i2k_tutorial?id=_3-build-web-based-plugins-for-image-analysis">Build web-based plugins for image analysis</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在本文中，将制作一个基于Web网页的用于图像分析的ImJoy交互式插件。</p><h1 id="使用-HTML-CSS-JS-制作GUI插件"><a href="#使用-HTML-CSS-JS-制作GUI插件" class="headerlink" title="使用 HTML/CSS/JS 制作GUI插件"></a>使用 HTML/CSS/JS 制作GUI插件</h1><p>如下插件实现了一个上传并显示图像的功能，具体函数说明详见下面代码的注释：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 以Json格式定义插件属性 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 名称为Image Viewer，类型为window插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">config</span> <span class="attr">lang</span>=<span class="string">&quot;json&quot;</span>&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;Image Viewer&quot;, </span><br><span class="line">    &quot;type&quot;: &quot;window&quot;,</span><br><span class="line">    &quot;tags&quot;: [],</span><br><span class="line">    &quot;ui&quot;: &quot;&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;0.1.0&quot;,</span><br><span class="line">    &quot;cover&quot;: &quot;&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;This is a demo plugin for displaying image&quot;,</span><br><span class="line">    &quot;icon&quot;: &quot;extension&quot;,</span><br><span class="line">    &quot;inputs&quot;: null,</span><br><span class="line">    &quot;outputs&quot;: null,</span><br><span class="line">    &quot;api_version&quot;: &quot;0.1.8&quot;,</span><br><span class="line">    &quot;env&quot;: &quot;&quot;,</span><br><span class="line">    &quot;permissions&quot;: [],</span><br><span class="line">    &quot;requirements&quot;: [],</span><br><span class="line">    &quot;dependencies&quot;: []</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用HTML编写窗口的显示内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">window</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 显示文本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Please open an image (jpg/png/gif)<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用&lt;input&gt;标签定义用户可输入的字段，其中：</span></span><br><span class="line"><span class="comment">        type属性定义元素类型，这里为file，即上传文件</span></span><br><span class="line"><span class="comment">        accept属性则限制可用文件类型，这里限制文件为图片类型</span></span><br><span class="line"><span class="comment">        capture属性则定义在移动设备上可以不上传文件，而是调用系统的相机来拍照</span></span><br><span class="line"><span class="comment">        这些属性的用法可以参见如下教程：</span></span><br><span class="line"><span class="comment">        https://cloud.tencent.com/developer/article/1537891 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span>  <span class="attr">id</span>=<span class="string">&quot;file-input&quot;</span> <span class="attr">accept</span>=<span class="string">&quot;image/*&quot;</span> <span class="attr">capture</span>=<span class="string">&quot;camera&quot;</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用&lt;canvas&gt;标签来定义一个画布，用于承载图像的显示</span></span><br><span class="line"><span class="comment">        canvas元素本身只是一个图像容器，没有绘图能力，需要使用JS脚本进行绘制 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;input-canvas&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100%; object-fit: cover;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">window</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用CSS代码来编写窗口显示内容的样式</span></span><br><span class="line"><span class="comment">这里没有定义特殊样式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 实际插件代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">// 将base64格式图片传到画布上</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 用法见：https://blog.csdn.net/qq_39765048/article/details/118021098</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> drawImage = <span class="function">(<span class="params">canvas, base64Image</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> img = <span class="keyword">new</span> Image()</span></span><br><span class="line"><span class="javascript">        img.crossOrigin = <span class="string">&quot;anonymous&quot;</span></span></span><br><span class="line"><span class="javascript">        img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> ctx = canvas.getContext(<span class="string">&quot;2d&quot;</span>);</span></span><br><span class="line"><span class="javascript">            canvas.width = <span class="built_in">Math</span>.min(<span class="built_in">this</span>.width, <span class="number">512</span>);</span></span><br><span class="line"><span class="javascript">            canvas.height= <span class="built_in">Math</span>.min(<span class="built_in">this</span>.height, <span class="built_in">parseInt</span>(<span class="number">512</span>*<span class="built_in">this</span>.height/<span class="built_in">this</span>.width), <span class="number">1024</span>);</span></span><br><span class="line"><span class="javascript">            <span class="comment">// draw the img into canvas</span></span></span><br><span class="line"><span class="javascript">            ctx.drawImage(<span class="built_in">this</span>, <span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span></span><br><span class="line">            resolve(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">        img.onerror = reject;</span><br><span class="line">        img.src = base64Image;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="comment">// 读取文件内容</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 注意这里的形参file，它对应的实参是File对象（由下面的fileInput.files[0]可知）</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> readImageFile = <span class="function">(<span class="params">file</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> U = <span class="built_in">window</span>.URL || <span class="built_in">window</span>.webkitURL;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 该流程用于safari浏览器</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// File对象继承自Blob</span></span></span><br><span class="line">        if(U.createObjectURL)&#123;</span><br><span class="line"><span class="javascript">            <span class="comment">// 以下用法就是将Blob用作URL，这样就可以直接访问它</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 用法见：https://zh.javascript.info/blob</span></span></span><br><span class="line">            resolve(U.createObjectURL(file))</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="comment">// 第二种就是将blob转为了base64编码</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 用法见：https://zh.javascript.info/file</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// https://segmentfault.com/a/1190000022208272</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> fr = <span class="keyword">new</span> FileReader();</span></span><br><span class="line"><span class="javascript">            <span class="comment">// when image is loaded, set the src of the image where you want to display it</span></span></span><br><span class="line"><span class="javascript">            fr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line">                resolve(e.target.result)</span><br><span class="line">            &#125;;</span><br><span class="line">            fr.onerror = reject</span><br><span class="line"><span class="javascript">            <span class="comment">// 转换为 base64 的 data url</span></span></span><br><span class="line">            fr.readAsDataURL(file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="comment">// 编写插件函数</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 一个最小的插件需要实现两个函数：setup() 和 run()</span></span></span><br><span class="line"><span class="javascript"><span class="class"><span class="keyword">class</span> <span class="title">ImJoyPlugin</span></span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// setup() 函数：在插件第一次加载和初始化时执行它。</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">async</span> <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 通过ID获得页面中的input元素</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> fileInput = <span class="built_in">document</span>.getElementById(<span class="string">&quot;file-input&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 通过ID获得页面中的canvas元素</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;input-canvas&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 为input元素添加点击事件，其中涉及了如下语法点：</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// （1）addEventListener语法：https://www.runoob.com/jsref/met-document-addeventlistener.html</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// （2）箭头函数：https://www.helloworld.net/p/0020086208</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// https://gauliang.github.io/blog/2020/javascript-arrow-function-best-practices/</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// （3）async/await异步编程：https://www.ruanyifeng.com/blog/2015/05/async.html</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Async_await</span></span></span><br><span class="line"><span class="javascript">        fileInput.addEventListener(<span class="string">&quot;change&quot;</span>, <span class="keyword">async</span> ()=&gt;&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 执行上面的readImageFile函数</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// 输入参数就是input元素获取的文件，具体用法如下：</span></span></span><br><span class="line"><span class="javascript">            <span class="comment">// https://developer.mozilla.org/en-US/docs/Web/API/FileList</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> img = <span class="keyword">await</span> readImageFile(fileInput.files[<span class="number">0</span>]);</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 执行上面的drawImage函数</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">await</span> drawImage(canvas, img);</span></span><br><span class="line"><span class="javascript">        &#125;, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">await</span> api.log(<span class="string">&quot;plugin initialized&quot;</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="comment">// run() 函数：每次执行插件时都会调用。</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 执行时，一个带有上下文（名为“ctx”）的对象object（Javascript插件）或字典dictionary（Python插件）将被传递到函数中。</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 返回的结果将显示为一个新窗口或传递给工作流中的下一个 op。</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">async</span> <span class="function"><span class="title">run</span>(<span class="params">ctx</span>)</span>&#123;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="comment">// 导出插件函数，或称注册插件函数，</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// 这是为了使得插件可以被ImJoy主程序或其他插件所调用</span></span></span><br><span class="line"><span class="javascript">api.export(<span class="keyword">new</span> ImJoyPlugin())</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><br>插件的运行结果如下图：<br><img src="https://user-images.githubusercontent.com/6218739/145956208-426aac96-134f-433c-9658-15a32939b996.png" alt="canvas"></p><h2 id="更改"><a href="#更改" class="headerlink" title="更改"></a>更改</h2><p>对上述插件做一点更改，来加深对它的理解。具体地，增加一个上传按钮<code>&lt;button&gt;</code>，它将触发打开文件对话框，以便可以使用该按钮来选择文件。 （这样做原因是为了后面可以轻松自定义按钮的外观。）<br>（1）在<code>&lt;input&gt;</code>标签下方，添加一行：<br><code>&lt;button id=&quot;select-button&quot;&gt;Open an image&lt;/button&gt;</code><br>（2）在<code>setup</code>函数中，添加：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当按钮点击时触发文件上传框 </span></span><br><span class="line"><span class="keyword">const</span> selectButton = <span class="built_in">document</span>.getElementById(<span class="string">&quot;select-button&quot;</span>);</span><br><span class="line">selectButton.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">    <span class="comment">// 模拟对&lt;input&gt;标签的点击</span></span><br><span class="line">    fileInput.click()</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><br>（3）在<code>&lt;style&gt;</code>块中添加一个css样式来隐藏<code>&lt;input&gt;</code>元素：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#file-input</span>&#123;</span><br><span class="line">   <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>（4）另外，可以通过添加更多css来更改标题文本的样式：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">   <span class="attribute">color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>现在插件变成了如下模样：<br><img src="https://user-images.githubusercontent.com/6218739/145958371-b1a76c5b-aa58-4420-be31-a00b75a51d30.png" alt="canvas2"></p><h1 id="使用css库"><a href="#使用css库" class="headerlink" title="使用css库"></a>使用css库</h1><p>手工制作CSS样式非常耗时，需要深入了解UI设计原理和CSS本身。<br>幸运的是，已经有很多UI库（<a href="https://getbootstrap.com/">Bootstrap</a>, <a href="https://materializecss.com/">https://materializecss.com/</a> 等）可以利用。还有更强大的js库和框架可以构建更专业的UI，例如：<a href="https://reactjs.org/">React</a>、<a href="https://vuejs.org/">Vuejs</a>和<a href="https://angular.io/">Angular</a>。在本教程中，将选择一个名为 <a href="https://bulma.io/"><strong>Bulma</strong></a> 的小型CSS进行说明。<br>通过查看Bulma的文档<a href="https://bulma.io/documentation/overview/start/">这里</a>，可以看出，只需要加载一个CSS文件。<br>在ImJoy插件中，加载第三方CSS或Javascript库的方式是将url添加到<code>&lt;config&gt;</code>块中的<code>requirements</code>字段。<br>因此增加如下代码：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;requirements&quot;</span>: [<span class="string">&quot;https://cdn.jsdelivr.net/npm/bulma@0.9.1/css/bulma.min.css&quot;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Bulma支持大量不同的元素和布局，可以在<a href="https://bulma.io/documentation/elements/button/">此处</a>阅读有关按钮的信息。<br>基本上，只需要向按钮标签添加一个类（例如<code>class=&quot;button is-primary&quot;</code>），它就会改变它的外观。同样，也可以在 <code>&lt;h1&gt;</code> 标题中添加 <code>class=&quot;title&quot;</code>。<br>即修改如下代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span>Please Open an image (jpg/png/gif)<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;select-button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;button is-primary&quot;</span>&gt;</span>Open an image<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>现在插件变成了如下模样：<br><img src="https://user-images.githubusercontent.com/6218739/145963258-5090eb3e-8280-46f2-b188-831169c4fb44.png" alt="canvas-3"></p><p>进一步地，可以尝试使用<a href="https://bulma.io/documentation/components/panel/">panel</a>将 <code>button</code> 和 <code>&lt;canvas&gt;</code> 分组。<br>要在Bulma中使用图标，需要添加 <code>https://use.fontawesome.com/releases/v5.14.0/js/all.js</code> 和 <code>requirements</code>。然后从<a href="https://fontawesome.com/icons">这里</a>搜索图标。例如，如果找到一个名为 <code>eye</code> 的图标，可以使用将该图标作为 <code>&lt;i class=&quot;fas fa-eye&quot;&gt;&lt;/i&gt;</code> 添加到html中。<br>在相应的地方修改代码如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&quot;requirements&quot;: [&quot;https://cdn.jsdelivr.net/npm/bulma@0.9.1/css/bulma.min.css&quot;, &quot;https://use.fontawesome.com/releases/v5.14.0/js/all.js&quot;]</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">window</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span>  <span class="attr">id</span>=<span class="string">&quot;file-input&quot;</span> <span class="attr">accept</span>=<span class="string">&quot;image/*&quot;</span> <span class="attr">capture</span>=<span class="string">&quot;camera&quot;</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;panel&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;panel-heading&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fas fa-eye&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> My Image Viewer</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel-block&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;select-button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;button is-link is-outlined is-fullwidth&quot;</span>&gt;</span></span><br><span class="line">            Open an image</span><br><span class="line">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel-block&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;input-canvas&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100%; object-fit: cover;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">window</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>现在插件变成了如下模样：<br><img src="https://user-images.githubusercontent.com/6218739/145964220-18b1e5fa-06dd-4331-9f67-c94e8c6ea7fd.png" alt="canvas-4"></p><h1 id="使用图像处理库OpenCV-js"><a href="#使用图像处理库OpenCV-js" class="headerlink" title="使用图像处理库OpenCV.js"></a>使用图像处理库OpenCV.js</h1><p>OpenCV是一个常用的计算机视觉库，用C++编写，现在它已经用WebAssembly编译，可以在浏览器中运行。<br>opencv.js有很多功能介绍文档，但对于本教程，以下两部分就足够了：<br>（1）了解如何使用opencv.js加载和保存图片，阅读<a href="https://docs.opencv.org/3.4/df/d24/tutorial_js_image_display.html">这里</a><br>（2）从<a href="https://docs.opencv.org/3.4/d2/df0/tutorial_js_table_of_contents_imgproc.html">此列表</a> 中选择一个图像处理教程并将其集成到图像查看器插件中。例如，<a href="https://docs.opencv.org/3.4/d7/dd0/tutorial_js_thresholding.html">图像阈值</a>、<a href="https://docs.opencv.org/3.4/dd/d6a/tutorial_js_filtering.html">平滑图像</a>、<a href="https://docs.opencv.org/3.4/d7/de1/tutorial_js_canny.html">canny 边缘检测</a>或<a href="https://docs.opencv.org/3.4/d7/d1c/tutorial_js_watershed.html">分水岭分割</a>。</p><p>基本上，需要经过三个步骤来实现：<br>（1）在<code>&lt;config&gt;</code>下的<code>&quot;requirements&quot;</code>中添加opencv.js库<code>&quot;https://docs.opencv.org/master/opencv.js&quot;</code><br>（2）从教程中取出图像处理部分，并将其包装为一个函数（例如<code>processImage</code>）<br>（3）添加点击时调用函数的<code>button</code>。</p><p>接下来以“彩色转灰度”这一功能作为例子：<br>（1）添加opencv.js库：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;requirements&quot;: [&quot;https://cdn.jsdelivr.net/npm/bulma@0.9.1/css/bulma.min.css&quot;, &quot;https://use.fontawesome.com/releases/v5.14.0/js/all.js&quot;, &quot;https://docs.opencv.org/master/opencv.js&quot;]</span><br></pre></td></tr></table></figure><br>（2）编写图像处理函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;panel-block&quot;</span>&gt;</span><br><span class="line">    &lt;canvas id=<span class="string">&quot;input-canvas&quot;</span> style=<span class="string">&quot;width: 100%; object-fit: cover;&quot;</span>&gt;&lt;/canvas&gt;</span><br><span class="line">    <span class="comment">// 新增一个画布，用于显示处理后的图像</span></span><br><span class="line">    &lt;canvas id=<span class="string">&quot;output-canvas&quot;</span> style=<span class="string">&quot;width: 100%; object-fit: cover;&quot;</span>&gt;&lt;/canvas&gt;</span><br><span class="line">&lt;/div&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment">// opencv图像处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processImage</span>(<span class="params">inputCanvasId, outputCanvasId</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> src = cv.imread(inputCanvasId);</span><br><span class="line">    <span class="keyword">let</span> dst = <span class="keyword">new</span> cv.Mat();</span><br><span class="line">    cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY);</span><br><span class="line">    cv.imshow(outputCanvasId, dst);</span><br><span class="line">    src.delete();</span><br><span class="line">    dst.delete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>(3) 添加事件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;panel-block&quot;</span>&gt;</span><br><span class="line">    &lt;button id=<span class="string">&quot;select-button&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;button is-link is-outlined is-fullwidth&quot;</span>&gt;</span><br><span class="line">    Open an image</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">    <span class="comment">// 新增一个按钮来触发图像处理操作</span></span><br><span class="line">    &lt;button id=<span class="string">&quot;process-button&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;button is-link is-outlined is-fullwidth&quot;</span>&gt;</span><br><span class="line">    RGB to Gray</span><br><span class="line">    &lt;/button&gt;            </span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在setup函数种新增如下事件</span></span><br><span class="line"><span class="keyword">const</span> processButton = <span class="built_in">document</span>.getElementById(<span class="string">&quot;process-button&quot;</span>);</span><br><span class="line">processButton.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">    processImage(<span class="string">&#x27;input-canvas&#x27;</span>, <span class="string">&#x27;output-canvas&#x27;</span>)</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><br>整个插件的运行示例如下：<br><img src="https://user-images.githubusercontent.com/6218739/146137751-81871ffc-4295-45c7-b552-2e028e39eabc.png" alt="opencvjs"></p><h1 id="使用深度学习库tensorflow-js"><a href="#使用深度学习库tensorflow-js" class="headerlink" title="使用深度学习库tensorflow.js"></a>使用深度学习库tensorflow.js</h1><p><a href="https://www.tensorflow.org/">Tensorflow</a>是一个被广泛使用的深度学习库，它已经被移植到javascript在浏览器中运行，该库被称为<a href="https://www.tensorflow.org/js/">Tensorflow.js</a>。<br>这一部分会将Tensorflow.js集成到上述插件中，具体功能为使用一个预训练的MobileNet算法对图像进行分类，详见<a href="https://github.com/imjoy-team/imjoy-plugins/blob/54675ae50a0e958605f2a5458e635fdb0437a1f4/repository/imageRecognition.imjoy.html">这里</a>。<br>（1）首先引用必要的JS库：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;requirements&quot;: [</span><br><span class="line">&quot;https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@0.14.1&quot;,</span><br><span class="line">&quot;https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@0.2.2&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><br>（2）增加预测按钮、结果显示、模型加载等窗口组件：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel-block&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;predict-button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;button is-link is-outlined is-fullwidth&quot;</span>&gt;</span></span><br><span class="line">    Predict</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&lt;!–– Header bar ––&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hero hero-sm bg-secondary&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mx-2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&quot;hero_title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;status&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><br>（3）在setup函数中增加事件响应：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> predictButton = <span class="built_in">document</span>.getElementById(<span class="string">&quot;predict-button&quot;</span>);</span><br><span class="line">predictButton.onclick = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.predict()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Load the model.</span></span><br><span class="line"><span class="keyword">const</span> statusElement = <span class="built_in">document</span>.getElementById(<span class="string">&quot;status&quot;</span>);</span><br><span class="line">statusElement.innerHTML = <span class="string">&#x27;Loading pretrained model...&#x27;</span>;</span><br><span class="line"><span class="built_in">this</span>.model = <span class="keyword">await</span> mobilenet.load();</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;hero_title&quot;</span>).innerHTML = <span class="string">&#x27;Model loaded&#x27;</span></span><br><span class="line">statusElement.innerHTML = <span class="string">&#x27;1. Open image (.png/.jpg) or use pre-loaded image. &lt;br&gt; 2. Click `Predict` for image recognition!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Display the predict button and file selection</span></span><br><span class="line">predictButton.style.display = <span class="string">&quot;inline&quot;</span>;</span><br><span class="line">fileInput.style.display = <span class="string">&quot;inline&quot;</span>;</span><br></pre></td></tr></table></figure><br>可以看出，分别为预测按钮绑定了点击事件响应，以及自动下载模型。<br>（4）编写模型预测逻辑：<br>在上面的预测按钮点击后，会触发如下预测函数（这个函数在setup之外，即与setup地位平齐）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">predict</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;input-canvas&#x27;</span>);</span><br><span class="line">  <span class="comment">// Classify the image.</span></span><br><span class="line">  <span class="keyword">const</span> predictions = <span class="keyword">await</span> <span class="built_in">this</span>.model.classify(canvas)</span><br><span class="line">  <span class="comment">// Output result in console</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Predictions&#x27;</span>, predictions);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Output results in interface</span></span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;hero_title&quot;</span>).innerHTML = <span class="string">&#x27;Predictions: &#x27;</span></span><br><span class="line">  <span class="keyword">const</span> result_string_html = <span class="string">`Top-1: <span class="subst">$&#123;predictions[<span class="number">0</span>].className&#125;</span> (<span class="subst">$&#123;<span class="built_in">Math</span>.round(predictions[<span class="number">0</span>].probability*<span class="number">100</span>)&#125;</span>%) &lt;br&gt; Top-2: <span class="subst">$&#123;predictions[<span class="number">1</span>].className&#125;</span> (<span class="subst">$&#123;<span class="built_in">Math</span>.round(predictions[<span class="number">1</span>].probability*<span class="number">100</span>)&#125;</span>%)`</span>;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;status&quot;</span>).innerHTML = result_string_html</span><br><span class="line">  <span class="comment">// Output results as ImJoy alert</span></span><br><span class="line">  <span class="keyword">const</span> result_string =  <span class="string">`Predictions: Top-1 <span class="subst">$&#123;predictions[<span class="number">0</span>].className&#125;</span> (<span class="subst">$&#123;<span class="built_in">Math</span>.round(predictions[<span class="number">0</span>].probability*<span class="number">100</span>)&#125;</span>%); Top-2 <span class="subst">$&#123;predictions[<span class="number">1</span>].className&#125;</span> (<span class="subst">$&#123;<span class="built_in">Math</span>.round(predictions[<span class="number">1</span>].probability*<span class="number">100</span>)&#125;</span>%);`</span>;</span><br><span class="line">  api.alert(result_string)</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>增加上述内容后，整个插件运行结果如下：<br><img src="https://user-images.githubusercontent.com/6218739/146505050-e59640d2-9cd4-45f2-8a9c-736ad08e87ca.png" alt="tfjs"><br>可以看出，在最下面对图像中的内容进行了分类识别。</p><p>注意：虽然基于浏览器的插件已经很有用，并且随着WebAssembly和<a href="https://en.wikipedia.org/wiki/WebGPU">WebGPU</a>等新技术的使用而变得更加强大，但它无法进行大规模计算，并且由于其安全性而受到许多限制。</p>]]></content>
    
    
    <summary type="html">参考文献
Build web-based plugins for image analysis

简介
在本文中，将制作一个基于Web网页的用于图像分析的ImJoy交互式插件。

使用 HTML/CSS/JS 制作GUI插件
如下插件实现了一个上传并显示图像的功能，具体函数说明详见下面代码的注释：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</summary>
    
    
    
    <category term="computer vision" scheme="http://qixinbo.github.io/categories/computer-vision/"/>
    
    
    <category term="ImJoy" scheme="http://qixinbo.github.io/tags/ImJoy/"/>
    
  </entry>
  
  <entry>
    <title>开源深度学习计算平台ImJoy解析：6 -- API</title>
    <link href="http://qixinbo.github.io/2021/12/11/ImJoy_6/"/>
    <id>http://qixinbo.github.io/2021/12/11/ImJoy_6/</id>
    <published>2021-12-10T16:00:00.000Z</published>
    <updated>2021-12-11T09:29:25.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://imjoy.io/docs/#/api">ImJoy API</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>ImJoy的每个插件都在自己的类似沙箱的容器环境中运行（如JavaScript插件的Web Worker 或iframe、Python插件的进程process）。这样可以避免其他插件的干扰并使ImJoy应用程序更加安全。<br>插件与ImJoy主程序或插件与插件之间的交互是通过一组API函数（<code>ImJoy API</code>）进行的。所有插件都可以访问到一个名为<code>api</code>的特殊对象。在Javascript中，<code>api</code> 是一个可以直接使用的全局对象。在Python中，可以通过调用 <code>from imjoy import api</code> 来导入它。有了这个对象，插件可以做很多事情，比如显示一个对话框、将结果发送到主应用程序，或调用另一个插件的参数和数据等。</p><h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><p>为了使交互更加高效和并发，对于这些API函数，ImJoy使用一种称为<a href="http://cs.brown.edu/courses/cs168/s12/handouts/async.pdf">异步编程</a>的编程模式。<br>所有ImJoy API函数都是异步的。这意味着当一个<code>ImJoy API</code>函数被调用时，ImJoy不会阻止原程序的执行，而是会立即返回一个名为 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ Promise">Promise(JS)</a> 或 <a href="https://docs.python.org/3/library/asyncio-future.html">Future (Python)</a>的对象。开发者可以决定等待实际结果返回或设置一个回调函数以在进程终止后再取回结果。例如，如果弹出一个对话框要求用户输入，在许多编程语言（同步编程）中，代码执行将被阻塞，直到用户关闭对话框。但是，对于一个异步程序，尽管用户没有关闭对话框，它会返回一个<code>promise</code>对象，然后继续执行。<br>由于每个API调用都是异步和非阻塞的，一个给定的插件可以调用多个其他插件来同时执行任务，而无需使用多线程或多进程等技术。<br>对于Python和JavaScript插件，ImJoy 都支持两种异步编程风格来访问这些异步函数：<code>async/await</code> 和 <code>callback</code> 风格。几个重要的注意点是：</p><ul><li>对于JavaScript和Python 3，推荐<code>async/await</code></li><li><code>callback</code> 样式可用于 JavaScript、Python 2 和 Python 3。</li><li>注意，不能同时使用这两种风格。</li><li>对于<code>async/await</code> 风格，可以使用 <code>try catch</code> (JavaScript) 或 <code>try except</code> (Python) 语法来捕获错误，但对于 <code>callback</code> 风格，则不能使用它们来捕获错误。</li></ul><p>在下面的API函数列表中，提供了 <code>async</code> 风格的示例。对于 Python 2，也可以轻松地转换为相应的<code>callback</code>风格。</p><h2 id="async-await风格"><a href="#async-await风格" class="headerlink" title="async/await风格"></a>async/await风格</h2><p>Javascript 和 Python 3+ 插件原生支持并推荐使用这种风格。<br>使用 <code>async</code> 关键字声明函数。在异步之前添加<code>await</code>函数等待结果返回。这基本上就是无需设置回调函数即可进行同步编程。<br>下面是一个名为<code>XXXXX</code>的api函数的简单示例。注意，在函数中使用await时，要在函数定义前添加async。对于 Python3，不要忘记<code>import asyncio</code>。<br>JavaScript语言的实现为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ImJoyPlugin</span>()</span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">run</span>(<span class="params">ctx</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      result = <span class="keyword">await</span> api.XXXXX()</span><br><span class="line">      <span class="built_in">console</span>.log(result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">      <span class="built_in">console</span>.error(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Python语言的实现为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> imjoy <span class="keyword">import</span> api</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImJoyPlugin</span>():</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">setup</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, ctx</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            result = <span class="keyword">await</span> api.XXXXX()</span><br><span class="line">            <span class="built_in">print</span>(result)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure></p><h2 id="Callback风格"><a href="#Callback风格" class="headerlink" title="Callback风格"></a>Callback风格</h2><p>对于 Python 2 或 Web Python，不支持 <code>asyncio</code>，因此此时需要使用<code>callback</code>风格。<br>调用异步函数并使用 <code>.then(callback_func)</code> 设置其回调。对于 JavaScript 插件，将返回原生 JavaScript <code>Promise</code>（<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">更多关于 Promise</a>。对于 Python 插件，它将返回<code>Promise</code>的一个简化的Python实现。<br>下面是名为“XXXXX”的 api 函数示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImJoyPlugin</span>()</span>&#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params">ctx</span>)</span>&#123;</span><br><span class="line">      api.XXXXX().then(<span class="built_in">this</span>.callback)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// optionally, you can catch error</span></span><br><span class="line">      <span class="keyword">const</span> <span class="function"><span class="title">error_callback</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(error)</span><br><span class="line">      &#125;</span><br><span class="line">      api.XXXXX().then(<span class="built_in">this</span>.callback).catch(error_callback)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">callback</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>或<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> imjoy <span class="keyword">import</span> api</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImJoyPlugin</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, ctx</span>):</span></span><br><span class="line">        api.XXXXX().then(self.callback)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># this function will be called when we get results from api.XXXXX()</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">result_callback</span>(<span class="params">result</span>):</span></span><br><span class="line">            <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># optionally, you can catch an error for the call</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">error_callback</span>(<span class="params">error</span>):</span></span><br><span class="line">            <span class="built_in">print</span>(error)</span><br><span class="line"></span><br><span class="line">        api.XXXXX().then(result_callback).catch(error_callback)</span><br></pre></td></tr></table></figure></p><h1 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h1><p>调用API函数时，大多数函数接收一个对象object（对于JavaScript）或字典dictionary（对于Python）作为它的第一个参数。<br>以下函数调用对JavaScript和Python都适用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript or Python</span></span><br><span class="line"><span class="keyword">await</span> api.XXXXX(&#123;<span class="string">&quot;option1&quot;</span>: <span class="number">3</span>, <span class="string">&quot;option2&quot;</span>: <span class="string">&#x27;hi&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><br>以下调用则仅适用于 Python：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python</span></span><br><span class="line"><span class="keyword">await</span> api.XXXXX(option1=<span class="number">3</span>, option2=<span class="string">&#x27;hi&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h1 id="净化的HTML和CSS"><a href="#净化的HTML和CSS" class="headerlink" title="净化的HTML和CSS"></a>净化的HTML和CSS</h1><p>出于安全原因，ImJoy使用<a href="https://github.com/cure53/DOMPurify">DOMPurify</a> 来净化ImJoy主界面中使用的HTML和CSS，主要是为了防止跨站脚本攻击XSS，包括所有的markdown、<code>&lt;config&gt;</code>块和<code>api.register</code>中的<code>ui</code>字符串，以及<code>api.alert</code>、<code>api.confirm</code>和<code>api.prompt</code>中显示的内容。 另请注意，<code>window</code>插件中显示的内容没有这些限制。</p><h1 id="API函数"><a href="#API函数" class="headerlink" title="API函数"></a>API函数</h1><p>对于每个API函数，下面提供了一个简短的代码片段来说明如何使用它的功能。这些例子是JavaScript语言编写的，但在Python中可以以类似的方式调用。</p><h2 id="api-alert"><a href="#api-alert" class="headerlink" title="api.alert"></a>api.alert</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> api.alert(message)</span><br></pre></td></tr></table></figure><p>参数：<br>对于纯文本：</p><ul><li><code>message</code>：String类型。其包含要显示的消息。消息中可以使用HTML标签，但仅限于一组受限的标签和 css，如上面[净化的HTML和CSS]一节所述。</li></ul><p>对于HTML：</p><ul><li><code>message</code>：Object类型。它包含以下字段：<ul><li>content：包含要显示的问题。消息中可以使用HTML标签，但仅限于一组受限的标签和 css，如上面[净化的HTML和CSS]一节所述。</li><li>title：对话框的标题</li></ul></li></ul><p>举例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> api.alert(<span class="string">&#x27;hello world&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h2 id="api-prompt"><a href="#api-prompt" class="headerlink" title="api.prompt"></a>api.prompt</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> answer = <span class="keyword">await</span> api.prompt(question, default_answer)</span><br></pre></td></tr></table></figure><p>显示要求用户输入的提示。<br>参数：<br>对于纯文本：</p><ul><li>question：String。包含要显示的问题。消息中可以使用 HTML 标签，但仅限于一组受限的标签和 css，如上面[净化的HTML和CSS]一节所述。</li></ul><p>对于 HTML：</p><ul><li><p>question：Object。它包含以下字段：</p><ul><li>content：包含要显示的问题。消息中可以使用 HTML 标签，但仅限于一组受限的标签和 css，如上面[净化的HTML和CSS]一节所述。</li><li>placeholder：问题的默认答案</li><li>title：对话框的标题</li></ul></li><li><p>default_answer（可选）：String。包含问题的默认答案。</p></li></ul><p>返回值：</p><ul><li>answer：布尔值Boolean。来自用户的回答。</li></ul><p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> answer = <span class="keyword">await</span> api.prompt(<span class="string">&#x27;What is your name?&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h2 id="api-confirm"><a href="#api-confirm" class="headerlink" title="api.confirm"></a>api.confirm</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> confirmation = <span class="keyword">await</span> api.confirm(question)</span><br></pre></td></tr></table></figure><p>向用户显示确认消息。<br>参数：<br>对于纯文本：</p><ul><li>question：String。包含要显示的问题。消息中可以使用 HTML 标签，但仅限于一组受限的标签和 css，如上面[净化的HTML和CSS]一节所述。</li></ul><p>对于 HTML：</p><ul><li>question：Object。它包含以下字段：<ul><li>content：包含要显示的问题。消息中可以使用 HTML 标签，但仅限于一组受限的标签和 css，如上面[净化的HTML和CSS]一节所述。</li><li>title：对话框的标题</li></ul></li></ul><p>返回值：</p><ul><li>confirmation：布尔值。对或错。</li></ul><p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> confirmation = <span class="keyword">await</span> api.confirm(<span class="string">&#x27;Do you want to delete these files?&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span>(confirmation)&#123;</span><br><span class="line">  delete_file()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;User cancelled file deletion.&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="api-call"><a href="#api-call" class="headerlink" title="api.call"></a>api.call</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="keyword">await</span> api.call(plugin_name, plugin_op, arg1, arg2 ...)</span><br></pre></td></tr></table></figure><p>从另一个插件调用函数。<br>还可以传输数据。参数的数量必须与被调用函数的参数所需的数目相匹配。<br>如果想频繁调用其他插件的功能，推荐使用<code>api.getPlugin</code>。</p><p>参数：</p><ul><li>plugin_name：String。被调用插件的名称。</li><li>plugin_op：String。插件的函数的名称 (op)。</li><li>args（可选）：可以传输的任何受支持的原始数据类型。</li></ul><p>返回值：</p><ul><li>result：插件的函数返回的结果（如果有）。</li></ul><p>例子：<br>调用插件<code>PluginX</code>中定义的函数<code>funcX</code>，并传入参数<code>1</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> api.call(<span class="string">&quot;PluginX&quot;</span>, <span class="string">&quot;funcX&quot;</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><h2 id="api-createWindow"><a href="#api-createWindow" class="headerlink" title="api.createWindow"></a>api.createWindow</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">win = <span class="keyword">await</span> api.createWindow(config)</span><br></pre></td></tr></table></figure><p>在 ImJoy 工作区中创建一个新窗口。<br>一旦创建了一个窗口，它将返回一个带有相应<code>window</code>插件API的对象，该对象可用于更新窗口，比如可以使用 <code>win.run(&#123;&quot;data&quot;: ...&#125;)</code> 更新数据字段。<br>注意1：调用关闭窗口的函数。如果窗口关闭并且尝试调用它的函数，将会得到一个错误，解决这个问题的一种方法是使用 <code>try ... catch</code>(JavaScript) 或 <code>try: ... except: ...</code>(Python) 语句来捕获错误。<br>注意2：<code>api.createWindow</code>和<code>api.getPlugin</code>之间的区别。两个函数都可用于获取包含<code>window</code>插件api的对象。但是，只有通过<code>api.createWindow</code>获取的对象才能用于更新现有窗口。相比之下，<code>api.getPlugin</code>返回的对象每次使用都会创建一个新窗口。这种行为差异可以通过ImJoy处理不同插件类型的行为来解释。当ImJoy加载一个不是<code>window</code>插件的插件时，它会启动独立的python进程、webworker或 iframe。这确保了只有一个插件实例正在运行。相比之下，<code>window</code> 插件将仅用来注册并创建代理插件，此时没有实际实例开启，除非用户点击插件菜单或插件被另一个插件所调用。工作区中的每个窗口都是 <code>window</code> 插件的一个新实例。当<code>api.getPlugin</code> 被调用时，它会返回代理插件的api，例如<code>proxy = await api.getPlugin(&#123;&#39;name&#39;: &#39;Image Window&#39;&#125;)</code>)。每次<code>run</code>函数执行后，将创建一个新窗口。例如，如果运行<code>proxy.run(&#123;data: ...&#125;)</code>10次，将创建10个窗口。要取得使用<code>api.createWindow</code>（或<code>api.showDialog</code>）创建的窗口，可以使用<code>api.getWindow</code>。当使用<code>api.createWindow</code>时，它会返回一个<code>window</code>插件的实例，例如<code>win=await api.createWindow(&#123;&#39;name&#39;: &#39;new window&#39;, &#39;type&#39;: &#39;Image Window&#39;, &#39;data&#39;: &#123;...&#125;&#125;)</code>)。如果运行 <code>win.run(&#123;&#39;data&#39;: ...&#125;)</code> 10 次，同一个窗口实例将被更新10次。运行 <code>win.close()</code> 将关闭窗口。</p><p>参数：</p><ul><li><p>config：String或Object。创建窗口的选项。当它是一个字符串时，它会被转换成一个对象。转换按照以下规则进行： 1) 如果字符串包含多行，比如URL或插件URI，则将其视为窗口插件源（参见下面的 <code>src</code> 键）； 2) 否则将被视为<code>window</code>插件类型（参见下面的“type”键）。<br>它包含以下字段：</p><ul><li><code>name</code>：String。指定新窗口的名称。</li><li><p><code>type</code>：String。指定窗口类型。这可以是<code>window</code>插件名称、ImJoy内部窗口类型或<code>external</code>。以下内部窗口类型是支持的：</p><ul><li><code>imjoy/generic</code>。将显示 <code>data</code> 中的所有对象。</li><li><code>imjoy/image</code>。显示图像。需要<code>data.src</code> 指向图像位置。</li><li><code>imjoy/image-compare</code>。显示进行比较的两个图像。图像作为 <code>data.first</code> 和 <code>data.second</code> 传递。请参阅下面的示例。</li><li><code>imjoy/panel</code>。渲染<code>&lt;config&gt;</code> 块中的<code>ui</code>字段。 </li><li><code>imjoy/markdown</code>。渲染<code>data.source</code>中提供的Markdown文本。</li><li><code>imjoy/plugin-editor</code>。打开源代码编辑器。 <code>data.id</code>是一个唯一的字符串（最好是随机的），用来指定窗口的id，<code>data.code</code> 包含源代码。</li></ul><p>如果从外部url创建窗口，例如托管在Github页面上的Web应用程序。在这种情况下，需要使用 <code>src</code> 键指定url。有关如何从外部Web应用程序支持ImJoy的详细信息，请参见 <a href="https://github.com/imjoy-team/imjoy-core/">此处</a>。<br>如果外部网页加载了ImJoy 插件api，就可以像普通的 ImJoy 插件一样与外部网站进行交互。但是，如果外部网页不支持ImJoy，则需要设置<code>passive=true</code>来告诉ImJoy该窗口将没有插件api。</p></li><li><code>src</code>：String，指定窗口插件的源代码、窗口插件源代码的 url 或支持 <code>imjoy-rpc</code> 的网络应用程序的 url。如果 url 以 <code>.imjoy.html</code> 结尾、 或是<code>gist</code> url 或是github源代码页面 url，则该 url 将被视为源代码。创建窗口时可以传递源代码这就使得如下场景成为可能，例如将窗口插件的源代码存储在 Python 插件中，并在需要时实例化它。<ul><li>tag：String。如果插件支持多个<code>tags</code>，则与<code>src</code> 一起使用来指定插件的标签。</li><li>namespace：String。与 <code>src</code> 一起使用来指定插件的命名空间。</li><li>passive: Boolean，仅在指定了 <code>src</code> 时使用。标记插件是否为被动网页（没有暴露ImJoy api）。默认值为 <code>false</code>。</li><li>w：Integer。网格的窗口列宽（1 列 = 30 像素）。</li><li>h：Integer。网格的窗口行高（1 行 = 30 像素）。</li><li>config：Object对象（JavaScript）或字典（Python）。</li><li>data：Object对象 (JavaScript) 或字典 (Python)。包含要传输到窗口的数据。</li></ul></li></ul></li></ul><p>返回值：</p><ul><li>win：Object对象。创建的窗口的API对象。可以存储在插件类中（Python的<code>self</code>，或JavaScript的<code>this</code>）供以后使用，例如更新窗口。注意：如果<code>type=&quot;external&quot;</code>和<code>passive=true</code>，则窗口不会暴露api，此时<code>win</code>为空。</li></ul><p>例子：<br>用 JavaScript 创建一个简单的窗口：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">win = <span class="keyword">await</span> api.createWindow(&#123;<span class="attr">name</span>: <span class="string">&#x27;new window&#x27;</span>, <span class="attr">type</span>: <span class="string">&#x27;Image Window&#x27;</span>, <span class="attr">w</span>:<span class="number">7</span>, <span class="attr">h</span>:<span class="number">7</span>, <span class="attr">data</span>: &#123;<span class="attr">image</span>: ...&#125;, <span class="attr">config</span>: &#123;&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>用python实现的话，Python 3可以使用 <code>async/await</code> 风格：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">win = <span class="keyword">await</span> api.createWindow(name=<span class="string">&#x27;new window&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;Image Window&#x27;</span>, w=<span class="number">7</span>, h=<span class="number">7</span>, data=&#123;image: ...&#125;, config=&#123;&#125;)</span><br></pre></td></tr></table></figure><br>Python 2可以使用<code>callback</code> 风格：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">window_callback</span>(<span class="params">win</span>):</span></span><br><span class="line">    self.win = win</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;window created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">api.createWindow(&#123;name: <span class="string">&#x27;new window&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;Image Window&#x27;</span>, w:<span class="number">7</span>, h:<span class="number">7</span>, data: &#123;image: ...&#125;, config: &#123;&#125;&#125;).then(window_callback)</span><br></pre></td></tr></table></figure><br>然后使用返回的对象更新窗口，或者使用<code>win.on(&#39;close&#39;, callback)</code>来设置关闭窗口时的回调函数。类似地，<code>win.on(&#39;resize&#39;, callback)</code> 可用于设置窗口大小改变时的回调函数。<br>要关闭创建的窗口，则调用 <code>win.close()</code>。<br>要滚动ImJoy工作区中的窗口，调用“win.focus()”。<br>在<code>window</code>插件中，可以使用<code>this.close</code>、<code>this.on</code>、<code>this.emit</code>、<code>this.focus</code>、<code>this.resize</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// win is the object returned from api.createWindow</span></span><br><span class="line"><span class="keyword">await</span> win.run(&#123;<span class="string">&#x27;data&#x27;</span>: &#123;<span class="string">&#x27;image&#x27;</span>: ...&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// set `on-close` callback</span></span><br><span class="line">win.on(<span class="string">&#x27;close&#x27;</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;closing window.&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>创建一个包含两个图像和一个比较滑块的窗口。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">api.createWindow(&#123;</span><br><span class="line">  name: <span class="string">&#x27;test compare&#x27;</span>,</span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&#x27;imjoy/image-compare&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    first: <span class="string">&#x27;//placehold.it/350x150/0288D1/FFFFFF&#x27;</span>,</span><br><span class="line">    second: <span class="string">&#x27;//placehold.it/350x150/E8117F/FFFFFF&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>调用<code>win</code>对象：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># win 是 api.createWindow 返回的对象</span></span><br><span class="line"><span class="comment"># 作为字典传递</span></span><br><span class="line"><span class="keyword">await</span> win.run(&#123;<span class="string">&#x27;data&#x27;</span>: &#123;<span class="string">&#x27;image&#x27;</span>: ...&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或命名参数</span></span><br><span class="line"><span class="keyword">await</span> win.run(data=&#123;<span class="string">&#x27;image&#x27;</span>: ...&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置`on-close`回调</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">close_callback</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;closing window.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">win.on(<span class="string">&#x27;close&#x27;</span>, close_callback)</span><br></pre></td></tr></table></figure></p><h2 id="api-error"><a href="#api-error" class="headerlink" title="api.error"></a>api.error</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api.error(message)</span><br></pre></td></tr></table></figure><p>记录当前插件的错误消息，该消息存储在其日志历史记录中。<br>插件名称旁边的红色图标表明有错误存在。点击此图标将打开一个显示日志历史记录的窗口。<br>与 <code>console.error</code> 或 <code>print</code> 类似，<code>api.error</code> 可以接受多个参数，这些参数将通过空格连接。<br>参数：</p><ul><li>message：String。要记录的错误消息。</li></ul><p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api.error(<span class="string">&#x27;Error occurred during processing.&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h2 id="api-echo"><a href="#api-echo" class="headerlink" title="api.echo"></a>api.echo</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api.echo(obj)</span><br></pre></td></tr></table></figure><p>返回与传入对象相同值的函数，用于测试目的。<br>这对于测试编码/解码对象很有用。</p><p>参数：</p><ul><li>obj：任意值。</li></ul><p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ret = <span class="keyword">await</span> api.echo(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(ret) <span class="comment">// should get &#x27;hi&#x27;</span></span><br></pre></td></tr></table></figure></p><h2 id="api-registerCodec"><a href="#api-registerCodec" class="headerlink" title="api.registerCodec"></a>api.registerCodec</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api.registerCodec(config)</span><br></pre></td></tr></table></figure><p>注册用于发送和接收远程对象的自定义编解码器。<br>注意：<code>web-python</code> 插件尚不支持该api。<br>参数：</p><ul><li>config：Object对象（JavaScript）或字典（Python）。编解码器的选项。它包含以下字段：<ul><li>name：String。编解码器名称</li><li>type：Class。用于匹配对象进行编码的类对象。在Javascript中，<code>instanceof</code> 将用于匹配类型。在Python中将使用 <code>isinstance()</code>，这也意味着在 Python 中，<code>type</code> 可以是类的元组。</li><li>encoder：Function。<code>encoder</code>函数将一个对象作为输入，需要返回要表示的对象/字典。注意，只能在要表示的对象中使用原始类型加上数组/列表和对象/字典。默认情况下，如果返回的对象不包含<code>_rtype</code>键，则编解码器<code>name</code>将用作 <code>_rtype</code>。还可以指定不同的<code>_rtype</code>名称，以允许不同类型之间的转换。</li><li>decoder：Function。 <code>decoder</code> 函数将编码对象转换为实际对象。仅当对象的<code>_rtype</code>与编解码器的<code>name</code>匹配时才会调用它。</li></ul></li></ul><p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, color, age, clean</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.color = color</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">    <span class="built_in">this</span>.clean = clean</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">api.registerCodec(&#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;cat&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;type&#x27;</span>: Cat, </span><br><span class="line">    <span class="string">&#x27;encoder&#x27;</span>: <span class="function">(<span class="params">obj</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// convert the Cat instance as a dictionary with all the properties</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">name</span>: obj.name, <span class="attr">color</span>: obj.color, <span class="attr">age</span>: obj.age, <span class="attr">clean</span>: obj.clean&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;decoder&#x27;</span>: <span class="function">(<span class="params">encoded_obj</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// recover the Cat instance</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cat(encoded_obj.name, encoded_obj.color, encoded_obj.age, encoded_obj.clean)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plugin</span> </span>&#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> dirtyCat = <span class="keyword">new</span> Cat(<span class="string">&#x27;boboshu&#x27;</span>, <span class="string">&#x27;mixed&#x27;</span>, <span class="number">0.67</span>, <span class="literal">false</span>)</span><br><span class="line">        <span class="comment">// assuming we have a shower plugin</span></span><br><span class="line">        <span class="keyword">const</span> showerPlugin = <span class="keyword">await</span> api.getPlugin(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;catShower&#x27;</span>&#125;)</span><br><span class="line">        <span class="comment">// now pass a cat into the shower plugin, and we should get a clean cat, the name should be the same</span></span><br><span class="line">        <span class="comment">// note that the other plugin is running in another sandboxed iframe or in Python</span></span><br><span class="line">        <span class="comment">// because we have the cat codec registered, we can send the Cat object to the other plugin</span></span><br><span class="line">        <span class="comment">// Also notice that the other plugin should also define custom encoding decoding following the same representation</span></span><br><span class="line">        <span class="keyword">const</span> cleanCat = <span class="keyword">await</span> showerPlugin.wash(dirtyCat)</span><br><span class="line">        <span class="keyword">if</span>(cleanCat.clean) api.alert(cleanCat.name + <span class="string">&#x27; is clean.&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">api.export(<span class="keyword">new</span> Plugin())</span><br></pre></td></tr></table></figure></p><h2 id="api-disposeObject"><a href="#api-disposeObject" class="headerlink" title="api.disposeObject"></a>api.disposeObject</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api.disposeObject(obj)</span><br></pre></td></tr></table></figure><p>从其对象存储中删除远程对象，以便垃圾收集器可以回收它。<br>当不再需要远程对象时调用此函数很重要，否则，它将导致内存泄漏，因为对象将保留在其对象存储中。<br>参数：</p><ul><li>obj：对象。要删除的远程对象。</li></ul><h2 id="api-export"><a href="#api-export" class="headerlink" title="api.export"></a>api.export</h2><p>将插件定义的函数导出为<code>Plugin API</code>。每个imjoy插件都应该导出其插件api函数，除非 <code>&lt;config&gt;</code> 下的 <code>passive</code> 键设置为 <code>true</code>。<br><code>Plugin API</code> 可以导出为插件类或包含所有api功能的对象/字典：<br>（1）JavaScript类<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImJoyPlugin</span>()</span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">run</span>(<span class="params">ctx</span>)</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">api.export(<span class="keyword">new</span> ImJoyPlugin())</span><br></pre></td></tr></table></figure><br>（2）JavaScript函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">api.export(&#123;<span class="attr">setup</span>: setup, <span class="attr">run</span>: run&#125;)</span><br></pre></td></tr></table></figure><br>（3）Python类<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImJoyPlugin</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, ctx</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">api.export(ImJoyPlugin())</span><br></pre></td></tr></table></figure></p><p>（4）Python函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">ctx</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">api.export(&#123;<span class="string">&#x27;setup&#x27;</span>: setup, <span class="string">&#x27;run&#x27;</span>: run&#125;)</span><br></pre></td></tr></table></figure></p><p>该API调用对于每个ImJoy插件都是强制性的（通常作为插件脚本的最后一行）。<br><code>ImJoyPlugin</code> 实例的每个成员都将导出为 <code>Plugin API</code>，这意味着这些导出的函数可以被ImJoy主程序或其他插件调用，其他插件可使用<code>api.run</code> 或<code>api.call</code> 来调用插件的功能。<br>注意：只能导出具有原始类型的函数和变量（数字、字符串、布尔值）。如果变量或函数的名称以<code>_</code>开头，则表示它是内部变量或函数，不会被导出。<br>还有需要注意，在JavaScript中，<code>new</code> 关键字是创建一个类的实例，而在Python中没有<code>new</code>关键字。</p><h2 id="api-init"><a href="#api-init" class="headerlink" title="api.init"></a>api.init</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api.init(config)</span><br></pre></td></tr></table></figure><p>使用最小的插件接口和配置进行初始化。当不想导出任何插件api时，这可以用作 <code>api.export</code> 的快捷方式。<br>以Python为例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api.init(config)</span><br></pre></td></tr></table></figure><br>等价于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def setup():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">api.export(&#123;&quot;setup&quot;: setup&#125;, config)</span><br></pre></td></tr></table></figure></p><p>参数：</p><ul><li>config：Object，可选。插件的配置，包括所有配置字段，比如<code>name</code>、<code>type</code>等（完整列表可以在<a href="https://imjoy.io/docs/#/development?id=ltconfiggt-block">这里</a>） .</li></ul><h2 id="api-exportFile"><a href="#api-exportFile" class="headerlink" title="api.exportFile"></a>api.exportFile</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api.exportFile(file, name)</span><br></pre></td></tr></table></figure><p>触发从浏览器下载文件。<br>参数：</p><ul><li>file：文件、Blob 或字符串。要下载的文件对象。如果传递了一个字符串，它将被包装为一个文本文件。<br>返回值：</li><li>name：String。文件名。</li></ul><p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([<span class="string">&quot;Hello, world!&quot;</span>], &#123;<span class="attr">type</span>: <span class="string">&quot;text/plain;charset=utf-8&quot;</span>&#125;);</span><br><span class="line">api.exportFile(blob, <span class="string">&#x27;hello.txt&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h2 id="api-getAttachment"><a href="#api-getAttachment" class="headerlink" title="api.getAttachment"></a>api.getAttachment</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content = <span class="keyword">await</span> api.getAttachment(att_name)</span><br></pre></td></tr></table></figure><p>获得存储在插件文件的<code>&lt;attachment&gt;</code>块中的数据。<br>可以在<code>&lt;attachment&gt;</code>块中存储任何文本数据，例如base64编码的图像、代码和 json。<br>参数：</p><ul><li>att_name：String。附件的标识符。<br>返回值：</li><li>content：存储在<code>&lt;attachment&gt;</code>块中的文本内容。</li></ul><p>例子：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">attachment</span> <span class="attr">name</span>=<span class="string">&quot;att_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">attachment</span>&gt;</span></span><br></pre></td></tr></table></figure><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content = <span class="keyword">await</span> api.getAttachment(att_name)</span><br></pre></td></tr></table></figure></p><h2 id="api-getConfig"><a href="#api-getConfig" class="headerlink" title="api.getConfig"></a>api.getConfig</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config_value = <span class="keyword">await</span> api.getConfig(config_name)</span><br></pre></td></tr></table></figure><p>获得插件的配置。<br>注1：使用 <code>api.setConfig</code> 保存时，数字会转换为字符串。在使用它们之前必须将它们转换回数字（在JavaScript中使用 <code>parseInt()</code> 或 <code>parseFloat()</code>，在Python中使用 <code>int()</code> 或 <code>float()</code>）。<br>注2：也可以通过在字段名后加上<code>_</code>来访问<code>&lt;config&gt;</code>块中定义的字段，例如，如果想读取<code>&lt;config&gt;</code> 块，可以使用 <code>plugin_name = await api.getConfig(&#39;_name&#39;)</code>。<br>参数：</p><ul><li>param_name：String。参数名称。<br>返回值：</li><li>param：String。返回的参数值。注意，数字也将作为字符串返回。</li></ul><p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sigma = <span class="keyword">await</span> api.getConfig(<span class="string">&#x27;sigma&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h2 id="api-installPlugin"><a href="#api-installPlugin" class="headerlink" title="api.installPlugin"></a>api.installPlugin</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugin = <span class="keyword">await</span> api.installPlugin(config)</span><br></pre></td></tr></table></figure><p>通过传递插件URI或源代码来安装插件，插件源代码将保存到浏览器数据库（在当前工作区中）。<br>参数：</p><ul><li>config：Object。配置对象。目前，可以传递以下配置：<ul><li><code>src</code>：String。要安装的插件的源代码、URI。</li><li><code>tag</code>：String，可选。如果插件有多个标签，则选择插件标签。</li><li><code>namespace</code>：String，可选。插件的命名空间。</li></ul></li></ul><p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> api.installPlugin(&#123;<span class="attr">uri</span>: <span class="string">&quot;https://raw.githubusercontent.com/imjoy-team/imjoy-core/master/src/plugins/webWorkerTemplate.imjoy.html&quot;</span>&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="api-uninstallPlugin"><a href="#api-uninstallPlugin" class="headerlink" title="api.uninstallPlugin"></a>api.uninstallPlugin</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugin = <span class="keyword">await</span> api.uninstallPlugin(config)</span><br></pre></td></tr></table></figure><p>卸载已安装的插件。<br>参数：</p><ul><li>config：Object。配置对象。目前，可以传递以下配置：<ul><li><code>name</code>：String。要卸载的插件的名称。</li><li><code>namespace</code>：String，插件的命名空间（注意，目前尚不支持该参数，但后面会支持）。</li></ul></li></ul><p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> api.uninstallPlugin(&#123;<span class="attr">name</span>: <span class="string">&quot;MyAwesomePlugin&quot;</span>&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="api-getPlugin"><a href="#api-getPlugin" class="headerlink" title="api.getPlugin"></a>api.getPlugin</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugin = <span class="keyword">await</span> api.getPlugin(config)</span><br></pre></td></tr></table></figure><p>通过id或名称获取已加载插件的API对象。插件必须已经加载到工作区中。<br>注1：如果插件被终止并且尝试调用其函数，则将收到错误消息。对此的一种解决方案是使用<code>try ... catch</code>(JavaScript) 或<code>try: ... except: ...</code>(Python)语句来捕获错误。<br>注2：关于<code>api.getPlugin</code>和<code>api.call</code>，如果想不断访问另一个插件的不同功能，最好使用<code>api.getPlugin</code>来获取该插件的所有API，然后可以通过返回的对象访问它们。如果只偶尔访问另一个插件中的API函数，则也可以使用<code>api.call</code>。</p><p>参数：</p><ul><li>config：String或Object。如果是一个字符串String，那么其应该是插件的名称，否则，可以传递一个包含键<code>id</code>或<code>name</code>的对象。<br>目前，可以传递以下配置：<ul><li>name：String。插件名称。</li><li>id：String。插件的id。</li></ul></li></ul><p>返回值：</p><ul><li>plugin：对象。可用于访问插件 API 函数的对象。</li></ul><p>例子：<br>获取插件<code>PluginX</code>的API，并访问其功能：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pluginX = <span class="keyword">await</span> api.getPlugin(<span class="string">&quot;PluginX&quot;</span>)</span><br><span class="line">result = <span class="keyword">await</span> pluginX.run()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Assuming that PluginX defined an API function `funcX`, you can access it with:</span></span><br><span class="line"><span class="keyword">await</span> pluginX.funcX()</span><br></pre></td></tr></table></figure></p><h2 id="api-loadPlugin"><a href="#api-loadPlugin" class="headerlink" title="api.loadPlugin"></a>api.loadPlugin</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugin = <span class="keyword">await</span> api.getPlugin(config)</span><br></pre></td></tr></table></figure><p>从源代码或URL加载插件，然后返回插件API对象。<br>参数：</p><ul><li>config：字符串或对象。获取插件的配置。如果它是一个字符串，那么根据字符串的内容，它将被转换为一个配置对象。转换按照以下规则进行： 1) 如果字符串包含多行，是URL或插件URI，则将其视为插件源（请参阅下面的 <code>src</code> 键）； 2) 否则将被视为插件名称并返回与<code>api.getPlugin</code> 相同的结果。目前，可以传递以下配置：<ul><li>src：字符串。插件的URL或源代码，在这种情况下，它将即时实例化。通过传递源代码，它可以灵活地将一个或多个插件源代码嵌入到另一个插件中。例如，一个Python插件可以动态填充一个HTML格式的<code>window</code>插件。</li><li>tag：字符串，可选。如果插件支持多个<code>tags</code>，则指定插件的标签，仅在<code>src</code>为插件源代码时使用。</li><li>namespace：字符串，可选。指定插件的命名空间，仅在<code>src</code>为插件源代码时使用。</li><li>engine_mode：字符串，可选。 仅适用于通过插件引擎运行的插件。选择默认引擎模式，它可以是 <code>auto</code> 或引擎 URL（例如：<code>https://mybinder.org</code>）。</li></ul></li></ul><p>返回值：</p><ul><li>plugin：Object对象。可用于访问插件API函数的对象。</li></ul><p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pokemonChooser = <span class="keyword">await</span> api.loadPlugin(&#123;<span class="attr">src</span>: <span class="string">&quot;https://gist.github.com/oeway/3c2e1ee72c79a6aafd9d6e3b473f0bbf&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> pokemonChooser.choosePokemon()</span><br></pre></td></tr></table></figure></p><h2 id="api-getServices"><a href="#api-getServices" class="headerlink" title="api.getServices"></a>api.getServices</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services = <span class="keyword">await</span> api.getServices(config)</span><br></pre></td></tr></table></figure><p>通过指定插件服务的<code>name</code>、<code>type</code>、<code>id</code> 等，获取插件服务列表（使用<code>api.registerService()</code> 注册）。<br>参数：</p><ul><li>config：Object对象。它是一个查询对象，由几个字段（至少一个）组成：<ul><li><code>id</code>：字符串。服务的ID（如果匹配，将返回一个包含一个元素的列表）。</li><li><code>name</code>：字符串。服务的名称。</li><li><code>type</code>：字符串。服务类型。</li><li>在服务api中定义的任何其他键。</li></ul></li></ul><p>返回值：</p><ul><li>services：Object对象。服务api或对象的列表。</li></ul><p>例子：<br>获取所有使用 <code>type=&quot;@model&quot;</code> 注册的插件服务：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> models = <span class="keyword">await</span> api.getServices(&#123;<span class="attr">type</span>: <span class="string">&quot;@model&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(models)</span><br></pre></td></tr></table></figure></p><h2 id="api-getWindow"><a href="#api-getWindow" class="headerlink" title="api.getWindow"></a>api.getWindow</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w = <span class="keyword">await</span> api.getWindow(config)</span><br></pre></td></tr></table></figure><p>通过窗口的<code>id</code>、<code>window_id</code>、<code>name</code>或<code>type</code>获取现有窗口。<br>参数：</p><ul><li>config：字符串或对象。它可以是一个窗口名称字符串，也可以是一个由几个字段（至少一个）组成的对象：<ul><li><code>name</code>：字符串。窗口名称。</li><li><code>type</code>：字符串。窗口的类型。</li><li><code>window_id</code>：字符串。窗口的id。</li><li><code>plugin_id</code>：字符串。附加到窗口的插件实例的id。</li></ul></li></ul><p>返回值</p><ul><li>w：对象。可用于访问窗口API函数的窗口对象。</li></ul><p>例子：<br>获取现有的<a href="https://kaibu.org">Kaibu</a> 窗口并访问它。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> createWindow(&#123;<span class="attr">name</span>: <span class="string">&quot;My Kaibu Window&quot;</span>, <span class="attr">src</span>: <span class="string">&quot;https://kaibu.org&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">w = <span class="keyword">await</span> api.getWindow(<span class="string">&quot;My Kaibu Window&quot;</span>)</span><br><span class="line"><span class="keyword">await</span> w.open(<span class="string">&quot;https://imjoy.io/static/img/imjoy-icon.png&quot;</span>)</span><br></pre></td></tr></table></figure></p><h2 id="api-getEngine"><a href="#api-getEngine" class="headerlink" title="api.getEngine"></a>api.getEngine</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">engine = <span class="keyword">await</span> api.getEngine(engine_url)</span><br></pre></td></tr></table></figure><p>获取插件引擎的API对象。<br>参数：</p><ul><li>engine_url：字符串。插件引擎的URL。</li></ul><p>返回值：</p><ul><li>engine：对象。可用于访问引擎API函数的引擎对象。</li></ul><p>例子：<br>获取引擎的API（url = <code>https://127.0.0.1:2957</code>），并访问其功能：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">engine = <span class="keyword">await</span> api.getEngine(<span class="string">&quot;https://127.0.0.1:2957&quot;</span>)</span><br><span class="line"><span class="keyword">await</span> engine.disconnect()</span><br></pre></td></tr></table></figure></p><h2 id="api-getEngineFactory"><a href="#api-getEngineFactory" class="headerlink" title="api.getEngineFactory"></a>api.getEngineFactory</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">engine_factory = <span class="keyword">await</span> api.getEngineFactory(engine_factory_name)</span><br></pre></td></tr></table></figure><p>获取插件引擎工厂的API对象。<br>参数：</p><ul><li>engine_factory_name：字符串。插件引擎工厂的名称。<br>返回值：</li><li>engine_factory：对象。一个插件引擎工厂对象，可用于访问引擎 API 函数。</li></ul><p>例子：<br>获取插件引擎工厂的API（name = <code>ImJoy-Engine</code>），并访问其功能：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">engine_factory = <span class="keyword">await</span> api.getEngineFactory(<span class="string">&quot;ImJoy-Engine&quot;</span>)</span><br><span class="line"><span class="keyword">await</span> engine_factory.addEngine(config)</span><br></pre></td></tr></table></figure></p><h2 id="api-getFileManager"><a href="#api-getFileManager" class="headerlink" title="api.getFileManager"></a>api.getFileManager</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_manager = <span class="keyword">await</span> api.getFileManager(file_manager_url)</span><br></pre></td></tr></table></figure><p>获取文件管理器的API对象。<br>注意：自从<code>api_version &gt; 0.1.6</code>，<code>api.getFileUrl</code> 和<code>api.requestUploadUrl</code> 已弃用，替换方案是先使用<code>api.getFileManager</code> 获取文件管理器，然后从返回的文件管理器对象中访问<code>getFileUrl</code> 和<code>requestUploadUrl</code>。<br>参数：</p><ul><li>file_manager_url：字符串。文件管理器的 URL。</li></ul><p>返回值：</p><ul><li>file_manager：对象。可用于访问文件管理器 API 函数的文件管理器对象。</li></ul><p>例子：<br>获取文件管理器的API（url = <code>https://127.0.0.1:2957</code>），并访问其功能：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file_manager = <span class="keyword">await</span> api.getFileManager(<span class="string">&quot;https://127.0.0.1:2957&quot;</span>)</span><br><span class="line"><span class="keyword">await</span> file_manager.listFiles()</span><br></pre></td></tr></table></figure><br>获取下载文件地址：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file_manager = <span class="keyword">await</span> api.getFileManager(<span class="string">&quot;https://127.0.0.1:2957&quot;</span>)</span><br><span class="line"><span class="keyword">await</span> file_manager.getFileUrl(&#123;<span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;./data/output.png&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><br>如果要获取当前文件的文件URL：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from imjoy import api</span><br><span class="line"></span><br><span class="line">class ImJoyPlugin():</span><br><span class="line">    def setup(self):</span><br><span class="line">        api.log(&#39;initialized&#39;)</span><br><span class="line"></span><br><span class="line">    async def run(self, ctx):</span><br><span class="line">        file_manager &#x3D; await api.getFileManager(api.config.file_manager)</span><br><span class="line">        url &#x3D; await file_manager.getFileUrl(&#123;&quot;path&quot;: &#39;.&#x2F;screenshot-imjoy-notebook.png&#39;&#125;)</span><br><span class="line">        await api.alert(url)</span><br><span class="line"></span><br><span class="line">api.export(ImJoyPlugin())</span><br></pre></td></tr></table></figure></p><p>用于上传的文件URL请求：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file_manager = <span class="keyword">await</span> api.getFileManager(<span class="string">&quot;https://127.0.0.1:2957&quot;</span>)</span><br><span class="line"><span class="keyword">await</span> file_manager.requestUploadUrl(&#123;<span class="string">&#x27;path&#x27;</span>: <span class="string">&#x27;./data/input.png&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="api-log"><a href="#api-log" class="headerlink" title="api.log"></a>api.log</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api.log(message)</span><br></pre></td></tr></table></figure><p>记录当前插件的状态消息，该消息存储在其日志历史记录中。<br>插件名旁边的灰色图标表明该状态的存在，点击此图标将打开一个窗口，显示历史记录的消息。<br>状态消息可以是字符串或图像。后者可用于创建自动日志，例如，记录神经网络的训练。<br>与 <code>console.log</code> 或 <code>print</code> 类似，<code>api.log</code> 可以接受多个参数，这些参数将通过空格连接。</p><p>参数：</p><ul><li>message：字符串。要记录的消息</li></ul><p>例子:<br>创建一个简单的文本消息：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api.log(<span class="string">&#x27;Processing data ...&#x27;</span>)</span><br></pre></td></tr></table></figure><br>记录一个图像文件。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api.log(&#123;<span class="attr">type</span>: <span class="string">&#x27;image&#x27;</span>, <span class="attr">value</span>: <span class="string">&#x27;https://imjoy.io/static/img/imjoy-icon.png&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure></p><h2 id="api-progress"><a href="#api-progress" class="headerlink" title="api.progress"></a>api.progress</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api.progress(progress)</span><br></pre></td></tr></table></figure><p>更新当前插件的进度条。<br>此进度条将显示在插件菜单本身中。使用<code>api.showProgress</code> 为ImJoy状态栏生成进度条。<br>参数：</p><ul><li>progress：浮点数或整数。进度百分比。整数的允许范围为 0 到 100，浮点数的范围为 0 到 1。</li></ul><p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api.progress(<span class="number">85</span>)</span><br></pre></td></tr></table></figure></p><h2 id="api-registerService"><a href="#api-registerService" class="headerlink" title="api.registerService"></a>api.registerService</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> service_id = <span class="keyword">await</span> api.registerService(config)</span><br></pre></td></tr></table></figure><p>注册一个插件服务。<br>参数：</p><ul><li>config：对象（JavaScript）或字典（Python）。它必须至少包含一个 <code>type</code> 键和一个 <code>name</code> 键。其他键取决于相应的类型定义（见下文）。</li></ul><p>返回值：</p><ul><li>service_id：字符串。该服务的id可用于获取或取消注册服务。</li></ul><h3 id="内置插件服务"><a href="#内置插件服务" class="headerlink" title="内置插件服务"></a>内置插件服务</h3><p>operator service (type=<code>operator</code>) 是一种内置服务，用于扩展插件菜单以执行特定任务。<br>对于服务的<code>config</code>，允许几个字段：</p><ul><li><code>name</code>：字符串。操作<code>op</code>名称。</li><li><code>ui</code>：对象（JavaScript）或字典（Python）。渲染界面。与 <code>&lt;config&gt;</code> 中的 <code>ui</code> 字段具有相同的定义规则。</li><li><code>run</code>：函数，可选。指定当<code>op</code>运行时所执行的 <code>Plugin API</code> 函数。注意，它必须是使用 <code>api.export</code> 导出的插件类的成员或函数。如果未指定，将执行插件的 <code>run</code> 函数。</li><li><code>update</code>：字符串，可选。指定当<code>ui</code>字段中的任何选项发生更改时将运行的<code>Plugin API</code>函数。</li><li><code>inputs</code>：对象，可选。 定义此<code>op</code>的输入，格式为<a href="https://json-schema.org/">JSON Schema</a>。</li><li><code>outputs</code>：对象，可选。定义此<code>op</code>的输出，格式为<a href="https://json-schema.org/">JSON Schema</a>。</li></ul><p>（另外参阅上面的[输入参数]一节了解如何设置参数。）<br><code>op</code>可以有自己的 GUI，由 <code>ui</code> 字符串定义。默认情况下，插件的所有操作都会调用插件的<code>run</code>函数。可以在<code>run</code>函数中使用 <code>ctx.config.type</code> 来区分调用了哪个操作。<br>如果想动态改变界面，可以运行<code>api.registerService</code>多次覆盖以前的版本。 <code>api.registerService</code> 也可以用于覆盖 <code>&lt;config&gt;</code> 中定义的插件的默认<code>ui</code>字符串，只需将插件名称设置为<code>op</code>名称（或不设置名称）。</p><p>例子：<br>注册一个新的插件操作符：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript</span></span><br><span class="line"><span class="keyword">await</span> api.registerService(&#123;</span><br><span class="line">     <span class="string">&quot;type&quot;</span>: <span class="string">&quot;operator&quot;</span>,</span><br><span class="line">     <span class="string">&quot;name&quot;</span>: <span class="string">&quot;LUT&quot;</span>,</span><br><span class="line">     <span class="string">&quot;ui&quot;</span>: [&#123;</span><br><span class="line">        <span class="string">&quot;apply LUT&quot;</span>: &#123;</span><br><span class="line">            id: <span class="string">&#x27;lut&#x27;</span>,</span><br><span class="line">            type: <span class="string">&#x27;choose&#x27;</span>,</span><br><span class="line">            options: [<span class="string">&#x27;hot&#x27;</span>, <span class="string">&#x27;rainbow&#x27;</span>],</span><br><span class="line">            placeholder: <span class="string">&#x27;hot&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;],</span><br><span class="line">      <span class="string">&quot;run&quot;</span>: <span class="built_in">this</span>.apply_lut,</span><br><span class="line">      <span class="string">&quot;update&quot;</span>: <span class="built_in">this</span>.update_lut</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="开发者贡献的插件服务"><a href="#开发者贡献的插件服务" class="headerlink" title="开发者贡献的插件服务"></a>开发者贡献的插件服务</h3><p>可以使用以下服务类型的插件服务：</p><ul><li>type=<code>@transformation</code>：<a href="https://scikit-learn.org/stable/data_transforms.html">scikit-learn兼容数据集转换</a><ul><li><code>transform(data)</code>: 将此转换模型应用于未见过的数据</li><li><code>fit(data)</code>：从数据中学习模型参数</li><li><code>fit_transform(data)</code>：同时建模和转换训练数据</li></ul></li><li>type=<code>@model</code>: keras 兼容模型服务<ul><li><code>predict(data)</code>：对数据进行预测（见<a href="https://keras.io/api/models/model_training_apis/#predict-method">这里</a>）</li><li><code>fit(data)</code>：在数据上训练模型（参见 <a href="https://keras.io/api/models/model_training_apis/#fit-method">此处</a>）</li></ul></li><li>还可以贡献自己的服务类型</li></ul><h3 id="定义一个新的插件服务类型"><a href="#定义一个新的插件服务类型" class="headerlink" title="定义一个新的插件服务类型"></a>定义一个新的插件服务类型</h3><p>如果内置和开发者贡献的服务类型都不能满足要求，还可以定义一个新的插件服务类型。最简单的方法是从定义自定义类型开始，例如：<code>api.registerService(&#123;&quot;type&quot;: &quot;my-awesome-service&quot;, ...&#125;)</code>。可以使用它来开发和测试服务。一旦服务类型定义稳定可用了，可以在服务类型名称中添加一个 <code>@</code> 并将该类型提交到 imjoy-core 存储库。<br>以下是提交类型定义的步骤：</p><ol><li>fork<a href="https://github.com/imjoy-team/imjoy-core">imjoy-core repo</a></li><li>编辑<a href="https://github.com/imjoy-team/imjoy-core/blob/master/docs/api.md">本页</a> 将新类型添加到上面的列表中，并提供详细说明</li><li>在 <a href="https://github.com/imjoy-team/imjoy-core/blob/master/src/serviceSpec.js">serviceSpec.js</a> 文件中定义模板。</li><li>向<a href="https://github.com/imjoy-team/imjoy-core">imjoy-core repo</a>提交PR。</li></ol><h2 id="api-run"><a href="#api-run" class="headerlink" title="api.run"></a>api.run</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> api.run(plugin_name)</span><br></pre></td></tr></table></figure><p>通过指定其名称运行另一个插件。<br>也可以传递<code>ctx</code>到这个插件中以传输数据。<br>参数：</p><ul><li>plugin_name：字符串。插件名称。</li></ul><p>例子：<br>调用一个插件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> api.run(<span class="string">&quot;Python Demo Plugin&quot;</span>)</span><br></pre></td></tr></table></figure></p><p>下面是两个插件并发执行的例子，其中两个插件是同时执行，但ImJoy一个接一个地等待结果。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python</span></span><br><span class="line">p1 = api.run(<span class="string">&quot;name of plugin 1&quot;</span>)</span><br><span class="line">p2 = api.run(<span class="string">&quot;name of plugin 2&quot;</span>)</span><br><span class="line"></span><br><span class="line">result1 = <span class="keyword">await</span> p1</span><br><span class="line">result2 = <span class="keyword">await</span> p2</span><br></pre></td></tr></table></figure><br>这也可以通过Python中的 <code>asyncio.gather</code> 来实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p1 = api.run(<span class="string">&quot;name of plugin 1&quot;</span>)</span><br><span class="line">p2 = api.run(<span class="string">&quot;name of plugin 2&quot;</span>)</span><br><span class="line">result1, result2 = <span class="keyword">await</span> asyncio.gather(p1, p2)</span><br></pre></td></tr></table></figure><br>如果用JavaScript写上面的例子，可以使用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = api.run(<span class="string">&quot;name of plugin 1&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> p2 = api.run(<span class="string">&quot;name of plugin 2&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> [result1, result2] = [<span class="keyword">await</span> p1, <span class="keyword">await</span> p2]</span><br></pre></td></tr></table></figure><br>而两个插件顺序执行的例子如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result1 = <span class="keyword">await</span> api.run(<span class="string">&quot;name of plugin 1&quot;</span>)</span><br><span class="line">result2 = <span class="keyword">await</span> api.run(<span class="string">&quot;name of plugin 2&quot;</span>)</span><br></pre></td></tr></table></figure></p><h2 id="api-setConfig"><a href="#api-setConfig" class="headerlink" title="api.setConfig"></a>api.setConfig</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api.setConfig(config_name, config_value)</span><br></pre></td></tr></table></figure><p>将插件数据存储在其配置中。<br>当ImJoy重新启动时，可以获得这些值。此功能非常适合存储和重新加载设置。但是，该函数旨在存储少量数据，而不是大型对象。当前的实现是使用<code>localStorage</code> 进行存储。大多数浏览器只允许ImJoy自身及所有插件一共使用5MB数据存储。<br>要删除一个参数，将其值设置为 <code>null</code> (JavaScript) 或 <code>None</code> (Python)。<br>参数：</p><ul><li>config<em>name：字符串。参数名称。不要使用以`</em><code>开头、且后跟</code><config>` 块的任何字段名称这样的名字。</li><li>config_value：数字或字符串。既不是对象/数组（JS）也不是字典/列表（Python）。请注意，数字被存储为字符串。</li></ul><p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api.setConfig(<span class="string">&#x27;sigma&#x27;</span>, <span class="number">928</span>)</span><br></pre></td></tr></table></figure></p><h2 id="api-showDialog"><a href="#api-showDialog" class="headerlink" title="api.showDialog"></a>api.showDialog</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">answer = <span class="keyword">await</span> api.showDialog(config)</span><br></pre></td></tr></table></figure><p>将窗口或自定义 GUI 显示为对话框。<br>类似于<code>api.createWindow</code>，可以传递一个对象<code>&#123;&quot;type&quot;: &quot;WINDOW_PLUGIN_NAME&quot;, &quot;name&quot;: &quot;new dialog&quot;, &quot;config&quot;: &#123;...&#125;, &quot;data&quot;: &#123;... &#125;&#125;</code>。这会将窗口插件实例显示为对话框。该对话框可以通过<code>win.close()</code>以编程方式关闭，也可以由用户使用关闭按钮关闭。<br>对于带有joy ui的简单对话框，可以传递<code>&#123;&quot;type&quot;: &quot;joy&quot;, &quot;name&quot;: &quot;new dialog&quot;, &quot;config&quot;: &#123;...&#125;, &quot;data&quot;: &#123;...&#125;&#125;</code>。对话框的回答将存储在返回的对象中，可以使用指定的<code>id</code>获得。当考虑用户按下<code>cancel</code>的情况，可以使用<code>try catch</code>（JavaScript）或<code>try except</code>（Python）语法。<br>参数：</p><ul><li>config：对象 (JavaScript) 或字典 (Python)。定义对话框。包含以下字段：<ul><li><code>name</code>：字符串。对话框的标题。</li><li><code>type</code>：字符串。对话框的类型（使用<code>window</code>插件名称或<code>joy</code>）。如果<code>type=&quot;joy&quot;</code>，则需要提供<code>ui</code>，它的定义与<code>&lt;config&gt;</code> 中的<code>ui</code> 字段相同。否则，需要为 <code>api.createWindow</code>提供 <code>config</code> 和 <code>data</code>。</li></ul></li></ul><p>返回值：</p><ul><li>answer。对象 (JavaScript) 或字典 (Python)。通过字段<code>answer[id]</code>包含对话框的答案。</li></ul><p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="keyword">await</span> api.showDialog(&#123;</span><br><span class="line">   <span class="string">&quot;name&quot;</span>: <span class="string">&quot;This is a dialog&quot;</span>,</span><br><span class="line">   <span class="string">&quot;ui&quot;</span>: <span class="string">&quot;Hey, please select a value for sigma: &#123;id:&#x27;sigma&#x27;, type:&#x27;choose&#x27;, options:[&#x27;1&#x27;, &#x27;3&#x27;], placeholder: &#x27;1&#x27;&#125;.&quot;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="api-showFileDialog"><a href="#api-showFileDialog" class="headerlink" title="api.showFileDialog"></a>api.showFileDialog</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = <span class="keyword">await</span> api.showFileDialog(config)</span><br></pre></td></tr></table></figure><p>显示一个文件对话框来选择文件或目录。<br>该函数将返回一个<code>promise</code>，可以从中获取文件路径的字符串。<br>根据插件引擎的实现，ImJoy将尝试通过<code>api.config.file_manager</code> 选择插件引擎指定的文件管理器。<br>ImJoy主程序和插件引擎的文件处理是不同的。<br>注意，JavaScript插件的文件路径作为url返回，而对于Python插件，它将是绝对文件路径。对于JavaScript插件，需要url格式来打开文件 。可以使用<code>uri_type</code> 选项（见下文）来改变此行为。例如，对于JavaScript插件也可以获取绝对路径。但是，不能使用此路径打开文件JavaScript，但可以将其传递给另一个Python插件进行处理。</p><p>参数：</p><ul><li>config：对象 (JavaScript) 或字典 (Python)。显示文件对话框的选项。它包含以下字段：</li></ul><ul><li>type：字符串。支持的文件对话框模式：<ul><li><code>file</code>（默认）：选择一个或多个文件；</li><li><code>directory</code>：选择一个或多个目录。对于Python插件，如果不指定类型，文件或目录都可以选择。</li></ul></li><li>title：字符串。对话框的标题。</li><li>root：字符串。显示对话框的初始路径。注意：对于Windows上的Python插件，可能希望使用 <code>r&quot;xxxxxx&quot;</code> 语法将路径字符串定义为原始字符串，因为有可能遇到无法识别普通字符串的路径问题。</li><li>mode：字符串。文件选择模式。默认情况下，用户可以选择单个或多个文件（按下 <code>shift</code> 键）<ul><li><code>single</code>：只能选择单个文件或目录。</li><li><code>multiple</code>：选择多个文件或目录，并以数组或列表的形式返回。</li><li><code>single|multiple</code>（默认）：允许单选和多选。</li></ul></li><li>file_manager：字符串。通过url指定文件管理器，例如在<code>native-python</code>插件中，可以通过<code>api.config.file_manager</code>获取文件管理器的URL。</li></ul><p>返回值：</p><ul><li>selected：对象数组 (JavaScript) 或字典 (Python)。它可以包含 0 到多个选定的文件/目录。如果返回的数组为空，则表示用户没有选择任何文件/目录。数组中的文件项通常包含（取决于不同的文件管理器实现）：<ul><li>path：字符串。文件路径。</li><li>url：字符串。文件的URL。</li><li>其他字段。</li></ul></li></ul><p>例子：<br>以下示例将显示指定的文件名或用户取消或插件引擎未运行的消息。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> selected = <span class="keyword">await</span> api.showFileDialog()</span><br><span class="line"><span class="keyword">if</span>(selected.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">await</span> api.alert(<span class="string">&quot;Selected file &quot;</span> + selected[<span class="number">0</span>].url)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">await</span> api.alert(<span class="string">&quot;User cancelled file selection.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="api-showMessage"><a href="#api-showMessage" class="headerlink" title="api.showMessage"></a>api.showMessage</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api.showMessage(message,duration)</span><br></pre></td></tr></table></figure><p>更新ImJoy状态栏上的状态文本并显示一个带有相应消息的快速弹出栏。<br>如果未指定持续时间，则快速弹出栏将显示 10 秒。<br>参数：</p><ul><li>message：字符串。要显示的消息。</li><li>duration（可选）：整数。显示消息的持续时间（以秒为单位）。</li></ul><p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api.showMessage(<span class="string">&#x27;Processing...&#x27;</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure></p><h2 id="api-showProgress"><a href="#api-showProgress" class="headerlink" title="api.showProgress"></a>api.showProgress</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api.showProgress(progress)</span><br></pre></td></tr></table></figure><p>更新Imjoy GUI 的进度条。<br>参数：</p><ul><li>progress：浮点数或整数。进度百分比。整数的允许范围为 0 到 100，浮点数的范围为 0 到 1。</li></ul><p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api.showProgress(<span class="number">85</span>)</span><br></pre></td></tr></table></figure></p><h2 id="api-showSnackbar"><a href="#api-showSnackbar" class="headerlink" title="api.showSnackbar"></a>api.showSnackbar</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api.showSnackbar(message, duration)</span><br></pre></td></tr></table></figure><p>显示一个带有消息的快速弹出栏，并在特定时间段内消失。</p><p>参数：</p><ul><li>message：字符串。要显示的消息。</li><li>duration：整数。将显示以秒为单位的持续时间消息。</li></ul><p>例子:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api.showSnackbar(<span class="string">&#x27;processing...&#x27;</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure></p><h2 id="api-showStatus"><a href="#api-showStatus" class="headerlink" title="api.showStatus"></a>api.showStatus</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api.showStatus(status)</span><br></pre></td></tr></table></figure><p>更新Imjoy GUI上的状态文本。<br>参数:</p><ul><li>status：字符串。要显示的消息。</li></ul><p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> api.showStatus(<span class="string">&#x27;processing...&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h2 id="api-TAG"><a href="#api-TAG" class="headerlink" title="api.TAG"></a>api.TAG</h2><p>这是一个常量，是用户在安装过程中选择的当前标签。</p><h2 id="api-unregisterService"><a href="#api-unregisterService" class="headerlink" title="api.unregisterService"></a>api.unregisterService</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> api.unregisterService(config)</span><br></pre></td></tr></table></figure><p>取消注册插件服务。<br>参数：</p><ul><li>config：对象。它必须包含插件服务的<code>id</code>。</li></ul><p>例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sid = <span class="keyword">await</span> api.registerService(&#123;<span class="attr">type</span>: <span class="string">&#x27;my-service&#x27;</span>, <span class="attr">my_data</span>: <span class="number">123</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> api.unregisterService(&#123;<span class="attr">id</span>: sid&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="api-utils"><a href="#api-utils" class="headerlink" title="api.utils.*"></a>api.utils.*</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> api.utils.UTILITY_NAME()</span><br></pre></td></tr></table></figure><p>调用效用函数。<br>目前所有插件都支持的功能是：</p><ul><li><code>api.utils.$forceUpdate()</code>：手动刷新 GUI。</li><li><code>api.utils.openUrl(url)</code>：在新的浏览器选项卡中打开一个 <code>url</code>。</li><li><code>api.utils.sleep(duration)</code>：以秒为单位休眠指定的<code>duration</code>。注意对于Python插件，请用 <code>time.sleep</code>。</li><li><code>api.utils.showOpenFilePicker</code>：仅适用于 Chrome 86+，弹出一个对话框，用于使用 <a href="https://web.dev/file-system-access/">文件系统访问</a> API打开文件</li><li><code>api.utils.showSaveFilePicker</code>：仅适用于 Chrome 86+，弹出一个对话框用于使用 <a href="https://web.dev/file-system-access/">文件系统访问</a> API保存文件</li><li><code>api.utils.showDirectoryPicker</code>: 仅适用于 Chrome 86+，弹出一个对话框用于选择具有<a href="https://web.dev/file-system-access/">文件系统访问</a> API的目录</li></ul><h2 id="api-config"><a href="#api-config" class="headerlink" title="api.config"></a>api.config</h2><p>配置信息包括：</p><ul><li><code>workspace</code>：当前工作区。</li><li><code>engine</code>：当前插件引擎的 URL，仅适用于原生 python 插件。</li><li><code>file_manager</code>：当前插件引擎注册的文件管理器的 URL，仅适用于原生 python 插件。</li></ul><h2 id="api-WORKSPACE"><a href="#api-WORKSPACE" class="headerlink" title="api.WORKSPACE"></a>api.WORKSPACE</h2><p><strong>已弃用！</strong> 使用 <code>api.config.workspace</code> 代替<br>当前工作区的名称。</p><h2 id="api-ENGINE-URL"><a href="#api-ENGINE-URL" class="headerlink" title="api.ENGINE_URL"></a>api.ENGINE_URL</h2><p><strong>已弃用！</strong> 使用 <code>api.config.engine</code> 代替<br><strong>仅适用于原生 python 插件</strong><br>当前插件引擎的 URL。</p><h2 id="api-FILE-MANAGER-URL"><a href="#api-FILE-MANAGER-URL" class="headerlink" title="api.FILE_MANAGER_URL"></a>api.FILE_MANAGER_URL</h2><p><strong>已弃用！</strong> 使用 <code>api.config.file_manager</code> 代替<br><strong>仅适用于原生 python 插件</strong><br>当前插件引擎注册的文件管理器的 URL。</p><h1 id="内部插件"><a href="#内部插件" class="headerlink" title="内部插件"></a>内部插件</h1><p>除了默认的 ImJoy api，还提供了一组内部支持的插件，这些插件可以直接使用。只有当另一个插件通过 <code>api.getPlugin(...)</code> 请求插件时，才会加载这些插件。<br>以下是这些内部插件及其 api 功能的列表。</p><h2 id="BrowserFS"><a href="#BrowserFS" class="headerlink" title="BrowserFS"></a>BrowserFS</h2><p>要使用 <code>BrowserFS</code> 插件，需要先调用：<br>在Javascript中<code>const bfs = await api.getPlugin(&#39;BrowserFS&#39;)</code> ，或在Python中<code>bfs = await api.getPlugin(&#39;BrowserFS&#39;)</code>。<br>然后，可以使用 <a href="https://nodejs.org/api/fs.html">Node JS 文件系统 API</a> 访问浏览器内的文件系统（例如：<code>bfs.readFile(&#39;/tmp/temp.txt&#39;, &#39;utf-8&#39;)</code>)。更多底层实现详见<a href="https://github.com/jvilk/BrowserFS">BrowserFS</a>，ImJoy默认文件系统支持以下节点：</p><ul><li><code>/tmp</code>: <code>InMemory</code>，数据保存在浏览器内存中，ImJoy关闭时清除。</li><li><code>/home</code>：<code>IndexedDB</code>，数据存储在浏览器IndexedDB数据库中，可以作为持久化存储。</li></ul><p>例子：<br>JavaScript写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test_browser_fs</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> bfs_plugin = <span class="keyword">await</span> api.getPlugin(<span class="string">&#x27;BrowserFS&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> bfs = bfs_plugin.fs</span><br><span class="line"></span><br><span class="line">  bfs.writeFile(<span class="string">&#x27;/tmp/temp.txt&#x27;</span>, <span class="string">&#x27;hello world&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(err);</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Successfully Written to File.&quot;</span>);</span><br><span class="line">      bfs.readFile(<span class="string">&#x27;/tmp/temp.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (err) &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(err);</span><br><span class="line">              <span class="keyword">return</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&#x27;Read from file&#x27;</span>, data)</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Python写法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">test_browser_fs</span>():</span></span><br><span class="line">  bfs_plugin = <span class="keyword">await</span> api.getPlugin(<span class="string">&#x27;BrowserFS&#x27;</span>)</span><br><span class="line">  bfs = bfs_plugin.fs</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">err, data=<span class="literal">None</span></span>):</span></span><br><span class="line">      <span class="keyword">if</span> err:</span><br><span class="line">          <span class="built_in">print</span>(err)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">cb</span>(<span class="params">err, data=<span class="literal">None</span></span>):</span></span><br><span class="line">          <span class="keyword">if</span> err:</span><br><span class="line">              <span class="built_in">print</span>(err)</span><br><span class="line">              <span class="keyword">return</span></span><br><span class="line">          api.log(data)</span><br><span class="line">      bfs.readFile(<span class="string">&#x27;/tmp/temp.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, cb)</span><br><span class="line"></span><br><span class="line">  bfs.writeFile(<span class="string">&#x27;/tmp/temp.txt&#x27;</span>, <span class="string">&#x27;hello world&#x27;</span>, read)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>在 JavaScript 中逐块读取大文件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generate_random_data</span>(<span class="params">size</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> chars = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span>.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> len = chars.length;</span><br><span class="line">    <span class="keyword">var</span> random_data = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">        random_data.push(chars[<span class="built_in">Math</span>.random()*len | <span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> random_data.join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fsRead</span>(<span class="params">fd, buffer, offset, chunkSize, bytesRead</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.read(fd, buffer, offset, chunkSize, bytesRead, (err, bytesRead,</span><br><span class="line">      read_buffer) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;err : &#x27;</span> + err);</span><br><span class="line">        reject(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> bytes = read_buffer.slice(<span class="number">0</span>, bytesRead)</span><br><span class="line">      resolve(bytes)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bfs.writeFile(<span class="string">&#x27;/tmp/test.txt&#x27;</span>, generate_random_data(<span class="number">100000</span>), <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (err)&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">&#125;</span><br><span class="line">bfs.open(<span class="string">&#x27;/tmp/test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, fd</span>) </span>&#123;</span><br><span class="line">    bfs.fstat(fd, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">err, stats</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(err)&#123;</span><br><span class="line">          <span class="built_in">console</span>.error(err)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> bufferSize = stats.size,</span><br><span class="line">          chunkSize = <span class="number">512</span>,</span><br><span class="line">          buffer = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(chunkSize)),</span><br><span class="line">          bytesRead = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (bytesRead &lt; bufferSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((bytesRead + chunkSize) &gt; bufferSize) &#123;</span><br><span class="line">                chunkSize = (bufferSize - bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> bytes = <span class="keyword">await</span> fsRead(fd, buffer, <span class="number">0</span>, chunkSize, bytesRead)</span><br><span class="line">            <span class="built_in">console</span>.log(bytes)</span><br><span class="line">            bytesRead += chunkSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Finished reading.&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(e)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span>&#123;</span><br><span class="line">        bfs.close(fd);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">参考文献
ImJoy API

简介
ImJoy的每个插件都在自己的类似沙箱的容器环境中运行（如JavaScript插件的Web Worker 或iframe、Python插件的进程process）。这样可以避免其他插件的干扰并使ImJoy应用程序更加安全。
插件与ImJoy主程序或插件与插件之间的交互是通过一组API函数（ImJoy API）进行的。所有插件都可以访问到一个名为api的特殊对象。在Javascript中，api 是一个可以直接使用的全局对象。在Python中，可以通过调用 from imjoy import api 来导入它。有了这个对象，插件可以做很多事情，比如显示一个对话</summary>
    
    
    
    <category term="computer vision" scheme="http://qixinbo.github.io/categories/computer-vision/"/>
    
    
    <category term="ImJoy" scheme="http://qixinbo.github.io/tags/ImJoy/"/>
    
  </entry>
  
  <entry>
    <title>开源深度学习计算平台ImJoy解析：5 -- 插件开发流程</title>
    <link href="http://qixinbo.github.io/2021/12/05/ImJoy_5/"/>
    <id>http://qixinbo.github.io/2021/12/05/ImJoy_5/</id>
    <published>2021-12-04T16:00:00.000Z</published>
    <updated>2021-12-05T02:26:53.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://imjoy.io/docs/#/development">Developing Plugins for ImJoy</a></p><p><a href="https://qixinbo.info/2021/12/04/imjoy_4/">上一篇文章</a>中介绍了插件的文件格式，这一篇介绍如何进行实际的插件开发。</p><h1 id="指定依赖"><a href="#指定依赖" class="headerlink" title="指定依赖"></a>指定依赖</h1><p>对于一个插件，其往往不是单一的功能实现，往往需要其他软件库的配合。<br>插件的依赖在其文件的<code>config</code> 块的<code>requirements</code>字段中进行指定。<br>根据不同的插件类型，可以指定不一样的依赖。</p><h2 id="Web-Worker-和-Window-插件"><a href="#Web-Worker-和-Window-插件" class="headerlink" title="Web Worker 和 Window 插件"></a>Web Worker 和 Window 插件</h2><p>对于这两类插件，可以通过一个JavaScript库的url数组来指定依赖。这些库会被<code>importScripts</code>方法导入。<br>例如，要指定最新的 <a href="https://plot.ly/javascript/">plotly.js</a> 库，可以这样写：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;requirements&quot;: [&quot;https://cdn.plot.ly/plotly-latest.min.js&quot;]</span><br></pre></td></tr></table></figure></p><p>特别地，对于window插件，还可以指定CSS库的url，这些需要以<code>.css</code> 结尾，否则需要在url 后添加前缀<code>css:</code>。<br>例如，要使用<a href="https://www.w3schools.com/w3css/">W3.CSS框架</a>，可以这样指定：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;requirements&quot;: [&quot;https://www.w3schools.com/w3css/4/w3.css&quot;]</span><br></pre></td></tr></table></figure><br>如果url不以<code>.css</code>结尾，则需要在其前面加上<code>css:</code>，例如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;requirements&quot;: [&quot;css:https://fonts.googleapis.com/icon?family=Material+Icons&quot;]</span><br></pre></td></tr></table></figure><br>ImJoy在这个<a href="https://github.com/imjoy-team/static.imjoy.io">GitHub仓库</a>中托管常用的库。可以使用简单的url来引用在<code>docs</code>文件夹中的所有文件：<code>https://static.imjoy.io</code> + <code>RelativePathInDocs</code>。<br>例如，在文件夹<code>static.imjoy.io/docs/js/</code>中的文件<code>FileSaver.js</code>可以这样引用：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;requirements&quot;: [&quot;https://static.imjoy.io/js/FileSaver.js&quot;]</span><br></pre></td></tr></table></figure><br>如果url不以<code>.js</code>结尾，则需要在其前面加上<code>js:</code>，例如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;requirements&quot;: [&quot;js:https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@0.11.2&quot;]</span><br></pre></td></tr></table></figure><br>对于离线访问的场景，Javascript和CSS文件在被添加到<code>requirements</code>后会被自动缓存。<br>还可以使用 <code>cache:</code> 前缀将其他资源（例如图像、字体文件）添加到离线缓存中，例如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;requirements&quot;: [&quot;cache:https://use.fontawesome.com/releases/v5.8.2/webfonts/fa-solid-900.woff2&quot;]</span><br></pre></td></tr></table></figure><br>需要注意的是，离线缓存过程不会跟踪所依赖的资源，需要手动将它们添加为依赖后才能缓存。<br>在<code>script</code>标签中导入 ES 模块时（使用 <code>type=&quot;module&quot;</code>），建议在 <code>requirements</code> 中明确添加 es 模块的 URL，并在 URL 前加上 <code>cache:</code> 前缀。这将允许 ImJoy 缓存动态脚本以供离线使用。</p><h2 id="Web-Python插件"><a href="#Web-Python插件" class="headerlink" title="Web Python插件"></a>Web Python插件</h2><p>可以使用所需 Python 模块的字符串列表来指定依赖。例如，<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;requirements&quot;: [&quot;numpy&quot;, &quot;matplotlib&quot;]</span><br></pre></td></tr></table></figure><br>默认情况下，这些包是从ImJoy开发者在<a href="https://github.com/imjoy-team/static.imjoy.io/tree/master/docs/pyodide">该Github仓库</a>上的静态托管加载的。特别地，对于 <code>scipy</code>，需要包含一个绝对路径的url：<br><code>&quot;requirements&quot;: [&quot;https://alpha.iodide.app/pyodide-0.10.0/scipy.js&quot;]</code>。<br>如果想导入额外的 js 文件，需要在 javascript url 之前使用 <code>js:</code> 前缀。<br>注意，<code>web-python</code>插件是基于<a href="https://github.com/iodide-project/pyodide/">pyodide</a>的，目前该技术只支持有限数量的 python 模块。</p><h2 id="Native-Python插件"><a href="#Native-Python插件" class="headerlink" title="Native Python插件"></a>Native Python插件</h2><p>也是通过一个字符串列表来指定依赖，然后添加一个前缀用于指定依赖的类型：<code>conda:</code>、<code>pip:</code>和<code>repo:</code>。<br>一般语法是<code>&quot;requirements&quot;: [&quot;prefix:requirementToInstall&quot;]</code>。<br>下表列出所有支持的依赖、ImJoy实际执行的命令，以及相应的例子。</p><div class="table-container"><table><thead><tr><th>Prefix</th><th>Command</th><th>Example</th></tr></thead><tbody><tr><td><code>conda</code></td><td><code>conda install -y</code></td><td><code>&quot;conda:scipy==1.0&quot;</code></td></tr><tr><td><code>pip</code></td><td><code>pip install</code></td><td><code>&quot;pip:scipy==1.0&quot;</code></td></tr><tr><td><code>repo</code></td><td><code>git clone</code> (new repo) <br> <code>git pull</code> (existing repo)</td><td><code>&quot;repo:https://github.com/userName/myRepo&quot;</code></td></tr><tr><td><code>cmd</code></td><td>Any other command</td><td><code>&quot;cmd:pip install -r myRepo/requirements.txt&quot;</code></td></tr></tbody></table></div><p>一些注意点：<br>（1）如果没有使用前缀，那么依赖将被视为<code>pip</code>库。<br>   <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;requirements&quot;: [&quot;numpy&quot;, &quot;scipy==1.0&quot;]</span><br></pre></td></tr></table></figure><br>（2）如果通过<code>env</code>字段定义了一个虚拟环境，那么所有<code>pip</code>和<code>conda</code> 软件包将安装到此环境中。更多的信息将在下面的“虚拟环境”一节进行介绍。<br>（3）可以直接在一个前缀后以一个字符串的形式列出多个依赖：<br>   <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;requirements&quot;: [&quot;conda:numpy scipy==1.0&quot;]</span><br></pre></td></tr></table></figure><br>或在一个列表中单独指定前缀：<br>   <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;requirements&quot;: [&quot;conda:numpy&quot;, &quot;conda:scipy==1.0&quot;]</span><br></pre></td></tr></table></figure><br>（4）不同的依赖类型可以合并为一个列表：<br>   <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;requirements&quot;: [&quot;conda:numpy&quot;, &quot;pip:scipy==1.0&quot;, &quot;repo:https://github.com/userName/myRepo&quot;]</span><br></pre></td></tr></table></figure></p><h3 id="从GitHub安装Python包"><a href="#从GitHub安装Python包" class="headerlink" title="从GitHub安装Python包"></a>从GitHub安装Python包</h3><p>如果想引用的python模块有一个可用的 <code>setup.py</code> 文件，则可以直接从 Github 使用它，而无需上传到 Python Package Index (<a href="https://pypi.org">PyPI</a>)。方法是按照下面的 PyPI 格式提供github仓库的URL。<a href="https://packaging.python.org/tutorials/packaging-projects/">这个链接</a>对这个方法有详细解释。<br>通用语法如下所示，参数以“{}”表示：<br> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;requirements&quot;: [&quot;pip:git+https://github.com/&#123;username&#125;/&#123;reponame&#125;@&#123;tagname&#125;#egg=&#123;reponame&#125;&quot;]</span><br></pre></td></tr></table></figure><br>语法 <code>&quot;pip:git+https...&quot;</code> 被 ImJoy 翻译成命令 <code>pip install git+https...</code>，该命令允许直接从Git安装python包，即<a href="https://pip.pypa.io/en/stable/topics/vcs-support/">pip install from GIT</a>。<br>必须指定以下参数：<br>（1）<code>username</code>：GitHub 帐户的名称。<br>（2）<code>reponame</code>：GitHub 存储库的名称。<br>（3）<code>tagname</code>：可以加上标签。这个参数可以是一个commit的hash tag，一个<a href="https://git-scm.com/book/en/v2/Git-Basics-Tagging">Git tag</a>，或<a href="https://help.github.com/articles/creating-releases/">GitHub release</a>。该参数可以精确地选择仓库的版本。<br>（4）<code>eggname</code>：这通常是仓库的名称。这个参数会告诉pip进行依赖项检查。<br>需要注意的是，一旦安装了软件包，它将不会被升级，除非指定一个新标签。有关的完整说明，请参阅 <a href="https://pip.pypa.io/en/latest/reference/pip_install/#git">pip 文档</a>。<br>测试起见的话，可以在终端使用<code>pip</code>命令加上上面指定的参数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install git+https://github.com/&#123;username&#125;/&#123;reponame&#125;@&#123;tagname&#125;<span class="comment">#egg=&#123;reponame&#125;</span></span><br></pre></td></tr></table></figure></p><h2 id="插件依赖的典型场景"><a href="#插件依赖的典型场景" class="headerlink" title="插件依赖的典型场景"></a>插件依赖的典型场景</h2><p>以下描述了添加依赖时的典型场景。</p><h3 id="pip库"><a href="#pip库" class="headerlink" title="pip库"></a>pip库</h3><p>想添加的python 模块在 pip 仓库（<code>pip.pypa.io</code>）中，此时非常简单，将该python模块的 pip 名称添加到 <code>requirements</code> 中即可，也可以添加版本号。<br>例如，要添加 <code>scipy</code>的1.0 版本，可以指定<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;requirements&quot;: [&quot;pip:scipy==1.0&quot;]</span><br></pre></td></tr></table></figure></p><h3 id="带有-setup-py-的仓库"><a href="#带有-setup-py-的仓库" class="headerlink" title="带有 setup.py 的仓库"></a>带有 <code>setup.py</code> 的仓库</h3><p>当python包中存在<code>setup.py</code> 时，<code>pip</code> 命令可以从 GitHub 仓库安装包及其依赖项。<br>例如：帐户 <code>myUserName</code>在GitHub上托管了<code>myRepo</code>仓库，其最新的 Git 标签是“v0.1.1”。然后可以这样添加：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;requirements&quot;: &quot;pip:git+https://github.com/myUserName/myRepo@v0.1.1#egg=myRepo&quot;</span><br></pre></td></tr></table></figure></p><h3 id="带有-requirements-txt-的仓库"><a href="#带有-requirements-txt-的仓库" class="headerlink" title="带有 requirements.txt 的仓库"></a>带有 <code>requirements.txt</code> 的仓库</h3><p>文件<code>requirements.txt</code>中列出了某个python库所依赖的所有软件包及其版本。有关更多详细信息，请参阅 <a href="https://pip.pypa.io/en/stable/user_guide/#requirements-files">此处</a>。<br>下面这个例子给出了如何引入这种带<code>requirements.txt</code>的python库。<br>比如，帐户 <code>myUserName</code>有一个GitHub 仓库 <code>myRepo</code> ，将此仓库添加到插件工作区，并安装依赖：<br> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;requirements&quot;: [&quot;repo:https://github.com/myUserName/myRepo&quot;, &quot;cmd: pip install -r myRepo/requirements.txt&quot;]</span><br></pre></td></tr></table></figure><br>然后，在自己要编写的 Python 插件中，可以将上述路径添加到 Python 系统路径中，这样就可以导入想要的库：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sys.path.insert(<span class="number">0</span>, <span class="string">&#x27;./myRepo&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span>  ... <span class="keyword">import</span> ...</span><br></pre></td></tr></table></figure></p><h3 id="带有-environment-yml-的仓库"><a href="#带有-environment-yml-的仓库" class="headerlink" title="带有 environment.yml 的仓库"></a>带有 <code>environment.yml</code> 的仓库</h3><p>yaml 文件 <code>environment.yml</code> 定义了一个带有 conda 和 pip 依赖关系的虚拟环境。详细的文件格式描述可以在<a href="https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html#create-env-file-manually">这里</a>找到。<br>仍然是上面的例子：帐户 <code>myUserName</code>有一个GitHub 仓库 <code>myRepo</code>，可以这样添加：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;requirements&quot;: [&quot;repo:https://github.com/myUserName/myRepo&quot;]</span><br></pre></td></tr></table></figure><br>并在<code>env</code>字段中安装虚拟环境：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;env&quot;: [&quot;conda env create -f myRepo/environment.yml&quot;]</span><br></pre></td></tr></table></figure></p><h3 id="托管在Dropbox上的仓库"><a href="#托管在Dropbox上的仓库" class="headerlink" title="托管在Dropbox上的仓库"></a>托管在Dropbox上的仓库</h3><p>还可以在 dropbox 上托管代码（以及数据）并通过https 请求来安装它。不过国内用户基本用不到这种场景。</p><h2 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h2><p>默认情况下，来自ImJoy的Python插件将在默认的conda环境中执行。然而，这些插件也可以具有特定的虚拟conda环境，这提供了一种隔离插件的方法。这样一来，就可以使用不同版本的Python运行它们，或者使用不同的conda或pip包。<br>建议每个插件及不同的标签使用独自的虚拟环境以保证稳定性。进一步地，建议为python、pip和conda包指定完整版本号(X.X.X)。通过指定完整版本，conda将尝试跨虚拟环境重用相同版本（和python版本）的包，从而减少所需的磁盘空间。<br>例如，以下两个环境将重用指定的 scipy 包，但不会重用 numpy 包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n test_env1 python&#x3D;3.6.8 scipy&#x3D;1.1.0 numpy&#x3D;1.16.1</span><br><span class="line">conda create -n test_env2 python&#x3D;3.6.8 scipy&#x3D;1.1.0 numpy&#x3D;1.15.4</span><br></pre></td></tr></table></figure><br>为了在特定的 conda 环境中运行插件，可以通过在插件的 <code>&lt;config&gt;</code> 部分设置 <code>env</code> 字段来指定它。<br><code>env</code> 可以是字符串或数组。在一行中需要执行多个命令时，需要使用 <code>&amp;&amp;</code> 或 <code>||</code>（注意操作系统的差别）。如果有多个相互独立的命令，可以使用一个数组来存储这些命令。例如：<br><code>&quot;env&quot;: [&quot;export CUDA_VISIBLE_DEVICES=1&quot;, &quot;conda create -n XXXXX python=3.7&quot;]</code>。<br>还可以直接从“environment.yml”文件创建环境，例如<br><code>&quot;env&quot;: &quot;conda env create -f ANNA-PALM/environment.yml&quot;</code>。<br>有关更多信息，请参阅专用的 <a href="https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html#creating-an-environment-from-an-environment-yml-file">conda 帮助页面</a>。</p><h1 id="插件开发"><a href="#插件开发" class="headerlink" title="插件开发"></a>插件开发</h1><p>配置好插件的属性及依赖后，最重要的部分是在 <code>&lt;script&gt;</code> 块中编写实际的插件代码。<br>ImJoy的插件系统建立在远程过程调用（RPC）之上，使用一套编码和解码方案在插件之间传输数据和功能。ImJoy开发者开发出了一组 API 函数（称为<code>ImJoy APIs</code>），以便插件与主应用程序以及插件彼此之间进行交互。<br>任何 ImJoy 插件都可以通过名为<code>api</code>的预定义对象访问<code>ImJoy APIs</code>。<a href="https://imjoy.io/docs/#/api">ImJoy API 函数</a> 这一部分展示了这些API可用的完整列表（稍后的博客会详细介绍）。</p><h2 id="导出插件函数"><a href="#导出插件函数" class="headerlink" title="导出插件函数"></a>导出插件函数</h2><p>每个插件都需要导出一个带有一组函数的插件对象，这些函数将被注册为插件 API 函数（也称为<code>Plugin APIs</code>）。这是通过在插件代码末尾调用<code>api.export</code>来完成的。一旦导出，这些函数就可以在 ImJoy 中注册，并且可以由用户从 ImJoy 用户界面或其他插件调用。重要的是，<code>setup</code> 和 <code>run</code> 是两个必须被定义和导出的插件 API 函数。</p><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>未导出为<code>Plugin API</code> 函数的插件函数，可以作为对象object发送给另一个插件或 ImJoy主程序。这些函数将被视为一个“回调”函数并且只能被调用一次。<br>一个典型的例子是通知函数，它可以告诉调用它的插件”计算已完成“。这样的功能必须只调用一次。</p><h2 id="插件菜单"><a href="#插件菜单" class="headerlink" title="插件菜单"></a>插件菜单</h2><p>大多数插件都可以从插件菜单访问，默认情况下，当用户单击插件菜单中的插件名称时，将调用 <code>run</code> 函数。在插件（或<code>op</code>，下面会详述）的执行过程中，它可以从它的第一个参数（通常命名为<code>ctx</code>）中访问不同的字段：<br>（1）<code>ctx.config</code>：GUI 中使用 <code>ui</code> 字段定义的数值（来自插件文件的<code>&lt;config&gt;</code> 块或来自单独的操作<code>api.register</code>，更多信息如下）。例如，如果你在插件<code>&lt;config&gt;</code>中定义了一个ui字符串（例如<code>&quot;ui&quot;: &quot;option &#123;id: &#39;opt1&#39;, type: &#39;number&#39;&#125;&quot;</code>），你可以通过<code>ctx.config.opt1</code>访问它。<br>（2）<code>ctx.data</code>：它存储来自当前活动窗口的数据和运行插件的状态。请注意，仅当数据与插件或 op 定义的 <code>inputs</code>字段的 json 模板语法匹配时，才会将其传递给插件。比如拖拽进来后缀为png的文件时，它会匹配在<code>inputs</code>字段定义了png格式的插件，然后该文件就传给该插件进行处理。<br>（3）<code>ctx._variables</code>：当插件在工作流中执行时，工作流中设置的变量将作为 <code>ctx._variables</code> 传递。如果用户使用诸如“Set [number]”之类的操作，它将被设置为实际变量值。</p><p>结果可以直接被返回，它们将显示为通用结果窗口。如果想对结果定义特定的窗口类型，可以返回一个至少有两个字段 <code>type</code> 和 <code>data</code> 的对象。ImJoy 将使用 <code>type</code> 来查找用于渲染存储在 <code>data</code> 中的结果的窗口。<br>在下面的示例中，来自 url 的图像将显示在图像窗口中或传递给工作流中的下一个操作。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;imjoy/image&quot;</span>, <span class="string">&quot;data&quot;</span>: &#123;<span class="string">&quot;src&quot;</span>: <span class="string">&quot;https://imjoy.io/static/img/imjoy-icon.png&quot;</span>&#125; &#125;</span><br></pre></td></tr></table></figure><br>ImJoy 使用 postMessage 在插件之间交换数据。这意味着对于 JavaScript插件，对象在传输过程中被复制。如果交换的数据特别大，那么创建的对象就不应该直接传输。要启用这种模式，可以在返回对象时将 <code>_transfer=true</code> 添加到对象中。在上面例子中，可以在返回 <code>ctx</code> 时设置 <code>ctx._transfer = true</code>。然而，它会只加速 <code>ArrayBuffers</code> 或 <code>ArrayBufferViews</code> 的传输（以及ndarrays 由 Python 生成），传输完毕后，将无法访问它。<br>(注意：在Python中，<code>ctx</code>的数据类型是字典，ImJoy添加了允许点表示法的接口，就像在JavaScript中一样。如果愿意，也可以在两种语言中使用<code>[]</code>访问字典或对象。）</p><h2 id="插件操作符（操作）"><a href="#插件操作符（操作）" class="headerlink" title="插件操作符（操作）"></a>插件操作符（操作）</h2><p>可以使用 Plugin API 为插件定义独立的运算符（或 <code>ops</code>）（有关详细信息可参考api.register）。这些<code>ops</code> 的定义方式与<code>&lt;config&gt;</code>块类似：可以定义一个接口来设置参数，它有一个专门的运行功能。当按下插件列表中的向下箭头按钮时，会显示这些不同的操作<code>ops</code>。</p><h2 id="数据交换"><a href="#数据交换" class="headerlink" title="数据交换"></a>数据交换</h2><h3 id="加载-保存文件"><a href="#加载-保存文件" class="headerlink" title="加载/保存文件"></a>加载/保存文件</h3><p>在 ImJoy 中可以以不同方式访问存储在文件系统上的文件。<br>一方面，在没有插件引擎的情况下，若想访问本地文件，用户需要打开或拖动文件导入ImJoy，对于结果文件则只能通过触发下载来保存。<br>另一方面，插件引擎拥有对本地文件系统的完全访问权限，native python 插件可以直接从本地文件系统读取和写入。<br><img src="https://user-images.githubusercontent.com/6218739/144711988-32c6ef87-129a-4942-a5b8-2a0bb1185085.png" alt="data-access"></p><p>因此，ImJoy提供了几种不同的方法来处理插件的加载/保存文件：<br>（1）如果Plugin Engine正在运行，那么对于所有类型插件，有 3 个api函数可以访问本地文件系统：<code>api.showFileDialog</code>、<code>api.getFileUrl</code>、<code>api.requestUploadUrl</code>。特别地，对于在插件引擎上运行的Python插件，可以直接使用标准的 python 文件操作来将文件加载或写入文件系统。<br>（2）如果Plugin Engine未运行，JavaScript或Web Python 插件访问文件的唯一途径是要求用户将文件或文件夹直接拖到 ImJoy 工作区中。这将呈现一个包含文件或文件夹内容的窗口。然后这些数据可以被插件访问并进行处理。要将结果导出为文件，可以使用<code>api.exportFile</code> 函数来触发下载。<br>与通过插件引擎运行的插件相比，在浏览器中运行的web插件无法直接访问本地文件系统，因此它们提供比 <code>native-python</code> 插件更高的安全性。</p><h3 id="通过函数调用来交换数据"><a href="#通过函数调用来交换数据" class="headerlink" title="通过函数调用来交换数据"></a>通过函数调用来交换数据</h3><p>对于运行时生成的少量数据（例如：数组、对象等），可以将数据对象作为参数传递给API函数（或者从API函数返回数据对象），从而将它们发送到另一个插件。<br>例如，可以将包含小型numpy数组、字符串、字节的数据（<10MB）从远程插件引擎中运行的`native-python`插件直接发送到在浏览器中运行的`window`插件。为了快速显示小图像，还可以将其保存为 png 格式并将其编码为 base64 字符串，然后可以使用标准的 HTML `《img>` 标签直接显示。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;output.png&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br><span class="line">    result = base64.b64encode(data).decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line">    imgurl = <span class="string">&#x27;data:image/png;base64,&#x27;</span> + result</span><br><span class="line">    api.createWindow(name=<span class="string">&#x27;unet prediction&#x27;</span>, <span class="built_in">type</span>=<span class="string">&#x27;imjoy/image&#x27;</span>, w=<span class="number">7</span>, h=<span class="number">7</span>, data= &#123;<span class="string">&quot;src&quot;</span>: imgurl&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="通过窗口传递数据"><a href="#通过窗口传递数据" class="headerlink" title="通过窗口传递数据"></a>通过窗口传递数据</h3><p>ImJoy中显示的窗口可以包含数据，例如图像，因此您可以将窗口用作将数据从一个插件传递到另一个插件的一种方式。<br>选择此类窗口并执行插件时（通过单击插件菜单），所包含的数据将被传送到该插件。<br>重要的是，如果窗口中包含的数据对象匹配某插件的 <code>&lt;config&gt;</code> 中 <code>inputs</code> 定义的 json 模式，ImJoy 就会将窗口中包含的数据传递给该插件。然后插件可以通过访问 <code>ctx.data</code> 来处理数据（通常在 <code>run</code> 函数内）。<br>ImJoy 原生支持 Numpy 数组和TensorFlow张量的转换和传输。插件开发人员可以直接使用这些数据类型并在插件之间进行交换，而不用管它们是在 Python 还是 JavaScript 中。</p><h3 id="处理大数据量"><a href="#处理大数据量" class="headerlink" title="处理大数据量"></a>处理大数据量</h3><p>对于大数据量，一种方式是以较小的块chunks来发送大文件，但这不是最佳的，并且可能会阻碍引擎和ImJoy应用程序之间的正常通信。建议将数据存储在磁盘上（例如在工作区目录中），然后使用<code>api.getFileUrl</code> 生成访问文件的 url。然后可以将生成的 url 发送到 Web 应用程序，并通过下载链接或使用 JavaScript 库（如“axios”）进行访问。很多库如 Three.js、Vega 等都可以直接通过 url 加载文件。</p><h2 id="工作流管理"><a href="#工作流管理" class="headerlink" title="工作流管理"></a>工作流管理</h2><p>ImJoy在 <code>ctx</code> 中提供了额外的字段，允许跟踪、维护和重建整个分析工作流程。<br>（1）<code>ctx._op</code>：给出正在执行的操作的名称。当一个插件注册了多个 op 并且没有为 op 指定回调函数时，<code>run</code> 函数将被调用，可以使用 <code>ctx._op</code> 来确定正在执行哪个 op。<br>（2）<code>ctx._source_op</code>：给出启动当前动作的op的名称。<br>（3）<code>ctx._workflow_id</code>：当插件在工作流中执行时，它的 id 将被传递到这里。当插件从插件菜单执行时，ImJoy 将尝试重用当前活动窗口中的工作流 id，如果没有窗口处于活动状态，则会分配一个新的工作流 id。所有具有相同 <code>_workflow_id</code> 的数据窗口在管道或计算图中虚拟连接。重要的是，通过将 <code>_workflow_id</code> 与 <code>_op</code> 和 <code>_source_op</code> 结合起来，<code>_workflow_id</code>、<code>_variables</code>、<code>_op</code> 和<code>_source_op</code> 可用于实现插件之间的交互，这意味着如果用户在结果窗口中更改了状态，下游工作流将自动更新。</p><h2 id="Native-Python插件的执行标志"><a href="#Native-Python插件的执行标志" class="headerlink" title="Native Python插件的执行标志"></a>Native Python插件的执行标志</h2><p>可以使用 <code>&lt;config&gt;</code> 块中的 <code>flags</code> 字段来控制 Python 插件进程的执行。接下来，将解释插件引擎上运行的 Python 进程如何与 ImJoy 界面交互。<br><img src="https://user-images.githubusercontent.com/6218739/144712604-1b9ba517-ea26-424f-ac87-9a5ffb2e98f1.png" alt="python-process"><br>上图中的几个概念：</p><ul><li>Interface：ImJoy 的web界面。可以在多个浏览器窗口（即多个界面）上运行 ImJoy。</li><li>Plugin Engine：在后台运行以执行来自不同 Python 插件的 Python 代码。</li><li>Python Plugin：包含 Python 代码的插件。一些插件可能有<code>tags</code>来进一步指定它们的执行细节。</li><li>Python Process：在插件引擎上运行的特定 Python 插件。进程可以在任务管理器上看到。</li><li>Workspace：已安装的 ImJoy 插件的集合。对于带有<code>tags</code> 的插件，用户选择合适的标签。工作区中的每个 Python 插件都有自己的进程。每个工作区都有一个唯一的名称。</li><li>ImJoy instance：是在一个 ImJoy 界面中运行的工作区。</li></ul><p>下面将介绍控制python插件执行的三个执行标志：</p><ul><li>默认（没有设置任何标志）：每个 ImJoy 实例在插件引擎上都有自己的进程。如果关闭该界面，则会终止该进程。</li><li><code>single-instance</code>：该标志将只允许一个进程为整个插件引擎运行。对于具有相同名称和标签的插件，那么<code>single-instance</code> 意味着它们访问相同的进程。</li><li><code>allow-detach</code>： 该标志表示进程在其 ImJoy 实例关闭时不会被终止。例如，这允许在后台执行长时间的计算任务，这些任务不需要额外的用户反馈并自动终止。还可用于保护长时间的计算任务免受浏览器不稳定的影响。如果希望能够附加到分离的进程，可以从相同的浏览器和工作区重新连接，或者结合使用 <code>single-instance</code> 标志，这样尽管从不同的浏览器和工作区连接，仍然能连接到之前的进程。</li></ul><p>当 ImJoy 尝试重新连接之前分离的插件进程时，如果在插件类中定义了<code>resume()</code>，那么<code>resume()</code>将被调用，否则像往常一样调用<code>setup()</code>。请注意，当存在<code>resume</code>时，在重新附加期间不会调用 <code>setup</code>。<br>这是 <code>flags</code> 选项在 <code>&lt;config&gt;</code> 块中的样子：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;config lang=&quot;json&quot;&gt;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  &quot;flags&quot;: [&quot;single-instance&quot;, &quot;allow-detach&quot;],</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&lt;/config&gt;</span><br></pre></td></tr></table></figure><br><code>flags</code> 也可以使用 <code>tags</code> 进行配置，例如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;config lang=&quot;json&quot;&gt;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  &quot;tags&quot;: [&quot;Single&quot;, &quot;Multi&quot;],</span><br><span class="line">  &quot;flags&quot;: &#123;&quot;Single&quot;: [&quot;single-instance&quot;, &quot;allow-detach&quot;], &quot;Multi&quot;: []&#125;,</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&lt;/config&gt;</span><br></pre></td></tr></table></figure><br>上面的 <code>&lt;config&gt;</code> 块将创建一个带有两个标签（<code>Single</code> 和 <code>Multi</code>）的插件。在安装期间，用户可以选择希望使用哪种运行时行为（插件进程的单个实例（<code>Single</code>），或者在同一个工作区打开多个 ImJoy 界面对应的多插件进程（<code>Multi</code>））。</p><h1 id="构建用户界面"><a href="#构建用户界面" class="headerlink" title="构建用户界面"></a>构建用户界面</h1><p>ImJoy的一个重要部分是提供一种灵活的方式与用户交互，以丰富的交互方式指定输入信息或生成输出。<br>ImJoy自带有一组基本元素，例如表单和进度条，它们提供了一种与用户交互的方式。<br>还可以使用自定义窗口构建更先进和强大的用户界面，开发人员可以利用基于Web的UI库来生成控件、交互式图表或呈现 3D 视图。</p><h2 id="基本的用户输入和输出"><a href="#基本的用户输入和输出" class="headerlink" title="基本的用户输入和输出"></a>基本的用户输入和输出</h2><p>获取用户输入的最简单方法是使用 ImJoy 生成的表单。<br>可以在 <code>&lt;config&gt;</code> 块中定义一个 <code>gui</code> 字符串，它将在插件菜单下呈现为表单。如果插件使用了多个插件操作op（将在API一文中解析），还可以为每个插件操作单独提供<code>gui</code>字符串。<br>当用户通过插件菜单运行插件或 op 时，<code>gui</code> 字符串中定义的所有字段值将被包装为 <code>config</code> 对象并传递到 <code>run</code> 函数中。然后可以通过 <code>ctx.config.FIELD_ID</code> 访问它们。<br>对于其他类型的输入，可以使用其他ImJoy API，例如弹出一个文件对话框<code>api.showFileDialog</code>。<br>为了显示结果或向用户提供反馈，ImJoy 提供了多个 API 函数来显示结果，例如使用<code>api.alert()</code>或<code>api.showMessage()</code>显示消息，使用<code>api.log()</code>或<code>api.error()</code>记录消息或错误，以及<code>api.showProgress</code>表示进度、<code>api.showStatus</code>更新ImJoy状态等。这些API函数将在API一节中详细解析。</p><h2 id="自定义窗口的用户输入和输出"><a href="#自定义窗口的用户输入和输出" class="headerlink" title="自定义窗口的用户输入和输出"></a>自定义窗口的用户输入和输出</h2><p>对于更灵活的用户界面，开发者可以制作专门的窗口插件。由于是基于<code>iframe</code>，所以大部分前端（HTML/CSS/JS）框架都可以在<code>window</code>插件中使用。此外，这样的接口可以与另一个插件通信，例如执行实际分析的 Python 插件。<br>使用<code>window</code>插件模板可以轻松创建这样的插件。除了其他插件之外，<code>window</code>插件还有两个额外的代码块：<code>&lt;window&gt;</code> 和<code>&lt;style&gt;</code>。用户可以将前端代码添加到相应的代码块中。创建后，这个新的<code>window</code>插件将用作模板来创建新的窗口实例。<br>ImJoy提供了两个API函数，用于从<code>window</code>插件创建窗口<code>api.createWindow</code>或显示对话框<code>api.showDialog</code>。<br>除此之外，对于常用的窗口类型，ImJoy 支持一组内部窗口类型，详见<code>api.createWindow</code>这个API。</p><h2 id="更多示例插件"><a href="#更多示例插件" class="headerlink" title="更多示例插件"></a>更多示例插件</h2><p>请前往<a href="https://imjoy.io/docs/#/demos">Demos</a>。</p><h1 id="托管和部署插件"><a href="#托管和部署插件" class="headerlink" title="托管和部署插件"></a>托管和部署插件</h1><p>这一部分提供了有关如何托管或部署 ImJoy 插件的详细信息。<br>这包括从存储单个文件到设置开发者自己的 ImJoy 插件库。然后插件可以直接作为文件分发或使用专用的 url 语法从而允许自动安装。<br>ImJoy 插件的默认方式及推荐方式都是部署在 GitHub 上（或作为单个文件或在插件仓库中），然后使用插件 url 分发。<br>这里推荐 GitHub，因为它提供稳定性和版本控制，保证了重现性和可追溯性。</p><h2 id="托管单个插件文件"><a href="#托管单个插件文件" class="headerlink" title="托管单个插件文件"></a>托管单个插件文件</h2><p>这是开发过程中的典型案例。<br>插件代码可以托管在网络上，例如GitHub、Gist 或 Dropbox。</p><h2 id="自定义的ImJoy插件库"><a href="#自定义的ImJoy插件库" class="headerlink" title="自定义的ImJoy插件库"></a>自定义的ImJoy插件库</h2><p>可以轻松地为现有 GitHub 项目创建 ImJoy 插件仓库。<br>可以在 <a href="https://github.com/imjoy-team/imjoy-project-template">此处</a> 找到模板项目。<br>然后将 ImJoy 插件保存在一个专用文件夹中，并添加一个清单文件 <code>manifest.imjoy.json</code> 到 GitHub 根文件夹。<br>此清单指定了仓库中有哪些插件，以及在哪里可以找到它们。该文件的架构如下所示，完整的模板可以在<a href="https://github.com/imjoy-team/imjoy-project-template/blob/master/manifest.imjoy.json">这里</a>找到。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;NAME OF THE REPOSITORY&quot;</span>,</span><br><span class="line"> <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;DESCRIBE THE REPOSITORY&quot;</span>,</span><br><span class="line"> <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.1.0&quot;</span>,</span><br><span class="line"> <span class="attr">&quot;uri_root&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line"> <span class="attr">&quot;plugins&quot;</span>: [</span><br><span class="line">   <span class="comment">//copy and paste the &lt;config&gt; block of your plugin here</span></span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后就可以自动或手动更新此清单：<br>（1）对于自动更新，ImJoy提供了一个<a href="https://github.com/imjoy-team/imjoy-project-template/blob/master/update_manifest.js">node脚本</a>。此脚本需要执行node.js。然后在包含<code>manifest.imjoy.json</code>文件的根文件夹中使用命令 <code>node update_manifest.js</code> 运行它，它会自动搜索ImJoy插件及生成清单。请注意，当第一次使用此nodejs脚本时，必须手动更改插件仓库的名称<code>name</code>。对于后续更新，该名称将保持不变。<br>（2）对于手动更新，按照下列步骤操作：<br>（2.1）将所有插件文件放在 GitHub 仓库中的一个文件夹中。例如一个名为<a href="https://github.com/imjoy-team/imjoy-project-template/tree/master/imjoy-plugins">imjoy-plugins</a>的文件夹。<br>（2.2）修改<code>manifest.imjoy.json</code>。对于每个插件：<br>（2.2.1）从插件代码中复制并粘贴<code>&lt;config&gt;</code>块的内容到 <code>manifest.imjoy.json</code> 中的 <code>plugins</code> 块。<br>（2.2.2）添加一个名为<code>&quot;uri&quot;</code>的字段，并将值设置为插件的实际文件名，包括 GitHub 仓库中的相对路径。例如，对于一个名为“untitledPlugin.imjoy.html”的插件文件，设定<code>&quot;uri&quot;: &quot;imjoy-plugins/untitledPlugin.imjoy.html&quot;</code>。如果你将插件的名字设为与插件文件的名字相同，则可以跳过此步骤。<br>在ImJoy中，可以以一个简单的url形式<code>http://imjoy.io/#/app?repo=GITHUB_USER_NAME/REPO_NAME</code>呈现仓库中所有插件的列表，其中<code>GITHUB_USER_NAME</code>是用户名，<code>REPO_NAME</code>是包含 ImJoy 插件的GitHub仓库的名称。然后用户就可以通过此列表来安装插件。有关如何生成此 url 的更多详细信息，并查看如何可以安装特定的插件，可以参阅下面的专门部分。</p><h2 id="官方ImJoy插件库"><a href="#官方ImJoy插件库" class="headerlink" title="官方ImJoy插件库"></a>官方ImJoy插件库</h2><p><code>ImJoy.io</code> 上显示的 ImJoy 插件库通过<a href="https://github.com/imjoy-team/imjoy-plugins">GitHub</a>部署。<br>为了将开发者自己的插件部署到<a href="https://github.com/imjoy-team/imjoy-plugins">该插件库</a>，可以fork该库，添加插件并发送pull request。PR被接受后，用户将能够从官方的插件仓库安装这个插件。</p><h1 id="分发插件"><a href="#分发插件" class="headerlink" title="分发插件"></a>分发插件</h1><p>要分发自己开发的插件，有两个主要选项。<br>（1）可以创建一个完整的url地址。单击时，ImJoy 将自动打开并安装插件。此链接可直接通过电子邮件或社交网络分享。在下面将详细说明如何创建此链接以及支持哪些选项。<br>（2）可以直接发送插件文件（扩展名<code>*.imjoy.html</code>）。这个文件可以被拖入ImJoy工作区，此时它会被自动识别为插件。</p><h2 id="使用自定义库分发插件"><a href="#使用自定义库分发插件" class="headerlink" title="使用自定义库分发插件"></a>使用自定义库分发插件</h2><p>如果开发的插件依赖于非标准库和模块，那么开发者必须随着插件一块提供这些库。可以将这些库和模块上传到 GitHub 仓库、GitHub Gist 或其他数据共享平台（例如 Dropbox）并将它们链接到插件代码中。<br>（1）对于JavaScript插件，需要创建一个 Gist 或 GitHub。将插件（以<code>.imjoy.html</code> 结尾）文件与其他 JavaScript 文件一起上传。在插件文件中，可以将 url 添加到插件 <code>requirements</code> 中。但是由于 GitHub 限制，不能直接使用 GitHub url，不过可以使用 <a href="https://combinatronics.com/">combinatronics.com</a> 进行转换。<br>（2）对于Python插件，建议将这些非标准库打包为 pip 模块，并放在GitHub上。</p><h2 id="存储在-Dropbox-上的代码-数据的分发"><a href="#存储在-Dropbox-上的代码-数据的分发" class="headerlink" title="存储在 Dropbox 上的代码/数据的分发"></a>存储在 Dropbox 上的代码/数据的分发</h2><p>此示例描述了如何部署和分发存储在 Dropbox 上的 Python 插件。<br>这允许共享私有项目。<br>（1）将code或data以 zip 文件的形式存储在 Dropbox 上。这允许通过替换 zip 文件来替换代码/数据（请参阅下面的注释）。<br>（2）将ImJoy 插件文件 (<code>.imjoy.html</code>) 使用私有或公开的gist托管。<br>假设 Python 代码位于存储在 Dropbox 上的 Zip 存档<code>testcode.zip</code>中，并且可通过链接“DROPBOXLINK/testcode.zip”获得。然后，可以将以下代码片段放在插件的 <code>setup()</code> 函数中以使其可用。该片段执行以下步骤：<br>（1）执行 <a href="http://docs.python-requests.org">http 请求</a>。注意此请求中的<code>dl=1</code>选项。默认情况下，此值设置为 0。<br>（2）使用返回的请求对象在本地生成zip文件，解压，最后删除。<br>（3）将本地路径添加到系统路径中。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://DROPBOXLINK/testcode.zip?dl=1&#x27;</span></span><br><span class="line">r = requests.get(url, allow_redirects=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># download the zip file</span></span><br><span class="line">name_zip = os.path.join(<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;testcode.zip&#x27;</span>)</span><br><span class="line"><span class="built_in">open</span>(name_zip, <span class="string">&#x27;wb&#x27;</span>).write(r.content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># extract to the current folder (i.e. workspace)</span></span><br><span class="line"><span class="keyword">with</span> zipfile.ZipFile(name_zip, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.extractall(<span class="string">&#x27;./&#x27;</span>)</span><br><span class="line">os.remove(name_zip)</span><br><span class="line"></span><br><span class="line"><span class="comment"># If you want to import your python modules, append the folder to sys.path</span></span><br><span class="line">sys.path.append(os.path.join(<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;testcode&#x27;</span>))</span><br></pre></td></tr></table></figure><br>一些注意点：<br>（1）代码本地存储在<code>USER_HOME/ImJoyWorkspace/WORKSPACENAME/testcode</code>中，其中WORKSPACENAME为当前ImJoy工作空间的名称。可以在提供的 URL 中自动设置工作区以分发插件。<br>（2）更新zip存档时，不要删除旧的，用新版本替换它。这保证了相同的链接是有效的。<br>（3）该代码每次都会安装当前版本的ZIP插件。</p><h2 id="生成用于共享的插件url"><a href="#生成用于共享的插件url" class="headerlink" title="生成用于共享的插件url"></a>生成用于共享的插件url</h2><p>分发插件的最简单方法是创建一个url，它可以通过电子邮件或社交网络共享。<br>基本格式是<code>http://imjoy.io/#/app?plugin=PLUGIN_URI</code>。注意要用实际plugin URI（统一资源标识符）来替换<code>PLUGIN_URI</code>。例如：<a href="https://imjoy.io/#/app?plugin=https://github.com/imjoy-team/imjoy-plugins/blob/master/repository/imageWindow.imjoy.html">https://imjoy.io/#/app?plugin=https://github.com/imjoy-team/imjoy-plugins/blob/master/repository/imageWindow.imjoy.html</a>。当用户点击此链接时，将显示一个插件安装对话框，提示安装指定的插件，用户只需单击“安装”即可确认。<br>此 url 支持一些额外参数来控制插件加载方式。这些参数将在下面的专门部分中进行描述。<br>有两种类型的URI，具体取决于插件的部署方式：<br>（1）如果插件部署在<code>ImJoy Plugin Repository</code>（如上所述），就可以使用格式为“GITHUB_USER_NAME/REPO_NAME:PLUGIN_NAME”的简短URI。比如可以用<code>imjoy-team/imjoy-project-template:Untitled Plugin</code>来表示托管在 <a href="https://github.com/oeway/DRFNS-Lite">https://github.com/oeway/DRFNS-Lite</a> 上的插件。<br>还可以通过在 <code>PLUGIN_NAME</code> 后添加 <code>@TAG</code> 来指定plugin的标签。例如：<code>oeway/DRFNS-Lite:DRFNS-Lite@GPU</code>。<br>如果还想指定一个git commit hashtag来将插件固定为某些提交，可以在<code>REPO_NAME</code>之后添加<code>@COMMIT_HASHTAG</code>。例如：<code>oeway/DRFNS-Lite@4063b24:DRFNS-Lite</code>，其中<code>4063b24</code>是<a href="https://github.com/oeway/DRFNS-Lite/tree/4063b24f01eab459718ba87678dd5c5db1e1eda1">4063b24f01eab459718ba87678dd5c5db1e1eda1</a>的短格式。<br>（2）还可以使用url指向任何托管的插件网站，包括开发者自己的项目站点、博客、GitHub、Gist或Dropbox。注意，插件文件需要以<code>.imjoy.html</code> 结尾。下面将介绍如何为不同的托管平台获取此 url：<br>（2.1）GitHub上的文件，只需复制文件链接即可。例如：<code>https://github.com/imjoy-team/imjoy-plugins/blob/master/repository/imageRecognition.imjoy.html</code>。<br>（2.2）对于Gist或其他Git提供者（如GitLab），如果Gist中只有一个文件，可以直接使用Gist链接（从浏览器地址栏复制）或获取插件<code>raw</code>文件的链接。对于具有多个文件的 Gist，需要为要使用的插件文件指定 <code>raw</code> 链接。要创建 Gist <code>raw</code> 链接：<br>（2.2.1）在自己的 GitHub 账户上访问Gist<a href="https://gist.github.com/">https://gist.github.com/</a><br>（2.2.2）创建新的 Gist，指定插件名称后跟 <code>.imjoy.html</code>，然后复制并粘贴插件代码。<br>（2.2.3）创建公共或私有 Gist。<br>（2.2.4）可以从<code>Raw</code>按钮获得Gist的链接（这链接到文件的未处理版本）。该链接如下所示：<code>https://gist.githubusercontent.com/oeway/aad257cd9aaab448766c6dc287cb8614/raw/909d0a86e45a9640c0e108adea5ecd7e78b81301/chartJSDemo.imjoy.html</code>。<br>（2.2.5）需要注意，当更新文件时，此url会更改。<br>（2.3）对于Dropbox，需要修改可共享的url如下：<br>（2.3.1）将<code>dl=0</code>替换为<code>dl=1</code>；<br>（2.3.2）将 <code>https://www.dropbox.com/</code> 替换为 <code>https://dl.dropboxusercontent.com/</code>。</p><p>要指定插件标签，只需在 <code>.imjoy.html</code> 后附加 <code>@TAG</code>。例如：<br><code>https://raw.githubusercontent.com/oeway/DRFNS-Lite/master/DRFNS-Lite.imjoy.html@GPU</code>。<br>可以在 ImJoy 中测试插件 url 是否有效：将其粘贴到 <code>+ PLUGINS</code> 对话框中，（<code>Install from URL</code>）并按<code>Enter</code>。如果一切正常，应该能够查看使用插件呈现的卡片，然后可以单击<code>INSTALL</code>。</p><h2 id="支持的url参数"><a href="#支持的url参数" class="headerlink" title="支持的url参数"></a>支持的url参数</h2><p>可以使用自定义参数来构建 ImJoy url，以便于安装。这些 url 参数可以在 <code>https://imjoy.io/#/app?</code> 之后使用，使用 <code>PARAM=VALUE</code> 语法。<br>这些参数相互独立，多个参数可以通过<code>&amp;</code>连接。例如我们要指定<code>par1=99</code>和<code>par2=hello</code>，相应的 url 将是 <code>https://imjoy.io/#/app?par1=99&amp;par2=hello</code>。<br>目前支持以下 url 参数：<br>（1）<code>plugin</code> 或 <code>p</code>：在插件管理对话框中显示指定的插件。如果存在具有相同名称和版本的插件，则不会显示该对话框。如果需要，添加 <code>upgrade=1</code> 以强制显示插件对话框。例如：<code>https://imjoy.io/#/app?p=imjoy-team/imjoy-demo-plugins:alert&amp;upgrade=1</code>。<br>（2）<code>workspace</code> 或 <code>w</code>：工作区的名称。 ImJoy 将切换到指定的工作区（如果存在），或创建一个新的工作区。例如，<code>https://imjoy.io/#/app?workspace=test</code><br>（3）<code>engine</code> 或 <code>e</code>：定义插件引擎的url。例如：<code>http://imjoy.io/#/app?engine=http://127.0.0.1:9527</code>。注意，如果想通过http（而非https）连接到远程机器，则只能使用 <code>http://imjoy.io</code> 而不是 <code>https://imjoy.io</code>。如果在某些浏览器（例如Firefox）中使用localhost，则此限制也存在。为避免这种情况，需要使用 <code>http://127.0.0.1:9527</code> 而不是 <code>http://localhost:9527</code>，因为大多数浏览器会认为 <code>127.0.0.1</code> 是安全连接，而<code>localhost</code>不是。但是，有一个例外，在 Safari 上，使用 <code>127.0.0.1</code> 不起作用，因为<a href="https://bugs.webkit.org/show_bug.cgi?id=171934">此限制</a>，请使用Firefox或Chrome。<br>（4）<code>token</code> 或 <code>t</code>：定义连接令牌。例如：<code>http://imjoy.io/#/app?token=2760239c-c0a7-4a53-a01e-d6da48b949bc</code><br>（5）<code>repo</code> 或 <code>r</code>：指定指向 ImJoy 插件仓库的清单文件。这可以是一个完整的 repo 链接，例如 <code>repo=https://github.com/imjoy-team/imjoy-plugins</code>或简化的 GitHub 链接 <code>repo=imjoy-team/imjoy-plugins</code>。如果从非GitHub网站（例如GitLab）托管插件库，就使用指向 <code>manifest.imjoy.json</code> 文件的 <code>raw</code> 链接。<br>（6）<code>start</code> 或 <code>s</code>：定义一个启动插件名称，它会在 ImJoy web 应用程序加载后自动启动。所有 url 参数将作为 <code>ctx.config</code> 传递给插件到 <code>run(ctx)</code> 函数。这允许添加自定义参数并在 <code>run(ctx)</code> 中使用它们。例如，插件可以使用<code>load=URL</code> 自动加载图像，并使用<code>width=1024&amp;height=2048</code> 设置图像的宽度和高度。例如，将<code>123</code>作为<code>ctx.data.x</code>传递给插件的<code>run</code>函数：<code>https://imjoy.io/#/app?x=123&amp;start=AwesomePlugin</code>。如果正在启动一个<code>window</code>插件，还可以将<code>standalone</code>或<code>fullscreen</code>设置为<code>1</code>以使窗口脱离工作区或处于全屏模式。例如：<code>https://imjoy.io/#/app?x=123&amp;start=AwesomeWindowPlugin&amp;fullscreen=1</code>。<br>（7）<code>load</code> 或 <code>l</code>：定义一个用于发起 http GET 请求的 URL，这个参数应该只在定义了一个带有 <code>start</code> 或 <code>s</code> 的启动插件时使用。从 URL 获取的数据将作为 <code>ctx.data.loaded</code> 传递给启动插件 <code>run(ctx)</code> 函数。<br>（8）<code>expose</code>：当 imjoy 嵌入到 iframe 中时，该参数指定是否应该将其 API 暴露给外部上下文（默认情况下不会暴露）。要启用，可以将 <code>expose=1</code> 添加到 URL 查询。</p><h2 id="添加ImJoy徽章"><a href="#添加ImJoy徽章" class="headerlink" title="添加ImJoy徽章"></a>添加ImJoy徽章</h2><p>如果开发者在项目中使用 ImJoy，建议将ImJoy徽章之一添加到项目仓库（例如在 Github 上）或网站。ImJoy有两个官方徽章：<img src="https://imjoy.io/static/badge/launch-imjoy-badge.svg" alt="launch ImJoy">和<img src="https://imjoy.io/static/badge/powered-by-imjoy-badge.svg" alt="powered by ImJoy">。<br>对于存储 ImJoy 插件的仓库，可以使用<img src="https://imjoy.io/static/badge/launch-imjoy-badge.svg" alt="launch ImJoy">徽章。<br>Markdown：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[![launch ImJoy](https:&#x2F;&#x2F;imjoy.io&#x2F;static&#x2F;badge&#x2F;launch-imjoy-badge.svg)](https:&#x2F;&#x2F;imjoy.io&#x2F;#&#x2F;app?plugin&#x3D;&lt;YOUR PLUGIN URL&gt;)</span><br></pre></td></tr></table></figure><br>reStructuredText：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.. image:: https:&#x2F;&#x2F;imjoy.io&#x2F;static&#x2F;badge&#x2F;launch-imjoy-badge.svg</span><br><span class="line"> :target: https:&#x2F;&#x2F;imjoy.io&#x2F;#&#x2F;app?plugin&#x3D;&lt;YOUR PLUGIN URL&gt;</span><br></pre></td></tr></table></figure></p><p>对于其他情况，例如，如果只是想感谢ImJoy，则可以使用<img src="https://imjoy.io/static/badge/powered-by-imjoy-badge.svg" alt="powered by ImJoy">。<br>Markdown:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[![powered by ImJoy](https:&#x2F;&#x2F;imjoy.io&#x2F;static&#x2F;badge&#x2F;powered-by-imjoy-badge.svg)](https:&#x2F;&#x2F;imjoy.io&#x2F;)</span><br></pre></td></tr></table></figure></p><p>reStructuredText:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.. image:: https:&#x2F;&#x2F;imjoy.io&#x2F;static&#x2F;badge&#x2F;powered-by-imjoy-badge.svg</span><br><span class="line"> :target: https:&#x2F;&#x2F;imjoy.io&#x2F;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">参考文献
Developing Plugins for ImJoy

上一篇文章中介绍了插件的文件格式，这一篇介绍如何进行实际的插件开发。

指定依赖
对于一个插件，其往往不是单一的功能实现，往往需要其他软件库的配合。
插件的依赖在其文件的config 块的requirements字段中进行指定。
根据不同的插件类型，可以指定不一样的依赖。

Web Worker 和 Window 插件
对于这两类插件，可以通过一个JavaScript库的url数组来指定依赖。这些库会被importScripts方法导入。
例如，要指定最新的 plotly.js 库，可以这样写：
1


&quot;requireme</summary>
    
    
    
    <category term="computer vision" scheme="http://qixinbo.github.io/categories/computer-vision/"/>
    
    
    <category term="ImJoy" scheme="http://qixinbo.github.io/tags/ImJoy/"/>
    
  </entry>
  
  <entry>
    <title>开源深度学习计算平台ImJoy解析：4 -- 插件文件格式</title>
    <link href="http://qixinbo.github.io/2021/12/04/ImJoy_4/"/>
    <id>http://qixinbo.github.io/2021/12/04/ImJoy_4/</id>
    <published>2021-12-03T16:00:00.000Z</published>
    <updated>2021-12-04T08:26:24.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://imjoy.io/docs/#/development">Developing Plugins for ImJoy</a></p><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>ImJoy插件文件本质上是包括一系列自定义块的html文件（受<code>.vue</code> 格式启发）。<br>如下是一个插件文件的典型组成。需要注意的是，这些块的顺序无关紧要，因此可以将块打乱。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">config</span> <span class="attr">lang</span>=<span class="string">&quot;json&quot;</span>&gt;</span></span><br><span class="line">   ** 该代码块以Json格式定义插件的属性**</span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">《script lang=&quot;javascript&quot;&gt;</span><br><span class="line">   ** 该代码块以JavaScript 或 Python 格式编写插件功能**</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">window</span> <span class="attr">lang</span>=<span class="string">&quot;html&quot;</span>&gt;</span></span><br><span class="line">   ** 该代码块以HTML 格式编写界面**（适用于window类型插件）</span><br><span class="line"><span class="tag">&lt;/<span class="name">window</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;css&quot;</span>&gt;</span></span><br><span class="line">   ** 该代码块以CSS 格式定义界面样式**（适用于window类型插件）</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">docs</span> <span class="attr">lang</span>=<span class="string">&quot;markdown&quot;</span>&gt;</span></span><br><span class="line">   ** 该代码块以Markdown 格式编写插件文档 **</span><br><span class="line"><span class="tag">&lt;/<span class="name">docs</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">attachment</span> <span class="attr">name</span>=<span class="string">&quot;XXXXX&quot;</span>&gt;</span></span><br><span class="line">   ** 该代码块用于存储文本数据**</span><br><span class="line"><span class="tag">&lt;/<span class="name">attachment</span>&gt;</span></span><br></pre></td></tr></table></figure><br>其中，只有<code>&lt;config&gt;</code>和<code>《script&gt;</code>这两个代码块是必须的，其他块都是可选的。</p><h1 id="config块"><a href="#config块" class="headerlink" title="config块"></a>config块</h1><p>使用 <a href="https://www.json.org/">JSON</a> 或 <a href="https://yaml.org/">YAML</a> 格式的字段来定义插件的通用属性。<br><code>json</code>格式的配置为（注意JSON本身不支持注释，所以下面#号以后的内容只是为了这里方便说明，实际要去除；一些需要详细解释的字段会在下面单独说明）：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">config</span> <span class="attr">lang</span>=<span class="string">&quot;json&quot;</span>&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;Untitled Plugin&quot;, # 插件名称。它必须是唯一的，以避免与其他插件冲突</span><br><span class="line">  &quot;type&quot;: &quot;web-worker&quot;, # 插件类型，选项有：`web-worker`、`window`、`native-python` 和`web-python`</span><br><span class="line">  &quot;ui&quot;: &quot;image processing&quot;, # 配置在插件下方显示的内容，详细用法将在下面详述</span><br><span class="line">  &quot;url&quot;: &quot;&quot;, # 当前文件的路径，用户从插件存储库安装插件时需使用该url来下载该插件</span><br><span class="line">  &quot;cover&quot;: &quot;&quot;, # 插件封面图片的url，详细用法将在下面详述</span><br><span class="line">  &quot;labels&quot;: [], # 定义一个“labels”列表来分类插件以允许基于语义标签进行搜索或过滤。</span><br><span class="line">  &quot;authors&quot;: [], # 作者姓名列表。</span><br><span class="line">  &quot;license&quot;: &quot;&quot;, # 插件所采用的许可证</span><br><span class="line">  &quot;repository&quot;: &quot;&quot;, # 插件项目存储库的url路径</span><br><span class="line">  &quot;website&quot;: &quot;&quot;, # 插件项目网站的url</span><br><span class="line">  &quot;tags&quot;: [], # 插件所支持的配置标签，详细用法将在下面详述</span><br><span class="line">  &quot;version&quot;: &quot;0.1.0&quot;, # 指定插件版本</span><br><span class="line">  &quot;api_version&quot;: &quot;0.1.6&quot;, # 指定插件所基于的 ImJoy 的 api 版本。</span><br><span class="line">  &quot;description&quot;: &quot;A plugin for image processing.&quot;, # 插件的简短描述</span><br><span class="line">  &quot;flags&quot;: [&quot;functional&quot;], # 用来控制插件行为，详细用法将在下面详述</span><br><span class="line">  &quot;icon&quot;: &quot;extension&quot;, # 定义插件菜单的图标，详细用法将在下面详述</span><br><span class="line">  &quot;inputs&quot;: null, # 定义用来触发插件的输入条件，比如拖进来一个文件，详细用法将在下面详述</span><br><span class="line">  &quot;outputs&quot;: null, # 定义插件的输出，详细用法将在下面详述</span><br><span class="line">  &quot;cmd&quot;: &quot;python&quot;, # 仅适用于python插件，用于运行插件的命令。默认情况下，它将使用`python`运行。根据安装的不同，它也可能是“python3”或“python27”等。</span><br><span class="line">  &quot;env&quot;: null, # 仅适用于python插件，虚拟环境或docker镜像命令，用于创建插件运行的环境。具体用法见另一篇博客的“指定依赖”一节</span><br><span class="line">  &quot;permissions&quot;: [], # 指定权限，详细用法将在下面详述</span><br><span class="line">  &quot;requirements&quot;: [], # 定义插件依赖，具体用法见另一篇博客的“指定依赖”一节</span><br><span class="line">  &quot;dependencies&quot;: [], # 指定当前插件依赖的其他ImJoy插件，详细用法将在下面详述</span><br><span class="line">  &quot;default&quot;: &#123;&#125;, # 仅适用于window插件，定义窗口的默认值，详细用法将在下面详述</span><br><span class="line">  &quot;base_frame&quot;: null, # 仅适用于window插件，定义在该窗口插件中内嵌的外部html的url路径，详细用法将在下面详述</span><br><span class="line">  &quot;runnable&quot;: true # 定义插件是否可以通过点击插件菜单来执行，详细用法将在下面详述</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure><br>而<code>yaml</code>格式的配置为:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">config</span> <span class="attr">lang</span>=<span class="string">&quot;yaml&quot;</span>&gt;</span></span><br><span class="line">name: Untitled Plugin</span><br><span class="line">type: web-worker</span><br><span class="line">tags: []</span><br><span class="line">ui: image processing</span><br><span class="line">cover: &#x27;&#x27;</span><br><span class="line">version: 0.1.0</span><br><span class="line">api_version: 0.1.6</span><br><span class="line">description: A plugin for image processing.</span><br><span class="line">icon: extension</span><br><span class="line">inputs: </span><br><span class="line">outputs: </span><br><span class="line">env: </span><br><span class="line">permissions: []</span><br><span class="line">requirements: []</span><br><span class="line">dependencies: []</span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="cover字段"><a href="#cover字段" class="headerlink" title="cover字段"></a>cover字段</h2><p><code>cover</code>字段用来指定插件封面图片的url，它将显示在图像安装对话框中，以及插件文档的顶部。<br>示例：<code>&quot;cover&quot;:&quot;https://imjoy.io/static/img/imjoy-card-plain.png&quot;</code>。<br>建议封面图片的纵横比为 16:9。 它可以托管在 GitHub 存储库中，此时应该使用图像的绝对路径URL。<br>可以使用多个图像，将 <code>cover</code> 设置为一个数组即可：<code>&quot;cover&quot;: [&quot;url_to_image1&quot;, &quot;url_to_image2&quot;, &quot;url_to_image3&quot;]</code>。</p><h2 id="tags字段"><a href="#tags字段" class="headerlink" title="tags字段"></a>tags字段</h2><p><code>tags</code>字段用来定义插件所支持的配置标签。<br>（注意：这里的<code>tags</code>不是用于分类或分组目的，分类或分组可以使用<code>labels</code>字段实现。）<br>这些定义的标签为插件执行提供了灵活的可配置的模式，比如可以配置插件是在 CPU 或 GPU 上运行。<br>以Unet Segmentation这个插件为例，如下是安装该插件时的界面及其源代码：<br><img src="https://user-images.githubusercontent.com/6218739/144185494-b3db5ddc-de2d-4d3b-a9fe-6e8549e062a5.png" alt="unet-tags"><br>可以看出，该插件在tags字段中定义了<code>CPU</code>、<code>GPU</code>、<code>Windows-CPU</code>、<code>Windows-GPU</code>四个标签，那么相应地，就可以在后面的环境配置和依赖库解析时，对其进行不同的要求：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;env&quot;</span>: </span><br><span class="line">&#123;<span class="string">&quot;CPU&quot;</span>: [<span class="string">&quot;conda config --add channels conda-forge&quot;</span>, <span class="string">&quot;conda create -n tf-cpu python=3.6&quot;</span>],</span><br><span class="line"><span class="string">&quot;GPU&quot;</span>: [<span class="string">&quot;conda config --add channels conda-forge&quot;</span>, <span class="string">&quot;conda create -n tf-gpu python=3.6&quot;</span>],</span><br><span class="line"><span class="string">&quot;Windows-CPU&quot;</span>: [<span class="string">&quot;conda config --add channels conda-forge&quot;</span>, <span class="string">&quot;conda create -n tf-cpu python=3.6&quot;</span>],</span><br><span class="line"><span class="string">&quot;Windows-GPU&quot;</span>: [<span class="string">&quot;conda config --add channels conda-forge&quot;</span>, <span class="string">&quot;conda create -n tf-gpu python=3.6&quot;</span>]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;requirements&quot;</span>: </span><br><span class="line">&#123;<span class="string">&quot;CPU&quot;</span>: [<span class="string">&quot;repo:https://github.com/zhixuhao/unet&quot;</span>, <span class="string">&quot;pip:h5py scikit-image keras==2.1.4 numpy==1.18.0 tensorflow==1.15.4&quot;</span>],</span><br><span class="line"><span class="string">&quot;GPU&quot;</span>: [<span class="string">&quot;repo:https://github.com/zhixuhao/unet&quot;</span>, <span class="string">&quot;pip:h5py scikit-image keras==2.1.4 numpy==1.18.0 tensorflow-gpu==1.15.4&quot;</span>],</span><br><span class="line"><span class="string">&quot;Windows-CPU&quot;</span>: [<span class="string">&quot;repo:https://github.com/zhixuhao/unet&quot;</span>, <span class="string">&quot;pip:h5py scikit-image keras==2.1.4 numpy==1.18.0 tensorflow==1.15.4&quot;</span>],</span><br><span class="line"><span class="string">&quot;Windows-GPU&quot;</span>: [<span class="string">&quot;repo:https://github.com/zhixuhao/unet&quot;</span>, <span class="string">&quot;pip:h5py scikit-image keras==2.1.4 numpy==1.18.0 tensorflow-gpu==1.15.4&quot;</span>]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><br>如果插件定义了tags，它们将出现在代码编辑器的顶部以及安装过程中。如果使用<code>url</code>分发插件，还可以具体指定插件将使用哪个标签安装。<br>在<code>&lt;config&gt;</code>代码块中，以下字段可以被tags所配置：<code>env</code>、<code>requirements</code>、<code>dependencies</code>、<code>icon</code>、<code>ui</code>、<code>type</code>、<code>flags</code>、<code>cover</code>。<br><code>&lt;script&gt;</code>代码块也可以被tags配置，此时必须把<code>tags</code>字段作为属性放到<code>&lt;script&gt;</code>中，同时注意原来的<code>lang</code>属性还要保留。比如：开发者可能想在插件的稳定版和开发版之间自由切换。那么可以定义这样的标签： <code>&quot;tags&quot;: [&quot;stable&quot;, &quot;dev&quot;]</code>，同时定义两个脚本块：<code>&lt;script lang=&quot;python&quot; tag=&quot;stable&quot;&gt;</code> 和 <code>&lt;script lang=&quot;python &quot;tag=&quot;dev&quot;&gt;</code>。在开发和测试插件时，ImJoy 编辑器会识别插件有多个标签，此时选择其中一个标签，那么加载插件时就会加载此标签下的相应代码。</p><h2 id="ui字段"><a href="#ui字段" class="headerlink" title="ui字段"></a>ui字段</h2><p><code>ui</code>字段是为了配置在插件下方显示的内容。<br>以HPA Classification插件为例，安装完成后，在ImJoy的左侧插件区，点击插件右侧的箭头，会看到<code>ui</code>字段定义的内容：<br><img src="https://user-images.githubusercontent.com/6218739/144191940-48d0ab2b-5c8c-4607-9543-b05daf28a1ee.png" alt="hpa-ui"></p><p>以下是<code>ui</code>字段的一个详细用法示例：<br><img src="https://user-images.githubusercontent.com/6218739/144377959-51a13531-9ce3-4752-8c13-7d841bcec51d.png" alt="ui-full"><br>包含了各种输入框的用法，以及同一个ui的三种写法：<code>option1</code>、<code>option11</code>、<code>option12</code>。<br>对于每个元素，都定义了一个唯一的<code>id</code>，然后可以使用 <code>ctx.config.id</code>来访问插件中此元素的值。</p><h2 id="flags字段"><a href="#flags字段" class="headerlink" title="flags字段"></a>flags字段</h2><p><code>flags</code>字段定义一个标志数组，用来控制插件的行为。<br>一个重要的flag是 <code>functional</code>：<code>functional</code>标志表示插件暴露的所有api函数都是<a href="https://segmentfault.com/a/1190000039807327">纯函数</a>。这意味着它们的输出将仅取决于输入。同时纯函数保证在调用任何插件 api 函数之后对插件没有副作用。这意味着应该避免修改插件函数中的全局变量（不过一个例外是<code>setup()</code> 函数）。<br>使一个插件具有<code>functional</code>标志，可以使调试更容易，重要的是其他插件或工作流调用<code>functional</code>插件时能严格重现其行为。<code>functional</code>插件对于 ImJoy 在将来执行并行化和批处理时至关重要。<br>作者还没有编写真正的测试来验证插件是否是<code>functional</code>，所以当前需要确定自己的插件仅包含纯函数时才添加 <code>functional</code> 标志。<br>此外，<code>flags</code>还支持运行时控制。这些标志允许用户界面和插件引擎如何处理 ImJoy 实例：</p><ul><li><code>single-instance</code>（仅适用于 python 插件）：在此标志下，Python引擎只会运行一个插件进程，即使从不同的浏览器或工作区调用了该插件。在这种情况下，不同的 ImJoy 实例将共享相同的插件进程。当插件需要独占有限的资源（例如 GPU）时，这尤其有用。</li><li><code>allow-detach</code>（仅适用于 python 插件）：在此标志下，允许插件进程与用户界面分离。这意味着当用户界面断开或关闭时，插件不会被杀死。然而，为了重新连接到这个进程，需要从同一个浏览器和相同的工作区重新连接，或添加 <code>single-instance</code> 标志。比如：如果想制作一个插件，它可以在没有用户界面的情况下在后台运行，那就对该插件赋予<code>&quot;flags&quot;: [&quot;single-instance&quot;, &quot;allow-detach&quot;]</code>。那么重新启动时，用户界面将自动重新连接到此进程。需要注意的是，如果多个 ImJoy 实例附加到此插件进程，每个实例都会调用 <code>setup()</code> 函数。这可能会导致冲突，因此建议 (1) 将与接口相关的代码保留在 <code>setup()</code> 中，例如<code>api.register()</code>; (2)将只想每个进程运行一次的代码移动到插件类的<code>__init__</code> 函数中。</li></ul><h2 id="icon字段"><a href="#icon字段" class="headerlink" title="icon字段"></a>icon字段</h2><p>定义插件菜单中使用的图标。可以选择以下格式：<br>（1）在<a href="https://material.io/tools/icons/">https://material.io/tools/icons/</a>找到图标，直接使用指定的名称即可；<br><img src="https://user-images.githubusercontent.com/6218739/144605127-ece26296-0933-4534-a798-cba6c4f0ace5.png" alt="icon"><br>实测使用该网站上的图标名称时，不能使用带空格的名称，以及全部要用小写。<br>（2）可以直接复制粘贴emoji符号，例如从<a href="https://getemoji.com/">这里</a>。<br><img src="https://user-images.githubusercontent.com/6218739/144605559-f3a9798b-23e1-4427-8185-3de397873d6c.png" alt="emoji"><br>（3）指定 JPEG、PNG 或 GIF 格式图像的 URL，推荐大小：64x64。<br><img src="https://user-images.githubusercontent.com/6218739/144605914-ada14870-30c1-45f8-b563-db5439a4710f.png" alt="gif-icon"><br>（4）如果设置为<code>null</code>或<code>&quot;&quot;</code>，它会默认使用第一条的material icon的<code>extension</code>图标。</p><h2 id="inputs字段"><a href="#inputs字段" class="headerlink" title="inputs字段"></a>inputs字段</h2><p>定义用于触发插件的输入条件，包括文件输入或数据匹配模式。例如，当用户将某个后缀的文件拖放到工作区时，相应的插件被激活。<br>基本上可以使用标准的 json 模式（<a href="http://json-schema.org/）来验证输入数据对象。例如，要定义插件使用">http://json-schema.org/）来验证输入数据对象。例如，要定义插件使用</a> png 文件，可以指定 <code>&quot;inputs&quot;: &#123;&quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: &#123;&quot;name&quot;: &#123;&quot;type&quot;: &quot;string&quot;, &quot;maxLength&quot; : 100&#125;&#125;, &quot;required&quot;: [&quot;name&quot;]&#125;</code>。在后台，ImJoy使用 <a href="https://github.com/epoberezkin/ajv">ajv</a> 库来验证对象。为了简化模式的使用，还使用以下关键字扩展了标准的 json 模式：<br>（1）<code>file</code>：对于文件对象，使用 <a href="https://en.wikipedia.org/wiki/Media_type">mime types</a> 或文件扩展名。可以使用以下关键字之一：</p><ul><li><code>mime</code>：常见的 mime 类型字符串（或列表）。例如<code>&#123;&quot;file&quot;: &#123;&quot;mime&quot;: &quot;image/png&quot;&#125;&#125;</code>。还可以指定一个 mime 类型列表：<code>&quot;mime&quot;: [&quot;image/png&quot;, &quot;image/jpeg&quot;, &quot;image/tiff&quot;]</code>。</li><li><code>ext</code>：文件扩展名字符串（或列表）。例如<code>&#123;&quot;file&quot;: &#123;&quot;ext&quot;: &quot;png&quot;&#125;&#125;</code>，或者可以指定一个扩展名列表：<code>&#123;&quot;file&quot;: &#123;&quot;ext&quot;: [&quot;png&quot;, &quot;jpg&quot;, &quot; jpeg&quot;]&#125;&#125;</code>。</li></ul><p>（2）<code>ndarray</code>：例如<code>&#123;&quot;ndarray&quot;: &#123;&quot;shape&quot;: [10, 10], &quot;dtype&quot;: &quot;uint8&quot;&#125;&#125;</code>。</p><ul><li><code>shape</code>：数组的形状。需要为每个维度指定一个数字，或者使用 <code>null</code> 表示该维度的任何大小。例如：<code>&#123;&quot;type&quot;: &quot;ndarray&quot;, &quot;shape&quot;: [10, 10]&#125;</code>，或者如果第一维可以是任意大小：<code>&#123;&quot;type&quot;: &quot;ndarray&quot;, &quot;shape&quot;: [null，10]&#125;</code></li><li><code>dtype</code>：数组的数据类型。例如：<code>&#123;&quot;ndarray&quot;: &#123;&quot;dtype&quot;: &quot;uint8&quot;&#125;&#125;</code> 或者如果同时支持 <code>uint8</code> 和 <code>float32</code>：<code>&#123;&quot;ndarray&quot;: &#123;&quot;dtype&quot;: [&quot;uint8&quot;, &quot; float32&quot;]&#125;&#125;</code>。支持的 <code>dtype</code> 是：<code>[&quot;int8&quot;, &quot;int16&quot;, &quot;int32&quot;, &quot;uint8&quot;, &quot;uint16&quot;, &quot;uint32&quot;, &quot;float32&quot;, &quot;float64&quot;, &quot;array&quot;]</code>。</li><li><code>ndim</code>：维数。例如：<code>&#123;&quot;ndarray&quot;: &#123;&quot;ndim&quot;: 2&#125;&#125;</code> 或者如果同时支持 2D 和 3D：<code>&#123;&quot;ndarray&quot;: &#123;&quot;ndim&quot;: [2, 3]&#125;&#125;</code></li></ul><p>（3）对于通过 http 或其他协议暴露的远程 url，<code>&#123;&quot;type&quot;: &quot;url&quot;, &quot;extension&quot;: &quot;zarr&quot;&#125;</code>。<br>另外需注意，如果在模式中使用正则表达式来验证字符串，可能需要设置 <code>maxLength</code>，否则它会非常慢，甚至在验证长字符串时可能会崩溃。例如，如果想匹配一个包含以<code>.tiff</code>结尾的<code>file_name</code>的对象，那么可以这样设置：<code>&#123;&quot;properties&quot;: &#123;&quot;file_name&quot;: &#123;&quot;type&quot;: &quot;string&quot;,&quot;pattern&quot;: &quot;.*\\.tiff$&quot;, &quot;maxLength&quot;: 1024&#125;&#125;&#125;</code>。</p><h2 id="outputs字段"><a href="#outputs字段" class="headerlink" title="outputs字段"></a>outputs字段</h2><p>使用 json-schema 语法 (<a href="http://json-schema.org/">http://json-schema.org/</a>) 定义输出。<br>格式与<code>inputs</code>相同。</p><h2 id="permissions字段"><a href="#permissions字段" class="headerlink" title="permissions字段"></a>permissions字段</h2><p>对于 <code>window</code> 插件，可以声明以下权限：</p><ul><li>摄像头camera</li><li>音乐数字接口midi</li><li>地理位置geolocation</li><li>麦克风microphone</li><li>加密媒体encryted-media</li><li>全屏full-screen</li><li>支付请求payment-request</li></ul><p>例如，如果某个<code>window</code>插件需要网络摄像头的访问权限，需要添加以下权限：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“permissions”：[“camera”]，</span><br></pre></td></tr></table></figure><br>注意，摄像头和麦克风等设备只有在 ImJoy 为 <code>https</code> 时才能工作，这意味着如果是从<a href="https://imjoy.io">https://imjoy.io</a> 运行这个插件，那么是可以工作的，但如果使用的是自己托管的以<code>http</code>协议访问的ImJoy服务器，那么它就不会运行。解决方法是使用隧道服务，例如使用 <a href="https://telebit.cloud">Telebit</a> 或 <a href="https://ngrok.com">ngrok</a> 将 <code>http</code> url 转换为 <code>https</code>。</p><h2 id="dependencies字段"><a href="#dependencies字段" class="headerlink" title="dependencies字段"></a>dependencies字段</h2><p>该字段指定当前插件依赖的其他ImJoy插件。这些所依赖的插件将在安装过程中自动安装。<br>要定义依赖项，请使用以下格式：<br>1) 对于没有tag的依赖，使用 <code>REPOSITORY:PLUGIN_NAME</code> 或 <code>PLUGIN_URL</code>，例如：<code>imjoy-team/imjoy-plugins:Image Window</code>；<br>2) 对于带有指定tag的依赖，使用<code>REPOSITORY:PLUGIN_NAME@TAG</code> 或<code>PLUGIN_URL@TAG</code>，例如：<code>imjoy-team/imjoy-plugins:Unet Segmentation@GPU</code>。在这种情况下，标签“GPU”用于指定托管在 GitHub 存储库<code>imjoy-team/imjoy-plugins</code>（<a href="https://github.com/imjoy-team/）上的名为`Unet">https://github.com/imjoy-team/）上的名为`Unet</a> Segmentation<code>的插件。如果插件没有托管在GitHub上或者该GitHub仓库不是ImJoy插件仓库的标准格式（即在仓库的根目录中没有定义</code>manifest.imjoy.json<code>文件），则可以直接使用 url，例如：</code><a href="https://github.com/imjoy-team/imjoy-demo-plugins/blob/master/repository/3dDemos.imjoy.html`（标签可以用`@TAG`添加）。">https://github.com/imjoy-team/imjoy-demo-plugins/blob/master/repository/3dDemos.imjoy.html`（标签可以用`@TAG`添加）。</a></p><h2 id="default字段"><a href="#default字段" class="headerlink" title="default字段"></a>default字段</h2><p>仅适用于<code>window</code>插件，用于定义一个对象的默认值。<br>例如，可以通过设置 <code>&quot;defaults&quot;: &#123;&quot;w&quot;: 10, &quot;h&quot;: 7&#125;</code> 来指定默认窗口大小。<br>或者，可以使用 <code>&quot;defaults&quot;: &#123;&quot;fullscreen&quot;: true&#125;</code> 默认使窗口处于全屏模式。<br>要使窗口默认处于独立模式（全屏并与工作区分离），可以设置 <code>&quot;defaults&quot;: &#123;&quot;standalone&quot;: true&#125;</code>。<br>如果要将窗口显示为对话框，设置 <code>&quot;defaults&quot;: &#123;&quot;as_dialog&quot;: true&#125;</code>。</p><h2 id="base-frame字段"><a href="#base-frame字段" class="headerlink" title="base_frame字段"></a>base_frame字段</h2><p>仅适用于window插件，定义在该窗口插件中内嵌的外部html的url路径。<br>虽然可以在<code>base_frame</code>字段中使用任何其他网站的url，但是为了Imjoy内核可以与该html进行通信，它需要满足以下条件：<br>（1）该网站需要允许嵌入，不过这并不总是能够有效，因为它们可能有严格的 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP">内容安全策略</a>的限制，通常是通过<code>X-Content-Security-Policy</code>的header，或页面中的 <code>&lt;meta&gt;</code> 元素来实现该限制。要解决这个问题，如果你可以控制该站点，需要将 <code>*.imjoy.io</code> 添加到header中。<br>（2）在<code>base_frame</code>里面，需要开启<code>imjoy-rpc</code>协议。这可以按照 <a href="https://github.com/imjoy-team/ImJoy-core">imjoy-core</a> 仓库中的说明轻松搞定。参考“ImJoy RPC library to your website”这一部分进行操作，基本上就是需要导入<code>imjoy-loader</code>，并加载imjoy RPC库，然后导出想公开给其他ImJoy插件的api。<br>完成上述操作后，就可以将第三方网站集成为一个ImJoy插件。</p><h2 id="runnable"><a href="#runnable" class="headerlink" title="runnable"></a>runnable</h2><p>定义插件是否可以通过点击插件菜单来执行（默认情况下，所有插件都是<code>runnable</code>）。<br>对于不单独运行的辅助插件，（例如，<code>native-python</code> 插件可以被<code>window</code> 插件调用，不一定由用户直接执行），设置<code>&quot;runnable&quot;: false</code> 会向下移动插件到插件菜单的底部，并使其不可点击。</p><h1 id="docs块"><a href="#docs块" class="headerlink" title="docs块"></a>docs块</h1><p>在该块中，使用 Markdown 语言来编写插件文档。<br>Markdown语言的介绍见<a href="https://guides.github.com/features/mastering-markdown/">这里</a>。<br>注意，如果在文档中提供的链接将在另一个选项卡中打开，则 ImJoy 实例将继续运行。</p><h1 id="window块"><a href="#window块" class="headerlink" title="window块"></a>window块</h1><p>在该块中，使用HTML 代码来编写窗口的显示内容。<br>ImJoy 使用 vue.js 来解析插件文件，它强制要求仅有根元素存在于模板中。这意味着在<code>&lt;window&gt;</code>块中必须使用一个<code>div</code>来包装所有节点：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">window</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span> line 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span> line 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">window</span>&gt;</span></span><br></pre></td></tr></table></figure><br>如下则不可以：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">window</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span> line 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span> line 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">window</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="style块"><a href="#style块" class="headerlink" title="style块"></a>style块</h1><p>在该块中，使用CSS 代码来编写窗口显示内容的样式。</p><p>以MNIST CNN插件为例，给出以上<code>&lt;window&gt;</code>块和<code>style</code>块的一个说明：<br><img src="https://user-images.githubusercontent.com/6218739/144701434-77ef0f5c-f952-4bdf-aec7-c5c7209ae7cb.png" alt="html-css"></p><h1 id="script块"><a href="#script块" class="headerlink" title="script块"></a>script块</h1><p>该块中包含实际的插件代码。<br>插件可以用 JavaScript 或 Python 编写，一个最小的插件需要实现两个函数：<code>setup()</code> 和 <code>run()</code>。有一个例外是那种辅助插件（用 <code>&quot;runnable&quot;: false</code> 指定），它不需要 <code>run()</code> 函数。<br>（1）<code>setup()</code> 函数：在插件第一次加载和初始化时执行它。<br>（2）<code>run()</code> 函数：每次执行插件时都会调用。执行时，一个带有上下文（名为“ctx”）的对象object（Javascript插件）或字典dictionary（Python插件）将被传递到函数中。返回的结果将显示为一个新窗口或传递给工作流中的下一个 <code>op</code>。更多内容请参见另一篇博客的 <a href="development?id=plugin-during-runtime">运行时插件</a> 部分。<br>（3）可选：<code>resume()</code> 函数：仅适用于带有 <code>allow-detach</code> 标志的可分离 <code>native-python</code> 插件。当ImJoy 重新连接到正在运行的插件进程时，<code>resume()</code> 将被调用（而不是 <code>setup()</code>） 。<br>（4）可选：<code>update()</code> 函数：将在操作的任何设置更改时调用。<br>（5）可选：<code>exit()</code>函数：当插件被杀死时，函数<code>exit</code> 将被调用。</p><p><code>&lt;script&gt;</code> 块的 <code>lang</code> 属性用于指定使用的编程语言：<br>（1）对于 Javascript，使用 <code>&lt;script lang=&quot;javascript&quot;&gt; ... &lt;/script&gt;</code><br>（2）对于 Python，使用 <code>&lt;script lang=&quot;python&quot;&gt; ... &lt;/script&gt;</code><br>对于 Javascript 插件，还支持 ES 模块，要启用它，将 <code>type=&quot;module&quot;</code> 添加到<code>&lt;script&gt;</code>标签中。例如：<code>&lt;script type=&quot;module&quot; lang=&quot;javascript&quot;&gt;...&lt;/script&gt;</code>。<br><code>&lt;script&gt;</code> 也支持 <code>tags</code>，有关信息参考上面的<code>tags</code>字段的解析。</p>]]></content>
    
    
    <summary type="html">参考文献
Developing Plugins for ImJoy

概览
ImJoy插件文件本质上是包括一系列自定义块的html文件（受.vue 格式启发）。
如下是一个插件文件的典型组成。需要注意的是，这些块的顺序无关紧要，因此可以将块打乱。
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23


&lt;config lang=&quot;json&quot;&gt;
   ** 该代码块以Json格式定义插件的属性**
&lt;/config&gt;

《script lang=&quot;javascript&quot;&gt;
   ** 该代码块以JavaScript 或 Pyth</summary>
    
    
    
    <category term="computer vision" scheme="http://qixinbo.github.io/categories/computer-vision/"/>
    
    
    <category term="ImJoy" scheme="http://qixinbo.github.io/tags/ImJoy/"/>
    
  </entry>
  
  <entry>
    <title>开源深度学习计算平台ImJoy解析：3 -- 插件概览</title>
    <link href="http://qixinbo.github.io/2021/12/01/ImJoy_3/"/>
    <id>http://qixinbo.github.io/2021/12/01/ImJoy_3/</id>
    <published>2021-11-30T16:00:00.000Z</published>
    <updated>2021-12-01T02:12:53.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://imjoy.io/docs/#/i2k_tutorial?id=_2-make-your-first-imjoy-plugin">I2K Workshop Tutorial</a><br><a href="https://imjoy.io/docs/#/development">Developing Plugins for ImJoy</a></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>开发ImJoy插件既简单又快速，可直接使用运行在web上的内置的代码编辑器，而不需要额外的 IDE 或编译器。<br>ImJoy 插件系统的主要功能有：<br>（1）支持 Python 和 JavaScript</p><ul><li>JavaScript 插件与安全沙箱隔离</li><li>Python 插件在自己的进程中运行</li><li>使用 <code>async/await</code> 语法支持并发 API 调用</li><li>支持 Python 的虚拟环境和 pip 包</li><li>支持托管在 GitHub 或 CDN 上的 JavaScript 库</li></ul><p>（2）原生支持 n 维数组和张量</p><ul><li>支持来自 Numpy 或 Numjs 的 ndarrays 进行数据交换</li><li>支持用于深度学习的 Tensorflow.js 和原生 Tensorflow、PyTorch、MxNet等深度学习库</li></ul><p>（3）使用 webGL、Three.js 等3D库渲染多维数据<br>（4）使用 GitHub 部署自定义的插件</p><h1 id="ImJoy架构"><a href="#ImJoy架构" class="headerlink" title="ImJoy架构"></a>ImJoy架构</h1><p>Imjoy 包含<strong>两个主要组件</strong>：<br>（1）<strong>ImJoy Web App</strong>：这是ImJoy 的核心部分，它是一个web应用，所以可在不同操作系统和设备的浏览器中运行。它提供了一个灵活的插件系统，具有工作流和窗口管理功能。插件可以用不同的编程语言开发，包括 JavaScript 和 Python。插件及其源代码可以组织到工作区中并存储在浏览器数据库中。 Web 插件在 <code>iframe</code> 或 <code>webworker</code> 中运行，因此开发者原则上可以为每个插件独立使用任何前端框架或 javascript 库。<br>（2）<strong>Plugin Engine</strong>：这是一个可选项，其用于在 CPython 中运行计算任务，以利用本机硬件（例如 GPU）和Python软件库（例如：numpy、Tensorflow、PyTorch 等）的强大功能。实际上，该插件引擎是一个在后台运行并通过 websocket 连接到 ImJoy Web App 的 Python 包 (<a href="https://github.com/imjoy-team/imjoy-engine">GitHub</a>)。它使用 <a href="https://conda.io/">conda</a> 来管理软件包（不仅是 Python，还有 C++、Java 等）和虚拟环境。然后开发者可以将具体的<code>conda</code> 或 <code>pypi</code> 包作为需求添加到插件中，它们可以由插件引擎自动解析。同样，开发人员可以在 Python 插件中使用任何 Python 库甚至非 Python 库。<br><img src="https://user-images.githubusercontent.com/6218739/144013956-2be625bd-3a30-4c10-be13-c138513d25be.png" alt="full-arch"></p><p>Plugin Engine 通过 websockets 与 ImJoy Web App 连接， 并与一个基于 <a href="https://github.com/miguelgrinberg/python-socketio">socket.io</a> 定制化的RPC（remote procedure calls）进行通信。</p><h1 id="什么是ImJoy插件"><a href="#什么是ImJoy插件" class="headerlink" title="什么是ImJoy插件"></a>什么是ImJoy插件</h1><p>简而言之，ImJoy插件是一个脚本，它生成一组可以被ImJoy内核或其他插件调用的服务函数（又名插件 API 函数）。<br>目前有 4 种常见的插件类型：<code>window</code>、<code>web-worker</code>、<code>web-python</code>、<code>native-python</code>。<br>（1）Web 插件直接在浏览器中运行，支持如下三种类型：</p><ul><li>Window (HTML/CSS/JS)(<code>type=window</code>) 插件，用于使用 HTML5/CSS 和 JavaScript 构建丰富的交互式用户界面；</li><li>Web Worker (JS)(type=<code>web-worker</code>) 插件，用于使用 JavaScript 或 WebAssembly 执行计算任务；</li><li>Web Python(type=<code>web-python</code>) 插件，用于在浏览器中通过 WebAssembly 和 <a href="https://github.com/iodide-project/pyodide">pyodide</a> 使用 Python 执行计算任务。这样的插件用小蛇🐍图标表示。这处于开发阶段，目前仅支持选定数量的 Python 库。</li></ul><p>（2）Native插件在插件引擎中运行，目前支持：</p><ul><li>Native Python(type=<code>native-python</code>) 插件，可使用 Python 及其大量库函数来执行繁重计算任务，不过这需要额外安装插件引擎。这些插件用火箭🚀图标表示。</li></ul><h2 id="Window插件"><a href="#Window插件" class="headerlink" title="Window插件"></a>Window插件</h2><p>Window 插件用于创建一个包含 HTML/CSS 和 JavaScript 的新 Web 界面。其是在<code>iframe</code>模式下创建的，将显示为一个窗口。 <code>&lt;window&gt;</code> 和 <code>&lt;style&gt;</code>块（见以后插件文件格式的详细解析）可用于定义窗口的实际内容。<br>不同于其他插件会在 ImJoy 启动时加载和初始化，只有在使用<code>api.createWindow</code>创建实际插件或用户在菜单中单击时，才会加载<code>window</code>插件。在<code>api.createWindow</code>执行过程中，<code>setup</code>和<code>run</code>会被首先调用，并返回一个窗口api对象（包含窗口的所有api函数，包括<code>setup</code>、<code>run</code>和其他功能（如果已定义））。然后就可以使用这个window api 对象来访问所有的函数，例如通过<code>win_obj.run(&#123;&#39;data&#39;: ... &#125;)</code> 来更新窗口的内容。</p><h2 id="Web-Worker插件"><a href="#Web-Worker插件" class="headerlink" title="Web Worker插件"></a>Web Worker插件</h2><p>Web Worker插件用于在另一个线程中执行计算任务，具体途径是使用一个名为 <a href="https://en.wikipedia.org/wiki/Web_worker">web worker</a> 的新元素。<br>它没有接口，是在一个新线程中运行，并且在运行过程中不会挂起主线程。它基本上是 JavaScript 实现多线程的一种方式。<br>由于 Web Worker 旨在执行计算任务，它们无权访问 <a href="https://www.w3schools.com/whatis/whatis_htmldom.asp">html dom</a>，但是开发者可以使用<code>ImJoy API</code>来与ImJoy的图形界面或其他可以触发用户界面更改的插件进行交互。</p><h2 id="Web-Python插件"><a href="#Web-Python插件" class="headerlink" title="Web Python插件"></a>Web Python插件</h2><p>Web Python插件可以完全在浏览器中运行 python 代码和科学库。ImJoy 使用 <a href="https://github.com/iodide-project/pyodide/">pyodide</a> 来运行 python 插件，它支持通过 WebAssembly 运行带有科学库（包括 numpy、scipy、scikit-learn 等）的 Python3 代码。</p><h2 id="Native-Python插件"><a href="#Native-Python插件" class="headerlink" title="Native Python插件"></a>Native Python插件</h2><p>Native Python插件用于运行原生 Python 代码以完全访问电脑硬件（例如 GPU、NVLINK）和软件（例如 CUDA 和 CUDNN）环境。这需要在使用插件之前安装并启动<strong>Python Plugin Engine</strong>。<br>与 Web Worker 插件类似，Native Python 插件无法访问 html dom，但可以使用 <code>ImJoy API</code> 与ImJoy 的图形界面或其他可以触发用户界面更改的插件进行交互。</p><h2 id="更多插件类型"><a href="#更多插件类型" class="headerlink" title="更多插件类型"></a>更多插件类型</h2><p>插件类型可以通过插件进一步扩展。例如，作者新创建一个新的插件类型来执行Fiji/Scijava脚本，参见 <a href="https://forum.image.sc/t/making-imjoy-plugins-with-fiji-scripts-for-running-remotely/39503">这篇文章</a>。</p><h2 id="ImJoy-App和Plugin-Engine与插件的关系"><a href="#ImJoy-App和Plugin-Engine与插件的关系" class="headerlink" title="ImJoy App和Plugin Engine与插件的关系"></a>ImJoy App和Plugin Engine与插件的关系</h2><p>使用 ImJoy App 的推荐方式是通过 <a href="https://imjoy.io">https://imjoy.io</a>。<br>不过ImJoy还不是普通的web应用，它是采用了称为渐进式 Web 应用 (PWA) 的新方法。例如，在 Chrome 中，用户可以将 ImJoy 安装到 <a href="chrome://apps/">chrome://apps/</a> 并从这个仪表板中启动ImJoy（同时生成桌面快捷方式）。一旦安装，ImJoy 就可以在独立的浏览器窗口中运行（没有地址栏）。 ImJoy 的内核部分支持离线，但插件目前还不支持（作者说后面将支持）。<br>可以使用ImJoy App运行所有web插件（<code>web-worker</code>、<code>window</code>、<code>web-python</code>），但是，对于本机插件（<code>native-python</code>），需要连接到插件引擎在本地或远程运行。<br>以下是安装插件引擎的两个选项：<br>（1）本地安装：下载并安装 Anaconda 或 Miniconda with Python3，然后运行<code>pip install imjoy</code>。然后可以通过 <code>imjoy --jupyter</code> 命令启动插件引擎。更多详细信息可在 <a href="https://github.com/imjoy-team/imjoy-engine/">此处</a> 获得。<br>（2）使用Jupyter托管服务：使用<a href="https://mybinder.org/">binder</a>提供的免费Jupyter服务器，该服务是远程的，所以不需要额外安装。然而，其提供的算力也有限（比如1GB内存、无GPU支持等）。<br><img src="https://user-images.githubusercontent.com/6218739/144159316-243a6048-fb9e-4201-965c-fa11db4c9ded.png" alt="engines"></p><h1 id="ImJoy代码编辑器和开发人员工具"><a href="#ImJoy代码编辑器和开发人员工具" class="headerlink" title="ImJoy代码编辑器和开发人员工具"></a>ImJoy代码编辑器和开发人员工具</h1><p>ImJoy提供了一个内置的代码编辑器供编写插件。结合浏览器提供的调试工具（例如：Google Chrome 开发者工具），不需要额外的 IDE 或工具。<br>可以通过单击插件菜单（插件名称旁边的图标）中的“Edit”来查看和修改任何现有插件的插件代码。<br><img src="https://user-images.githubusercontent.com/6218739/144052196-ace51e31-757c-4519-988d-904bb3a1d89a.png" alt="editor"></p><p><a href="https://developers.google.com/web/tools/chrome-devtools">Chrome 开发者工具</a> 提供了不同的调试HTML/CSS/Javascript、网络等的工具。建议使用它来调试Web插件。例如，可以像正常JavaScript开发那样在JavaScript中使用 <code>console.log()</code>、<code>console.error()</code>等，然后在浏览器控制台中检查日志和错误。在Python插件中，错误追溯也会转发到浏览器控制台。<br><img src="https://user-images.githubusercontent.com/6218739/144053608-0dd72e3b-752f-4f66-98e7-52ac4ade46c5.png" alt="chrome"><br>除此之外，还可以使用ImJoy API函数，包括 <code>api.log()</code>、<code>api.error()</code>、<code>api.alert()</code>、<code>api.showMessage()</code> 等来向ImJoy应用程序显示消息。<br>特别地，对于Python插件，<code>print()</code>只会在启动插件引擎的终端中看到，因此建议开发Python插件时使用这些API函数来辅助debug。</p><h1 id="ImJoy插件文件格式"><a href="#ImJoy插件文件格式" class="headerlink" title="ImJoy插件文件格式"></a>ImJoy插件文件格式</h1><p>ImJoy插件通常是一个扩展名为<code>*.imjoy.html</code>的文本文件。其中使用HTML/XML标签，例如 <code>&lt;config&gt;</code>、<code>&lt;script&gt;</code>、<code>&lt;window&gt;</code> 来存储代码块。<br>大多数插件类型至少需要两个代码块：<code>&lt;config&gt;</code> 和<code>&lt;script&gt;</code>，例如<code>web-worker</code>、<code>web-python</code> 和<code>native-python</code>。对于<code>window</code> 插件，代码中需要额外一个<code>&lt;window&gt;</code> 块，以及一个可选<code>&lt;style&gt;</code> 块用于CSS定义。</p><p>对于<code>&lt;script&gt;</code>代码块，大多数插件至少会暴露两个特殊函数：<code>setup</code>（用于初始化）和<code>run</code>（当用户点击插件菜单按钮时调用）。在加载插件时，一个包含所有ImJoyAPI函数的<code>api</code>对象将被传递给插件，然后插件可以构建服务函数并通过调用 <code>api.export(...)</code> 函数来注册它们。</p><p>比如以下插件中定义了 3 个 API 函数：一个空的 <code>setup</code> 函数，一个 <code>choosePokemon</code> 函数，以及一个可供调用的 <code>run</code> 函数（由 ImJoy内核调用或用户点击插件菜单时）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImJoyPlugin</span></span>&#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">choosePokemon</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> pokemon = <span class="keyword">await</span> api.prompt(<span class="string">&quot;What is your favorite Pokémon?&quot;</span>, <span class="string">&quot;Pikachu&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> api.showMessage(<span class="string">&quot;Your have chose &quot;</span> + pokemon + <span class="string">&quot; as your Pokémon.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">run</span>(<span class="params">ctx</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="built_in">this</span>.choosePokemon()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">api.export(<span class="keyword">new</span> ImJoyPlugin())</span><br></pre></td></tr></table></figure><br>关于 ImJoy 插件文件的详细说明可以在这里找到：<a href="https://imjoy.io/docs/#/development?id=plugin-file-format">插件文件格式</a>。</p><h1 id="ImJoy的Hello-World插件"><a href="#ImJoy的Hello-World插件" class="headerlink" title="ImJoy的Hello World插件"></a>ImJoy的Hello World插件</h1><p>要制作第一个 ImJoy 插件，即ImJoy的Hello World，可以单击<code>+ PLUGINS</code>，然后从<code>+ CREATE A NEW PLUGIN</code>下拉菜单中选择默认模板<code>Default template</code>。<br><img src="https://user-images.githubusercontent.com/6218739/144052725-44768110-a754-4cce-a9fb-8f70a2bcbfc7.png" alt="helloworld"><br>生成的插件代码为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;docs&gt;</span><br><span class="line">[TODO: write documentation <span class="keyword">for</span> <span class="built_in">this</span> plugin.]</span><br><span class="line">&lt;/docs&gt;</span><br><span class="line">&lt;config lang=<span class="string">&quot;json&quot;</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Untitled Plugin&quot;</span>,</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;web-worker&quot;</span>,</span><br><span class="line">  <span class="string">&quot;tags&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;ui&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.1.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;cover&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;description&quot;</span>: <span class="string">&quot;[TODO: describe this plugin with one sentence.]&quot;</span>,</span><br><span class="line">  <span class="string">&quot;icon&quot;</span>: <span class="string">&quot;extension&quot;</span>,</span><br><span class="line">  <span class="string">&quot;inputs&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;outputs&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;api_version&quot;</span>: <span class="string">&quot;0.1.8&quot;</span>,</span><br><span class="line">  <span class="string">&quot;env&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="string">&quot;permissions&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;requirements&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;dependencies&quot;</span>: []</span><br><span class="line">&#125;</span><br><span class="line">&lt;/config&gt;</span><br><span class="line">&lt;script lang=<span class="string">&quot;javascript&quot;</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImJoyPlugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    api.log(<span class="string">&#x27;initialized&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">run</span>(<span class="params">ctx</span>)</span> &#123;</span><br><span class="line">    api.alert(<span class="string">&#x27;hello world.&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">api.export(<span class="keyword">new</span> ImJoyPlugin())</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><br>上述代码的具体语法会在后面具体详述。<br>在不更改代码的情况下，可以通过单击保存图标来保存它，此时会在插件菜单中添加一个名为“Untitled Plugin”的新条目。<br>要运行这个插件，可以单击“Untitled Plugin”按钮。此时将看到一个带有“Hello World”的弹出对话框。<br><img src="https://user-images.githubusercontent.com/6218739/144055127-ffd19736-bcde-4f58-9c15-e7a976bb82ae.png" alt="hello"></p><p>如果是在本地电脑编辑的ImJoy插件文件（扩展名为 <code>*.imjoy.html</code>），那么可通过下面操作加载到ImJoy Web App中：<br>1) 转到 <a href="https://imjoy.io/#/app">https://imjoy.io/#/app</a><br>2) 将该文件拖放到浏览器中即可。</p><p>对于 Python 开发，可以使用 <a href="https://github.com/imjoy-team/imjoy-jupyter-extension">jupyter notebook 扩展</a>。该部分会在以后详细解析。</p><h1 id="部署和共享插件"><a href="#部署和共享插件" class="headerlink" title="部署和共享插件"></a>部署和共享插件</h1><p>如果你想与他人分享你的插件，可以直接发送插件文件，或者将插件上传到 Github/Gist。建议使用后者，因为它会更大范围地分发插件。<br>以下步骤可以帮助编写及部署插件：<br>（1）在 Github 上 <a href="https://github.com/imjoy-team/imjoy-starter/fork">fork imjoy-starter repo</a>（或者，如果你愿意，可以创建一个空的）。imjoy-starter仓库包含一个<a href="https://github.com/imjoy-team/imjoy-starter/tree/master/docs">docs 文件夹</a>，开发者可以在 Markdown 中做笔记，它将渲染为像这样的<a href="https://imjoy-team.github.io/imjoy-starter/">交互式的网站</a>。有关更多信息，请参阅<a href="https://docsify.js.org/#/"><strong>此处</strong></a>。可以在Markdown中添加带有一些特殊标记的插件代码，然后就可以看到<strong>Run</strong>和<strong>Edit</strong>按钮。<br>（2）然后可以将自己的插件命名为，例如，<code>hello.imjoy.html</code> 并使用 git 命令将其上传到你所fork的仓库的 <code>plugins</code> 文件夹或直接上传到仓库。<br>（3）然后单击插件文件并复制地址栏中的url，它应该类似于：<code>https://github.com/&lt;YOUR-GITHUB-USERNAME&gt;/imjoy-starter/blob/master/plugins/hello.imjoy.html</code><br>此路径可用于在ImJoy中安装插件。<br>（4）单击<strong>Run</strong>打开ImJoy Web App。要安装插件，单击<code>+PLUGINS</code>并将URL粘贴到<code>Install from URL</code>输入框中，然后按 Enter。<br>（5）现在可以构建一个URL与他人共享，只需在 <code>https://imjoy.io/#/app?plugin=</code> 后面添加 URL 即可，比如这样：<code>https://imjoy.io/#/app?plugin=https://github.com/&lt;YOUR-GITHUB-USERNAME&gt;/imjoy-starter/blob/master/plugins/hello.imjoy.html</code>。<br>如果用户单击这个插件URL，它将直接在ImJoy中打开插件并提示用户安装它。</p>]]></content>
    
    
    <summary type="html">参考文献
I2K Workshop Tutorial
Developing Plugins for ImJoy

概述
开发ImJoy插件既简单又快速，可直接使用运行在web上的内置的代码编辑器，而不需要额外的 IDE 或编译器。
ImJoy 插件系统的主要功能有：
（1）支持 Python 和 JavaScript

 * JavaScript 插件与安全沙箱隔离
 * Python 插件在自己的进程中运行
 * 使用 async/await 语法支持并发 API 调用
 * 支持 Python 的虚拟环境和 pip 包
 * 支持托管在 GitHub 或 CDN 上的 JavaScript</summary>
    
    
    
    <category term="computer vision" scheme="http://qixinbo.github.io/categories/computer-vision/"/>
    
    
    <category term="ImJoy" scheme="http://qixinbo.github.io/tags/ImJoy/"/>
    
  </entry>
  
  <entry>
    <title>开源深度学习计算平台ImJoy解析：2 -- 核心概念</title>
    <link href="http://qixinbo.github.io/2021/11/30/ImJoy_2/"/>
    <id>http://qixinbo.github.io/2021/11/30/ImJoy_2/</id>
    <published>2021-11-29T16:00:00.000Z</published>
    <updated>2021-12-18T04:11:22.413Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇主要介绍ImJoy中的核心概念。<br>参考文献：<br><a href="https://imjoy.io/docs/#/i2k_tutorial">I2K Workshop Tutorial</a></p><h1 id="ImJoy插件"><a href="#ImJoy插件" class="headerlink" title="ImJoy插件"></a>ImJoy插件</h1><p>ImJoy 提供了一个灵活的框架来开发具有不同类型的 Web 或 Python 编程语言的插件。<br><img src="https://user-images.githubusercontent.com/6218739/143839866-7d945048-055f-4898-b65b-64af66d4d316.png" alt="plugins"><br>有四种类型的插件，其可用于不同的目的：<br>（1）Web 插件直接在浏览器中运行，支持如下三种类型：</p><ul><li>Window (HTML/CSS/JS)(<code>type=window</code>) 插件，用于使用 HTML5/CSS 和 JavaScript 构建丰富的交互式用户界面；</li><li>Web Worker (JS)(type=<code>web-worker</code>) 插件，用于使用 JavaScript 或 WebAssembly 执行计算任务；</li><li>Web Python(type=<code>web-python</code>) 插件，用于在浏览器中通过 WebAssembly 和 <a href="https://github.com/iodide-project/pyodide">pyodide</a> 使用 Python 执行计算任务。这样的插件用小蛇🐍图标表示。这处于开发阶段，目前仅支持选定数量的 Python 库。</li></ul><p>（2）Native插件在插件引擎中运行，目前支持：</p><ul><li>Native Python(type=<code>native-python</code>) 插件，可使用 Python 及其大量库函数来执行繁重计算任务，不过这需要额外安装插件引擎。这些插件用火箭🚀图标表示。</li></ul><p>可以通过单击 <code>+ PLUGINS</code> 按钮，然后从“创建新插件”下拉菜单中访问上述插件的模板，如图：<br><img src="https://user-images.githubusercontent.com/6218739/144004594-0ccaac1d-6fb0-4c83-a42d-8dc1c565f823.png" alt="4plugins"></p><p>关于插件具体怎样编写，会在后面博文中具体解析。</p><h1 id="ImJoy-API"><a href="#ImJoy-API" class="headerlink" title="ImJoy API"></a>ImJoy API</h1><p>为了允许基本的用户交互，ImJoy 提供了一组 API（应用程序编程接口）函数，这些函数可以在所有插件类型和支持的编程语言中以相同的方式调用。<br>例如，与 Javascript 函数 <code>alert()</code>等效的 ImJoy API 函数是 <code>api.alert()</code>。</p><p>可以直接访问 Javascript 插件中的 <code>api</code> 对象（使用 type=<code>window</code> 或 <code>web-worker</code>）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api.alert(<span class="string">&quot;Hello from ImJoy!&quot;</span>)</span><br></pre></td></tr></table></figure><br>在 Python 插件（type=<code>web-python</code> 或 <code>native-python</code>）中，需要先添加 <code>from imjoy import api</code>，然后才能访问 <code>api</code> 对象。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import api object</span></span><br><span class="line"><span class="keyword">from</span> imjoy <span class="keyword">import</span> api</span><br><span class="line">...</span><br><span class="line"><span class="comment"># use api object</span></span><br><span class="line">api.alert(<span class="string">&quot;Hello from ImJoy!&quot;</span>)</span><br></pre></td></tr></table></figure></p><p>可以在 <a href="https://imjoy.io/docs/#/api">此处</a> 中找到所有 ImJoy API 功能的详细说明。同样，后面会对这些API详细解析。</p><h1 id="远程过程调用RPC"><a href="#远程过程调用RPC" class="headerlink" title="远程过程调用RPC"></a>远程过程调用RPC</h1><p>首先来看一下什么是远程过程调用<strong>Remote Procedure Calls (RPC)</strong>。<br>洪春涛的<a href="https://www.zhihu.com/question/25536695/answer/221638079">这个知乎回答</a>非常言简意赅。以下是对该回答的摘引。</p><h2 id="本地过程调用"><a href="#本地过程调用" class="headerlink" title="本地过程调用"></a>本地过程调用</h2><p>RPC就是要像调用本地的函数一样去调远程函数。在研究RPC前，我们先看看本地调用是怎么调的。假设我们要调用函数Multiply来计算<code>lvalue * rvalue</code>的结果:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="built_in">int</span> Multiply(<span class="built_in">int</span> l, <span class="built_in">int</span> r) &#123;</span><br><span class="line"><span class="number">2</span>    <span class="built_in">int</span> y = l * r;</span><br><span class="line"><span class="number">3</span>    <span class="keyword">return</span> y;</span><br><span class="line"><span class="number">4</span> &#125;</span><br><span class="line"><span class="number">5</span> </span><br><span class="line"><span class="number">6</span> <span class="built_in">int</span> lvalue = <span class="number">10</span>;</span><br><span class="line"><span class="number">7</span> <span class="built_in">int</span> rvalue = <span class="number">20</span>;</span><br><span class="line"><span class="number">8</span> <span class="built_in">int</span> l_times_r = Multiply(lvalue, rvalue);</span><br></pre></td></tr></table></figure><br>那么在第8行时，我们实际上执行了以下操作：<br>（1）将lvalue和rvalue的值压栈<br>（2）进入Multiply函数，取出栈中的值10和20，将其赋予l和r<br>（3）执行第2行代码，计算<code>l*r</code>，并将结果存在y<br>（4）将y的值压栈，然后从Multiply返回<br>（5）第8行，从栈中取出返回值200 ，并赋值给<code>l_times_r</code><br>以上5步就是执行本地调用的过程。（20190116注：以上步骤只是为了说明原理。事实上编译器经常会做优化，对于参数和返回值少的情况会直接将其存放在寄存器，而不需要压栈弹栈的过程，甚至都不需要调用call，而直接做inline操作。仅就原理来说，这5步是没有问题的。）</p><h2 id="远程过程调用带来的新问题"><a href="#远程过程调用带来的新问题" class="headerlink" title="远程过程调用带来的新问题"></a>远程过程调用带来的新问题</h2><p>在远程调用时，我们需要执行的函数体是在远程的机器上的，也就是说，Multiply是在另一个进程中执行的。这就带来了几个新问题：<br>（1）Call ID映射。我们怎么告诉远程机器我们要调用Multiply，而不是Add或者FooBar呢？在本地调用中，函数体是直接通过函数指针来指定的，我们调用Multiply，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。所以，在RPC中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个<code>&#123;函数 &lt;--&gt; Call ID&#125;</code>的对应表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。<br>（2）序列化和反序列化。客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用C++，客户端用Java或者Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。<br>（3）网络传输。远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2。Java的Netty也属于这层的东西。</p><h2 id="RPC的实现"><a href="#RPC的实现" class="headerlink" title="RPC的实现"></a>RPC的实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Client端 </span><br><span class="line">//    <span class="built_in">int</span> l_times_r = Call(ServerAddr, Multiply, lvalue, rvalue)</span><br><span class="line"><span class="number">1.</span> 将这个调用映射为Call ID。这里假设用最简单的字符串当Call ID的方法</span><br><span class="line"><span class="number">2.</span> 将Call ID，lvalue和rvalue序列化。可以直接将它们的值以二进制形式打包</span><br><span class="line"><span class="number">3.</span> 把<span class="number">2</span>中得到的数据包发送给ServerAddr，这需要使用网络传输层</span><br><span class="line"><span class="number">4.</span> 等待服务器返回结果</span><br><span class="line"><span class="number">5.</span> 如果服务器调用成功，那么就将结果反序列化，并赋给l_times_r</span><br><span class="line"></span><br><span class="line">// Server端</span><br><span class="line"><span class="number">1.</span> 在本地维护一个Call ID到函数指针的映射call_id_map，可以用std::<span class="built_in">map</span>&lt;std::string, std::function&lt;&gt;&gt;</span><br><span class="line"><span class="number">2.</span> 等待请求</span><br><span class="line"><span class="number">3.</span> 得到一个请求后，将其数据包反序列化，得到Call ID</span><br><span class="line"><span class="number">4.</span> 通过在call_id_map中查找，得到相应的函数指针</span><br><span class="line"><span class="number">5.</span> 将lvalue和rvalue反序列化后，在本地调用Multiply函数，得到结果</span><br><span class="line"><span class="number">6.</span> 将结果序列化后通过网络返回给Client</span><br></pre></td></tr></table></figure><p>所以要实现一个RPC框架，其实只需要按以上流程实现就基本完成了。</p><p>其中：<br>（1）Call ID映射可以直接使用函数字符串，也可以使用整数ID。映射表一般就是一个哈希表。<br>（2）序列化反序列化可以自己写，也可以使用Protobuf或者FlatBuffers之类的。<br>（3）网络传输库可以自己写socket，或者用asio，ZeroMQ，Netty之类。</p><h2 id="ImJoy中的远程过程调用"><a href="#ImJoy中的远程过程调用" class="headerlink" title="ImJoy中的远程过程调用"></a>ImJoy中的远程过程调用</h2><p>尽管调用 <code>alert()</code> 和 <code>api.alert()</code> 会产生相同的结果（都是弹出消息），但要注意的是其底层过程是不同的。当调用<code>alert()</code>时，直接从插件启动弹出对话框，而调用<code>api.alert()</code>会从ImJoy内核（ImJoy core）中启动弹出对话框。<br>需要时刻注意的是，ImJoy 是在独立或沙盒环境（即sandboxed iframe、webworker、conda 虚拟环境或 docker 容器）中运行每个插件。简而言之，这意味着默认情况下，函数和变量不会在插件之间或插件与ImJoy内核之间进行共享。<br>当从插件中调用 ImJoy API 函数时，该函数将在 ImJoy 内核中执行。由于插件运行在不同的环境中，所以ImJoy内核中定义的所有功能都是“远程”功能。相比之下，同一个插件中定义的所有函数都是“本地”的。<br>因此，调用ImJoy API函数意味着执行远程过程调用。<br>（ImJoy支持双向RPC，不仅在插件和 ImJoy内核之间，而且在插件之间也是如此。RPC可以在不同编程语言和不同主机之间统一地使用）<br>比如，当一个在远程服务器上运行的Python插件进行调用<code>api.alert()</code>时，弹出对话框则是由用户浏览器中的ImJoy内核（用Javascript实现）来启动的。<br>RPC允许将任务分发到以不同语言和不同位置运行的不同插件。例如，我们可以使用强大的UI库（例如<a href="https://d3js.org/">D3</a> 和 <a href="https://kitware.github.io/itk-vtk-viewer/">ITK/VTK Viewer</a>)来构建用户界面，并用<a href="https://www.tensorflow.org/js">Tensorflow. js</a>中的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">Web Worker</a> 来运行深度学习模型 。对于使用GPU来训练模型这种重型计算任务，可以在本地或远程（例如在GPU 集群或实验室工作站上）的Jupyter笔记本服务器（即ImJoy插件引擎 Plugin Engine）上编写Python 插件来实现。<br>这篇博文(<a href="http://tomerfiliba.com/blog/RPCs-Life-And-All/">RPCs, Life and All</a>) 解释了用于Python远程过程调用的库(<a href="https://rpyc.readthedocs.io/en/latest/">RPyC</a>)背后的想法 ，该库与ImJoy中提供的类似。</p><h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><p>由于 ImJoy API 函数是远程函数，它们的操作与同一插件中定义的本地函数略有不同。更具体地说，远程函数是异步的。<br>在ImJoy中调用异步函数有一个简化的规则：ImJoy中的所有远程功能都是异步的，可以像其他本地函数一样使用它们，只需在函数调用前添加 <code>await</code>。<br>即应该执行 <code>await api.alert(&#39;hello&#39;)</code> 来调用上面的alert函数。<br>如果API函数有返回值，例如<a href="https://imjoy.io/docs/#/api?id=apiprompt"><code>api.prompt</code></a>，应该写成：<code>result = await api.prompt( &#39;type a number&#39;)</code>。</p><p>但是需要注意的是，如果直接执行 <code>await api.alert(&#39;hello&#39;)</code>，会导致语法错误而不能执行。<br>要修复错误，需要将代码封装在一个异步函数中：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Javascript 中的异步/等待示例</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">await</span> api.alert(<span class="string">&quot;Hello from ImJoy!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">sayHello()</span><br></pre></td></tr></table></figure><br>因此，另一个使用 <code>async/await</code> 的简单规则是：<br>在函数中使用<code>await</code>时，在函数定义前添加<code>async</code>。</p><p>再举一个例子，使用另一个 ImJoy API 函数 <a href="https://imjoy.io/docs/#/api?id=apiprompt"><code>api.prompt</code></a> 在弹出对话框中获取用户的输入，并使用这个API <a href="https://imjoy.io/docs/#/api?id=apishowmessage"><code>api.showMessage</code></a>来显示消息。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">choosePokemon</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> pokemon = <span class="keyword">await</span> api.prompt(<span class="string">&quot;What is your favorite Pokémon?&quot;</span>,<span class="string">&quot;Pikachu&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> api.showMessage(<span class="string">&quot;Your have chose &quot;</span>+pokemon +<span class="string">&quot; as your Pokémon.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">choosePokemon()</span><br></pre></td></tr></table></figure></p><h2 id="Python的Async-Await"><a href="#Python的Async-Await" class="headerlink" title="Python的Async/Await"></a>Python的Async/Await</h2><p><code>async/await</code> 语法在 Python 中类似。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 中的异步/等待示例</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">say_hello</span>():</span></span><br><span class="line">    <span class="keyword">await</span> api.alert(<span class="string">&quot;Hello from ImJoy!&quot;</span>)</span><br></pre></td></tr></table></figure></p><p>在 Python 中使用 asyncio 时，一个好的做法是避免直接在主线程中运行繁重的计算，而是可以使用<a href="https://pymotw.com/3/asyncio/executors.html">Executors</a> (线程和进程）。<br>还可以通过执行以下操作来使用默认线程执行器：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loop.run_in_executor(<span class="literal">None</span>, my_heavy_computation, arg1, arg2...)</span><br></pre></td></tr></table></figure></p><h2 id="Callback、Promise和Async-Await"><a href="#Callback、Promise和Async-Await" class="headerlink" title="Callback、Promise和Async/Await"></a>Callback、Promise和Async/Await</h2><p>如前所述，通过 RPC 将任务分配给不同插件的一个优势是可以并行调度和运行任务（通常在 Python、Java 和许多其他编程语言中，还有许多其他技术可以实现并发性，包括多线程和多进程）。异步编程是一种越来越流行的以更具可扩展性的方式实现并发的方式。<br>其基本思想是，我们不必总是等待一项任务完成，然后才移动到下一项。比如，当我们去一家咖啡店，点一杯卡布奇诺咖啡并获得一张取餐号，在制作咖啡的同时，我们可以拨打电话或阅读报纸。几分钟后，可以通过出示取餐号来获取卡布奇诺咖啡。<br>异步编程与多线程等其他技术的一大区别在于程序是在一个线程和进程中运行。因此，在 ImJoy 中，异步编程通常用于将任务调度到其他插件，而不是在同一插件内并行运行繁重的计算任务。<br><code>async/await</code> 并不是进行异步编程的唯一方式，事实上，它在最近几年才变得更加流行。例如， Python 3 之后才引入了它。<br>关于异步编程，可以后面再详细解析。</p><h2 id="将-RPC-与-Async-Await-结合使用"><a href="#将-RPC-与-Async-Await-结合使用" class="headerlink" title="将 RPC 与 Async/Await 结合使用"></a>将 RPC 与 Async/Await 结合使用</h2><p>另一种理解<code>await</code> 和<code>async</code> 函数的角度是：<br>1) 异步函数一旦调用将立即返回；<br>2) 返回的对象不是实际结果，而是Javascript 中称为<code>Promise</code> 或Python中称为<code>Future</code> 的特殊对象。直觉上，这就像你点了一杯咖啡后得到的取餐号；<br>3) 如果将 <code>await</code> 应用到 <code>Promise</code> 或 <code>Future</code> 对象，就会得到实际的结果。<br>如下两种异步函数是等价的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">choosePokemon1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 直接申请await，我们会得到实际的结果</span></span><br><span class="line">    <span class="keyword">const</span> pokemon = <span class="keyword">await</span> api.prompt(<span class="string">&quot;What is your favorite Pokemon?&quot;</span>, <span class="string">&quot;Pikachu&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> pokemon</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">choosePokemon2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 如果不使用 `await`，我们会得到一个对实际结果的承诺promise</span></span><br><span class="line">    <span class="keyword">const</span> promise = api.prompt(<span class="string">&quot;What is your favorite Pokemon?&quot;</span>, <span class="string">&quot;Pikachu&quot;</span><span class="string">&quot;)</span></span><br><span class="line"><span class="string">    // 要检索实际结果，将 await 应用于 Promise</span></span><br><span class="line"><span class="string">    const pokemon = await promise</span></span><br><span class="line"><span class="string">    return pokemon</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><br>虽然上面的例子是用 Javascript 写的，当然也可以在 Python 中做同样的事情。<br>简单地为所有异步函数应用<code>await</code> 将导致顺序执行。要并行运行任务，我们可以在不立即应用 <code>await</code> 的情况下调用函数，而是可以先收集所有的 <code>Promise</code> 对象，然后一块<code>await</code>。<br>假设我们有 taskA（需要 10 分钟）、taskB（需要 5 分钟）和 taskC（需要 3 分钟），我们想使用从 A 和 B 返回的结果来完成任务 C。以下是不同的实现方式：<br>（1）在所有函数之前应用 <code>await</code>，需要 18(<code>10+5+3</code>) 分钟<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doTasks</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 在 A 之后执行任务 B</span></span><br><span class="line">        <span class="keyword">const</span> resultA = <span class="keyword">await</span> doTaskA() <span class="comment">// 需要 10 分钟</span></span><br><span class="line">        <span class="keyword">const</span> resultB = <span class="keyword">await</span> doTaskB() <span class="comment">// 需要 5 分钟</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> doTaskC(resultA, resultB) <span class="comment">// 需要 3 分钟</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>（2）调度这两个任务，然后对两者<code>await</code>，需要 13 (<code>max(10, 5) + 3</code>) 分钟。<br>在 Javascript 中，可以使用 <code>Promise.all</code> 将两个 promise 合二为一：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doTasks</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 并行运行任务 A 和 B</span></span><br><span class="line">    <span class="keyword">const</span> promiseA = doTaskA()</span><br><span class="line">    <span class="keyword">const</span> promiseB = doTaskB()</span><br><span class="line">    <span class="comment">// 收集结果</span></span><br><span class="line">    <span class="keyword">const</span> [resultA, resultB] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([promiseA, promiseB])</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> doTaskC(resultA, resultB)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在 Python 中，可以使用 <code>asyncio.gather</code> 来收集两个 promise：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">doTasks</span>():</span></span><br><span class="line">    <span class="comment"># 并行运行任务 A 和 B</span></span><br><span class="line">    promiseA = doTaskA()</span><br><span class="line">    promiseB = doTaskB()</span><br><span class="line">    <span class="comment"># 收集结果</span></span><br><span class="line">    [resultA, resultB] = <span class="keyword">await</span> asyncio.gather(promiseA, promiseB)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> doTaskC(resultA, resultB)</span><br></pre></td></tr></table></figure></p><h1 id="外部集成"><a href="#外部集成" class="headerlink" title="外部集成"></a>外部集成</h1><p>ImJoy 插件生态系统旨在以两种方式开放：<br>（1）其他软件工具和网站应该能够轻松使用 ImJoy 及其插件；<br>（2）其他软件工具应该可以在 ImJoy 中轻松使用，通常是以插件的形式。<br>一般来说，任何使用ImJoy RPC协议来提供服务功能的软件都可以被视为ImJoy插件。这包括 ImJoy Web 应用程序本身，它可以读取插件文件并生成插件 API。同时，作者还提供了 <a href="https://github.com/imjoy-team/imjoy-rpc">imjoy-rpc</a> 库，目前支持 Python 和 Javascirpt，供其他软件或 Web 应用程序直接与 ImJoy 内核通信。<br>目前已经有几个web 应用程序可以在独立模式下运行，也可以作为 ImJoy 插件：</p><ul><li><a href="https://kitware.github.io/itk-vtk-viewer/docs/imjoy.html">ITK/VTK 查看器</a> 由 <a href="https://github.com/thewtex">Matt McCormick</a> 等人撰写。</li><li><a href="https://github.com/hms-dbmi/vizarr">vizarr</a> 由 <a href="https://github.com/manzt">Trevor Manz</a> 等人撰写。</li><li><a href="https://kaibu.org/#/app">Kaibu</a> 由 ImJoy 团队提供。</li><li><a href="https://ij.imjoy.io">ImageJ.JS</a> 由 ImJoy 团队提供。</li></ul><p>例如，<a href="https://kitware.github.io/itk-vtk-viewer/docs/imjoy.html">ITK/VTK Viewer</a> 是一个开源软件系统，用于医学和科学图像、网格和点集可视化。虽然它可以<a href="https://kitware.github.io/itk-vtk-viewer/app/?fileToLoad=https://data.kitware.com/api/v1/file/564a65d58d777f7522dbfb61/ download/data.nrrd">作为独立应用程序运行</a>，也可以<a href="https://kitware.github.io/itk-vtk-viewer/docs/imjoy.html">作为 ImJoy 插件</a>运行 。<br>可以点击<a href="http://imjoy.io/#/app?plugin=https://kitware.github.io/itk-vtk-viewer/app/">这个链接</a>进行试用。</p><p><a href="https://ij.imjoy.io">ImageJ.JS</a>是一个独立的网络应用程序，它以两种方式支持ImJoy：1) 大多数ImJoy插件可以在ImageJ.JS中直接运行； 2) ImageJ.JS可以通过其URL用作ImJoy的插件。<br>有关更多详细信息，请参阅 <a href="https://github.com/imjoy-team/imagej.js">项目存储库</a>。</p><p>比如，可以在ImageJ.JS的左上角单击ImJoy图标，然后选择加载插件，粘贴插件的Github/Gist URL，即可将自己的插件加载到ImageJ.JS中。<br><img src="https://user-images.githubusercontent.com/6218739/144003370-395d9e87-7469-4f51-9753-4bc7b6e5e00a.png" alt="imagej"></p>]]></content>
    
    
    <summary type="html">这一篇主要介绍ImJoy中的核心概念。
参考文献：
I2K Workshop Tutorial

ImJoy插件
ImJoy 提供了一个灵活的框架来开发具有不同类型的 Web 或 Python 编程语言的插件。

有四种类型的插件，其可用于不同的目的：
（1）Web 插件直接在浏览器中运行，支持如下三种类型：

 * Window (HTML/CSS/JS)(type=window) 插件，用于使用 HTML5/CSS 和 JavaScript 构建丰富的交互式用户界面；
 * Web Worker (JS)(type=web-worker) 插件，用于使用 JavaScript 或 WebA</summary>
    
    
    
    <category term="computer vision" scheme="http://qixinbo.github.io/categories/computer-vision/"/>
    
    
    <category term="ImJoy" scheme="http://qixinbo.github.io/tags/ImJoy/"/>
    
  </entry>
  
  <entry>
    <title>开源深度学习计算平台ImJoy解析：1 -- 介绍</title>
    <link href="http://qixinbo.github.io/2021/11/28/ImJoy_1/"/>
    <id>http://qixinbo.github.io/2021/11/28/ImJoy_1/</id>
    <published>2021-11-27T16:00:00.000Z</published>
    <updated>2021-11-29T08:38:33.670Z</updated>
    
    <content type="html"><![CDATA[<p>从该博文开始，将会对ImJoy这一开源深度学习计算平台做一详细解析。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>（这部分是对官方文档（在<a href="https://imjoy.io/docs/#/">这里</a>）的翻译理解）<br>ImJoy是一个由插件驱动的混合计算平台，用于部署深度学习应用程序，例如高级图像分析工具。<br>ImJoy可以运行在跨操作系统的移动和桌面环境中，其中的插件可以运行在浏览器、本地主机、远程和云服务器中。<br>借助 ImJoy，凭借其灵活的插件系统和可共享的插件 URL，可以非常简单地向最终用户提供深度学习工具，免去了用户自己配置深度学习环境、安装应用程序的繁琐和痛苦。对于开发人员来说，也可以轻松地对自己现有的Python代码添加丰富的交互式 Web 界面，从而让自己的程序更加“触手可及”。<br>下面是ImJoy的整体架构图：<br><img src="https://user-images.githubusercontent.com/6218739/143673530-061125ed-4f2c-4bbd-8cef-b8ea12921c92.png" alt="arch"><br>可以看出，ImJoy系统非常灵活，体现在以下几个方面：<br>（1）跨平台获取：因为ImJoy是基于web的，所以只要是有浏览器的地方，ImJoy就可以使用，比如桌面端、移动端调用等；<br>（2）插件形式灵活：可以使用JavaScript、Python等编程语言；<br>（3）插件运行环境多样：对于不同量级的插件，可以选择其应用环境，比如一个简单的插件，可以直接在浏览器中运行；如果是一个重型的深度学习应用，可以在本地工作站中运行，也可以在远程服务器或者云服务器中运行。</p><h1 id="ImJoy特点"><a href="#ImJoy特点" class="headerlink" title="ImJoy特点"></a>ImJoy特点</h1><p>（1）小巧且灵活的插件驱动的 Web 应用程序<br>（2）具有离线支持的无服务器渐进式 Web 应用程序（PWA技术）<br>（3）支持移动设备<br>（4）基于Web的丰富的交互式用户界面：可以使用任何现有的网页设计库、使用 webGL、Three.js 等以 3D 形式呈现多维数据。<br>（5）易于使用的工作流组合<br>（6）用于分组插件的独立工作区<br>（7）方便的插件原型设计和开发：内置代码编辑器，开发不需要额外的IDE<br>（8）强大且可扩展的计算后端，可用于浏览器内计算、本地计算和云计算</p><ul><li>支持 Javascript、原生 Python 和 web Python（即直接在网页中运行Python程序，底层技术是Pyodide）</li><li>通过异步编程并发插件执行</li><li>使用 Webassembly 在浏览器中运行 Python 插件</li><li>浏览器插件与安全沙箱隔离</li><li>支持Python3 和 Javascript 的async/await语法</li><li>支持 Python 的 Conda 虚拟环境和 pip 包</li><li>支持托管在 Github 或 CDN 上的 JavaScript 库</li><li>通过 GitHub 或 Gist 轻松部署和共享插件</li><li>将开发者自己的插件仓库部署到 Github</li><li>原生支持 n 维数组和张量</li><li>支持 Numpy 的 ndarrays 用于数据交换</li></ul><p>ImJoy 大大加快了新工具的开发和传播。开发者可以在 ImJoy 中开发插件，将插件文件部署到 Github，并通过社交网络分享插件 URL。用户可以通过多种方式使用这些插件，比如在手机上单击一下即可调用。<br><img src="https://user-images.githubusercontent.com/6218739/143677962-526c570c-e61e-423e-8092-e78a013ef231.png" alt="deploy"></p><h1 id="依赖库"><a href="#依赖库" class="headerlink" title="依赖库"></a>依赖库</h1><p>ImJoy主要使用的开源库有：</p><ul><li>Joy.js（这就是ImJoy的名字由来！）</li><li>Jailed（用于隔离插件）</li><li>Vue.js（主要的前端UI使用 Vue.js 编写）</li><li>vue-grid-layout（用于窗口管理）</li><li>python-socketio（使得插件引擎可以与 ImJoy主程序进行通信）</li><li>pyodide（使用 WebAssembly 启用 web python 模式）</li><li>conda（插件引擎使用 Conda 来管理虚拟环境和包）</li><li>docsify（ImJoy 文档是用 docsify 创建的）</li></ul><h1 id="发表论文"><a href="#发表论文" class="headerlink" title="发表论文"></a>发表论文</h1><p>ImJoy的研究工作也发表在了Nature子刊 Nature Methods上，大佬就是大佬。<br>文章链接见：<a href="https://www.nature.com/articles/s41592-019-0627-0">ImJoy: an open-source computational platform for the deep learning era</a><br>也可以通过<a href="https://rdcu.be/bYbGO">这个链接</a>免费获取该论文。</p><h1 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h1><h2 id="前端界面"><a href="#前端界面" class="headerlink" title="前端界面"></a>前端界面</h2><p>可以直接在浏览器中使用ImJoy，网站在<a href="https://imjoy.io/#/app">这里</a>。<br>（也可以自己托管ImJoy，即使用GitHub上的<a href="https://github.com/imjoy-team/ImJoy">这个仓库</a>）<br>整个应用的前端界面如下：<br><img src="https://user-images.githubusercontent.com/6218739/143802507-b85944e6-4a5d-49d6-82d8-fcceb76991a3.png" alt="UI"><br>包括了插件管理区、工作区、状态栏、工具栏、插件窗口等多个部分。</p><h2 id="上手体验"><a href="#上手体验" class="headerlink" title="上手体验"></a>上手体验</h2><p>官方提供的一个demo是使用一个预训练的神经网络来进行图像识别。<br>这个插件可以通过在<a href="https://imjoy.io/repo/">插件库</a>中安装插件Image Recognition来获得，<br>也可以直接点击<a href="https://imjoy.io/#/app?plugin=imjoy-team/imjoy-plugins:Image%20Recognition&amp;w=getting-started">该链接</a>来使用。<br>安装插件后，它将出现在左侧的插件对话框中。然后单击其名称启动插件。这将打开一个窗口并加载训练好的网络。<br>然后就可以通过上传文件来预测图像中的物体。<br>注意，如果是在电脑上使用该插件，则是上传电脑中的文件，如果是在手机上使用该插件，则调用摄像头来获取图像。<br>如下是我在手机上试用的截图：<br><img src="https://user-images.githubusercontent.com/6218739/143830446-897d525c-c84e-4e85-a689-8d1fcab75b0e.jpg" alt="test"></p><p>通过此例也可以看出，ImJoy提供了一种非常方便地获取最新深度学习技术的方式，能极大地降低技术的应用门槛。</p>]]></content>
    
    
    <summary type="html">从该博文开始，将会对ImJoy这一开源深度学习计算平台做一详细解析。

简介
（这部分是对官方文档（在这里）的翻译理解）
ImJoy是一个由插件驱动的混合计算平台，用于部署深度学习应用程序，例如高级图像分析工具。
ImJoy可以运行在跨操作系统的移动和桌面环境中，其中的插件可以运行在浏览器、本地主机、远程和云服务器中。
借助 ImJoy，凭借其灵活的插件系统和可共享的插件 URL，可以非常简单地向最终用户提供深度学习工具，免去了用户自己配置深度学习环境、安装应用程序的繁琐和痛苦。对于开发人员来说，也可以轻松地对自己现有的Python代码添加丰富的交互式 Web 界面，从而让自己的程序更加“触手</summary>
    
    
    
    <category term="computer vision" scheme="http://qixinbo.github.io/categories/computer-vision/"/>
    
    
    <category term="ImJoy" scheme="http://qixinbo.github.io/tags/ImJoy/"/>
    
  </entry>
  
  <entry>
    <title>图神经网络入门详解</title>
    <link href="http://qixinbo.github.io/2021/11/24/gnn/"/>
    <id>http://qixinbo.github.io/2021/11/24/gnn/</id>
    <published>2021-11-23T16:00:00.000Z</published>
    <updated>2021-11-24T06:47:19.043Z</updated>
    
    <content type="html"><![CDATA[<p>本文基本是对<a href="https://distill.pub/2021/gnn-intro/">A Gentle Introduction to Graph Neural Networks</a>这篇文章的翻译理解。<br>（注意：原文中有很多可交互的动画，更有启发性。本文对原文中的有些图像进行了调整，方便初学者理解）</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>（这部分大都来自于<a href="https://zhuanlan.zhihu.com/p/75307407">这篇参考文献</a>）<br>曾有学者将本次人工智能浪潮的兴起归因于三个条件，分别是：<br>（1）计算资源的快速发展（如GPU）<br>（2）大量训练数据的可用性<br>（3）深度学习从欧氏空间数据中提取潜在特征的有效性<br>尽管传统的深度学习方法被应用在提取欧氏空间数据的特征方面取得了巨大的成功，但许多实际应用场景中的数据是从非欧式空间生成的，传统的深度学习方法在处理非欧式空间数据上的表现却仍难以使人满意。<br>常见的欧几里得结构化数据主要包含：<br>（1）1D：声音，时间序列等；<br>（2）2D：图像等；<br>（3）3D：视频，高光谱图像等。<br>常见的非欧几里得结构化数据有：<br>（1）1D：社交网络(如Facebook，Twitter)等；<br>（2）2D：生物网络(基因，分子，大脑连接)等；<br>（3）3D：基础设施网络(如能源，交通，互联网，通信等。</p><p>例如，在电子商务中，一个基于图（Graph）的学习系统能够利用用户和产品之间的交互来做出非常准确的推荐，但图的复杂性使得现有的深度学习算法在处理时面临着巨大的挑战。这是因为图是不规则的，每个图都有一个大小可变的无序节点，图中的每个节点都有不同数量的相邻节点，导致一些重要的操作（例如卷积）在图像（Image）上很容易计算，但不再适合直接用于图。此外，现有深度学习算法的一个核心假设是数据样本之间彼此独立。然而，对于图来说，情况并非如此，图中的每个数据样本（节点）都会有边与图中其他实数据样本（节点）相关，这些信息可用于捕获实例之间的相互依赖关系。</p><p>近年来，人们对深度学习方法在图上的扩展越来越感兴趣。在多方因素的成功推动下，研究人员借鉴了卷积网络、循环网络和深度自动编码器的思想，定义和设计了用于处理图数据的神经网络结构，由此一个新的研究热点——图神经网络（Graph Neural Networks，GNN）。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>什么是图？图（graph）是一系列实体（nodes）之间的关系（edges）。<br><img src="https://user-images.githubusercontent.com/6218739/142832766-879eefb5-ebb6-4edb-979a-2b8318c880a4.png" alt="graph"><br>黄色的是节点或称顶点，其属性包括节点标识、邻居数量等；<br>蓝色的是边或称链接，其属性包括边的标识、边的权重等；<br>红色线框包围的就是整张图，或称全局，该全局属性包括节点数量、图中的最长路径等特征。<br>其中，根据边的方向性还有两种情形，有向图和无向图：<br><img src="https://user-images.githubusercontent.com/6218739/142834186-f97f87f4-afb1-46c4-a5ed-6e1f22c6d68e.png" alt="edge"></p><h1 id="哪些是图"><a href="#哪些是图" class="headerlink" title="哪些是图"></a>哪些是图</h1><h2 id="社交网络作为图"><a href="#社交网络作为图" class="headerlink" title="社交网络作为图"></a>社交网络作为图</h2><p>图graph结构最简单明了的一种真实应用场景就是社交网络。<br>社交网络是用来研究人在机构、组织等集体中的行为模式的工具。我们可以通过将个人建模为节点、将人与人之间的关系建模为边来构建表示社交网络的图。<br>比如如下是莎士比亚的戏剧《奥赛罗》中的社交网络的图表达：<br><img src="https://user-images.githubusercontent.com/6218739/142959871-586a3938-6432-4b59-a5b5-c1dbf605a7c7.png" alt="social"><br>一种可视化图的连通性的方法是通过其邻接矩阵。如果人与人之间有关系，则在该矩阵中填充数值：<br><img src="https://user-images.githubusercontent.com/6218739/142960047-1590c3f0-9058-4275-8f09-4f9fef2f3b1d.png" alt="othello-matrix"></p><h2 id="引文网络作为图"><a href="#引文网络作为图" class="headerlink" title="引文网络作为图"></a>引文网络作为图</h2><p>科学家在发表论文时经常引用其他科学家的工作。我们可以将这些引文网络可视化为一个图，其中每篇论文都是一个节点，每个有向边是一篇论文和另一篇论文之间的引用。此外，我们可以将每篇论文的信息添加到每个节点中，例如摘要的词嵌入。</p><h2 id="分子作为图"><a href="#分子作为图" class="headerlink" title="分子作为图"></a>分子作为图</h2><p>分子是物质的基石，由3D空间中的原子和电子构成。所有粒子都在相互作用，但是当一对原子彼此保持稳定的距离时，我们说它们共享一个共价键。不同的原子对和键有不同的距离（例如单键、双键）。将这个3D对象描述为图是一种非常方便和常见的抽象，其中节点是原子，边是共价键。<br>如下是咖啡因因子的3D表示，及将它建模为图。<br><img src="https://user-images.githubusercontent.com/6218739/142960475-a26bf1b8-1275-4073-9135-81c4d99eb652.png" alt="Caffeine"></p><p>以上三例的数据都是异构的，由其所建的图graph中的节点的邻居数量是可变的。下面将展示两种可能认为无法建模为图的数据类型：图像和文本。这两类的数据就非常规整，表现在其邻居数量是固定的，但是它们仍然可以建模为图这一种数据结构。</p><h3 id="图像作为图"><a href="#图像作为图" class="headerlink" title="图像作为图"></a>图像作为图</h3><p>通常将图像视为具有图像通道的矩形网格，并将它们表示为数组（例如，244x244x3 浮点数）。<br>另一种方式就是将图像视为具有规则结构的图，其中每个像素代表一个节点，并通过边连接到相邻像素。每个非边界像素正好有 8 个邻居，每个节点存储的信息是一个 3 维向量，表示像素的 RGB 值。如下面的 5x5 笑脸图像：<br><img src="https://user-images.githubusercontent.com/6218739/142835438-5437aebb-e206-4165-8abc-ba0393d0f0a3.png" alt="imageasgraph"><br>在邻接矩阵中，我们对25个节点进行排序，并形成一个 $ n_{nodes} \times n_{nodes} $ 的矩阵，如果两个节点共享一条边，则在矩阵中填充数值，如下：<br><img src="https://user-images.githubusercontent.com/6218739/142958394-555a75ae-67ce-49a2-8210-3950f08ca9b7.png" alt="matrix"></p><h2 id="文本作为图"><a href="#文本作为图" class="headerlink" title="文本作为图"></a>文本作为图</h2><p>首先将文本进行“数字化”：比如对每个字符character、单词word或token都关联一个索引，然后文本就可以表示为一系列的索引（这种方式是文本在循环神经网络RNN 中经常表示的方式）。<br>这将创建一个简单的有向图，其中每个索引都是一个节点，并通过一条边连接到它后面的节点。如下图所示：<br><img src="https://user-images.githubusercontent.com/6218739/142958918-f8780d03-7f99-4794-9971-844de5c9f4c4.png" alt="text"></p><p>当然，在实践中，这通常不是文本和图像的编码方式：这种图graph的表达是冗余的，因为所有图像和所有文本都具有非常规则的结构。例如，图像在其邻接矩阵中具有带状结构，这是因为所有节点（像素）都在一个规则网格中相互连接。文本的邻接矩阵只是一条对角线，因为每个单词只连接到前一个单词和下一个单词。</p><h2 id="其他例子"><a href="#其他例子" class="headerlink" title="其他例子"></a>其他例子</h2><p>在计算机视觉中，我们有时想标记视觉场景中的对象。然后可以通过将这些对象视为节点，将它们的关系视为边来构建图。<br>机器学习模型，编程代码和数学方程也可以表述为图，其中变量是节点，边是将这些变量作为输入和输出的操作。术语“数据流图”dataflow graph就是这个意思。</p><h1 id="图能干什么"><a href="#图能干什么" class="headerlink" title="图能干什么"></a>图能干什么</h1><p>图上的预测任务一般分为三种类型：图级graph-level、节点级node-level和边级edge-level。<br>在图级任务中，我们预测整个图的单个属性。对于节点级任务，我们预测图中每个节点的一些属性。对于边级任务，我们希望预测图中边的属性或存在。</p><h2 id="图级任务"><a href="#图级任务" class="headerlink" title="图级任务"></a>图级任务</h2><p>在图级任务中，我们的目标是预测整个图的属性。例如，对于表示为图的分子，我们可能想要预测该分子的气味，或者它是否会与与疾病有关的受体结合。<br>比如下面例子，就是判断哪些分子结构有两个环。<br><img src="https://user-images.githubusercontent.com/6218739/142964879-87631629-7c46-4183-88e4-7d2160966d70.png" alt="graph-level"><br>这类似于 MNIST 和 CIFAR 的图像分类问题，我们希望将标签与整个图像相关联。对于文本，一个类似的问题是情感分析，我们希望一次识别整个句子的情绪或情感。</p><h2 id="节点级任务"><a href="#节点级任务" class="headerlink" title="节点级任务"></a>节点级任务</h2><p>节点级任务与预测图中每个节点的身份或角色有关。<br>节点级预测问题的一个经典示例是 Zach 的空手道俱乐部。该数据集是一个单一的社交网络图，整个图由在政治分歧后宣誓效忠两个空手道俱乐部之一的个人练习者组成。故事是这样的，Hi 先生（讲师）和 John H（管理员）之间的不和导致了空手道俱乐部的分裂。节点代表个人空手道练习者，边代表这些成员之间在空手道之外的互动。预测问题是对给定成员在发生争执后是变得忠诚于 Mr. Hi 还是 John H 进行分类。在这种情况下，此分类标签与节点到讲师或管理员之间的距离高度相关。<br><img src="https://user-images.githubusercontent.com/6218739/142966298-4f66bdd6-e14e-489f-87c4-0e125d3ec9fc.png" alt="zach"><br>（在左边我们有问题的初始条件，在右边我们有一个可能的解决方案，其中每个节点都基于联盟进行了分类。该数据集可用于其他图问题，如无监督学习。）</p><p>按照图像类比，节点级预测问题类似于图像分割，我们试图标记图像中每个像素的作用。对于文本，类似的任务是预测句子中每个单词的词性（例如名词、动词、副词等）。</p><h2 id="边级任务"><a href="#边级任务" class="headerlink" title="边级任务"></a>边级任务</h2><p>边级推理的一个例子是图像场景理解。除了识别图像中的对象外，深度学习模型还可用于预测它们之间的关系。我们可以将其表述为边级分类：给定代表图像中对象的节点，我们希望预测这些节点中的哪些共享一条边或该边的值是什么。如果我们希望发现实体（节点）之间的联系，可以考虑图完全连接后再根据它们的预测值修剪边以得到稀疏图。<br><img src="https://user-images.githubusercontent.com/6218739/142966575-d4257640-7739-43c6-9178-dbf09a1680b0.png" alt="edge-task"><br>（在上面的 (b) 中，原始图像 (a) 被分割为五个实体：两个格斗者、裁判、观众和垫子。(C) 显示了这些实体之间的关系。）<br><img src="https://user-images.githubusercontent.com/6218739/142966943-6f5556f6-8bf3-49d4-9fac-b1cf5d8fb2bf.png" alt="edge-2"><br>（左侧是根据之前的视觉场景构建的初始图，右侧是根据模型的输出对某些连接进行修剪后得到的该图可能的边标记。）</p><h1 id="在机器学习中使用图的挑战"><a href="#在机器学习中使用图的挑战" class="headerlink" title="在机器学习中使用图的挑战"></a>在机器学习中使用图的挑战</h1><p>那么，我们如何用神经网络解决这些不同的图任务呢？第一步是考虑我们将如何表示图以与神经网络兼容。<br>机器学习模型通常采用矩形或网格状阵列作为输入。因此，如何以与深度学习兼容的格式表示它们并不是很直观。图有多达四种类型的信息可能想要用来进行预测：节点、边、全局上下文和连通性。前三个比较简单：比如对于节点，我们可以通过为每个节点分配一个索引$i$从而组成一个节点特征矩阵$N$，然后在$N$中存储特征$node_i$。虽然这些矩阵具有可变数量的实例，但处理矩阵不需要任何特殊的技巧。<br>然而，表示图的连通性更为复杂。也许最明显的选择是使用邻接矩阵，因为它很容易张量化。然而，这种表示有一些缺点。<br>如下是一个示例数据集表：<br><img src="https://user-images.githubusercontent.com/6218739/142975690-bfdcacd4-8364-4dd1-94c8-f093f5711b87.png" alt="table"><br>从示例数据集表中，我们看到图中的节点数量可能达到数百万，每个节点的边数可能变化很大。通常，这会导致非常稀疏的邻接矩阵，这是空间效率低下的。<br>另一个问题是，有很多邻接矩阵可以编码相同的连通性，并不能保证这些不同的矩阵在深度神经网络中会产生相同的结果（也就是说，它们不是排列不变的）。<br>例如，前面的奥赛罗图可以用如下这两个邻接矩阵等价地描述。它也可以用节点的所有其他可能的排列来描述。<br><img src="https://user-images.githubusercontent.com/6218739/142975871-caa24e50-a2e0-496d-8be8-adc7c2120b92.png" alt="two-adjacent"><br>更直观一点，下面的这个小图由四个节点组成，可以表示它的邻接矩阵如下：<br><img src="https://user-images.githubusercontent.com/6218739/142976045-3d08ec6b-b460-471c-9712-69a4d6175b17.png" alt="simple-demo-adj"><br>可以看出，对于这么简单的一个小图，可以表示同样信息的邻接矩阵就很多了，更不必说有更多节点的奥赛罗图。</p><p>表示稀疏矩阵的一种优雅且节省内存的方法是邻接列表。它把节点$n_i$和节点$n_j$之间的边$e_k$的连通性表达为邻接表的第k个元素中的元组$(i,j)$。由于通常情况下边的数量远低于邻接矩阵的元素数量（$n_{nodes}^2$)，因此可以避免在图的断开部分（即没有边的部分）进行计算和存储。<br>举一个例子：<br><img src="https://user-images.githubusercontent.com/6218739/142979027-73439a11-218d-4cc3-8910-4e91e2036e5c.png" alt="adjacent-list"><br>可以看出，整个图graph中有8个节点和7个边。<br>Nodes列表里给出了8个节点的属性，取值只有两个0和1；Edges列表里给出了7个边的属性，取值为1或2；临界列表里则给出了这些边由哪两个节点形成，比如Edges里的倒数第二条边就是连接的7号节点和4号节点。Global给出了整个图的标识，这里标识为0。</p><p>需要注意的是，该图中每个节点/边/全局的属性都是标量，即都只有一个值，但大多数真实的图中的属性都是向量（或称特征向量或嵌入）。比如对于一个节点，上例中节点列表是$[n_{nodes}]$，但真实情况大概率是这样的形状$[n_{nodes}, node_{dim}]$。对于边的属性、全局属性也同理。</p><p>上述这种对于图的描述方式具有排列不变性。</p><h1 id="图神经网络"><a href="#图神经网络" class="headerlink" title="图神经网络"></a>图神经网络</h1><p>图神经网络GNN是对图的所有属性（节点、边、全局上下文）进行优化的变换，它保留了图的对称性（置换不变性）。这里使用 Gilmer 等人提出的“消息传递神经网络”框架构建 GNN。<br>GNN 采用“图入图出”架构，这意味着这些模型类型接受图作为输入，将信息加载到其节点、边和全局上下文中，并逐步转换这些嵌入，而不会改变输入图的连通性。</p><h2 id="最简单的GNN"><a href="#最简单的GNN" class="headerlink" title="最简单的GNN"></a>最简单的GNN</h2><p>一个最简单的 GNN架构如下：<br><img src="https://user-images.githubusercontent.com/6218739/142980841-566452d1-6626-4de6-a739-88a659a09fae.png" alt="gnn"><br>该GNN在图的每个组件上使用单独的多层感知器 (MLP)（或其他可微模型），我们称之为 GNN 层。比如，对于每个节点向量，我们应用 MLP 并返回一个学习到的节点向量；对每条边做同样的事情，学习每条边的嵌入（或称新的特征向量）；以及全局上下文向量，为整个图学习一个嵌入。（在该架构中学习了所有图属性（节点、边、全局）的新嵌入，但尚未使用图的连通性。）<br>然后将这些GNN层堆叠在一起。<br>因为 GNN 不会更新输入图的连通性，所以我们可以用与输入图相同的邻接表和相同数量的特征向量来描述 GNN 的输出图。但是，输出图更新了嵌入，因为 GNN 更新了每个节点、边和全局上下文表示。</p><h2 id="通过汇集信息进行-GNN-预测"><a href="#通过汇集信息进行-GNN-预测" class="headerlink" title="通过汇集信息进行 GNN 预测"></a>通过汇集信息进行 GNN 预测</h2><p>上面已经构建了一个简单的 GNN，但是如何在上述任何任务中进行预测呢？<br>这里考虑一个二元分类的情况（但这个框架可以很容易地扩展到多类或回归的情况）。如果任务是对节点进行二元预测，并且图形已经包含节点信息，则该方法很简单——对于每个节点嵌入，应用线性分类器。<br><img src="https://user-images.githubusercontent.com/6218739/142982195-8b262b41-61ff-4191-9b1a-dbe4384b56cb.png" alt="v-class"><br>然而，事情并不总是那么简单。例如，我们可能将图中的信息存储在边中，但节点中没有信息，但仍需要对节点进行预测。可以想象一个社交网络，我们希望匿名化用户数据（节点），不使用这些用户信息，而仅使用关系数据（边）来达到我们的预测目的。这种场景的一个实例就是之前在空手道俱乐部示例中，仅使用人与人之间的会面次数，而不使用任何具体的人的信息，来确定效忠于Mr. Hi还是John H.。<br>此时就需要一种从边收集信息并将它们提供给节点进行预测的方法。我们可以通过池化（或称汇集pooling）来做到这一点。池化分两步进行：<br>（1）对于要汇集的每个项目，收集它们的每个嵌入并将它们连接成一个矩阵。<br>（2）然后聚合收集到的嵌入，通常通过求和运算来实现。</p><p>用字母$\rho$表示池化操作，然后用$p_{E_n \to V_{n}}$表示从边上收集信息到节点上。<br><img src="https://user-images.githubusercontent.com/6218739/142982910-046a91f3-06e9-4e3c-9f52-8d38afb8b726.png" alt="pool"><br>因此，如果我们只有边上的特征，并且想尝试预测节点的二元分类信息，那可以使用池化将信息路由（或传递）到需要去的地方。<br>该模型如下。<br><img src="https://user-images.githubusercontent.com/6218739/142983257-cff12488-0713-4529-be70-803427f57b2e.png" alt="pool-class"></p><p>反过来，如果我们只有节点级特征，并试图预测边上的二元分类信息（这种场景的一个例子比如上面的边级任务，节点就是图像实体，想预测这些实体是否共享关系，即二元边）。此时模型看起来像这样。<br><img src="https://user-images.githubusercontent.com/6218739/142983667-4b88c3ac-b273-43d9-baee-eb51a60993ec.png" alt="pool-v2e"></p><p>如果我们只有节点级别的特征，并且需要预测一个全局的二进制属性，此时需要将所有可用的节点信息收集在一起并聚合它们。这类似于CNN 中的全局平均池化层。边缘到全局的信息也可以这样做。<br>（这是预测分子特性的常见场景。例如，我们有原子信息及其连通性，我们想知道一个分子的毒性（有毒/无毒），或者它是否有特定的气味（玫瑰/非玫瑰））<br><img src="https://user-images.githubusercontent.com/6218739/142983974-8e481cd7-b2f1-4dd0-b917-4213fc657673.png" alt="v2u"></p><p>在上面例子中，分类模型$c$可以很容易地替换为任何可微模型，或使用广义线性模型来做多分类问题。<br><img src="https://user-images.githubusercontent.com/6218739/142984209-6bd326ae-2a1f-416f-a908-831d536e4d08.png" alt="e2egnn"></p><p>上面构建了一个简单的 GNN 模型，并通过在图的不同部分之间路由信息来进行二元预测。这种池化技术将作为构建更复杂 GNN 模型的基石。如果我们有新的图属性，只需要定义如何将信息从一个属性传递到另一个属性即可。<br>请注意，在这个最简单的 GNN 公式中，没有在 GNN 层内部使用图的连通性。每个节点都是独立处理的，每个边以及全局上下文也是如此。我们只是在汇集信息进行预测时使用连通性。</p><h2 id="在图的各个部分之间传递消息"><a href="#在图的各个部分之间传递消息" class="headerlink" title="在图的各个部分之间传递消息"></a>在图的各个部分之间传递消息</h2><p>如上所述，我们仅在最后预测时使用了池化来汇聚消息。自然地，我们可以通过在 GNN 层之间使用池化来进行更复杂的预测，以使中间学习的嵌入（或称特征向量）知道图的连通性。<br>我们可以使用消息传递来做到这一点，其中相邻的节点或边交换信息，并影响彼此更新后的嵌入。<br>消息传递分三步进行：<br>（1）对于图中的每个节点，收集所有相邻节点嵌入（或消息）；<br>（2）通过聚合函数（如 sum）聚合所有消息；<br>（3）所有汇集的消息都通过一个更新函数，该函数通常是一个可学习的神经网络。<br>（第二步和第三步顺序可以调整，即先更新再聚合，这种方式也具有置换不变性）</p><p>整个过程如下所示：<br><img src="https://user-images.githubusercontent.com/6218739/142985277-0ffce405-5353-42b7-977e-f95861a0309b.png" alt="message"></p><p>正如池化可以应用于节点或边一样，消息传递可以发生在节点或边之间。<br>这些步骤是利用图形连通性的关键。我们将在 GNN 层中构建更精细的消息传递变体，从而产生具有增加表现力和能力的 GNN 模型。</p><p>这一系列操作，当应用一次时，就是消息传递 GNN 层的最简单形式。<br>这跟图像处理中的标准卷积操作类似：本质上，消息传递和卷积是聚合和处理元素邻居的信息以更新元素值的操作。在图中，元素是一个节点，而在图像中，元素是一个像素。然而，图中相邻节点的数量可以是可变的，这与每个像素具有一组固定数量相邻元素的图像不同。<br>通过将传递 GNN 层的消息堆叠在一起，一个节点最终可以合并来自整个图的信息：在三层之后，一个节点拥有距离它三步远的节点的信息。（这跟图像中的感受野类似）</p><p>于是，前面最简单的GNN架构图可以增加上面这一部分内容，即包含新的节点消息源，形成一个更复杂的GNN架构：<br><img src="https://user-images.githubusercontent.com/6218739/142985721-2aa3d0de-13af-4188-8ac2-85893ca8174f.png" alt="updated-gnn-arch"></p><h2 id="学习边的表示"><a href="#学习边的表示" class="headerlink" title="学习边的表示"></a>学习边的表示</h2><p>我们的数据集并不总是包含所有类型的信息（节点、边和全局上下文）。当我们想对节点进行预测，但我们的数据集只有边信息时，我们在上面展示了如何使用池化将信息从边路由到节点，但仅限于模型的最后预测步骤。我们可以使用消息传递在 GNN 层内的节点和边之间共享信息。<br>我们可以以与之前使用相邻节点信息相同的方式合并来自相邻边的信息，首先将边信息池化，用更新函数对其进行转换，然后存储它。<br>但是，图中存储的节点和边信息不一定具有相同的大小或形状，因此如何将它们组合起来还不是很清楚。一种方法是学习从边空间到节点空间的线性映射，反之亦然。或者，可以在更新函数之前将它们连接在一起。模型如下：<br><img src="https://user-images.githubusercontent.com/6218739/142986481-f4cf8094-d378-4690-94f6-8c87e9a9337c.png" alt="message-v-e"><br>构建GNN时一个需要设计的地方在于：更新哪些图属性以及更新它们的顺序。我们可以选择是在缘嵌入之前更新节点嵌入，或者以相反的顺序。<br>该领域仍在活跃研究中，目前有多种解决方案。例如，我们可以以“编织”方式进行更新：<br><img src="https://user-images.githubusercontent.com/6218739/142986915-9a7204b5-d4d3-4940-94bf-aa00cece8f1e.png" alt="weave"></p><h2 id="添加全局表示"><a href="#添加全局表示" class="headerlink" title="添加全局表示"></a>添加全局表示</h2><p>到目前为止，上面描述的网络存在一个缺陷：图中彼此相距很远的节点可能永远无法有效地相互传输信息，即使我们多次应用消息传递。对于一个节点，如果我们有 k 层，信息最多将传播 k 步。对于预测任务依赖于相距很远的节点或节点组的情况，这可能是一个问题。<br>一种解决方案是让所有节点都能够相互传递信息。不幸的是，对于大图来说，这很快就会变得计算成本很高（尽管称为“虚拟边”的方法已被用于分子等小图）。<br>该问题的一种解决方案是使用图 (U) 的全局表示，该图有时称为主节点master node或上下文向量。这个全局上下文向量连接到网络中的所有其他节点和边，并可以作为它们之间的桥梁来传递信息，从而为整个图构建一个表示。这创建了一个更丰富、更复杂的而不是通过其他方式学习的图表示。<br><img src="https://user-images.githubusercontent.com/6218739/142987592-8bb25c8f-7b42-493f-aebd-a1879043f834.png" alt="U"><br>上述架构称为Graph Nets。</p><p>此时，可以发现，所有的图属性都学习了表示，因此我们可以在池化过程中通过调节我们感兴趣的属性的信息来使用它们。例如，对于一个节点，我们可以考虑来自相邻节点、所连接的边和全局信息的信息。为了在所有这些可能的信息源上调整新节点嵌入，我们可以简单地将它们连接起来。此外，我们还可以通过线性映射将它们映射到相同的空间并添加它们或应用特征调制层，这可以被认为是一种特征化的注意力机制。<br><img src="https://user-images.githubusercontent.com/6218739/142988081-315d33c4-d905-4d63-8ba9-8f42c911c084.png" alt="complex"></p><h1 id="GNN游乐场"><a href="#GNN游乐场" class="headerlink" title="GNN游乐场"></a>GNN游乐场</h1><p>上面给出了GNN的各种架构和组件，到底在实践中怎么用呢？<br>作者直接给出了一个在线DEMO，即GNN游乐场，该游乐场基于tensorflow.js构建，用户在上面可以自由地玩耍和配置，从而探索上面不同的组件和架构如何用于GNN中。<br>整个DEMO展示了一个带有小分子图的图级预测任务。使用 Leffingwell 气味数据集，它由具有相关气味感知（标签）的分子组成。<br>预测分子结构（图）与其气味的关系是一个跨越化学、物理、神经科学和机器学习的百年历史问题。为了简化问题，只考虑每个分子的一个二元标签，根据专业调香师的标签，对分子图是否闻起来“刺鼻”进行分类。如果一个分子具有强烈、醒目的气味，我们就说它具有“刺鼻”气味。例如，可能含有烯丙醇分子的大蒜和芥末就具有这种性质。胡椒酮分子，通常用于薄荷味糖果，也被描述为具有刺鼻的气味。<br>这里将每个分子表示为一个图，其中原子是包含对其原子身份（碳、氮、氧、氟）进行独热编码的节点，而键是包含对其键类型（单、双、三重或芳香）进行独热编码的边。<br>针对这个问题的通用建模模板是使用GNN层序列构建，然后接一个用于分类的 sigmoid 激活函数。<br>整个GNN模型有多个超参数可供调节：<br>（1）GNN 层数，也称为深度；<br>（2）更新时每个属性的维度。更新函数是一个 1 层 MLP，其具有 relu 激活函数和用于激活归一化的标准化层；<br>（3）池化中使用的聚合函数：max、mean 或 sum；<br>（4）更新的图形属性或消息传递的样式：节点、边和全局表示。我们通过布尔切换（开或关）来控制这些。基线模型是一个与图无关的 GNN（关闭所有消息传递），它将最后的所有数据聚合到一个全局属性中。打开所有的消息传递函数就会形成一个 Graph Nets 架构（即上面添加了全局表示的GNN架构）。</p><p>为了更好地理解 GNN 如何学习图的任务优化表示，作者还查看了 GNN 的倒数第二层激活。这些“图嵌入”是 GNN 模型在预测之前的输出。由于使用广义线性模型进行预测，因此线性映射足以让用户了解如何围绕决策边界学习表示。但由于这些是高维向量，所以通过主成分分析 (PCA) 将它们简化为 2D。一个完美的模型可以很容易地将这个决策边界显示出来，但由于这里压缩了维度并且模型也不完美，因此这个边界可能很难看到。（如下截图有点那个边界的意思了）</p><p>游乐场的截图如下：<br><img src="https://user-images.githubusercontent.com/6218739/142991597-b51165df-ac35-49b6-a5c0-dad0633d2dd0.png" alt="playground"></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://distill.pub/2021/gnn-intro/">A Gentle Introduction to Graph Neural Networks</a><br><a href="https://zhuanlan.zhihu.com/p/75307407">图神经网络（Graph Neural Networks，GNN）综述</a><br><a href="https://cloud.tencent.com/developer/article/1479463">GNN 系列：Graph 基础知识介绍</a></p>]]></content>
    
    
    <summary type="html">本文基本是对A Gentle Introduction to Graph Neural Networks这篇文章的翻译理解。
（注意：原文中有很多可交互的动画，更有启发性。本文对原文中的有些图像进行了调整，方便初学者理解）

简介
（这部分大都来自于这篇参考文献）
曾有学者将本次人工智能浪潮的兴起归因于三个条件，分别是：
（1）计算资源的快速发展（如GPU）
（2）大量训练数据的可用性
（3）深度学习从欧氏空间数据中提取潜在特征的有效性
尽管传统的深度学习方法被应用在提取欧氏空间数据的特征方面取得了巨大的成功，但许多实际应用场景中的数据是从非欧式空间生成的，传统的深度学习方法在处理非欧式空间数</summary>
    
    
    
    <category term="machine learning" scheme="http://qixinbo.github.io/categories/machine-learning/"/>
    
    
    <category term="GNN" scheme="http://qixinbo.github.io/tags/GNN/"/>
    
  </entry>
  
  <entry>
    <title>ImagePy解析： 28 -- 三维可视化</title>
    <link href="http://qixinbo.github.io/2021/11/18/ImagePy_28/"/>
    <id>http://qixinbo.github.io/2021/11/18/ImagePy_28/</id>
    <published>2021-11-17T16:00:00.000Z</published>
    <updated>2021-11-18T08:22:51.670Z</updated>
    
    <content type="html"><![CDATA[<p>本文解析一下ImagePy的三维画布。<br>以如下例子入手：<br><img src="https://user-images.githubusercontent.com/6218739/141955577-f4a7c5c5-0a9a-409b-9fde-399a92f0c1d8.png" alt="demo"><br>首先，原始图像是一个5乘5的方形图像，其中间是4乘4的白色，周围是一圈黑色。<br>由这张原始图根据距离变换得到右上角的高程图，继而对该高程图做三维可视化。</p><h1 id="渲染插件"><a href="#渲染插件" class="headerlink" title="渲染插件"></a>渲染插件</h1><p>二维平面的三维可视化插件是这样写的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Surface2D</span>(<span class="params">Simple</span>):</span></span><br><span class="line">    title = <span class="string">&#x27;2D Surface&#x27;</span></span><br><span class="line">    note = [<span class="string">&#x27;8-bit&#x27;</span>, <span class="string">&#x27;16-bit&#x27;</span>, <span class="string">&#x27;float&#x27;</span>]</span><br><span class="line">    para = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;undifine&#x27;</span>, <span class="string">&#x27;sample&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;sigma&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;h&#x27;</span>:<span class="number">0.3</span>, <span class="string">&#x27;cm&#x27;</span>:<span class="string">&#x27;gray&#x27;</span>&#125;</span><br><span class="line">    view = [(<span class="built_in">str</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">            (<span class="built_in">int</span>, <span class="string">&#x27;sample&#x27;</span>, (<span class="number">1</span>,<span class="number">10</span>), <span class="number">0</span>, <span class="string">&#x27;down sample&#x27;</span>, <span class="string">&#x27;pix&#x27;</span>),</span><br><span class="line">            (<span class="built_in">int</span>, <span class="string">&#x27;sigma&#x27;</span>, (<span class="number">0</span>,<span class="number">30</span>), <span class="number">0</span>, <span class="string">&#x27;sigma&#x27;</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">            (<span class="built_in">float</span>, <span class="string">&#x27;h&#x27;</span>, (<span class="number">0.1</span>,<span class="number">10</span>), <span class="number">1</span>, <span class="string">&#x27;scale z&#x27;</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">            (<span class="string">&#x27;cmap&#x27;</span>, <span class="string">&#x27;cm&#x27;</span>, <span class="string">&#x27;color map&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, ips, imgs, para = <span class="literal">None</span></span>):</span></span><br><span class="line">        ds, sigma, cm = para[<span class="string">&#x27;sample&#x27;</span>], para[<span class="string">&#x27;sigma&#x27;</span>], ColorManager.get(para[<span class="string">&#x27;cm&#x27;</span>])</span><br><span class="line">        mesh = Surface2d(ips.img, sample=ds, sigma=sigma, k=para[<span class="string">&#x27;h&#x27;</span>], cmap=cm)</span><br><span class="line">        self.app.show_mesh(mesh, para[<span class="string">&#x27;name&#x27;</span>])</span><br></pre></td></tr></table></figure><br>其界面为：<br><img src="https://user-images.githubusercontent.com/6218739/141955719-7c81041c-9c56-4f10-ba0c-1d5d68643f20.png" alt="interface"><br>即设定名字、下采样率、平滑率和z轴伸缩率，以及渲染所用的colormap。(在该demo中，就按如图中的参数进行设置)<br>然后将这些参数传给Surface2d这个ImagePy定义的Mesh对象。<br>最后调用show_mesh方法将其呈现出来。<br>下面是一步步分析这个Mesh对象及其绘制方法。</p><h1 id="Mesh对象"><a href="#Mesh对象" class="headerlink" title="Mesh对象"></a>Mesh对象</h1><p>如前所述，二维高程图传给了Surface2d这一类，具体看一下其代码实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Surface2d</span>(<span class="params">Mesh</span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, img=<span class="literal">None</span>, sample=<span class="number">1</span>, sigma=<span class="number">0</span>, k=<span class="number">0.3</span>, **key</span>):</span></span><br><span class="line">self.img, self.sample, self.sigma, self.k = img, sample, sigma, k</span><br><span class="line">Mesh.__init__(self, **key)</span><br><span class="line">self.set_data(img, sample, sigma, k)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_data</span>(<span class="params">self, img=<span class="literal">None</span>, sample=<span class="literal">None</span>, sigma=<span class="literal">None</span>, k=<span class="literal">None</span>, **key</span>):</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> img <span class="keyword">is</span> <span class="literal">None</span>: self.img = img</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> sample <span class="keyword">is</span> <span class="literal">None</span>: self.sample = sample</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> sigma <span class="keyword">is</span> <span class="literal">None</span>: self.sigma = sigma</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> k <span class="keyword">is</span> <span class="literal">None</span>: self.k = k</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">sum</span>([<span class="keyword">not</span> i <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">for</span> i <span class="keyword">in</span> (img, sample, sigma, k)])&gt;<span class="number">0</span>:</span><br><span class="line"><span class="keyword">from</span> ..util <span class="keyword">import</span> meshutil</span><br><span class="line">vert, fs = meshutil.create_surface2d(self.img, self.sample, self.sigma, self.k)</span><br><span class="line">Mesh.set_data(self, verts=vert, faces=fs.astype(np.uint32), colors=vert[:,<span class="number">2</span>], **key)</span><br><span class="line"><span class="keyword">else</span>: Mesh.set_data(self, **key)</span><br></pre></td></tr></table></figure><br>可以看到，在它的初始化函数中调用了set_data方法。进一步地，在该方法中有两个核心方法：将图像转化为顶点和面，然后再转为Mesh对象。</p><h2 id="位图提取格点坐标和像素值"><a href="#位图提取格点坐标和像素值" class="headerlink" title="位图提取格点坐标和像素值"></a>位图提取格点坐标和像素值</h2><p>即如下方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vert, fs = meshutil.create_surface2d(self.img, self.sample, self.sigma, self.k)</span><br></pre></td></tr></table></figure><br>源码及注释为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_surface2d</span>(<span class="params">img, sample=<span class="number">1</span>, sigma=<span class="number">0</span>, k=<span class="number">0.3</span></span>):</span></span><br><span class="line">    <span class="keyword">from</span> scipy.ndimage <span class="keyword">import</span> gaussian_filter</span><br><span class="line">    <span class="comment">#start = time()</span></span><br><span class="line">    <span class="comment"># 以采样率为步长进行图像的重新提取</span></span><br><span class="line">    img = img[::sample, ::sample].astype(np.float32)</span><br><span class="line">    <span class="comment"># 如果指定了平滑率，则使用高斯滤波进行平滑</span></span><br><span class="line">    <span class="keyword">if</span> sigma&gt;<span class="number">0</span>: img = gaussian_filter(img, sigma)</span><br><span class="line">    <span class="comment"># 根据采样后的图像形状生成网格格点</span></span><br><span class="line">    xs, ys = np.mgrid[:img.shape[<span class="number">0</span>],:img.shape[<span class="number">1</span>]]</span><br><span class="line">    <span class="comment"># 根据采样率，将格点范围伸缩到之前的大小</span></span><br><span class="line">    xs *= sample; ys *= sample</span><br><span class="line">    <span class="comment"># 将图像像素值乘以伸缩大小，作为z轴的值，与格点坐标xy传入下面的方法</span></span><br><span class="line">    <span class="keyword">return</span> create_grid_mesh(xs, ys, img*k)</span><br></pre></td></tr></table></figure><br>在此例中，依照上面的参数，来看一下各个中间结果：<br>首先高程图在降采样后，图像矩阵为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">2.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]]</span><br></pre></td></tr></table></figure><br>然后在$\sigma=1$的高斯滤波后，图像矩阵为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">0.17534617</span> <span class="number">0.2415005</span>  <span class="number">0.17534617</span>]</span><br><span class="line"> [<span class="number">0.2415005</span>  <span class="number">0.3326134</span>  <span class="number">0.2415005</span> ]</span><br><span class="line"> [<span class="number">0.17534617</span> <span class="number">0.2415005</span>  <span class="number">0.17534617</span>]]</span><br></pre></td></tr></table></figure><br>其再经过k倍的伸缩，变为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">0.8767308</span> <span class="number">1.2075025</span> <span class="number">0.8767308</span>]</span><br><span class="line"> [<span class="number">1.2075025</span> <span class="number">1.6630671</span> <span class="number">1.2075025</span>]</span><br><span class="line"> [<span class="number">0.8767308</span> <span class="number">1.2075025</span> <span class="number">0.8767308</span>]]</span><br></pre></td></tr></table></figure><br>同时xs和ys即网格格点坐标，也经过了降采样，以及范围伸缩，变为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">2</span> <span class="number">2</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">4</span> <span class="number">4</span>]]</span><br></pre></td></tr></table></figure></p><h2 id="获取格点和面的信息"><a href="#获取格点和面的信息" class="headerlink" title="获取格点和面的信息"></a>获取格点和面的信息</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_grid_mesh</span>(<span class="params">xs, ys, zs</span>):</span></span><br><span class="line">    h, w = xs.shape</span><br><span class="line">    <span class="comment"># 将xy坐标位置和z值合并起来</span></span><br><span class="line">    vts = np.array([xs, ys, zs], dtype=np.float32)</span><br><span class="line">    <span class="comment"># 这一步是定义以某格点为参考点的坐标系下它与哪些点形成面</span></span><br><span class="line">    <span class="comment"># 在局部坐标系下，参考点索引为0，那么它所构成的面有两个</span></span><br><span class="line">    <span class="comment"># 分别与(1, 1+w)这两个点构成一个面，与(1+w, w)这两个点构成一个面</span></span><br><span class="line">    <span class="comment"># 比如在此例下，did的值就是[[0 1 4 0 4 3]]</span></span><br><span class="line">    did = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>+w, <span class="number">0</span>, <span class="number">1</span>+w, w]], dtype=np.uint32)</span><br><span class="line">    <span class="comment"># rcs由两部分构成</span></span><br><span class="line">    <span class="comment"># 第一部分是获取全局坐标系下每一排的第一个元素的索引，所以是以w为步长</span></span><br><span class="line">    <span class="comment"># 注意排除最后一排，即是w*h还要减去w，因为最后一排元素所参与的面可以通过倒数第二排来获得</span></span><br><span class="line">    <span class="comment"># 对于此例，就是[[0], [3]]，注意这里使用None来增加一个维度</span></span><br><span class="line">    <span class="comment"># 第二部分是获取全局坐标系下每一列的索引，所以是以1为步长</span></span><br><span class="line">    <span class="comment"># 注意是排除最后一列，即w要减去1，这也是因为最后一列参与的面可以通过前一列得到</span></span><br><span class="line">    <span class="comment"># 对于此例，就是[0, 1]</span></span><br><span class="line">    <span class="comment"># 最终rcs就是numpy数组的[[0],[3]]+[0, 1]</span></span><br><span class="line">    <span class="comment"># 这里用到了numpy的广播： https://qixinbo.info/2019/10/20/python-indexing/</span></span><br><span class="line">    <span class="comment"># [[0, 0],[3, 3]] + [[0, 1], [0, 1]] = [[0, 1], [3, 4]]</span></span><br><span class="line">    <span class="comment"># 代表的意思就是在全局坐标系中，第一排取索引为0和1的格点，在第二排取索引为3和4的格点</span></span><br><span class="line">    rcs = np.arange(<span class="number">0</span>,w*h-w,w)[:,<span class="literal">None</span>] + np.arange(<span class="number">0</span>,w-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 接下来就是根据上面取得的格点，得到每个格点上所形成的面</span></span><br><span class="line">    <span class="comment"># 首先第一部分是将rcs拉直为[[0], [1], [3], [4]]，即这四个格点索引拉平到一个维度上</span></span><br><span class="line">    <span class="comment"># 然后加上上面的局部坐标系下形成面的格点索引[[0 1 4 0 4 3]]</span></span><br><span class="line">    <span class="comment"># 同样根据广播原则，就得到了每个格点与相邻点所形成的面</span></span><br><span class="line">    <span class="comment"># 结果为：[[0 1 4 0 4 3], [1 2 5 1 5 4], [3 4 7 3 7 6], [4 5 8 4 8 7]] </span></span><br><span class="line">    <span class="comment"># 即每个格点上都参与形成两个面，具体每一个面的格点组成看上面的序列</span></span><br><span class="line">    faces = rcs.reshape(-<span class="number">1</span>,<span class="number">1</span>) + did</span><br><span class="line">    <span class="comment"># 返回值是两个</span></span><br><span class="line">    <span class="comment"># 第一个就是格点坐标及其上面的值，并按这三个值合并起来算一个重新改变形状</span></span><br><span class="line">    <span class="comment"># 第二个就是由格点所形成的面的信息</span></span><br><span class="line">    <span class="keyword">return</span> vts.reshape(<span class="number">3</span>,-<span class="number">1</span>).T.copy(), faces.reshape(-<span class="number">1</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>具体的解析过程见上面源码。<br>最后说一下最终返回的格点信息和面信息，分别是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">0.</span>        <span class="number">0.</span>        <span class="number">0.8767308</span>]</span><br><span class="line"> [<span class="number">0.</span>        <span class="number">2.</span>        <span class="number">1.2075025</span>]</span><br><span class="line"> [<span class="number">0.</span>        <span class="number">4.</span>        <span class="number">0.8767308</span>]</span><br><span class="line"> [<span class="number">2.</span>        <span class="number">0.</span>        <span class="number">1.2075025</span>]</span><br><span class="line"> [<span class="number">2.</span>        <span class="number">2.</span>        <span class="number">1.6630671</span>]</span><br><span class="line"> [<span class="number">2.</span>        <span class="number">4.</span>        <span class="number">1.2075025</span>]</span><br><span class="line"> [<span class="number">4.</span>        <span class="number">0.</span>        <span class="number">0.8767308</span>]</span><br><span class="line"> [<span class="number">4.</span>        <span class="number">2.</span>        <span class="number">1.2075025</span>]</span><br><span class="line"> [<span class="number">4.</span>        <span class="number">4.</span>        <span class="number">0.8767308</span>]]</span><br></pre></td></tr></table></figure><br>以第一个格点为例，它是在(0, 0)坐标，同时上面的值是0.8767308。<br>以及面信息：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">0</span> <span class="number">1</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">4</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">2</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">5</span> <span class="number">4</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">4</span> <span class="number">7</span>]</span><br><span class="line"> [<span class="number">3</span> <span class="number">7</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">8</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">8</span> <span class="number">7</span>]]</span><br></pre></td></tr></table></figure><br>以第一个面为例，它由(0, 1, 4)号格点组成。</p><h2 id="构建Mesh对象"><a href="#构建Mesh对象" class="headerlink" title="构建Mesh对象"></a>构建Mesh对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传入上面的格点、面、颜色（这里取的是格点上的z值）以及cmap</span></span><br><span class="line">Mesh.set_data(self, verts=vert, faces=fs.astype(np.uint32), colors=vert[:,<span class="number">2</span>], **key)</span><br></pre></td></tr></table></figure><p>上述代码是调用了Mesh对象的set_data方法。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mesh</span>:</span></span><br><span class="line"><span class="comment"># 在初始化函数中传入一个Mesh对象所需要的信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, verts=<span class="literal">None</span>, faces=<span class="literal">None</span>, colors=<span class="literal">None</span>, cmap=<span class="literal">None</span>, **key</span>):</span></span><br><span class="line"><span class="comment"># 如果有格点信息，但没有面信息</span></span><br><span class="line"><span class="keyword">if</span> faces <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> verts <span class="keyword">is</span> <span class="literal">None</span>: </span><br><span class="line"><span class="comment"># 则直接按格点个数-1生成面，即两个相邻格点相连，就成为面</span></span><br><span class="line">faces = np.arange(<span class="built_in">len</span>(verts), dtype=np.uint32)</span><br><span class="line"><span class="comment"># 传入格点信息</span></span><br><span class="line">self.verts = verts.astype(np.float32, copy=<span class="literal">False</span>) <span class="keyword">if</span> <span class="keyword">not</span> verts <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"><span class="comment"># 传入面信息</span></span><br><span class="line">self.faces = faces.astype(np.uint32, copy=<span class="literal">False</span>) <span class="keyword">if</span> <span class="keyword">not</span> faces <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"><span class="comment"># 传入颜色信息</span></span><br><span class="line">self.colors = colors</span><br><span class="line"><span class="comment"># 设置模式、可见性和dirty属性等</span></span><br><span class="line">self.mode, self.visible, self.dirty = <span class="string">&#x27;mesh&#x27;</span>, <span class="literal">True</span>, <span class="string">&#x27;geom&#x27;</span></span><br><span class="line"><span class="comment"># 设置alpha透明度和边信息</span></span><br><span class="line">self.alpha = <span class="number">1</span>; self.edges = <span class="literal">None</span></span><br><span class="line"><span class="comment"># 设置高光、colormap</span></span><br><span class="line">self.high_light = <span class="literal">False</span>; self.cmap = <span class="string">&#x27;gray&#x27;</span> <span class="keyword">if</span> cmap <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> cmap</span><br><span class="line"><span class="comment"># 调用set_data方法</span></span><br><span class="line">self.set_data(**key)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_data</span>(<span class="params">self, verts=<span class="literal">None</span>, faces=<span class="literal">None</span>, colors=<span class="literal">None</span>, **key</span>):</span></span><br><span class="line"><span class="comment"># 同上面的初始化功能近似，区别是可以直接调用它来配置信息</span></span><br><span class="line"><span class="keyword">if</span> faces <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> verts <span class="keyword">is</span> <span class="literal">None</span>: </span><br><span class="line">faces = np.arange(<span class="built_in">len</span>(verts), dtype=np.uint32)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> verts <span class="keyword">is</span> <span class="literal">None</span>: self.verts = verts.astype(np.float32, copy=<span class="literal">False</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> faces <span class="keyword">is</span> <span class="literal">None</span>: self.faces = faces.astype(np.uint32, copy=<span class="literal">False</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> colors <span class="keyword">is</span> <span class="literal">None</span>: self.colors = colors</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> faces <span class="keyword">is</span> <span class="literal">None</span>: self.edge = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">sum</span>([i <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">for</span> i <span class="keyword">in</span> [verts, faces, colors]])&lt;<span class="number">3</span>: self.dirty = <span class="string">&#x27;geom&#x27;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> self.faces <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> self.faces.ndim==<span class="number">1</span>: key[<span class="string">&#x27;mode&#x27;</span>] = <span class="string">&#x27;points&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> <span class="keyword">not</span> self.faces <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> self.faces.shape[<span class="number">1</span>]==<span class="number">2</span>: </span><br><span class="line"><span class="keyword">if</span> key.get(<span class="string">&#x27;mode&#x27;</span>, self.mode)==<span class="string">&#x27;mesh&#x27;</span>: key[<span class="string">&#x27;mode&#x27;</span>] = <span class="string">&#x27;grid&#x27;</span></span><br><span class="line"><span class="keyword">if</span> key.get(<span class="string">&#x27;mode&#x27;</span>, self.mode) != self.mode: self.dirty = <span class="string">&#x27;geom&#x27;</span></span><br><span class="line">self.mode = key.get(<span class="string">&#x27;mode&#x27;</span>, self.mode)</span><br><span class="line">self.visible = key.get(<span class="string">&#x27;visible&#x27;</span>, self.visible)</span><br><span class="line">self.alpha = key.get(<span class="string">&#x27;alpha&#x27;</span>, self.alpha)</span><br><span class="line">self.high_light = key.get(<span class="string">&#x27;high_light&#x27;</span>, <span class="literal">False</span>)</span><br><span class="line">self.cmap = key.get(<span class="string">&#x27;cmap&#x27;</span>, self.cmap)</span><br><span class="line">self.dirty = self.dirty <span class="keyword">or</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></p><h1 id="可视化Mesh"><a href="#可视化Mesh" class="headerlink" title="可视化Mesh"></a>可视化Mesh</h1><p>即将Mesh对象通过三维画布展示出来：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.app.show_mesh(mesh, para[<span class="string">&#x27;name&#x27;</span>])</span><br></pre></td></tr></table></figure><br>这里就是调用了app的show_mesh方法。<br>ImagePy的三维画布是基于VisPy的，同时又进行了封装，最底层的是如下这个类：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Canvas3D</span>(<span class="params">scene.SceneCanvas</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, parent, scene3d=<span class="literal">None</span></span>):</span></span><br><span class="line">        self = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">        scene.SceneCanvas.__init__(self, app=<span class="string">&quot;wx&quot;</span>, parent=parent, keys=<span class="string">&#x27;interactive&#x27;</span>, show=<span class="literal">True</span>, dpi=<span class="number">150</span>)</span><br><span class="line">        canvas = parent.GetChildren()[-<span class="number">1</span>]</span><br><span class="line">        self.unfreeze()</span><br><span class="line">        self.canvas = weakref.ref(canvas)</span><br><span class="line">        self.view = self.central_widget.add_view()</span><br><span class="line">        self.set_scene(scene3d <span class="keyword">or</span> Scene())</span><br><span class="line">        self.visuals = &#123;&#125;</span><br><span class="line">        self.curobj = <span class="literal">None</span></span><br><span class="line">        self.freeze()</span><br><span class="line">        canvas.Bind(wx.EVT_IDLE, self.on_idle)</span><br><span class="line">        canvas.tool = <span class="literal">None</span></span><br><span class="line">        canvas.camera = scene.cameras.TurntableCamera(parent=self.view.scene, fov=<span class="number">45</span>, name=<span class="string">&#x27;Turntable&#x27;</span>)</span><br><span class="line">        canvas.set_camera = self.set_camera</span><br><span class="line">        canvas.fit = <span class="keyword">lambda</span> : self.set_camera(auto=<span class="literal">True</span>)</span><br><span class="line">        canvas.at = self.at</span><br><span class="line">        self.view.camera = canvas.camera</span><br><span class="line">        <span class="keyword">return</span> canvas</span><br></pre></td></tr></table></figure><br>VisPy的教程略微有点少，留坑待填。</p>]]></content>
    
    
    <summary type="html">本文解析一下ImagePy的三维画布。
以如下例子入手：

首先，原始图像是一个5乘5的方形图像，其中间是4乘4的白色，周围是一圈黑色。
由这张原始图根据距离变换得到右上角的高程图，继而对该高程图做三维可视化。

渲染插件
二维平面的三维可视化插件是这样写的：
1
2
3
4
5
6
7
8
9
10
11
12
13
14


class Surface2D(Simple):
    title = &#39;2D Surface&#39;
    note = [&#39;8-bit&#39;, &#39;16-bit&#39;, &#39;float&#39;]
    para = {&#39;name&#39;:&#39;undifine&#39;, &#39;sample&#39;:2, &#39;</summary>
    
    
    
    <category term="computer vision" scheme="http://qixinbo.github.io/categories/computer-vision/"/>
    
    
    <category term="ImagePy" scheme="http://qixinbo.github.io/tags/ImagePy/"/>
    
  </entry>
  
</feed>
