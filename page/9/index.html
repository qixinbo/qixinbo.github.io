<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"qixinbo.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Be interesting!">
<meta property="og:type" content="website">
<meta property="og:title" content="亓欣波">
<meta property="og:url" content="http://qixinbo.github.io/page/9/index.html">
<meta property="og:site_name" content="亓欣波">
<meta property="og:description" content="Be interesting!">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Xin-Bo Qi(亓欣波)">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://qixinbo.github.io/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>亓欣波</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">亓欣波</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Hi, I am Xin-Bo Qi (亓欣波)</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-scholar">

    <a href="/scholar/" rel="section"><i class="bar-chart fa-fw"></i>scholar</a>

  </li>
        <li class="menu-item menu-item-sources">

    <a href="/sources/" rel="section"><i class="rss fa-fw"></i>sources</a>

  </li>
        <li class="menu-item menu-item-gallery">

    <a href="/gallery/" rel="section"><i class="file-image-o fa-fw"></i>gallery</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404.html" rel="section"><i class="heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2016/11/29/dealii-learn-step48/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Be interesting!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亓欣波">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/11/29/dealii-learn-step48/" class="post-title-link" itemprop="url">求解偏微分方程开源有限元软件deal.II学习--Step 48</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-11-29 00:00:00" itemprop="dateCreated datePublished" datetime="2016-11-29T00:00:00+08:00">2016-11-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 15:20:30" itemprop="dateModified" datetime="2021-03-25T15:20:30+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computational-material-science/" itemprop="url" rel="index"><span itemprop="name">computational material science</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2016/11/29/dealii-learn-step48/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/11/29/dealii-learn-step48/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>本例提供了一个框架来应用MatrixFree类，既包括求解非线性偏微分方程过程，同时演示MatrixFree类怎样处理“constraints”以及如何在分布式节点上并行。这个算例显示基于单元的运算在六面体单元的二阶或更高阶插值上要比稀疏矩阵-向量乘法快得多，能达到后者10倍的浮点运算速率。<br>使用MatrixFree类，可以不用组装一个大型的稀疏矩阵，其运算都是基于单元。这里的并行也充分利用了现代超算机器的架构，分为三个层级：</p>
<ul>
<li>不同节点之间使用MPI并行</li>
<li>单个节点内使用“动态任务规划”进行线程并行</li>
<li>单个核心内使用处理器的向量单元进行显式向量化并行</li>
</ul>
<p>很多通用有限元包，比如deal.II、libMesh等都将有限元计算和线性代数分开，然后依赖迭代型求解器的稀疏矩阵-向量乘法的内核，比如直接应用特定线性代数包PETSc或Trilinos等。这个算例想要挑战这种传统的将线性代数和有限元组装分开的思路。</p>
<p>具体来说，就是不组装一个全局的稀疏矩阵，仅仅存储参考单元形函数信息、自由度的枚举、从参考单元到真实单元的变换。通常情况下这个方法能够显著降低存储需求，在数值结算操作上比系数矩阵稍有增大，但有时甚至会更少。降低内存需求会提高浮点运算速率，因为稀疏矩阵运算通常受限于内存带宽，而不是浮点运算。尽管可以将稀疏矩阵优化成比如只运算非零元素的模式，但此时的浮点运算速率很少能超过峰值运算的2%-20%。<br>除了稀疏矩阵-向量乘法较差的计算性能，对于一个d维的(p-1)次的有限单元来说，矩阵中每排的非零元素的数目与p的d次方成正比，这样对于很高次的方法的开销就很大。如果我们将有限元算子分割成用参考单元的形函数值及其导数表示的函数计算和积分步，那么就可以通过一个张量乘法一次就对一个维度上的形函数信息同时计算，这使得计算复杂度变为每个自由度计算d^2p此，这在文献中称为sum-factorization方法。<br>之前的有限元方法应用中通常存储单元矩阵及其指标，这些单元矩阵再组成总体刚度矩阵，这是一种“一个元素一个元素”的存储方法。然后这种方法增大了内存消耗量。最近，不明确存储矩阵、基于单元的方法已经用在GPU运算和一些应用导向的软件包如SPEC-FEM 3D中。</p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>这里还是选择一个通用问题：算子A对一个向量u作用。<br>如果用了MPI并行，那么算法就是：<br>(1)从其他MPI进程中导入向量值，用于当前MPI进程在自己所拥有的单元上的计算。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update_ghost_values</span><br></pre></td></tr></table></figure>
<p>(2)对当前拥有的单元进行循环(在当前MPI进程中进行线程并行)<br>(2.1)取得当前单元上向量的局部值<br>(2.2)通过积分计算当前单元上矩阵与向量的值<br>(2.3)将当前单元的贡献叠加到全局目标向量中<br>(3)与另一个MPI进程所拥有的单元交换所计算的信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compress</span><br></pre></td></tr></table></figure>
<p>第(2.2)步可以通过显式地构建单元矩阵A来实现，这就是通常的存储矩阵的所有元素的方法。为了避免这种显式地存储，就可以用无矩阵方式(还有另外一种方法，是FEniCs软件包中用的方式，但其局限于线性算子和简单几何上，即雅各比变换是常量，所以不如下面更通用)：<br>在单元上通过积分计算“算子作用在向量上”：计算有限元函数u在所有积分点上的值和/或它的导数，然后用所有与此单元相关的试函数来测试。<br>下面是对方法的具体分析。</p>
<h2 id="局部积分方法"><a href="#局部积分方法" class="headerlink" title="局部积分方法"></a>局部积分方法</h2><p>为了方便说明，这里特化算子A为变系数的拉普拉斯算子：<br>$$<br>-\nabla \cdot K(x) \nabla<br>$$<br>其中，K是d乘d的对称矩阵。<br>相应的有限元弱形式为：<br>$$<br>(\nabla \phi_j, K\nabla u^h), \qquad j=1,…,n<br>$$<br>其中，$u^h(x)=\sum_{i=1}^n \phi_i (x)u^{(i)}$是全局有限元函数u的离散插值，${\phi_j,j=1,…,n}$是试探函数。n是总自由度个数。<br>再定义参考单元上的基函数$\hat{\phi}_j(\hat{x}),j=1,…,p^d$。对应于全局的积分点$x_q$，其在参考单元上的对应的积分点就是$\hat{x}_q$。即在参考单元上的对应量都加上个冒，其中$(p-1)$是有限单元的“度”，即p是每个方向上自由度的个数，d是维度。<br>，在某个单元k上，在积分点$x_q$上，有限元函数u的插值就是：<br>$$<br>u_k^h(x_q)=\sum_{i=1}^{p^d}\hat{\phi}_i (\hat{x}_q)u_k^{(i)}<br>$$<br>在新方法中，显式地计算该局部有限元插值的梯度：<br>$$<br>\nabla u_k^h(x_q)=\sum_{i=1}^{p^d}J_k^{-T}(\hat{x}_q) \hat{\nabla}\hat{\phi}_i (\hat{x}_q)u_k^{(i)}=J_k^{-T}(\hat{x}_q) \sum_{i=1}^{p^d} \hat{\nabla}\hat{\phi}_i (\hat{x}_q)u_k^{(i)}<br>$$<br>其中，$\nabla$代表真实坐标系中的梯度，$\hat{\nabla}$代表参考单元上的梯度，$J_k^{-T}(\hat{x}_q)$是从参考单元到真实单元的逆转置的雅各比矩阵。注意：上面先求梯度，即先求和，再施加几何变换。<br>目标向量$v_k=A_k u_k$的每一个分量i都是一个积分，通过数值积分来获得：<br>$$<br>\begin{split}<br>v_k^{(i)}&amp;=\sum_q (\nabla \phi_i (x_q)^T K(x_q)\nabla u^h(x_q))w_q |\text{det}J_K(\hat{x}_q)| \<br>&amp;=\sum_q (\hat{\nabla}\hat{\phi}_i (\hat{x}_q)^T (J_k^{-T}(\hat{x}_q))^T K(x_q)\nabla u^h (x_q))w_q |\text{det}J_k (\hat{x}_q)|<br>\end{split}<br>$$</p>
<p>因此，对于拉普拉斯算子的局部算法可以表述为：<br>(1)计算参考单元上所有积分点上的梯度值，即第一个公式的求和部分<br>(2)在每个积分点上：</p>
<ul>
<li>施加雅各比变换，从而根据第一个公式得到真实空间上的离散函数u的梯度</li>
<li>乘以变系数矩阵</li>
<li>再乘以雅各比行列式和积分权重</li>
<li>再次施加雅各比矩阵变换</li>
</ul>
<p>(3)乘以参考单元上形函数的梯度，然后遍历所有积分点求和</p>
<p>这种算法相比于传统的矩阵组装算法有如下特点：</p>
<ul>
<li>将梯度的计算分成两部分：在参考单元上计算梯度，然后再施加雅各比变换。而不是直接在真实空间中计算形函数梯度。</li>
<li>参考单元上的计算对所有单元都是相同的，所以很多单元可以组合在一块同时计算</li>
<li>对于张量积单元，可以应用下面的“sum-factorization”算法，其相比于传统的直接运算方法(对所有积分点和局部基函数嵌套循环)有更小的复杂度</li>
</ul>
<h2 id="FEEvaluation类"><a href="#FEEvaluation类" class="headerlink" title="FEEvaluation类"></a>FEEvaluation类</h2><p>上面给出了在每个单元上的局部积分算法，这些基于单元的操作全部在FEEvaluation类中实现：</p>
<ul>
<li>读取源向量，然后再组装回全局目标向量中</li>
<li>使用“sum-factorization”算法计算参考单元上的函数值、梯度及二阶导数，并对其积分</li>
<li>应用雅各比变换、与变系数向量相乘等。</li>
</ul>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>这里要求解Sine-Gordon方程：<br>$$<br>\begin{split}<br>u_{tt} &amp;= \Delta u -\sin(u) \quad\mbox{for}\quad (x,t) \in \Omega \times (t_0,t_f],\<br>{\mathbf n} \cdot \nabla u &amp;= 0 \quad\mbox{for}\quad (x,t) \in \partial\Omega \times (t_0,t_f],\\<br>u(x,t_0) &amp;= u_0(x).<br>\end{split}<br>$$</p>
<p>这里采用显式的时间步进离散方法：<br>$$<br>(v,u^{n+1}) = (v,2 u^n-u^{n-1} - (\Delta t)^2 \sin(u^n)) - (\nabla v, (\Delta t)^2 \nabla u^n)<br>$$</p>
<p>如果使用Gauss-Lobatto单元，将会产生一个对角质量矩阵M，那么更新方程就变成：<br>$$<br>U^{n+1}=M^{-1}L(U^n,U^{n-1})<br>$$<br>其中，非线性算子$L(U^n,U^{n-1})$就是上式右端项。</p>
<h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><h2 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h2><p>FEEvaluation取得某个自由度和某个积分点上的函数值的返回类型都是value_type类型，其定义为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> FEEvaluationAccess&lt;dim,n_components_,Number&gt; BaseClass;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> BaseClass::value_type value_type;</span><br></pre></td></tr></table></figure>
<p>而此处用到的FEEvaluationAccess类是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FEEvaluationAccess</span>&lt;</span>dim,<span class="number">1</span>,Number&gt;</span><br><span class="line"><span class="keyword">typedef</span> VectorizedArray&lt;Number&gt; value_type;</span><br></pre></td></tr></table></figure>
<p>所以，此处得到返回值的类型都是VectorizeArray类型的。</p>
<p>同理，对于返回的梯度类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> FEEvaluationAccess&lt;dim,n_components_,Number&gt; BaseClass;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> BaseClass::gradient_type gradient_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Tensor&lt;<span class="number">1</span>,dim,VectorizedArray&lt;Number&gt; &gt; gradient_type;</span><br></pre></td></tr></table></figure>
<p>即，返回的梯度是一个一阶张量，即矢量，它有dim个分量。</p>
<h2 id="梯度计算"><a href="#梯度计算" class="headerlink" title="梯度计算"></a>梯度计算</h2><p>真实单元中的函数值和梯度与参考单元中的不同，两者要进行矩阵变换，同时梯度之间的变换还要再多一道，这在FEEvaluation的submit_gradient函数中能够明确地体现出来：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;gradients_quad[<span class="number">0</span>][d][q_point] = (grad_in[d] *</span><br><span class="line">  <span class="keyword">this</span>-&gt;cartesian_data[<span class="number">0</span>][d] *</span><br><span class="line">  JxW);</span><br></pre></td></tr></table></figure>
<p>而在计算函数值时则不需要加中间的数值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;values_quad[<span class="number">0</span>][q_point] = val_in * JxW;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2016/10/08/fem_matrix/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Be interesting!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亓欣波">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/10/08/fem_matrix/" class="post-title-link" itemprop="url">结构力学有限元刚度矩阵的性质</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-10-08 00:00:00" itemprop="dateCreated datePublished" datetime="2016-10-08T00:00:00+08:00">2016-10-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 15:20:30" itemprop="dateModified" datetime="2021-03-25T15:20:30+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computational-material-science/" itemprop="url" rel="index"><span itemprop="name">computational material science</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2016/10/08/fem_matrix/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/10/08/fem_matrix/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>本文是对曾攀老师的《有限元分析及应用》和王勖成老师的《有限单元法》关于单元刚度矩阵和整体刚度矩阵部分的学习笔记。</p>
<p>刚度矩阵在有限元方法中占有最重要的位置，分析和了解其性质对于我们更深层次地掌握有限元法具有重要的作用。不同的方程对应不同的刚度矩阵，所以，具体刚度矩阵的性质需要针对具体的方程才能下定论。这里只对结构力学的刚度矩阵进行初探，以期对其他方程也能有更深的理解。</p>
<h1 id="单元刚度矩阵的性质"><a href="#单元刚度矩阵的性质" class="headerlink" title="单元刚度矩阵的性质"></a>单元刚度矩阵的性质</h1><h2 id="性质1-矩阵元素具有明确物理意义"><a href="#性质1-矩阵元素具有明确物理意义" class="headerlink" title="性质1:矩阵元素具有明确物理意义"></a>性质1:矩阵元素具有明确物理意义</h2><p>以一维2节点杆单元为例，其刚度方程为：<br>$$<br>\begin{bmatrix}<br>k_{11} &amp; k_{12} \<br>k_{21} &amp; k_{22}<br>\end{bmatrix}<br>\begin{bmatrix}<br>u_1 \<br>u_2<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>f_1 \<br>f_2<br>\end{bmatrix}<br>$$<br>分两种情况进行具体讨论：<br>(1)考虑单元左端，即节点1，发生单位位移，而右端，即节点2，固定：<br>$$<br>u_1=1,\qquad u_2=0<br>$$<br>此时：<br>$$<br>k_{11}=f_1<br>$$<br>这说明，$k_{11}$是为保持这样一种状态，即使节点2的位移为0，使节点1产生单位位移，而需要在节点1上所施加的力。<br>推广到单元刚度矩阵的对角线元素，则有：<br>单元刚度矩阵的对角线元素$k_{ii}$表示要使单元的第i个节点产生单位位移，而其他节点不动时，需在节点i上所施加的力。</p>
<p>同时，对角线元素还都大于0，因为在这个节点上，力与位移的方向必须相同，这是稳定的必然要求。</p>
<p>(2)考虑单元左端，即节点1，固定，而右端，即节点2，固定：<br>$$<br>u_1=0,\qquad u_2=1<br>$$<br>此时：<br>$$<br>k_{12}=f_1<br>$$<br>这说明，$k_{12}$是为保持这样一种状态，即使节点1的位移为0，使节点2产生单位位移，而需要在节点1上所施加的力。<br>推广到单元刚度矩阵的非对角线元素，则有：<br>单元刚度矩阵的非对角线元素$k_{ji}(i\neq j)$表示要使单元的第j个节点产生单位位移，而其他节点不动时，需在节点i上所施加的力。</p>
<h2 id="对称性"><a href="#对称性" class="headerlink" title="对称性"></a>对称性</h2><p>即：<br>$$<br>k_{ij}=k_{ji}<br>$$<br>因为：<br>$$<br>K^{eT}=[\int B^T D B d\Omega]^T=\int B^T D B d\Omega =K^e<br>$$</p>
<h2 id="半正定性"><a href="#半正定性" class="headerlink" title="半正定性"></a>半正定性</h2><p>这里先理清一个概念：刚体位移。以平面杆单元为例，它除了在原地变形，还可以有刚体位移。它的刚体位移包括两个方向的移动和一个面内的转动。<br>将基于节点表达的应变能展开：<br>$$<br>\begin{split}<br>U&amp;=\frac{1}{2}q^{eT}K^e q^e \<br>&amp;=\frac{1}{2}(k_{11}u_1^2+…+k_{1i}u_1 u_i+…+k_{1n}u_1 u_n + … \<br>             +k_{j1}u_j^2+…+k_{ji}u_j u_i+…+k_{jn}u_j u_n + … \<br>             +k_{n1}u_n^2+…+k_{ni}u_n u_i+…+k_{nn}u_n u_n) \<br>&amp;=\frac{1}{2}\sum_{i=1}^{n}\sum_{j=1}^{n}k_{ij}u_i u_j<br>\end{split}<br>$$<br>其中，$q^e=[u_1 u_2 … u_n]^T$代表节点位移。<br>上式表明：应变能是位移的二次齐次多项式。在线性代数里，上式被称为矩阵$K^e$的二次型。<br>分两种情形考虑：<br>(1)不考虑刚体位移：不论位移列阵取何值，除非没有位移，因为应变能为一种能量，所以应变能总是正值。所以，此时，矩阵$K^e$是正定矩阵。<br>(2)考虑刚体位移：此时位移列阵不为0，因为刚体位移也是位移。而此时如果单元没有变形，那么应变能为0，那么只能$|K^e|=0$。</p>
<p>综上两种情形，矩阵$K^e$是半正定的。</p>
<h2 id="奇异性"><a href="#奇异性" class="headerlink" title="奇异性"></a>奇异性</h2><p>假设一个单元在受相同外载的情形下存在两种状态位移，即该单元可以任意移动，但所受的力是保持平衡的。仍以之前的一维杆单元为例说明。<br>在节点载荷$(f_1,f_2)$作用下，该单元有位移：<br>$$<br>\begin{split}<br>u_1 &amp;= c_1^{(1)} \<br>u_2 &amp;= c_2^{(1)}<br>\end{split}<br>$$<br>假设该单元在保持$(f_1,f_2)$作用下有一刚体位移，则此时位移有：<br>$$<br>\begin{split}<br>u_1 &amp;= c_1^{(1)}+u_0 = c_1^{(2)} \<br>u_2 &amp;= c_2^{(1)}+u_0 = c_2^{(2)}<br>\end{split}<br>$$<br>则对应于以上两种情形的单元刚度方程为：<br>$$<br>\begin{split}<br>\begin{bmatrix}<br>k_{11} &amp; k_{12} \<br>k_{21} &amp; k_{22}<br>\end{bmatrix}<br>\begin{bmatrix}<br>c_1^{(1)} \<br>c_2^{(1)}<br>\end{bmatrix}<br>&amp;=<br>\begin{bmatrix}<br>f_1 \<br>f_2<br>\end{bmatrix}  \<br>\begin{bmatrix}<br>k_{11} &amp; k_{12} \<br>k_{21} &amp; k_{22}<br>\end{bmatrix}<br>\begin{bmatrix}<br>c_1^{(2)} \<br>c_2^{(2)}<br>\end{bmatrix}<br>&amp;=<br>\begin{bmatrix}<br>f_1 \<br>f_2<br>\end{bmatrix}<br>\end{split}<br>$$<br>两式相减，有：<br>$$<br>\begin{bmatrix}<br>k_{11} &amp; k_{12} \<br>k_{21} &amp; k_{22}<br>\end{bmatrix}<br>\begin{bmatrix}<br>c_1^{(2)}-c_1^{(1)} \<br>c_2^{(2)}-c_2^{(1)}<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>0 \<br>0<br>\end{bmatrix}<br>$$<br>由于刚体位移平移量$u_0$不为零，所以上式有非零解的条件是矩阵奇异。</p>
<p>即：给定节点载荷，即使它们满足平衡，却不能由该方程确定单元节点位移，这是因为单元还可以有任意的刚体位移。</p>
<h1 id="整体刚度矩阵的性质"><a href="#整体刚度矩阵的性质" class="headerlink" title="整体刚度矩阵的性质"></a>整体刚度矩阵的性质</h1><p>由单元刚度矩阵组装起来的整体刚度矩阵具有以下性质：</p>
<h2 id="任一元素具有物理意义"><a href="#任一元素具有物理意义" class="headerlink" title="任一元素具有物理意义"></a>任一元素具有物理意义</h2><p>任一元素$k_{ji}(i\neq j)$表示要使单元的第j个节点产生单位位移，而其他节点不动时，需在节点i上所施加的力。<br>与单元不同之处在于：整体是单元的集合，每个单元都对整体起一定的作用。</p>
<h2 id="对称性-1"><a href="#对称性-1" class="headerlink" title="对称性"></a>对称性</h2><h2 id="半正定性-1"><a href="#半正定性-1" class="headerlink" title="半正定性"></a>半正定性</h2><h2 id="奇异性-1"><a href="#奇异性-1" class="headerlink" title="奇异性"></a>奇异性</h2><h2 id="大型稀疏矩阵"><a href="#大型稀疏矩阵" class="headerlink" title="大型稀疏矩阵"></a>大型稀疏矩阵</h2><p>当连续体离散为有限个单元时，每个节点的相关单元只是围绕在该节点周围为数很少的几个，一个节点通过相关单元与之发生关系的相关节点也只是周围的少数几个，因此虽然整体单元数和节点数很多，整体刚度矩阵的阶数很高，但刚度系数中非零系数却很少，这就是刚度矩阵的大型和稀疏性。</p>
<h2 id="非零元素呈带状分布"><a href="#非零元素呈带状分布" class="headerlink" title="非零元素呈带状分布"></a>非零元素呈带状分布</h2><p>当节点编号合理时，稀疏的非零元素将集中在以主对角线为中心的带状区域内，即呈现带状分布的特点。</p>
<h1 id="位移边界条件的作用"><a href="#位移边界条件的作用" class="headerlink" title="位移边界条件的作用"></a>位移边界条件的作用</h1><p>由于刚度矩阵是奇异的，所以求解方程时，除了力的施加不当造成无解的情形(即力不在刚度矩阵的列空间内)外，会有无穷解。解的维数取决于自由变量的个数。<br>为了消除奇异性，需要引入位移边界条件，让其填充自由变量的位置，从而获得唯一解。<br>从物理图像上理解，就是位移边界条件限制了刚体位移，从而使位移量唯一。</p>
<h1 id="其他方程的刚度矩阵的性质"><a href="#其他方程的刚度矩阵的性质" class="headerlink" title="其他方程的刚度矩阵的性质"></a>其他方程的刚度矩阵的性质</h1><p>其他方程不一定与上述结构力学的刚度方程的性质相同。<br>比如NS方程，由于其有对流项，其刚度矩阵是非对称的。<br>比如Possion方程，其刚度矩阵直接就是正定的？见这个<a target="_blank" rel="noopener" href="http://scicomp.stackexchange.com/questions/21423/in-fem-why-is-the-stiffness-matrix-positive-definite">讨论</a>。<br>所以一句话，具体问题具体分析。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2016/09/29/dealii-link-petsc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Be interesting!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亓欣波">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/09/29/dealii-link-petsc/" class="post-title-link" itemprop="url">deal.II链接PETSc过程记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-09-29 00:00:00" itemprop="dateCreated datePublished" datetime="2016-09-29T00:00:00+08:00">2016-09-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 15:20:30" itemprop="dateModified" datetime="2021-03-25T15:20:30+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computational-material-science/" itemprop="url" rel="index"><span itemprop="name">computational material science</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2016/09/29/dealii-link-petsc/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/09/29/dealii-link-petsc/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2016-11-16-Update"><a href="#2016-11-16-Update" class="headerlink" title="2016-11-16 Update"></a>2016-11-16 Update</h1><p>p4est与deal.II的链接注意事项：</p>
<ul>
<li>p4est安装时需要开启mpi，即configure时加上–enable-mpi选项。</li>
<li>链接时增添：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-DP4EST_DIR=/path/to/installation -DDEAL_II_WITH_P4EST=ON -DDEAL_II_WITH_MPI=ON</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在学习deal.II的Step17和18时，需要用到PETSc。<br>PETSc，全称Portable-Extensible-Toolkit-for-Scientific-Computation，是美国能源部ODE2000支持开发的20多个ACTS工具箱之一，由Argonne国家实验室开发的可移植可扩展科学计算工具箱，主要用于在分布式存储环境高效求解偏微分方程组及相关问题。PETSc所有消息传递通信均采用MPI标准实现，见<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/3600627.htm">百度百科介绍</a>。<br>默认安装deal.II时没有与PETSc集成，那么就需要重新编译。</p>
<p>注：这里链接PETSc的过程也同样适用于Trilinos、SLEPc等第三方软件。</p>
<h1 id="提前准备"><a href="#提前准备" class="headerlink" title="提前准备"></a>提前准备</h1><p>这里链接的是deal.II的8.4.1版本和PETSc的3.5.4版本。<br>还额外需要MPI库，这里用的是Open MPI的1.6.3版本。还需要hypre，用的是2.9.0版本。<br>openmpi和hypre之前都安装过，分别安装在/usr/local/openmpi和/usr/local/hypre。这两个的具体安装过程不再详述。</p>
<h1 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h1><h2 id="编译PETSc"><a href="#编译PETSc" class="headerlink" title="编译PETSc"></a>编译PETSc</h2><p>解压下载的安装包，得到petsc-3.5.4文件夹，然后进入，执行以下命令：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> PETSC_DIR=`pwd`</span><br><span class="line"><span class="keyword">export</span> PETSC_ARCH=x86_64   <span class="meta"># or any other identifying text for your machine</span></span><br><span class="line">./config/configure.py --with-shared-libararies=<span class="number">1</span> --with-x=<span class="number">0</span> --with-mpi=<span class="number">1</span> --with-mpi-dir=/usr/local/openmpi --with-hypre=<span class="number">1</span> --with-hypre-dir=/usr/local/hypre</span><br><span class="line">make all test</span><br></pre></td></tr></table></figure>
<p>要点：</p>
<ul>
<li>这里没有指定prefix路径，也就是在当前安装文件夹下编译。</li>
<li>环境变量PETSC_DIR是指定PETSc的安装文件位置，环境变量PETSC_ARCH是指定配置名字，比如x86_64或gnu_intel等等，这样可以生成不同名字的目录，方便切换版本。</li>
<li>configure的第一个参数是生成动态链接库，这样在lib下就能生成libpetsc.so。</li>
<li>一定要使用MPI，并且指定好它的路径，否则跟deal.II不对应也不行。这里务必注意！</li>
<li>一定使用hypre，并且指定好路径。否则step17还是不能编译。</li>
</ul>
<p>编译好PETSc后，将那两个环境变量写入.bashrc中，让其能够始终有效：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> PETSC_DIR=/home/qixinbo/program/petsc<span class="number">-3.5</span><span class="number">.4</span></span><br><span class="line"><span class="keyword">export</span> PETSC_ARCH=x86_64</span><br><span class="line"><span class="keyword">export</span> LD_LIBRARY_PATH=$PETSC_DIR/$PETSC_ARCH/lib:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>
<p>这样同时将PETSc的lib路径加入了全局的动态链接库路径中。</p>
<h2 id="编译deal-II"><a href="#编译deal-II" class="headerlink" title="编译deal.II"></a>编译deal.II</h2><p>解压下载的tar包，得到dealii-8.4.1文件夹，进入，然后执行以下命令：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -DCMAKE_INSTALL_PREFIX=/opt/dealii -DDEAL_II_WITH_PETSC=ON -DDEAL_II_WITH_MPI=ON ..</span><br><span class="line">sudo make install</span><br><span class="line">make test</span><br></pre></td></tr></table></figure>
<p>要点：</p>
<ul>
<li>用-DDEAL_II_WITH_PETSC=ON来指明链接PETSC</li>
<li>一定要指明用MPI，与前面的PETSc相对应</li>
</ul>
<h1 id="Step17编译运行成功"><a href="#Step17编译运行成功" class="headerlink" title="Step17编译运行成功"></a>Step17编译运行成功</h1><p>最后附上一张Step17编译运行成功的靓照：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjjxhizrlj30zk0sgqif.jpg"></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a target="_blank" rel="noopener" href="https://www.dealii.org/developer/external-libs/petsc.html">Interfacing deal.II to PETSc</a><br><a target="_blank" rel="noopener" href="https://www.dealii.org/developer/readme.html">Installation instructions and further information on deal.II</a><br><a target="_blank" rel="noopener" href="http://www.mcs.anl.gov/petsc/documentation/installation.html">PETSc:Documentation: Installation</a><br><a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_684b397d0101h9ov.html">安装 deal.II 7.1.0 心得</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2016/09/20/dealii-learn-step13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Be interesting!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亓欣波">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/09/20/dealii-learn-step13/" class="post-title-link" itemprop="url">求解偏微分方程开源有限元软件deal.II学习--Step 13</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-09-20 00:00:00" itemprop="dateCreated datePublished" datetime="2016-09-20T00:00:00+08:00">2016-09-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 15:20:30" itemprop="dateModified" datetime="2021-03-25T15:20:30+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computational-material-science/" itemprop="url" rel="index"><span itemprop="name">computational material science</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2016/09/20/dealii-learn-step13/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/09/20/dealii-learn-step13/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文来自亓欣波的博客<a href="qixinbo.github.io">qixinbo.info</a>。<br>转载请保留上面信息，谢谢！</p>
<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>本例亮点：</p>
<ul>
<li>精确寻找某个节点并通过要求提供该节点上的自由度指标来取出该点上的值。</li>
<li>使用线程并行，否则只能串行等待上一步完成。线程是计算的最小单元。</li>
</ul>
<p>在本例中，将不太关心描述使用deal.II的新方法，而是着眼于书写模块化及可扩展的有限元程序的方法。<br>这主要是为了考虑先进研究软件的大小和灵活性：使用了先进误差估计概念和自适应解的应用通常相当庞大。而大家的共识是这样的：庞大的程序，如果没有分成更小更独立的组件，将会很快消亡，因为甚至作者也会很快忘记程序内部各个部分之间的依赖关系。数据封装，比如面向对象编程和定义小巧且固定的界面的模块化编程，将会有效组织数据流以及理清相互依赖关系。这对于一个程序有多个开发者而言更是必不可少的。<br>本例仍然是一个Laplace求解，但跟之前不同的是：</p>
<ul>
<li>负责数值求解的类不再是“求解—误差估计—细化—再求解”这样的过程，我们将它委派给一个外部函数。这样首先能把它当成一个构件来呼应更大的问题，比如Laplace求解仅是这个问题的一小部分的情形。再者也能基于该类建立求解其他问题的框架。</li>
<li>把分析所求解的过程分成很多类，原因是因为人们可能不关心方程的解，而是关系它的其他方面。比如在弹性问题中想要知道某个边界上的拉力，或者在给定位置的接收器上的地震波信号。这样分析的过程通常不会影响求解过程，将它分成若干类，构建不同的过滤器来用于不同的用途。</li>
<li>将网格细化的类从计算类中分离出来</li>
<li>将测试算例的描述从程序中剥离出来</li>
<li>用WorkStream将组装线性系统并行化</li>
</ul>
<p>该程序所做的事不新，但是它的组织方式值得借鉴。不同的人有不同的软件设计方式，要勤加思考。<br>看这个程序时可以发现，它甚至是有些复杂的，但它代表了一种良好的能复用的设计方式，尤其是对大型程序。在编程开始时设计好程序是很重要的，否则可能在后期需要重构。<br>本例肯定也会有一些缺陷，但它却提示人们，尽量少编写紧耦合的代码！</p>
<p>本例最重要的是它的结构，但也得明白它干了啥：求解给定右端项的Laplace方程，使得解是$u(x,t)=\exp(x+\sin(10y+5x^2))$。计算目的是得到解在点$x_0=(0.5,0.5)$处的值，同时对比两种细化准则下的精度。</p>
<h1 id="程序解析"><a href="#程序解析" class="headerlink" title="程序解析"></a>程序解析</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/quadrature_lib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/function.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/logstream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/table_handler.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/thread_management.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/work_stream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/vector.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/full_matrix.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/sparse_matrix.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/solver_cg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/precondition.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/constraint_matrix.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/grid_generator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria_accessor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria_iterator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/grid_refinement.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_handler.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_accessor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_tools.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/fe/fe_q.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/fe/fe_values.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/vector_tools.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/matrix_tools.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/data_out.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/error_estimator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>这次的头文件顺序有点讲究：base – lac – grid – dofs – fe – numerics。基本后面是构建于前面基础上。<br>然后开始创建本例的命名空间：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Step13</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> dealii;</span><br></pre></td></tr></table></figure>

<h2 id="解的分析"><a href="#解的分析" class="headerlink" title="解的分析"></a>解的分析</h2><p>这里也是封装成一个命名空间：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Evaluation</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EvaluationBase</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">virtual</span> ~<span class="built_in">EvaluationBase</span> ();</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">set_refinement_cycle</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> refinement_cycle)</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> DoFHandler&lt;dim&gt; &amp;dof_handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> Vector&lt;<span class="keyword">double</span>&gt; &amp;solution)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">protected</span>:</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> refinement_cycle;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>这个定义了一个基类，主要是创建一个虚函数operator，接收DoFHandler和solution。这个“分析”基类可以用于多种分析用途，通过传入solution，然后定义不同的虚函数实现，从而达到目的。<br>然后是它的具体实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">EvaluationBase&lt;dim&gt;::~<span class="built_in">EvaluationBase</span> ()</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">EvaluationBase&lt;dim&gt;::<span class="built_in">set_refinement_cycle</span> (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> step)</span><br><span class="line">&#123;</span><br><span class="line">    refinement_cycle = step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面就是真正地用这个类——用作提取某点的值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PointValueEvaluation</span> :</span> <span class="keyword">public</span> EvaluationBase&lt;dim&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">PointValueEvaluation</span> (<span class="keyword">const</span> Point&lt;dim&gt; &amp;evaluation_point,</span><br><span class="line">                TableHandler &amp;results_table);</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> DoFHandler&lt;dim&gt; &amp;dof_handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> Vector&lt;<span class="keyword">double</span>&gt; &amp;solution)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="built_in">DeclException1</span> (ExcEvaluationPointNotFound,</span><br><span class="line">                Point&lt;dim&gt;,</span><br><span class="line">                &lt;&lt; <span class="string">&quot;The evaluation point &quot;</span> &lt;&lt; arg1</span><br><span class="line">                &lt;&lt; <span class="string">&quot; was not found among the vertices of the present grid.&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">const</span> Point&lt;dim&gt; evaluation_point;</span><br><span class="line">        TableHandler &amp;results_table;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>点的位置是在构造函数中传入，输出在构造函数的第二个参数中。<br>如果不依赖已知所用的有限单元形式，来找到有限元场中任意一点的值是相当困难的，因为我们不能在节点之间内插。这里简单起见，会确保这个点确实是节点，如果在对所有节点循环过程中没有发现该点，就会抛出一个异常，而不是简单的忽略。这里使用的是跟Step9一样的DeclExceptionN宏。<br>虽然这里明确写出析构函数，编译器会产生一个默认的析构函数，它也是虚函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">PointValueEvaluation&lt;dim&gt;::</span><br><span class="line"><span class="built_in">PointValueEvaluation</span> (<span class="keyword">const</span> Point&lt;dim&gt; &amp;evaluation_point,</span><br><span class="line">        TableHandler &amp;results_table)</span><br><span class="line">    :</span><br><span class="line">        <span class="built_in">evaluation_point</span> (evaluation_point),</span><br><span class="line">        <span class="built_in">results_table</span> (results_table)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这是构造函数，就是接收数据并存储下来。<br>下面就是最重要的部分，计算某点的值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">PointValueEvaluation&lt;dim&gt;::</span><br><span class="line"><span class="built_in"><span class="keyword">operator</span></span> () (<span class="keyword">const</span> DoFHandler&lt;dim&gt; &amp;dof_handler,</span><br><span class="line">        <span class="keyword">const</span> Vector&lt;<span class="keyword">double</span>&gt; &amp;solution) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> point_value = <span class="number">1e20</span>;</span><br></pre></td></tr></table></figure>
<p>首先分配一个变量来存储该点上的数值。用一个明显是错误的值来初始化它，这样如果没有正确地赋值，就能迅速地发现错误。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator</span><br><span class="line">cell = dof_handler.<span class="built_in">begin_active</span>(),</span><br><span class="line">     endc = dof_handler.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">bool</span> evaluation_point_found = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (; (cell!=endc) &amp;&amp; !evaluation_point_found; ++cell)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> vertex=<span class="number">0</span>;</span><br><span class="line">            vertex&lt;GeometryInfo&lt;dim&gt;::vertices_per_cell;</span><br><span class="line">            ++vertex)</span><br><span class="line">        <span class="keyword">if</span> (cell-&gt;<span class="built_in">vertex</span>(vertex) == evaluation_point)</span><br><span class="line">        &#123;</span><br></pre></td></tr></table></figure>
<p>然后对单元和单元上的节点进行循环，检查该节点是否是要找的点。如果找到了，同时要设置一个旗标，说明找到了，跳出循环。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">point_value = <span class="built_in">solution</span>(cell-&gt;<span class="built_in">vertex_dof_index</span>(vertex,<span class="number">0</span>));</span><br><span class="line">evaluation_point_found = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<p>上面就是取出全局解在该点上的值，如果解是个矢量，就取出第一个分量。但这里需要说明的是这里使用的有限元的自由度与节点是相关的，但这不是完全通用的，比如对间断有限元就不适用。理想情况下，需要在前面加一个Assert语句来捕获异常。这里省略了，因为如果我们用语句vertex_dof_index来要求返回该点的自由度指标，但是其实没有时会导致错误。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AssertThrow</span> (evaluation_point_found,</span><br><span class="line">        <span class="built_in">ExcEvaluationPointNotFound</span>(evaluation_point));</span><br></pre></td></tr></table></figure>
<p>然后再次判定一下确实找到了那个点。考虑到该点可能在细化和粗化过程中消失，所以判定是必要的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">results_table.<span class="built_in">add_value</span> (<span class="string">&quot;DoFs&quot;</span>, dof_handler.<span class="built_in">n_dofs</span>());</span><br><span class="line">results_table.<span class="built_in">add_value</span> (<span class="string">&quot;u(x_0)&quot;</span>, point_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将结果存储下来。<br>一个额外的功能可以顺便实现了，就是将结果输出成图片形式，因为我们有了DoFHandler和解，万事俱备，可以顺手解决这个问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SolutionOutput</span> :</span> <span class="keyword">public</span> EvaluationBase&lt;dim&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">SolutionOutput</span> (<span class="keyword">const</span> std::string &amp;output_name_base,</span><br><span class="line">                <span class="keyword">const</span> DataOutBase::OutputFormat output_format);</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">const</span> DoFHandler&lt;dim&gt; &amp;dof_handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> Vector&lt;<span class="keyword">double</span>&gt; &amp;solution)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">const</span> std::string output_name_base;</span><br><span class="line">        <span class="keyword">const</span> DataOutBase::OutputFormat output_format;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">SolutionOutput&lt;dim&gt;::</span><br><span class="line"><span class="built_in">SolutionOutput</span> (<span class="keyword">const</span> std::string &amp;output_name_base,</span><br><span class="line">        <span class="keyword">const</span> DataOutBase::OutputFormat output_format)</span><br><span class="line">    :</span><br><span class="line">        <span class="built_in">output_name_base</span> (output_name_base),</span><br><span class="line">        <span class="built_in">output_format</span> (output_format)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数的接收参数是输出名字的主部分和输出格式。<br>然后具体操作过程是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">SolutionOutput&lt;dim&gt;::<span class="built_in"><span class="keyword">operator</span></span> () (<span class="keyword">const</span> DoFHandler&lt;dim&gt; &amp;dof_handler,</span><br><span class="line">        <span class="keyword">const</span> Vector&lt;<span class="keyword">double</span>&gt; &amp;solution) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    DataOut&lt;dim&gt; data_out;</span><br><span class="line">    data_out.<span class="built_in">attach_dof_handler</span> (dof_handler);</span><br><span class="line">    data_out.<span class="built_in">add_data_vector</span> (solution, <span class="string">&quot;solution&quot;</span>);</span><br><span class="line">    data_out.<span class="built_in">build_patches</span> ();</span><br><span class="line">    std::ostringstream filename;</span><br><span class="line">    filename &lt;&lt; output_name_base &lt;&lt; <span class="string">&quot;-&quot;</span></span><br><span class="line">        &lt;&lt; <span class="keyword">this</span>-&gt;refinement_cycle</span><br><span class="line">        &lt;&lt; data_out.<span class="built_in">default_suffix</span> (output_format)</span><br><span class="line">        &lt;&lt; std::ends;</span><br><span class="line">    <span class="function">std::ofstream <span class="title">out</span> <span class="params">(filename.str().c_str())</span></span>;</span><br><span class="line">    data_out.<span class="built_in">write</span> (out, output_format);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## Laplace求解器</span><br><span class="line">也是先设置一个命名空间：</span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">namespace</span> LaplaceSolver</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                <span class="built_in">Base</span> (Triangulation&lt;dim&gt; &amp;coarse_grid);</span><br><span class="line">                <span class="keyword">virtual</span> ~<span class="built_in">Base</span> ();</span><br><span class="line">                <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">solve_problem</span> <span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">                <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">postprocess</span> <span class="params">(<span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">                <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">refine_grid</span> <span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">                <span class="function"><span class="keyword">virtual</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">n_dofs</span> <span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">protected</span>:</span><br><span class="line">                <span class="keyword">const</span> SmartPointer&lt;Triangulation&lt;dim&gt; &gt; triangulation;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">    Base&lt;dim&gt;::<span class="built_in">Base</span> (Triangulation&lt;dim&gt; &amp;coarse_grid)</span><br><span class="line">    :</span><br><span class="line">        <span class="built_in">triangulation</span> (&amp;coarse_grid)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">    Base&lt;dim&gt;::~<span class="built_in">Base</span> ()</span><br><span class="line">    &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>先声明一个抽象基类，它不实现具体功能，只存储一个后来有用的指向triangulation的指针。这里使用的是一个智能指针，保证它一直存在。<br>这个基类是通用型的，可以用于其他的静态问题，它提供了这些函数声明：求解、后处理和细化网格等。<br>下面是一个具体的通用求解类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solver</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> Base&lt;dim&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Solver</span> (Triangulation&lt;dim&gt; &amp;triangulation,</span><br><span class="line">                <span class="keyword">const</span> FiniteElement&lt;dim&gt; &amp;fe,</span><br><span class="line">                <span class="keyword">const</span> Quadrature&lt;dim&gt; &amp;quadrature,</span><br><span class="line">                <span class="keyword">const</span> Function&lt;dim&gt; &amp;boundary_values);</span><br><span class="line">        <span class="keyword">virtual</span></span><br><span class="line">            ~<span class="built_in">Solver</span> ();</span><br><span class="line">        <span class="keyword">virtual</span></span><br><span class="line">            <span class="keyword">void</span></span><br><span class="line">            <span class="built_in">solve_problem</span> ();</span><br><span class="line">        <span class="keyword">virtual</span></span><br><span class="line">            <span class="keyword">void</span></span><br><span class="line">            <span class="built_in">postprocess</span> (<span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor) <span class="keyword">const</span>;</span><br><span class="line">        <span class="keyword">virtual</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">            <span class="built_in">n_dofs</span> () <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="keyword">const</span> SmartPointer&lt;<span class="keyword">const</span> FiniteElement&lt;dim&gt; &gt; fe;</span><br><span class="line">        <span class="keyword">const</span> SmartPointer&lt;<span class="keyword">const</span> Quadrature&lt;dim&gt; &gt; quadrature;</span><br><span class="line">        DoFHandler&lt;dim&gt; dof_handler;</span><br><span class="line">        Vector&lt;<span class="keyword">double</span>&gt; solution;</span><br><span class="line">        <span class="keyword">const</span> SmartPointer&lt;<span class="keyword">const</span> Function&lt;dim&gt; &gt; boundary_values;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">assemble_rhs</span> <span class="params">(Vector&lt;<span class="keyword">double</span>&gt; &amp;rhs)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">LinearSystem</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="built_in">LinearSystem</span> (<span class="keyword">const</span> DoFHandler&lt;dim&gt; &amp;dof_handler);</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">(Vector&lt;<span class="keyword">double</span>&gt; &amp;solution)</span> <span class="keyword">const</span></span>;</span><br><span class="line">            ConstraintMatrix hanging_node_constraints;</span><br><span class="line">            SparsityPattern sparsity_pattern;</span><br><span class="line">            SparseMatrix&lt;<span class="keyword">double</span>&gt; matrix;</span><br><span class="line">            Vector&lt;<span class="keyword">double</span>&gt; rhs;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">AssemblyScratchData</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="built_in">AssemblyScratchData</span> (<span class="keyword">const</span> FiniteElement&lt;dim&gt; &amp;fe,</span><br><span class="line">                    <span class="keyword">const</span> Quadrature&lt;dim&gt; &amp;quadrature);</span><br><span class="line">            <span class="built_in">AssemblyScratchData</span> (<span class="keyword">const</span> AssemblyScratchData &amp;scratch_data);</span><br><span class="line">            FEValues&lt;dim&gt; fe_values;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">AssemblyCopyData</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            FullMatrix&lt;<span class="keyword">double</span>&gt; cell_matrix;</span><br><span class="line">            std::vector&lt;types::global_dof_index&gt; local_dof_indices;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">void</span></span><br><span class="line">            <span class="built_in">assemble_linear_system</span> (LinearSystem &amp;linear_system);</span><br><span class="line">        <span class="keyword">void</span></span><br><span class="line">            <span class="built_in">local_assemble_matrix</span> (<span class="keyword">const</span> <span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator &amp;cell,</span><br><span class="line">                    AssemblyScratchData &amp;scratch_data,</span><br><span class="line">                    AssemblyCopyData &amp;copy_data) <span class="keyword">const</span>;</span><br><span class="line">        <span class="keyword">void</span></span><br><span class="line">            <span class="built_in">copy_local_to_global</span>(<span class="keyword">const</span> AssemblyCopyData &amp;copy_data,</span><br><span class="line">                    LinearSystem &amp;linear_system) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它除了继承基类中的求解和后处理函数外，还加了一个新的虚函数assemble_rhs。这是因为我们会用两种不同的方法来构建右端项。在protect和private中还有一些额外的数据成员，从它们的名字可以推知它们的功能。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">Solver&lt;dim&gt;::<span class="built_in">Solver</span> (Triangulation&lt;dim&gt; &amp;triangulation,</span><br><span class="line">        <span class="keyword">const</span> FiniteElement&lt;dim&gt; &amp;fe,</span><br><span class="line">        <span class="keyword">const</span> Quadrature&lt;dim&gt; &amp;quadrature,</span><br><span class="line">        <span class="keyword">const</span> Function&lt;dim&gt; &amp;boundary_values)</span><br><span class="line">    :</span><br><span class="line">        Base&lt;dim&gt; (triangulation),</span><br><span class="line">        <span class="built_in">fe</span> (&amp;fe),</span><br><span class="line">        <span class="built_in">quadrature</span> (&amp;quadrature),</span><br><span class="line">        <span class="built_in">dof_handler</span> (triangulation),</span><br><span class="line">        <span class="built_in">boundary_values</span> (&amp;boundary_values)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">Solver&lt;dim&gt;::~<span class="built_in">Solver</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    dof_handler.<span class="built_in">clear</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数和析构函数如上。<br>下面是程序求解的主要架构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">Solver&lt;dim&gt;::<span class="built_in">solve_problem</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    dof_handler.<span class="built_in">distribute_dofs</span> (*fe);</span><br><span class="line">    solution.<span class="built_in">reinit</span> (dof_handler.<span class="built_in">n_dofs</span>());</span><br><span class="line">    <span class="function">LinearSystem <span class="title">linear_system</span> <span class="params">(dof_handler)</span></span>;</span><br><span class="line">    <span class="built_in">assemble_linear_system</span> (linear_system);</span><br><span class="line">    linear_system.<span class="built_in">solve</span> (solution);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它用传入的有限单元构建了DoFHandler对象，然后根据它创建了整个线性系统，包括矩阵、右端项和解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">Solver&lt;dim&gt;::</span><br><span class="line"><span class="built_in">postprocess</span> (<span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">postprocessor</span> (dof_handler, solution);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是后处理。<br>自由度的个数是自解释的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">Solver&lt;dim&gt;::<span class="built_in">n_dofs</span> () <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> dof_handler.<span class="built_in">n_dofs</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面就是在每一步求解时组装矩阵和右端项：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">Solver&lt;dim&gt;::<span class="built_in">assemble_linear_system</span> (LinearSystem &amp;linear_system)</span><br><span class="line">&#123;</span><br><span class="line">    Threads::Task&lt;&gt; rhs_task = Threads::<span class="built_in">new_task</span> (&amp;Solver&lt;dim&gt;::assemble_rhs,</span><br><span class="line">            *<span class="keyword">this</span>,</span><br><span class="line">            linear_system.rhs);</span><br><span class="line">    WorkStream::<span class="built_in">run</span>(dof_handler.<span class="built_in">begin_active</span>(),</span><br><span class="line">            dof_handler.<span class="built_in">end</span>(),</span><br><span class="line">            std_cxx11::<span class="built_in">bind</span>(&amp;Solver&lt;dim&gt;::local_assemble_matrix,</span><br><span class="line">                <span class="keyword">this</span>,</span><br><span class="line">                std_cxx11::_1,</span><br><span class="line">                std_cxx11::_2,</span><br><span class="line">                std_cxx11::_3),</span><br><span class="line">            std_cxx11::<span class="built_in">bind</span>(&amp;Solver&lt;dim&gt;::copy_local_to_global,</span><br><span class="line">                <span class="keyword">this</span>,</span><br><span class="line">                std_cxx11::_1,</span><br><span class="line">                std_cxx11::<span class="built_in">ref</span>(linear_system)),</span><br><span class="line">            <span class="built_in">AssemblyScratchData</span>(*fe, *quadrature),</span><br><span class="line">            <span class="built_in">AssemblyCopyData</span>());</span><br><span class="line">    linear_system.hanging_node_constraints.<span class="built_in">condense</span> (linear_system.matrix);</span><br></pre></td></tr></table></figure>
<p>这里使用了并行，并且是在多个层次上。在计算右端项，新开一个task，意思就是CPU这里有任务要做，当有可用的CPU核心时就分配给它，然后继续干其他的，当需要那个task的计算结果时等着它完成。在组装矩阵时，则是使用WorkStream。当然第一种比起第二种要好写得多。上面使用了C++11的语法，详情见帮助文档。<br>在等待右端项完成的同时，还可以构建边界条件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;types::global_dof_index,<span class="keyword">double</span>&gt; boundary_value_map;</span><br><span class="line">VectorTools::<span class="built_in">interpolate_boundary_values</span> (dof_handler,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        *boundary_values,</span><br><span class="line">        boundary_value_map);</span><br><span class="line">rhs_task.<span class="built_in">join</span> ();</span><br><span class="line">linear_system.hanging_node_constraints.<span class="built_in">condense</span> (linear_system.rhs);</span><br></pre></td></tr></table></figure>
<p>然后再将结果join起来。<br>最后是将边界条件加入到矩阵和右端项中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MatrixTools::<span class="built_in">apply_boundary_values</span> (boundary_value_map,</span><br><span class="line">        linear_system.matrix,</span><br><span class="line">        solution,</span><br><span class="line">        linear_system.rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体工作就是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">Solver&lt;dim&gt;::AssemblyScratchData::</span><br><span class="line"><span class="built_in">AssemblyScratchData</span> (<span class="keyword">const</span> FiniteElement&lt;dim&gt; &amp;fe,</span><br><span class="line">        <span class="keyword">const</span> Quadrature&lt;dim&gt; &amp;quadrature)</span><br><span class="line">    :</span><br><span class="line">        <span class="built_in">fe_values</span> (fe,</span><br><span class="line">                quadrature,</span><br><span class="line">                update_gradients | update_JxW_values)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">Solver&lt;dim&gt;::AssemblyScratchData::</span><br><span class="line"><span class="built_in">AssemblyScratchData</span> (<span class="keyword">const</span> AssemblyScratchData &amp;scratch_data)</span><br><span class="line">    :</span><br><span class="line">        <span class="built_in">fe_values</span> (scratch_data.fe_values.<span class="built_in">get_fe</span>(),</span><br><span class="line">                scratch_data.fe_values.<span class="built_in">get_quadrature</span>(),</span><br><span class="line">                update_gradients | update_JxW_values)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">Solver&lt;dim&gt;::<span class="built_in">local_assemble_matrix</span> (<span class="keyword">const</span> <span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator &amp;cell,</span><br><span class="line">        AssemblyScratchData &amp;scratch_data,</span><br><span class="line">        AssemblyCopyData &amp;copy_data) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> dofs_per_cell = fe-&gt;dofs_per_cell;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> n_q_points = quadrature-&gt;<span class="built_in">size</span>();</span><br><span class="line">    copy_data.cell_matrix.<span class="built_in">reinit</span> (dofs_per_cell, dofs_per_cell);</span><br><span class="line">    copy_data.local_dof_indices.<span class="built_in">resize</span>(dofs_per_cell);</span><br><span class="line">    scratch_data.fe_values.<span class="built_in">reinit</span> (cell);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> q_point=<span class="number">0</span>; q_point&lt;n_q_points; ++q_point)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dofs_per_cell; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j=<span class="number">0</span>; j&lt;dofs_per_cell; ++j)</span><br><span class="line">                copy_data.<span class="built_in">cell_matrix</span>(i,j) += (scratch_data.fe_values.<span class="built_in">shape_grad</span>(i,q_point) *</span><br><span class="line">                        scratch_data.fe_values.<span class="built_in">shape_grad</span>(j,q_point) *</span><br><span class="line">                        scratch_data.fe_values.<span class="built_in">JxW</span>(q_point));</span><br><span class="line">    cell-&gt;<span class="built_in">get_dof_indices</span> (copy_data.local_dof_indices);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">Solver&lt;dim&gt;::<span class="built_in">copy_local_to_global</span>(<span class="keyword">const</span> AssemblyCopyData &amp;copy_data,</span><br><span class="line">        LinearSystem &amp;linear_system) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;copy_data.local_dof_indices.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j=<span class="number">0</span>; j&lt;copy_data.local_dof_indices.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            linear_system.matrix.<span class="built_in">add</span> (copy_data.local_dof_indices[i],</span><br><span class="line">                    copy_data.local_dof_indices[j],</span><br><span class="line">                    copy_data.<span class="built_in">cell_matrix</span>(i,j));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的也用到了并行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">Solver&lt;dim&gt;::LinearSystem::</span><br><span class="line"><span class="built_in">LinearSystem</span> (<span class="keyword">const</span> DoFHandler&lt;dim&gt; &amp;dof_handler)</span><br><span class="line">&#123;</span><br><span class="line">    hanging_node_constraints.<span class="built_in">clear</span> ();</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*mhnc_p) (<span class="keyword">const</span> DoFHandler&lt;dim&gt; &amp;,</span><br><span class="line">            ConstraintMatrix &amp;)</span><br><span class="line">        = &amp;DoFTools::make_hanging_node_constraints;</span><br><span class="line">    Threads::Task&lt;&gt; side_task</span><br><span class="line">        = Threads::<span class="built_in">new_task</span> (mhnc_p,</span><br><span class="line">                dof_handler,</span><br><span class="line">                hanging_node_constraints);</span><br><span class="line">    <span class="function">DynamicSparsityPattern <span class="title">dsp</span><span class="params">(dof_handler.n_dofs(), dof_handler.n_dofs())</span></span>;</span><br><span class="line">    DoFTools::<span class="built_in">make_sparsity_pattern</span> (dof_handler, dsp);</span><br><span class="line">    side_task.<span class="built_in">join</span>();</span><br><span class="line">    hanging_node_constraints.<span class="built_in">close</span> ();</span><br><span class="line">    hanging_node_constraints.<span class="built_in">condense</span> (dsp);</span><br><span class="line">    sparsity_pattern.<span class="built_in">copy_from</span>(dsp);</span><br><span class="line">    matrix.<span class="built_in">reinit</span> (sparsity_pattern);</span><br><span class="line">    rhs.<span class="built_in">reinit</span> (dof_handler.<span class="built_in">n_dofs</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是求解算法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">Solver&lt;dim&gt;::LinearSystem::<span class="built_in">solve</span> (Vector&lt;<span class="keyword">double</span>&gt; &amp;solution) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">SolverControl <span class="title">solver_control</span> <span class="params">(<span class="number">1000</span>, <span class="number">1e-12</span>)</span></span>;</span><br><span class="line">    SolverCG&lt;&gt; <span class="built_in">cg</span> (solver_control);</span><br><span class="line">    PreconditionSSOR&lt;&gt; preconditioner;</span><br><span class="line">    preconditioner.<span class="built_in">initialize</span>(matrix, <span class="number">1.2</span>);</span><br><span class="line">    cg.<span class="built_in">solve</span> (matrix, solution, rhs, preconditioner);</span><br><span class="line">    hanging_node_constraints.<span class="built_in">distribute</span> (solution);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面提供了一个能自己组装右端项的类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimalSolver</span> :</span> <span class="keyword">public</span> Solver&lt;dim&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">PrimalSolver</span> (Triangulation&lt;dim&gt; &amp;triangulation,</span><br><span class="line">                <span class="keyword">const</span> FiniteElement&lt;dim&gt; &amp;fe,</span><br><span class="line">                <span class="keyword">const</span> Quadrature&lt;dim&gt; &amp;quadrature,</span><br><span class="line">                <span class="keyword">const</span> Function&lt;dim&gt; &amp;rhs_function,</span><br><span class="line">                <span class="keyword">const</span> Function&lt;dim&gt; &amp;boundary_values);</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="keyword">const</span> SmartPointer&lt;<span class="keyword">const</span> Function&lt;dim&gt; &gt; rhs_function;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">assemble_rhs</span> <span class="params">(Vector&lt;<span class="keyword">double</span>&gt; &amp;rhs)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">PrimalSolver&lt;dim&gt;::</span><br><span class="line"><span class="built_in">PrimalSolver</span> (Triangulation&lt;dim&gt; &amp;triangulation,</span><br><span class="line">        <span class="keyword">const</span> FiniteElement&lt;dim&gt; &amp;fe,</span><br><span class="line">        <span class="keyword">const</span> Quadrature&lt;dim&gt; &amp;quadrature,</span><br><span class="line">        <span class="keyword">const</span> Function&lt;dim&gt; &amp;rhs_function,</span><br><span class="line">        <span class="keyword">const</span> Function&lt;dim&gt; &amp;boundary_values)</span><br><span class="line">    :</span><br><span class="line">        Base&lt;dim&gt; (triangulation),</span><br><span class="line">        Solver&lt;dim&gt; (triangulation, fe,</span><br><span class="line">                quadrature, boundary_values),</span><br><span class="line">        <span class="built_in">rhs_function</span> (&amp;rhs_function)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">PrimalSolver&lt;dim&gt;::</span><br><span class="line"><span class="built_in">assemble_rhs</span> (Vector&lt;<span class="keyword">double</span>&gt; &amp;rhs) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">FEValues&lt;dim&gt; <span class="title">fe_values</span> <span class="params">(*<span class="keyword">this</span>-&gt;fe, *<span class="keyword">this</span>-&gt;quadrature,</span></span></span><br><span class="line"><span class="function"><span class="params">            update_values | update_quadrature_points |</span></span></span><br><span class="line"><span class="function"><span class="params">            update_JxW_values)</span></span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> dofs_per_cell = <span class="keyword">this</span>-&gt;fe-&gt;dofs_per_cell;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> n_q_points = <span class="keyword">this</span>-&gt;quadrature-&gt;<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">Vector&lt;<span class="keyword">double</span>&gt; <span class="title">cell_rhs</span> <span class="params">(dofs_per_cell)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">double</span>&gt; <span class="title">rhs_values</span> <span class="params">(n_q_points)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;types::global_dof_index&gt; <span class="title">local_dof_indices</span> <span class="params">(dofs_per_cell)</span></span>;</span><br><span class="line">    <span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator</span><br><span class="line">        cell = <span class="keyword">this</span>-&gt;dof_handler.<span class="built_in">begin_active</span>(),</span><br><span class="line">             endc = <span class="keyword">this</span>-&gt;dof_handler.<span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">for</span> (; cell!=endc; ++cell)</span><br><span class="line">    &#123;</span><br><span class="line">        cell_rhs = <span class="number">0</span>;</span><br><span class="line">        fe_values.<span class="built_in">reinit</span> (cell);</span><br><span class="line">        rhs_function-&gt;<span class="built_in">value_list</span> (fe_values.<span class="built_in">get_quadrature_points</span>(),</span><br><span class="line">                rhs_values);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> q_point=<span class="number">0</span>; q_point&lt;n_q_points; ++q_point)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dofs_per_cell; ++i)</span><br><span class="line">                <span class="built_in">cell_rhs</span>(i) += (fe_values.<span class="built_in">shape_value</span>(i,q_point) *</span><br><span class="line">                        rhs_values[q_point] *</span><br><span class="line">                        fe_values.<span class="built_in">JxW</span>(q_point));</span><br><span class="line">        cell-&gt;<span class="built_in">get_dof_indices</span> (local_dof_indices);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dofs_per_cell; ++i)</span><br><span class="line">            <span class="built_in">rhs</span>(local_dof_indices[i]) += <span class="built_in">cell_rhs</span>(i);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，除了网格细化这一步，其他的函数都已经实现了。这里使用了两种方式来细化：全局细化和局部细化。<br>全局细化为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefinementGlobal</span> :</span> <span class="keyword">public</span> PrimalSolver&lt;dim&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">RefinementGlobal</span> (Triangulation&lt;dim&gt; &amp;coarse_grid,</span><br><span class="line">                <span class="keyword">const</span> FiniteElement&lt;dim&gt; &amp;fe,</span><br><span class="line">                <span class="keyword">const</span> Quadrature&lt;dim&gt; &amp;quadrature,</span><br><span class="line">                <span class="keyword">const</span> Function&lt;dim&gt; &amp;rhs_function,</span><br><span class="line">                <span class="keyword">const</span> Function&lt;dim&gt; &amp;boundary_values);</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">refine_grid</span> <span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">RefinementGlobal&lt;dim&gt;::</span><br><span class="line"><span class="built_in">RefinementGlobal</span> (Triangulation&lt;dim&gt; &amp;coarse_grid,</span><br><span class="line">        <span class="keyword">const</span> FiniteElement&lt;dim&gt; &amp;fe,</span><br><span class="line">        <span class="keyword">const</span> Quadrature&lt;dim&gt; &amp;quadrature,</span><br><span class="line">        <span class="keyword">const</span> Function&lt;dim&gt; &amp;rhs_function,</span><br><span class="line">        <span class="keyword">const</span> Function&lt;dim&gt; &amp;boundary_values)</span><br><span class="line">    :</span><br><span class="line">        Base&lt;dim&gt; (coarse_grid),</span><br><span class="line">        PrimalSolver&lt;dim&gt; (coarse_grid, fe, quadrature,</span><br><span class="line">                rhs_function, boundary_values)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">RefinementGlobal&lt;dim&gt;::<span class="built_in">refine_grid</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;triangulation-&gt;<span class="built_in">refine_global</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>局部细化为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefinementKelly</span> :</span> <span class="keyword">public</span> PrimalSolver&lt;dim&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">RefinementKelly</span> (Triangulation&lt;dim&gt; &amp;coarse_grid,</span><br><span class="line">                <span class="keyword">const</span> FiniteElement&lt;dim&gt; &amp;fe,</span><br><span class="line">                <span class="keyword">const</span> Quadrature&lt;dim&gt; &amp;quadrature,</span><br><span class="line">                <span class="keyword">const</span> Function&lt;dim&gt; &amp;rhs_function,</span><br><span class="line">                <span class="keyword">const</span> Function&lt;dim&gt; &amp;boundary_values);</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">refine_grid</span> <span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">RefinementKelly&lt;dim&gt;::</span><br><span class="line"><span class="built_in">RefinementKelly</span> (Triangulation&lt;dim&gt; &amp;coarse_grid,</span><br><span class="line">        <span class="keyword">const</span> FiniteElement&lt;dim&gt; &amp;fe,</span><br><span class="line">        <span class="keyword">const</span> Quadrature&lt;dim&gt; &amp;quadrature,</span><br><span class="line">        <span class="keyword">const</span> Function&lt;dim&gt; &amp;rhs_function,</span><br><span class="line">        <span class="keyword">const</span> Function&lt;dim&gt; &amp;boundary_values)</span><br><span class="line">    :</span><br><span class="line">        Base&lt;dim&gt; (coarse_grid),</span><br><span class="line">        PrimalSolver&lt;dim&gt; (coarse_grid, fe, quadrature,</span><br><span class="line">                rhs_function, boundary_values)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">RefinementKelly&lt;dim&gt;::<span class="built_in">refine_grid</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Vector&lt;<span class="keyword">float</span>&gt; <span class="title">estimated_error_per_cell</span> <span class="params">(<span class="keyword">this</span>-&gt;triangulation-&gt;n_active_cells())</span></span>;</span><br><span class="line">    KellyErrorEstimator&lt;dim&gt;::<span class="built_in">estimate</span> (<span class="keyword">this</span>-&gt;dof_handler,</span><br><span class="line">            QGauss&lt;dim<span class="number">-1</span>&gt;(<span class="number">3</span>),</span><br><span class="line">            <span class="keyword">typename</span> FunctionMap&lt;dim&gt;::<span class="built_in">type</span>(),</span><br><span class="line">            <span class="keyword">this</span>-&gt;solution,</span><br><span class="line">            estimated_error_per_cell);</span><br><span class="line">    GridRefinement::<span class="built_in">refine_and_coarsen_fixed_number</span> (*<span class="keyword">this</span>-&gt;triangulation,</span><br><span class="line">            estimated_error_per_cell,</span><br><span class="line">            <span class="number">0.3</span>, <span class="number">0.03</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;triangulation-&gt;<span class="built_in">execute_coarsening_and_refinement</span> ();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于学术目的，还想看看数值解跟解析解之间的差别，所以这里定义一个类来表现精确解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> :</span> <span class="keyword">public</span> Function&lt;dim&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Solution</span> () : Function&lt;dim&gt; () &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">value</span> <span class="params">(<span class="keyword">const</span> Point&lt;dim&gt; &amp;p,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">double</span></span><br><span class="line">Solution&lt;dim&gt;::<span class="built_in">value</span> (<span class="keyword">const</span> Point&lt;dim&gt; &amp;p,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> / *component* /) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> q = <span class="built_in">p</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">1</span>; i&lt;dim; ++i)</span><br><span class="line">        q += std::<span class="built_in">sin</span>(<span class="number">10</span>*<span class="built_in">p</span>(i)+<span class="number">5</span>*<span class="built_in">p</span>(<span class="number">0</span>)*<span class="built_in">p</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> exponential = std::<span class="built_in">exp</span>(q);</span><br><span class="line">    <span class="keyword">return</span> exponential;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RightHandSide</span> :</span> <span class="keyword">public</span> Function&lt;dim&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">RightHandSide</span> () : Function&lt;dim&gt; () &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">value</span> <span class="params">(<span class="keyword">const</span> Point&lt;dim&gt; &amp;p,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">double</span></span><br><span class="line">RightHandSide&lt;dim&gt;::<span class="built_in">value</span> (<span class="keyword">const</span> Point&lt;dim&gt; &amp;p,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> / *component* /) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> q = <span class="built_in">p</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">1</span>; i&lt;dim; ++i)</span><br><span class="line">        q += std::<span class="built_in">sin</span>(<span class="number">10</span>*<span class="built_in">p</span>(i)+<span class="number">5</span>*<span class="built_in">p</span>(<span class="number">0</span>)*<span class="built_in">p</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> u = std::<span class="built_in">exp</span>(q);</span><br><span class="line">    <span class="keyword">double</span> t1 = <span class="number">1</span>,</span><br><span class="line">           t2 = <span class="number">0</span>,</span><br><span class="line">           t3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">1</span>; i&lt;dim; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t1 += std::<span class="built_in">cos</span>(<span class="number">10</span>*<span class="built_in">p</span>(i)+<span class="number">5</span>*<span class="built_in">p</span>(<span class="number">0</span>)*<span class="built_in">p</span>(<span class="number">0</span>)) * <span class="number">10</span> * <span class="built_in">p</span>(<span class="number">0</span>);</span><br><span class="line">        t2 += <span class="number">10</span>*std::<span class="built_in">cos</span>(<span class="number">10</span>*<span class="built_in">p</span>(i)+<span class="number">5</span>*<span class="built_in">p</span>(<span class="number">0</span>)*<span class="built_in">p</span>(<span class="number">0</span>)) -</span><br><span class="line">            <span class="number">100</span>*std::<span class="built_in">sin</span>(<span class="number">10</span>*<span class="built_in">p</span>(i)+<span class="number">5</span>*<span class="built_in">p</span>(<span class="number">0</span>)*<span class="built_in">p</span>(<span class="number">0</span>)) * <span class="built_in">p</span>(<span class="number">0</span>)*<span class="built_in">p</span>(<span class="number">0</span>);</span><br><span class="line">        t3 += <span class="number">100</span>*std::<span class="built_in">cos</span>(<span class="number">10</span>*<span class="built_in">p</span>(i)+<span class="number">5</span>*<span class="built_in">p</span>(<span class="number">0</span>)*<span class="built_in">p</span>(<span class="number">0</span>))*std::<span class="built_in">cos</span>(<span class="number">10</span>*<span class="built_in">p</span>(i)+<span class="number">5</span>*<span class="built_in">p</span>(<span class="number">0</span>)*<span class="built_in">p</span>(<span class="number">0</span>)) -</span><br><span class="line">            <span class="number">100</span>*std::<span class="built_in">sin</span>(<span class="number">10</span>*<span class="built_in">p</span>(i)+<span class="number">5</span>*<span class="built_in">p</span>(<span class="number">0</span>)*<span class="built_in">p</span>(<span class="number">0</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">    t1 = t1*t1;</span><br><span class="line">    <span class="keyword">return</span> -u*(t1+t2+t3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是建立整个程序运行的过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line"><span class="built_in">run_simulation</span> (LaplaceSolver::Base&lt;dim&gt; &amp;solver,</span><br><span class="line">        <span class="keyword">const</span> std::list&lt;Evaluation::EvaluationBase&lt;dim&gt; *&gt; &amp;postprocessor_list)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Refinement cycle: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> step=<span class="number">0</span>; <span class="literal">true</span>; ++step)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; step &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::flush;</span><br><span class="line">        solver.<span class="built_in">solve_problem</span> ();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">typename</span> std::list&lt;Evaluation::EvaluationBase&lt;dim&gt; *&gt;::const_iterator</span><br><span class="line">                i = postprocessor_list.<span class="built_in">begin</span>();</span><br><span class="line">                i != postprocessor_list.<span class="built_in">end</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            (*i)-&gt;<span class="built_in">set_refinement_cycle</span> (step);</span><br><span class="line">            solver.<span class="built_in">postprocess</span> (**i);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span> (solver.<span class="built_in">n_dofs</span>() &lt; <span class="number">20000</span>)</span><br><span class="line">            solver.<span class="built_in">refine_grid</span> ();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve_problem</span> <span class="params">(<span class="keyword">const</span> std::string &amp;solver_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> std::string header = <span class="string">&quot;Running tests with \&quot;&quot;</span> + solver_name +</span><br><span class="line">        <span class="string">&quot;\&quot; refinement criterion:&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; header &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; std::<span class="built_in">string</span> (header.<span class="built_in">size</span>(), <span class="string">&#x27;-&#x27;</span>) &lt;&lt; std::endl;</span><br><span class="line">    Triangulation&lt;dim&gt; triangulation;</span><br><span class="line">    GridGenerator::<span class="built_in">hyper_cube</span> (triangulation, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">    triangulation.<span class="built_in">refine_global</span> (<span class="number">2</span>);</span><br><span class="line">    <span class="function"><span class="keyword">const</span> FE_Q&lt;dim&gt; <span class="title">fe</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> QGauss&lt;dim&gt; <span class="title">quadrature</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="keyword">const</span> RightHandSide&lt;dim&gt; rhs_function;</span><br><span class="line">    <span class="keyword">const</span> Solution&lt;dim&gt; boundary_values;</span><br><span class="line">    LaplaceSolver::Base&lt;dim&gt; *solver = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (solver_name == <span class="string">&quot;global&quot;</span>)</span><br><span class="line">        solver = <span class="keyword">new</span> LaplaceSolver::RefinementGlobal&lt;dim&gt; (triangulation, fe,</span><br><span class="line">                quadrature,</span><br><span class="line">                rhs_function,</span><br><span class="line">                boundary_values);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (solver_name == <span class="string">&quot;kelly&quot;</span>)</span><br><span class="line">        solver = <span class="keyword">new</span> LaplaceSolver::RefinementKelly&lt;dim&gt; (triangulation, fe,</span><br><span class="line">                quadrature,</span><br><span class="line">                rhs_function,</span><br><span class="line">                boundary_values);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">AssertThrow</span> (<span class="literal">false</span>, <span class="built_in">ExcNotImplemented</span>());</span><br><span class="line">    TableHandler results_table;</span><br><span class="line">    Evaluation::PointValueEvaluation&lt;dim&gt;</span><br><span class="line">        <span class="built_in">postprocessor1</span> (Point&lt;dim&gt;(<span class="number">0.5</span>,<span class="number">0.5</span>), results_table);</span><br><span class="line">    Evaluation::SolutionOutput&lt;dim&gt;</span><br><span class="line">        <span class="built_in">postprocessor2</span> (std::<span class="built_in">string</span>(<span class="string">&quot;solution-&quot;</span>)+solver_name,</span><br><span class="line">                DataOutBase::gnuplot);</span><br><span class="line">    std::list&lt;Evaluation::EvaluationBase&lt;dim&gt; *&gt; postprocessor_list;</span><br><span class="line">    postprocessor_list.<span class="built_in">push_back</span> (&amp;postprocessor1);</span><br><span class="line">    postprocessor_list.<span class="built_in">push_back</span> (&amp;postprocessor2);</span><br><span class="line">    <span class="built_in">run_simulation</span> (*solver, postprocessor_list);</span><br><span class="line">    results_table.<span class="built_in">write_text</span> (std::cout);</span><br><span class="line">    <span class="keyword">delete</span> solver;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是main函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        Step13::solve_problem&lt;<span class="number">2</span>&gt; (<span class="string">&quot;global&quot;</span>);</span><br><span class="line">        Step13::solve_problem&lt;<span class="number">2</span>&gt; (<span class="string">&quot;kelly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (std::exception &amp;exc)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; exc.<span class="built_in">what</span>() &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="计算结果"><a href="#计算结果" class="headerlink" title="计算结果"></a>计算结果</h1><p>某点的值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Running tests with <span class="string">&quot;global&quot;</span> refinement criterion:</span><br><span class="line">-------------------------------------------------</span><br><span class="line">Refinement cycle: <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="function">DoFs <span class="title">u</span><span class="params">(x_0)</span></span></span><br><span class="line"><span class="function">25 1.2868</span></span><br><span class="line"><span class="function">81 1.6945</span></span><br><span class="line"><span class="function">289 1.4658</span></span><br><span class="line"><span class="function">1089 1.5679</span></span><br><span class="line"><span class="function">4225 1.5882</span></span><br><span class="line"><span class="function">16641 1.5932</span></span><br><span class="line"><span class="function">66049 1.5945</span></span><br><span class="line">Running tests with &quot;kelly&quot; refinement criterion:</span><br><span class="line">------------------------------------------------</span><br><span class="line">Refinement cycle: <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span></span><br><span class="line"><span class="function">DoFs <span class="title">u</span><span class="params">(x_0)</span></span></span><br><span class="line"><span class="function">25 1.2868</span></span><br><span class="line"><span class="function">47 0.8775</span></span><br><span class="line"><span class="function">89 1.5365</span></span><br><span class="line"><span class="function">165 1.2974</span></span><br><span class="line"><span class="function">316 1.6442</span></span><br><span class="line"><span class="function">589 1.5221</span></span><br><span class="line"><span class="function">1093 1.5724</span></span><br><span class="line"><span class="function">2042 1.5627</span></span><br><span class="line"><span class="function">3766 1.5916</span></span><br><span class="line"><span class="function">7124 1.5876</span></span><br><span class="line"><span class="function">13111 1.5942</span></span><br><span class="line"><span class="function">24838 1.5932</span></span><br></pre></td></tr></table></figure>
<p>局部细化9次以后的网格：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjl4qyzqsj30o910eh05.jpg"><br>从上面看网格是这样的：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjl575tdjj30at0a9glf.jpg"><br>本例中还有一个问题：局部细化的效果要差于全局细化！全局细化能提供一个与网格尺寸相关的稳定收敛性，而局部细化的收敛性不规则，虽然也是网格越细越收敛，但收敛阶忽高忽低。<br>原教程中有答案使得局部细化的效果变好。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2016/09/17/dealii-learn-step12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Be interesting!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亓欣波">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/09/17/dealii-learn-step12/" class="post-title-link" itemprop="url">求解偏微分方程开源有限元软件deal.II学习--Step 12</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-09-17 00:00:00" itemprop="dateCreated datePublished" datetime="2016-09-17T00:00:00+08:00">2016-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 15:20:30" itemprop="dateModified" datetime="2021-03-25T15:20:30+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computational-material-science/" itemprop="url" rel="index"><span itemprop="name">computational material science</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2016/09/17/dealii-learn-step12/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/09/17/dealii-learn-step12/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>本例主要讲解MeshWorker框架和间断Galerkin方法，即DG。</p>
<ul>
<li>用间断Galerkin法离散线性对流方程</li>
<li>使用MeshWorker::loop()来组装系统矩阵</li>
</ul>
<p>本例主要关心的就是间断Galerkin法的循环，这相当复杂，因为必须分辨边界、常规内部边和有悬点的内部边。MeshWorker框架能够对所有的单元和边进行标准循环，它将分辨过程隐藏在了内部。<br>使用MeshWorker需要手动做两件事：一是针对特定问题写内部积分器，二是从该命名空间中选择类，然后将它们组合起来来解决问题。</p>
<p>要求解的问题是线性对流方程：<br>$$<br>\nabla\cdot \left({\mathbf \beta} u\right)=0 \qquad\mbox{in }\Omega,<br>$$<br>边界条件是：<br>$$<br>u=g\quad\mbox{on }\Gamma_-,<br>$$<br>这是入流边界，定义是：<br>$$<br>\Gamma_-:=[{\bf x}\in\Gamma, {\mathbf \beta}({\bf x})\cdot{\bf n}({\bf x})&lt;0]<br>$$</p>
<p>这个方程是之前的Step9的守恒版本。<br>具体取值为：$\Omega=[0,1]^2$，${\mathbf \beta}=\frac{1}{|x|}(-x_2, x_1)$代表一个环形逆时针流场，在${\bf x}\in\Gamma_-^1:=[0,0.5]\times[0]$上$g=1$，而在${\bf x}\in \Gamma_-\setminus \Gamma_-^1$上$g=0$。<br>这里使用迎风间断Galerkin方法。<br>从这里就完全看不懂了。留坑待填。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2016/09/16/dealii-learn-step10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Be interesting!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亓欣波">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/09/16/dealii-learn-step10/" class="post-title-link" itemprop="url">求解偏微分方程开源有限元软件deal.II学习--Step 10</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-09-16 00:00:00" itemprop="dateCreated datePublished" datetime="2016-09-16T00:00:00+08:00">2016-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 15:20:30" itemprop="dateModified" datetime="2021-03-25T15:20:30+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computational-material-science/" itemprop="url" rel="index"><span itemprop="name">computational material science</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2016/09/16/dealii-learn-step10/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/09/16/dealii-learn-step10/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>这个小例子主要演示更高阶的映射。映射的意思是参考单元和真实单元之间的变换，之前的例子中默认使用线性或双线性映射。这里的线性映射不是形函数用线性近似，同时也不是Cn单元的概念，Cn单元代表解的最高阶导数的概念。如果边界是弯曲的话，用线性近似就可能不充分。如果使用分段二次抛物线来近似的话，就说这是二次或Q2近似。如果使用分段三次多项式近似的话，就称为Q3近似。依次类推。<br>这里是用逼近圆周率来说明映射问题。用两种方法：一种是对半径为1的圆进行三角剖分，然后积分，如果完全是圆，那么它的面积精确为圆周率，但因为是多项式近似，所以肯定不精确，这里展示不同映射下随着网格细化的收敛性。第二种不是计算面积，而是计算周长，那么圆周率就大约是周长的一半。</p>
<h1 id="程序解析"><a href="#程序解析" class="headerlink" title="程序解析"></a>程序解析</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/quadrature_lib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/convergence_table.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/grid_generator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria_accessor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria_iterator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/manifold_lib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/grid_out.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_handler.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_accessor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/fe/fe_q.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/fe/fe_values.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>这是之前用过的头文件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/fe/mapping_q.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>这是新的头文件。用来声明MappingQ类，进行任意阶数的多项式映射。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>C++的标准头文件。<br>然后开始定义这个问题的命名空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Step10</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> dealii;</span><br></pre></td></tr></table></figure>
<p>先定义一种非常精确的圆周率值用于后面比较：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> pi = <span class="number">3.141592653589793238462643</span>;</span><br></pre></td></tr></table></figure>
<p>下面是输出。这里因为是个小程序，没有用类，而是用函数模板，参数是空间维度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gnuplot_output</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Output of grids into gnuplot files:&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;===================================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Triangulation&lt;dim&gt; triangulation;</span><br><span class="line">    GridGenerator::<span class="built_in">hyper_ball</span> (triangulation);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> SphericalManifold&lt;dim&gt; boundary;</span><br><span class="line">    triangulation.<span class="built_in">set_all_manifold_ids_on_boundary</span>(<span class="number">0</span>);</span><br><span class="line">    triangulation.<span class="built_in">set_manifold</span> (<span class="number">0</span>, boundary);</span><br></pre></td></tr></table></figure>
<p>首先产生一个粗的三角剖分，施加一个合适的边界描述。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> refinement=<span class="number">0</span>; refinement&lt;<span class="number">2</span>;</span><br><span class="line">        ++refinement, triangulation.<span class="built_in">refine_global</span>(<span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Refinement level: &quot;</span> &lt;&lt; refinement &lt;&lt; std::endl;</span><br><span class="line">    std::string filename_base = <span class="string">&quot;ball&quot;</span>;</span><br><span class="line">    filename_base += <span class="string">&#x27;0&#x27;</span>+refinement;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> degree=<span class="number">1</span>; degree&lt;<span class="number">4</span>; ++degree)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Degree = &quot;</span> &lt;&lt; degree &lt;&lt; std::endl;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> MappingQ&lt;dim&gt; <span class="title">mapping</span> <span class="params">(degree)</span></span>;</span><br></pre></td></tr></table></figure>
<p>然后使用不同的映射，分别是Q1、Q2和Q3。当分段线性映射，即Q1时，可以直接使用MappingQ1这个类。Attention！！MappingQ1也是很多函数和类默认使用的映射方式，如果不明确指定映射方式的话。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GridOut grid_out;</span><br><span class="line"><span class="function">GridOutFlags::Gnuplot <span class="title">gnuplot_flags</span><span class="params">(<span class="literal">false</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">grid_out.<span class="built_in">set_flags</span>(gnuplot_flags);</span><br><span class="line">std::string filename = filename_base+<span class="string">&quot;_mapping_q&quot;</span>;</span><br><span class="line">filename += (<span class="string">&#x27;0&#x27;</span>+degree);</span><br><span class="line">filename += <span class="string">&quot;.dat&quot;</span>;</span><br><span class="line"><span class="function">std::ofstream <span class="title">gnuplot_file</span> <span class="params">(filename.c_str())</span></span>;</span><br><span class="line">grid_out.<span class="built_in">write_gnuplot</span> (triangulation, gnuplot_file, &amp;mapping);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是使用Gnuplot进行输出。<br>下面就进入该算例的主要部分：圆周率的计算。<br>因为这里的圆的半径是1，所以圆的面积的计算就是对常数1在整个计算域上积分：<br>$$<br>\int_K 1 dx=\int_{\hat K} 1 \ \textrm{det}\ J(\hat x) d\hat x \approx \sum_i \textrm{det} \ J(\hat x_i)w(\hat x_i)<br>$$<br>计算开始：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute_pi_by_area</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Computation of Pi by the area:&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;==============================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> QGauss&lt;dim&gt; <span class="title">quadrature</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> degree=<span class="number">1</span>; degree&lt;<span class="number">5</span>; ++degree)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Degree = &quot;</span> &lt;&lt; degree &lt;&lt; std::endl;</span><br><span class="line">        Triangulation&lt;dim&gt; triangulation;</span><br><span class="line">        GridGenerator::<span class="built_in">hyper_ball</span> (triangulation);</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> SphericalManifold&lt;dim&gt; boundary;</span><br><span class="line">        triangulation.<span class="built_in">set_all_manifold_ids_on_boundary</span> (<span class="number">0</span>);</span><br><span class="line">        triangulation.<span class="built_in">set_manifold</span>(<span class="number">0</span>, boundary);</span><br><span class="line">        <span class="function"><span class="keyword">const</span> MappingQ&lt;dim&gt; <span class="title">mapping</span> <span class="params">(degree)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里选择的积分精度足够大，保证在这里任意映射下都能正确求解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> FE_Q&lt;dim&gt; <span class="title">dummy_fe</span> <span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">DoFHandler&lt;dim&gt; <span class="title">dof_handler</span> <span class="params">(triangulation)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里创建了虚假的有限单元和自由度句柄，因为这里不需要知道在积分点上有限元上的值，只是为了知道那个积分权重。注意，这里有限单元的形函数次数是1，再次说明线性形函数跟线性映射不是一个概念。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FEValues&lt;dim&gt; <span class="title">fe_values</span> <span class="params">(mapping, dummy_fe, quadrature,</span></span></span><br><span class="line"><span class="function"><span class="params">        update_JxW_values)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里传递给FEValues的第一个参数是mapping对象，之前的例子中这个参数是省略的，默认使用MappingQ1这样的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConvergenceTable table;</span><br></pre></td></tr></table></figure>
<p>这里再创建一个收敛性表格，来看收敛速率。<br>然后开始对细化步数循环：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> refinement=<span class="number">0</span>; refinement&lt;<span class="number">6</span>;</span><br><span class="line">        ++refinement, triangulation.<span class="built_in">refine_global</span> (<span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">    table.<span class="built_in">add_value</span>(<span class="string">&quot;cells&quot;</span>, triangulation.<span class="built_in">n_active_cells</span>());</span><br><span class="line">    dof_handler.<span class="built_in">distribute_dofs</span> (dummy_fe);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> area = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>然后对所有单元进行循环：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator</span><br><span class="line">cell = dof_handler.<span class="built_in">begin_active</span>(),</span><br><span class="line">     endc = dof_handler.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">for</span> (; cell!=endc; ++cell)</span><br><span class="line">&#123;</span><br><span class="line">    fe_values.<span class="built_in">reinit</span> (cell);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;fe_values.n_quadrature_points; ++i)</span><br><span class="line">        area += fe_values.<span class="built_in">JxW</span> (i);</span><br><span class="line">&#125;</span><br><span class="line">table.<span class="built_in">add_value</span>(<span class="string">&quot;eval.pi&quot;</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt; (area));</span><br><span class="line">table.<span class="built_in">add_value</span>(<span class="string">&quot;error&quot;</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt; (std::<span class="built_in">fabs</span>(area-pi)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且存储进table中。<br>然后开始计算收敛性：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">table.<span class="built_in">omit_column_from_convergence_rate_evaluation</span>(<span class="string">&quot;cells&quot;</span>);</span><br><span class="line">table.<span class="built_in">omit_column_from_convergence_rate_evaluation</span>(<span class="string">&quot;eval.pi&quot;</span>);</span><br><span class="line">table.<span class="built_in">evaluate_all_convergence_rates</span>(ConvergenceTable::reduction_rate_log2);</span><br><span class="line">table.<span class="built_in">set_precision</span>(<span class="string">&quot;eval.pi&quot;</span>, <span class="number">16</span>);</span><br><span class="line">table.<span class="built_in">set_scientific</span>(<span class="string">&quot;error&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">table.<span class="built_in">write_text</span>(std::cout);</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">下面的计算方法不是计算面积，而是计算周长：</span><br><span class="line">```cpp</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute_pi_by_perimeter</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Computation of Pi by the perimeter:&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;===================================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    const QGauss&lt;dim-1&gt; quadrature(4);</span><br></pre></td></tr></table></figure>
<p>注意，上面的QGauss的维度是dim-1，这是因为是对边积分，而不是对体单元。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> degree=<span class="number">1</span>; degree&lt;<span class="number">5</span>; ++degree)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Degree = &quot;</span> &lt;&lt; degree &lt;&lt; std::endl;</span><br><span class="line">    Triangulation&lt;dim&gt; triangulation;</span><br><span class="line">    GridGenerator::<span class="built_in">hyper_ball</span> (triangulation);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> SphericalManifold&lt;dim&gt; boundary;</span><br><span class="line">    triangulation.<span class="built_in">set_all_manifold_ids_on_boundary</span> (<span class="number">0</span>);</span><br><span class="line">    triangulation.<span class="built_in">set_manifold</span> (<span class="number">0</span>, boundary);</span><br><span class="line">    <span class="function"><span class="keyword">const</span> MappingQ&lt;dim&gt; <span class="title">mapping</span> <span class="params">(degree)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> FE_Q&lt;dim&gt; <span class="title">fe</span> <span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">DoFHandler&lt;dim&gt; <span class="title">dof_handler</span> <span class="params">(triangulation)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这些跟上面的一样。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FEFaceValues&lt;dim&gt; <span class="title">fe_face_values</span> <span class="params">(mapping, fe, quadrature,</span></span></span><br><span class="line"><span class="function"><span class="params">        update_JxW_values)</span></span>;</span><br><span class="line">ConvergenceTable table;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> refinement=<span class="number">0</span>; refinement&lt;<span class="number">6</span>;</span><br><span class="line">        ++refinement, triangulation.<span class="built_in">refine_global</span> (<span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">    table.<span class="built_in">add_value</span>(<span class="string">&quot;cells&quot;</span>, triangulation.<span class="built_in">n_active_cells</span>());</span><br><span class="line">    dof_handler.<span class="built_in">distribute_dofs</span> (fe);</span><br></pre></td></tr></table></figure>
<p>Attention！这里是创建的FEFaceValues而不是FEValues对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator</span><br><span class="line">cell = dof_handler.<span class="built_in">begin_active</span>(),</span><br><span class="line">     endc = dof_handler.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> perimeter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; cell!=endc; ++cell)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> face_no=<span class="number">0</span>; face_no&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face_no)</span><br><span class="line">        <span class="keyword">if</span> (cell-&gt;<span class="built_in">face</span>(face_no)-&gt;<span class="built_in">at_boundary</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            fe_face_values.<span class="built_in">reinit</span> (cell, face_no);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;fe_face_values.n_quadrature_points; ++i)</span><br><span class="line">                perimeter += fe_face_values.<span class="built_in">JxW</span> (i);</span><br><span class="line">        &#125;</span><br><span class="line">table.<span class="built_in">add_value</span>(<span class="string">&quot;eval.pi&quot;</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt; (perimeter/<span class="number">2.</span>));</span><br><span class="line">table.<span class="built_in">add_value</span>(<span class="string">&quot;error&quot;</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt; (std::<span class="built_in">fabs</span>(perimeter/<span class="number">2.</span>-pi)));</span><br><span class="line">&#125;</span><br><span class="line">table.<span class="built_in">omit_column_from_convergence_rate_evaluation</span>(<span class="string">&quot;cells&quot;</span>);</span><br><span class="line">table.<span class="built_in">omit_column_from_convergence_rate_evaluation</span>(<span class="string">&quot;eval.pi&quot;</span>);</span><br><span class="line">table.<span class="built_in">evaluate_all_convergence_rates</span>(ConvergenceTable::reduction_rate_log2);</span><br><span class="line">table.<span class="built_in">set_precision</span>(<span class="string">&quot;eval.pi&quot;</span>, <span class="number">16</span>);</span><br><span class="line">table.<span class="built_in">set_scientific</span>(<span class="string">&quot;error&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">table.<span class="built_in">write_text</span>(std::cout);</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Attention！！这里积分时，只有边界上的才能被叠加进去，所以需要有一个判断是否边界的语句。<br>然后是main函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout.<span class="built_in">precision</span> (<span class="number">16</span>);</span><br><span class="line">        Step10::gnuplot_output&lt;<span class="number">2</span>&gt;();</span><br><span class="line">        Step10::compute_pi_by_area&lt;<span class="number">2</span>&gt; ();</span><br><span class="line">        Step10::compute_pi_by_perimeter&lt;<span class="number">2</span>&gt; ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (std::exception &amp;exc)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; exc.<span class="built_in">what</span>() &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="计算结果"><a href="#计算结果" class="headerlink" title="计算结果"></a>计算结果</h1><p><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjl2m8t1wj308c08c74g.jpg"><br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjl33o61aj308c08c74i.jpg"><br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjl3b1j24j308c081mxd.jpg"><br>上面展示的是粗网格上的结果。实线是网格，虚线是精确的圆。<br>可以看出，即使在粗网格上，二次和三次映射都取得了很好的吻合结果。<br>然后是计算精度：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">Computation of Pi by the area:</span><br><span class="line">==============================</span><br><span class="line">Degree = <span class="number">1</span></span><br><span class="line">cells eval.pi error</span><br><span class="line"><span class="number">5</span> <span class="number">1.9999999999999993</span> <span class="number">1.1416e+00</span> -</span><br><span class="line"><span class="number">20</span> <span class="number">2.8284271247461894</span> <span class="number">3.1317e-01</span> <span class="number">1.87</span></span><br><span class="line"><span class="number">80</span> <span class="number">3.0614674589207178</span> <span class="number">8.0125e-02</span> <span class="number">1.97</span></span><br><span class="line"><span class="number">320</span> <span class="number">3.1214451522580520</span> <span class="number">2.0148e-02</span> <span class="number">1.99</span></span><br><span class="line"><span class="number">1280</span> <span class="number">3.1365484905459393</span> <span class="number">5.0442e-03</span> <span class="number">2.00</span></span><br><span class="line"><span class="number">5120</span> <span class="number">3.1403311569547534</span> <span class="number">1.2615e-03</span> <span class="number">2.00</span></span><br><span class="line">Degree = <span class="number">2</span></span><br><span class="line">cells eval.pi error</span><br><span class="line"><span class="number">5</span> <span class="number">3.1045694996615865</span> <span class="number">3.7023e-02</span> -</span><br><span class="line"><span class="number">20</span> <span class="number">3.1391475703122271</span> <span class="number">2.4451e-03</span> <span class="number">3.92</span></span><br><span class="line"><span class="number">80</span> <span class="number">3.1414377167038303</span> <span class="number">1.5494e-04</span> <span class="number">3.98</span></span><br><span class="line"><span class="number">320</span> <span class="number">3.1415829366419015</span> <span class="number">9.7169e-06</span> <span class="number">4.00</span></span><br><span class="line"><span class="number">1280</span> <span class="number">3.1415920457576911</span> <span class="number">6.0783e-07</span> <span class="number">4.00</span></span><br><span class="line"><span class="number">5120</span> <span class="number">3.1415926155921139</span> <span class="number">3.7998e-08</span> <span class="number">4.00</span></span><br><span class="line">Degree = <span class="number">3</span></span><br><span class="line">cells eval.pi error</span><br><span class="line"><span class="number">5</span> <span class="number">3.1410033851499310</span> <span class="number">5.8927e-04</span> -</span><br><span class="line"><span class="number">20</span> <span class="number">3.1415830393583861</span> <span class="number">9.6142e-06</span> <span class="number">5.94</span></span><br><span class="line"><span class="number">80</span> <span class="number">3.1415925017363837</span> <span class="number">1.5185e-07</span> <span class="number">5.98</span></span><br><span class="line"><span class="number">320</span> <span class="number">3.1415926512106722</span> <span class="number">2.3791e-09</span> <span class="number">6.00</span></span><br><span class="line"><span class="number">1280</span> <span class="number">3.1415926535525962</span> <span class="number">3.7197e-11</span> <span class="number">6.00</span></span><br><span class="line"><span class="number">5120</span> <span class="number">3.1415926535892140</span> <span class="number">5.7923e-13</span> <span class="number">6.00</span></span><br><span class="line">Degree = <span class="number">4</span></span><br><span class="line">cells eval.pi error</span><br><span class="line"><span class="number">5</span> <span class="number">3.1415871927401127</span> <span class="number">5.4608e-06</span> -</span><br><span class="line"><span class="number">20</span> <span class="number">3.1415926314742437</span> <span class="number">2.2116e-08</span> <span class="number">7.95</span></span><br><span class="line"><span class="number">80</span> <span class="number">3.1415926535026228</span> <span class="number">8.7170e-11</span> <span class="number">7.99</span></span><br><span class="line"><span class="number">320</span> <span class="number">3.1415926535894529</span> <span class="number">3.4036e-13</span> <span class="number">8.00</span></span><br><span class="line"><span class="number">1280</span> <span class="number">3.1415926535897927</span> <span class="number">2.9187e-16</span> <span class="number">10.19</span></span><br><span class="line"><span class="number">5120</span> <span class="number">3.1415926535897944</span> <span class="number">1.3509e-15</span> <span class="number">-2.21</span></span><br><span class="line">Computation of Pi by the perimeter:</span><br><span class="line">===================================</span><br><span class="line">Degree = <span class="number">1</span></span><br><span class="line">cells eval.pi error</span><br><span class="line"><span class="number">5</span> <span class="number">2.8284271247461898</span> <span class="number">3.1317e-01</span> -</span><br><span class="line"><span class="number">20</span> <span class="number">3.0614674589207178</span> <span class="number">8.0125e-02</span> <span class="number">1.97</span></span><br><span class="line"><span class="number">80</span> <span class="number">3.1214451522580520</span> <span class="number">2.0148e-02</span> <span class="number">1.99</span></span><br><span class="line"><span class="number">320</span> <span class="number">3.1365484905459393</span> <span class="number">5.0442e-03</span> <span class="number">2.00</span></span><br><span class="line"><span class="number">1280</span> <span class="number">3.1403311569547525</span> <span class="number">1.2615e-03</span> <span class="number">2.00</span></span><br><span class="line"><span class="number">5120</span> <span class="number">3.1412772509327729</span> <span class="number">3.1540e-04</span> <span class="number">2.00</span></span><br><span class="line">Degree = <span class="number">2</span></span><br><span class="line">cells eval.pi error</span><br><span class="line"><span class="number">5</span> <span class="number">3.1248930668550594</span> <span class="number">1.6700e-02</span> -</span><br><span class="line"><span class="number">20</span> <span class="number">3.1404050605605449</span> <span class="number">1.1876e-03</span> <span class="number">3.81</span></span><br><span class="line"><span class="number">80</span> <span class="number">3.1415157631807014</span> <span class="number">7.6890e-05</span> <span class="number">3.95</span></span><br><span class="line"><span class="number">320</span> <span class="number">3.1415878042798617</span> <span class="number">4.8493e-06</span> <span class="number">3.99</span></span><br><span class="line"><span class="number">1280</span> <span class="number">3.1415923498174534</span> <span class="number">3.0377e-07</span> <span class="number">4.00</span></span><br><span class="line"><span class="number">5120</span> <span class="number">3.1415926345932004</span> <span class="number">1.8997e-08</span> <span class="number">4.00</span></span><br><span class="line">Degree = <span class="number">3</span></span><br><span class="line">cells eval.pi error</span><br><span class="line"><span class="number">5</span> <span class="number">3.1414940401456057</span> <span class="number">9.8613e-05</span> -</span><br><span class="line"><span class="number">20</span> <span class="number">3.1415913432549156</span> <span class="number">1.3103e-06</span> <span class="number">6.23</span></span><br><span class="line"><span class="number">80</span> <span class="number">3.1415926341726914</span> <span class="number">1.9417e-08</span> <span class="number">6.08</span></span><br><span class="line"><span class="number">320</span> <span class="number">3.1415926532906893</span> <span class="number">2.9910e-10</span> <span class="number">6.02</span></span><br><span class="line"><span class="number">1280</span> <span class="number">3.1415926535851360</span> <span class="number">4.6571e-12</span> <span class="number">6.01</span></span><br><span class="line"><span class="number">5120</span> <span class="number">3.1415926535897203</span> <span class="number">7.2845e-14</span> <span class="number">6.00</span></span><br><span class="line">Degree = <span class="number">4</span></span><br><span class="line">cells eval.pi error</span><br><span class="line"><span class="number">5</span> <span class="number">3.1415921029432576</span> <span class="number">5.5065e-07</span> -</span><br><span class="line"><span class="number">20</span> <span class="number">3.1415926513737600</span> <span class="number">2.2160e-09</span> <span class="number">7.96</span></span><br><span class="line"><span class="number">80</span> <span class="number">3.1415926535810712</span> <span class="number">8.7218e-12</span> <span class="number">7.99</span></span><br><span class="line"><span class="number">320</span> <span class="number">3.1415926535897594</span> <span class="number">3.3668e-14</span> <span class="number">8.02</span></span><br><span class="line"><span class="number">1280</span> <span class="number">3.1415926535897922</span> <span class="number">1.0617e-15</span> <span class="number">4.99</span></span><br><span class="line"><span class="number">5120</span> <span class="number">3.1415926535897931</span> <span class="number">1.0061e-16</span> <span class="number">3.40</span></span><br></pre></td></tr></table></figure>
<p>可以看出，随着映射次数提高，计算精度也在提高，而Q1映射在最细网格上的精度还不如Q3映射在最粗网格上的精度。最后一栏是收敛阶，可以看出阶数达到了$h^{2p}$。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2016/09/16/dealii-learn-step11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Be interesting!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亓欣波">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/09/16/dealii-learn-step11/" class="post-title-link" itemprop="url">求解偏微分方程开源有限元软件deal.II学习--Step 11</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-09-16 00:00:00" itemprop="dateCreated datePublished" datetime="2016-09-16T00:00:00+08:00">2016-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 15:20:30" itemprop="dateModified" datetime="2021-03-25T15:20:30+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computational-material-science/" itemprop="url" rel="index"><span itemprop="name">computational material science</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2016/09/16/dealii-learn-step11/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/09/16/dealii-learn-step11/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>这个例子的亮点：介绍了最简单的Laplace方程的组装矩阵和右端项的一键生成函数。<br>这个例子来求解仅考虑Neumann边界条件的Laplace问题：<br>$$<br>\begin{equation}<br>\begin{split}<br>-\Delta u &amp;=f \qquad \mathrm{in}\ \Omega, \\<br>\partial_n u &amp;=g \qquad \mathrm{on}\ \partial\Omega.<br>\end{split}<br>\end{equation}<br>$$<br>如果有解的话，解必须满足协调条件：<br>$$<br>\int_\Omega f dx + \int_{\partial\Omega} g ds = 0.<br>$$<br>这里考虑计算域是以原点为圆心，半径为1的圆，$f=-2,g=1$是满足协调条件的。<br>虽然协调条件允许有解，但解仍然是不定的：在方程中仅仅解的导数固定，解可以是任意常数。所以需要施加另外一个条件来固定这个常数。可以有以下可能的方法：</p>
<ul>
<li>固定离散后的某个节点值为0或其他固定值。这意味着一个额外的条件$u_h(x_0)=0$。尽管这是通常的做法，但不是一个好方法，因为我们知道Laplace方程的解是在H1空间，它不允许定义某个点的值，因为这样不是连续函数的子集。因此，尽管固定某点的值在离散时是允许的，但这样不是连续函数，结果经常是数值上的一个尖峰。</li>
<li>固定计算域上的平均值是0或其他固定值。这满足了连续性。</li>
<li>固定计算域边界上的平均值是0或者其他固定值。这也满足了连续性。</li>
</ul>
<p>这里选择最后一种，因为还想展示另一项技术。<br>具体到在程序中怎样解方程，除了额外的平均值限制，其他技术都已经涉及过了，这里需要把Dirichlet边界条件删掉，至于怎样映射，在绝大多数情况下，完全可以把它当成黑盒，程序已自动处理。唯一一点就是平均值限制。幸运的是，库中有一个类知道怎样处理这种限制。如果假定边界节点沿边界均匀分布，那么平均值限制：<br>$$<br>\int_{\partial \Omega} u(x) ds = 0<br>$$<br>就可以写为：<br>$$<br>\sum_{i\in\partial\Omega_h} u_i = 0,<br>$$<br>这个求和应该遍历所有在边界上的自由度。设$i_0$是边界上指标最小的自由度，那么：<br>$$<br>u_{i_0} = \sum_{i\in\partial\Omega_h\backslash i_0} -u_i.<br>$$<br>这是ConstraintMatrix类所想要的形式。注意我们之前已经多次用到过这个类，比如悬点限制：中间节点上的值等于相邻节点的平均值。通常来说，ConstraintMatrix来处理均匀限制：<br>$$<br>CU=0<br>$$<br>其中C是矩阵，U是节点值的向量。</p>
<h1 id="程序解析"><a href="#程序解析" class="headerlink" title="程序解析"></a>程序解析</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/quadrature_lib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/function.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/logstream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/table_handler.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/vector.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/sparse_matrix.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/solver_cg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/precondition.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/constraint_matrix.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/grid_generator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/manifold_lib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria_accessor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria_iterator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_handler.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_accessor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_tools.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/fe/fe_q.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/fe/fe_values.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/fe/mapping_q.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/vector_tools.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/matrix_tools.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>之前用过的头文件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>这个是新的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>C++的标准头文件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Step11</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> dealii;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">LaplaceProblem</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                <span class="built_in">LaplaceProblem</span> (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> mapping_degree);</span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span></span>;</span><br><span class="line">            <span class="keyword">private</span>:</span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">setup_system</span> <span class="params">()</span></span>;</span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">assemble_and_solve</span> <span class="params">()</span></span>;</span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span>;</span><br><span class="line">                Triangulation&lt;dim&gt; triangulation;</span><br><span class="line">                FE_Q&lt;dim&gt; fe;</span><br><span class="line">                DoFHandler&lt;dim&gt; dof_handler;</span><br><span class="line">                MappingQ&lt;dim&gt; mapping;</span><br><span class="line">                SparsityPattern sparsity_pattern;</span><br><span class="line">                SparseMatrix&lt;<span class="keyword">double</span>&gt; system_matrix;</span><br><span class="line">                ConstraintMatrix mean_value_constraints;</span><br><span class="line">                Vector&lt;<span class="keyword">double</span>&gt; solution;</span><br><span class="line">                Vector&lt;<span class="keyword">double</span>&gt; system_rhs;</span><br><span class="line">                TableHandler output_table;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<p>这个声明跟Step5差不多，仅有少许不同。它的构造函数中接收一个映射次数的参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">LaplaceProblem&lt;dim&gt;::<span class="built_in">LaplaceProblem</span> (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> mapping_degree) :</span><br><span class="line">    <span class="built_in">fe</span> (<span class="number">1</span>),</span><br><span class="line">    <span class="built_in">dof_handler</span> (triangulation),</span><br><span class="line">    <span class="built_in">mapping</span> (mapping_degree)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Using mapping with degree &quot;</span> &lt;&lt; mapping_degree &lt;&lt; <span class="string">&quot;:&quot;</span></span><br><span class="line">            &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;============================&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>构造函数，使用1阶有限单元，即fe的参数是1，映射次数是后续手动传入的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> LaplaceProblem&lt;dim&gt;::<span class="built_in">setup_system</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    dof_handler.<span class="built_in">distribute_dofs</span> (fe);</span><br><span class="line">    solution.<span class="built_in">reinit</span> (dof_handler.<span class="built_in">n_dofs</span>());</span><br><span class="line">    system_rhs.<span class="built_in">reinit</span> (dof_handler.<span class="built_in">n_dofs</span>());</span><br></pre></td></tr></table></figure>
<p>然后是建立系统：首先建立一个DoFHandler对象，初始化解和右端项。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="keyword">bool</span>&gt; <span class="title">boundary_dofs</span> <span class="params">(dof_handler.n_dofs(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">DoFTools::<span class="built_in">extract_boundary_dofs</span> (dof_handler,</span><br><span class="line">        <span class="built_in">ComponentMask</span>(),</span><br><span class="line">        boundary_dofs);</span><br></pre></td></tr></table></figure>
<p>然后就是建立边界上自由度上的平均值为0的限制对象。这里首先得提取出边界上的自由度。DoFTools有一个函数能返回一个布尔值的列表，其中true代表节点在边界上。第二个参数是一个蒙版，选择矢量函数的某个分量。这里处理的是一个标量有限元，所以只有一个分量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> first_boundary_dof</span><br><span class="line">= std::<span class="built_in">distance</span> (boundary_dofs.<span class="built_in">begin</span>(),</span><br><span class="line">        std::<span class="built_in">find</span> (boundary_dofs.<span class="built_in">begin</span>(),</span><br><span class="line">            boundary_dofs.<span class="built_in">end</span>(),</span><br><span class="line">            <span class="literal">true</span>));</span><br></pre></td></tr></table></figure>
<p>然后就是具体的限制。正如引子中所说，我们限制边界上某一个节点的值等于边界上其他所有自由度的值总和。所以，先找到第一个自由度，这里是查找第一个true值，然后计算它离第一个元素的距离从而确定它的指标。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mean_value_constraints.<span class="built_in">clear</span> ();</span><br><span class="line">mean_value_constraints.<span class="built_in">add_line</span> (first_boundary_dof);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=first_boundary_dof+<span class="number">1</span>; i&lt;dof_handler.<span class="built_in">n_dofs</span>(); ++i)</span><br><span class="line">    <span class="keyword">if</span> (boundary_dofs[i] == <span class="literal">true</span>)</span><br><span class="line">        mean_value_constraints.<span class="built_in">add_entry</span> (first_boundary_dof,</span><br><span class="line">                i, <span class="number">-1</span>);</span><br><span class="line">mean_value_constraints.<span class="built_in">close</span> ();</span><br></pre></td></tr></table></figure>
<p>然后创建一个限制对象。首先清除所有的之前的内容，然后加上这么一行限制，在其他所有自由度的总和前加上-1的权重。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DynamicSparsityPattern <span class="title">dsp</span> <span class="params">(dof_handler.n_dofs(),</span></span></span><br><span class="line"><span class="function"><span class="params">        dof_handler.n_dofs())</span></span>;</span><br><span class="line">DoFTools::<span class="built_in">make_sparsity_pattern</span> (dof_handler, dsp);</span><br><span class="line">mean_value_constraints.<span class="built_in">condense</span> (dsp);</span><br><span class="line">sparsity_pattern.<span class="built_in">copy_from</span> (dsp);</span><br><span class="line">system_matrix.<span class="built_in">reinit</span> (sparsity_pattern);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是创建稀疏矩阵。这里也是先使用动态稀疏模式来大致估计长度，然后再创建稀疏矩阵。<br>接下来是组装和求解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> LaplaceProblem&lt;dim&gt;::<span class="built_in">assemble_and_solve</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> gauss_degree</span><br><span class="line">        = std::<span class="built_in">max</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(std::<span class="built_in">ceil</span>(<span class="number">1.</span>*(mapping.<span class="built_in">get_degree</span>()+<span class="number">1</span>)/<span class="number">2</span>)),</span><br><span class="line">                <span class="number">2U</span>);</span><br><span class="line">    MatrixTools::<span class="built_in">create_laplace_matrix</span> (mapping, dof_handler,</span><br><span class="line">            QGauss&lt;dim&gt;(gauss_degree),</span><br><span class="line">            system_matrix);</span><br><span class="line">    VectorTools::<span class="built_in">create_right_hand_side</span> (mapping, dof_handler,</span><br><span class="line">            QGauss&lt;dim&gt;(gauss_degree),</span><br><span class="line">            ConstantFunction&lt;dim&gt;(<span class="number">-2</span>),</span><br><span class="line">            system_rhs);</span><br></pre></td></tr></table></figure>
<p>首先必须组装矩阵和右端项。因为Laplace方程比较简单，库函数直接提供了工具，将单元循环什么的都集成了起来，正如上面所写。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector&lt;<span class="keyword">double</span>&gt; <span class="title">tmp</span> <span class="params">(system_rhs.size())</span></span>;</span><br><span class="line">VectorTools::<span class="built_in">create_boundary_right_hand_side</span> (mapping, dof_handler,</span><br><span class="line">        QGauss&lt;dim<span class="number">-1</span>&gt;(gauss_degree),</span><br><span class="line">        ConstantFunction&lt;dim&gt;(<span class="number">1</span>),</span><br><span class="line">        tmp);</span><br></pre></td></tr></table></figure>
<p>边界力的计算也是直接调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system_rhs += tmp;</span><br></pre></td></tr></table></figure>
<p>然后将边界上的贡献叠加到整体右端项中。注意这个地方需要显式地叠加，因为这两个create函数都是先清除输出变量，所以不能直接叠加。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mean_value_constraints.<span class="built_in">condense</span> (system_matrix);</span><br><span class="line">mean_value_constraints.<span class="built_in">condense</span> (system_rhs);</span><br><span class="line"><span class="built_in">solve</span> ();</span><br><span class="line">mean_value_constraints.<span class="built_in">distribute</span> (solution);</span><br></pre></td></tr></table></figure>
<p>然后施加限制条件，再求解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector&lt;<span class="keyword">float</span>&gt; <span class="title">norm_per_cell</span> <span class="params">(triangulation.n_active_cells())</span></span>;</span><br><span class="line">VectorTools::<span class="built_in">integrate_difference</span> (mapping, dof_handler,</span><br><span class="line">        solution,</span><br><span class="line">        ZeroFunction&lt;dim&gt;(),</span><br><span class="line">        norm_per_cell,</span><br><span class="line">        QGauss&lt;dim&gt;(gauss_degree+<span class="number">1</span>),</span><br><span class="line">        VectorTools::H1_seminorm);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> norm = norm_per_cell.<span class="built_in">l2_norm</span>();</span><br><span class="line">output_table.<span class="built_in">add_value</span> (<span class="string">&quot;cells&quot;</span>, triangulation.<span class="built_in">n_active_cells</span>());</span><br><span class="line">output_table.<span class="built_in">add_value</span> (<span class="string">&quot;|u|_1&quot;</span>, norm);</span><br><span class="line">output_table.<span class="built_in">add_value</span> (<span class="string">&quot;error&quot;</span>, std::<span class="built_in">fabs</span>(norm-std::<span class="built_in">sqrt</span>(<span class="number">3.14159265358</span>/<span class="number">2</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是计算了范数并输出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> LaplaceProblem&lt;dim&gt;::<span class="built_in">solve</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">SolverControl <span class="title">solver_control</span> <span class="params">(<span class="number">1000</span>, <span class="number">1e-12</span>)</span></span>;</span><br><span class="line">    SolverCG&lt;&gt; <span class="built_in">cg</span> (solver_control);</span><br><span class="line">    PreconditionSSOR&lt;&gt; preconditioner;</span><br><span class="line">    preconditioner.<span class="built_in">initialize</span>(system_matrix, <span class="number">1.2</span>);</span><br><span class="line">    cg.<span class="built_in">solve</span> (system_matrix, solution, system_rhs,</span><br><span class="line">            preconditioner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是求解，跟Step5相同。<br>run函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> LaplaceProblem&lt;dim&gt;::<span class="built_in">run</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    GridGenerator::<span class="built_in">hyper_ball</span> (triangulation);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> SphericalManifold&lt;dim&gt; boundary;</span><br><span class="line">    triangulation.<span class="built_in">set_all_manifold_ids_on_boundary</span>(<span class="number">0</span>);</span><br><span class="line">    triangulation.<span class="built_in">set_manifold</span> (<span class="number">0</span>, boundary);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> cycle=<span class="number">0</span>; cycle&lt;<span class="number">6</span>; ++cycle, triangulation.<span class="built_in">refine_global</span>(<span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">setup_system</span> ();</span><br><span class="line">        <span class="built_in">assemble_and_solve</span> ();</span><br><span class="line">    &#125;;</span><br><span class="line">    output_table.<span class="built_in">set_precision</span>(<span class="string">&quot;|u|_1&quot;</span>, <span class="number">6</span>);</span><br><span class="line">    output_table.<span class="built_in">set_precision</span>(<span class="string">&quot;error&quot;</span>, <span class="number">6</span>);</span><br><span class="line">    output_table.<span class="built_in">write_text</span> (std::cout);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是main函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout.<span class="built_in">precision</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> mapping_degree=<span class="number">1</span>; mapping_degree&lt;=<span class="number">3</span>; ++mapping_degree)</span><br><span class="line">            Step11::LaplaceProblem&lt;<span class="number">2</span>&gt;(mapping_degree).<span class="built_in">run</span> ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (std::exception &amp;exc)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; exc.<span class="built_in">what</span>() &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="计算结果"><a href="#计算结果" class="headerlink" title="计算结果"></a>计算结果</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Using mapping with degree <span class="number">1</span>:</span><br><span class="line">============================</span><br><span class="line">cells |u|_1 error</span><br><span class="line"><span class="number">5</span> <span class="number">0.680402</span> <span class="number">0.572912</span></span><br><span class="line"><span class="number">20</span> <span class="number">1.085518</span> <span class="number">0.167796</span></span><br><span class="line"><span class="number">80</span> <span class="number">1.208981</span> <span class="number">0.044334</span></span><br><span class="line"><span class="number">320</span> <span class="number">1.242041</span> <span class="number">0.011273</span></span><br><span class="line"><span class="number">1280</span> <span class="number">1.250482</span> <span class="number">0.002832</span></span><br><span class="line"><span class="number">5120</span> <span class="number">1.252605</span> <span class="number">0.000709</span></span><br><span class="line">Using mapping with degree <span class="number">2</span>:</span><br><span class="line">============================</span><br><span class="line">cells |u|_1 error</span><br><span class="line"><span class="number">5</span> <span class="number">1.050963</span> <span class="number">0.202351</span></span><br><span class="line"><span class="number">20</span> <span class="number">1.199642</span> <span class="number">0.053672</span></span><br><span class="line"><span class="number">80</span> <span class="number">1.239913</span> <span class="number">0.013401</span></span><br><span class="line"><span class="number">320</span> <span class="number">1.249987</span> <span class="number">0.003327</span></span><br><span class="line"><span class="number">1280</span> <span class="number">1.252486</span> <span class="number">0.000828</span></span><br><span class="line"><span class="number">5120</span> <span class="number">1.253108</span> <span class="number">0.000206</span></span><br><span class="line">Using mapping with degree <span class="number">3</span>:</span><br><span class="line">============================</span><br><span class="line">cells |u|_1 error</span><br><span class="line"><span class="number">5</span> <span class="number">1.086161</span> <span class="number">0.167153</span></span><br><span class="line"><span class="number">20</span> <span class="number">1.204349</span> <span class="number">0.048965</span></span><br><span class="line"><span class="number">80</span> <span class="number">1.240502</span> <span class="number">0.012812</span></span><br><span class="line"><span class="number">320</span> <span class="number">1.250059</span> <span class="number">0.003255</span></span><br><span class="line"><span class="number">1280</span> <span class="number">1.252495</span> <span class="number">0.000819</span></span><br><span class="line"><span class="number">5120</span> <span class="number">1.253109</span> <span class="number">0.000205</span></span><br></pre></td></tr></table></figure>
<p>其中一个有意思的地方是：使用线性映射的误差要比使用更高阶映射的三倍要大。因此在本例中使用更高阶映射，不是因为它提高了收敛阶数，而是它直接计算出了常数。另一方面，使用三次映射并没有显著提高精度。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2016/09/15/dealii-learn-step9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Be interesting!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亓欣波">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/09/15/dealii-learn-step9/" class="post-title-link" itemprop="url">求解偏微分方程开源有限元软件deal.II学习--Step 9</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-09-15 00:00:00" itemprop="dateCreated datePublished" datetime="2016-09-15T00:00:00+08:00">2016-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 15:20:30" itemprop="dateModified" datetime="2021-03-25T15:20:30+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computational-material-science/" itemprop="url" rel="index"><span itemprop="name">computational material science</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2016/09/15/dealii-learn-step9/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/09/15/dealii-learn-step9/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>本例将要完成以下目标：</p>
<ul>
<li>求解对流方程$\beta \cdot \nabla u = f$</li>
<li>使用多线程求解</li>
<li>设计一个简单的细化准则</li>
</ul>
<h2 id="方程离散"><a href="#方程离散" class="headerlink" title="方程离散"></a>方程离散</h2><p>对流方程中$\beta$是一个描述对流方向和速度的矢量场，可能与空间位置相关，$f$是源项，$u$是解。这个方程求解的物理过程可以是浓度u在给定流场下的传输，没有扩散过程，但有源。<br>明显地，在入流侧，上述方程需要在边界上获得补充：<br>$$<br>u = g \qquad\qquad \mathrm{on}\ \partial\Omega_-,<br>$$<br>其中，$\Omega_-$代表边界的入流部分，其定义为：<br>$$<br>\partial\Omega_-=[{\mathbf x}\in\partial\Omega:\beta\cdot{\mathbf n}({\mathbf x}) &lt; 0],<br>$$<br>其中，${\mathbf n}({\mathbf x})$是点$x$上的外法线。这种定义方式是非常直观的：因为如果外法线是朝外的，那么在入流边界上流动方向就肯定是朝内的。而且，数学理论要求不能在外流边界上施加任何边界条件。在下面的弱形式中也可以看出，确实是没有对外流边界作任何处理。这里跟Fluent软件中的自由外流出口边界还不同，Fluent中默认其在出流界面上法线通量为0，即出流速度不影响前方的速度，其是由完全外推得到。但这里因为没有应用分部积分，所以也不需要处理外流边界上的速度值，只是在方程两侧显性地加上了入流条件。<br>注意：这个传输方程使用标准的有限元方法是不能稳定求解的。这里使用“流线扩散稳定方法”，测试函数的形式变成$v+\delta\beta\cdot v$，其中$\delta$是一个与局部网格间距$h$有关的参数，通常$\delta=0.1 h$。当网格尺寸为0时，测试函数就回归之前的形式。具体原理可以参见相关书籍和论文。<br>方程的弱形式为：<br>$$<br>(\beta \cdot \nabla u_h, v_h + \delta \beta\cdot\nabla v_h)_\Omega - (\beta\cdot {\mathbf n} u_h, v_h)_{\partial\Omega_-} = (f, v_h + \delta \beta\cdot\nabla v_h)_\Omega - (\beta\cdot {\mathbf n} g, v_h)_{\partial\Omega_-}.<br>$$<br>Attention！！上式已经加入了边界条件，即右端第二项。而为了满足等式，在左侧也加入了对应的积分项，所以，左侧边界积分项中是未知解，而右端项边界积分中是对应的边界值。<br>那么，其中的刚度矩阵就是：<br>$$<br>a_{ij} = (\beta \cdot \nabla \varphi_i, \varphi_j + \delta \beta\cdot\nabla \varphi_j)_\Omega - (\beta\cdot {\mathbf n} \varphi_i, \varphi_j)_{\partial\Omega_-},<br>$$<br>但是这样的话就需要求解这样的方程：<br>$$<br>{\mathbf u}^T A = {\mathbf f}^T,<br>$$<br>实际求解时需要转置一下：<br>$$<br>A^T{\mathbf u} = {\mathbf f},<br>$$<br>此时如果$A^T=A$还好说，即A是对称矩阵，但此时的问题中的矩阵非对称，所以具体组装矩阵时就要注意元素的位置，为了防止出现需要计算转置这种问题，养成这样一种习惯：每次都把试探函数左乘，而不是右乘，则有：<br>$$<br>(v_h + \delta \beta\cdot\nabla v_h, \beta \cdot \nabla u_h)_\Omega - (\beta\cdot {\mathbf n} v_h, u_h)_{\partial\Omega_-} = (v_h + \delta \beta\cdot\nabla v_h, f)_\Omega - (\beta\cdot {\mathbf n} v_h, g)_{\partial\Omega_-}<br>$$<br>那么矩阵就变成：<br>$$<br>a_{ij} = (\varphi_i + \delta \beta \cdot \nabla \varphi_i, \beta\cdot\nabla \varphi_j)_\Omega - (\beta\cdot {\mathbf n} \varphi_i, \varphi_j)_{\partial\Omega_-},<br>$$<br>对于方程的解，因为矩阵不再是对称正定的，CG算法不再适用，这里采用双共轭梯度稳定算法。<br>方程中的具体数值为：<br>$$<br>\begin{equation}<br>\begin{split}<br>\Omega &amp;=[-1,1]^d \\<br>\beta({\mathbf x}) &amp;=<br>\begin{bmatrix}<br>2 \\<br>1+\frac{4}{5}\sin(8\pi x),<br>\end{bmatrix} \\<br>f({\mathbf x}) &amp;=<br>\begin{bmatrix}<br>\frac {1}{10 s^d} &amp; \mathrm{for}\ |{\mathbf x}-{\mathbf x}_0|&lt;s, \<br>0                 &amp; \mathrm{else},<br>\end{bmatrix}<br>\qquad\qquad {\mathbf x}_0 =<br>\begin{bmatrix}<br>-\frac{3}{4} \<br>-\frac{3}{4}<br>\end{bmatrix} \<br>g &amp;=e^{5(1-|{\mathbf x}|^2)} \sin(16\pi|{\mathbf x}|^2)<br>\end{split}<br>\end{equation}<br>$$</p>
<h2 id="基于任务task并行"><a href="#基于任务task并行" class="headerlink" title="基于任务task并行"></a>基于任务task并行</h2><p>传统的在共享内存机器上的并行是将程序分成多个线程，但这里先讲基于任务的并行。<br>“任务”是程序的独立部分，它们之间或者互相依赖，或者互相不依赖。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> dof_handler.<span class="built_in">distribute_dofs</span> (fe);</span><br><span class="line"><span class="number">2</span> DoFTools::<span class="built_in">make_hanging_node_constraints</span> (dof_handler, hanging_node_constraints);</span><br><span class="line"><span class="number">3</span> DoFTools::<span class="built_in">make_sparsity_pattern</span> (dof_handler, sparsity_pattern);</span><br><span class="line"><span class="number">4</span> hanging_node_constraints.<span class="built_in">condense</span> (sparsity_pattern);</span><br></pre></td></tr></table></figure>
<p>上述4个操作每个都需要较大的计算量。但是注意并不是全部都互相依赖：明显地，操作1必须首先运行，操作4也必须最后运行，但2和3没有先后顺序。<br>Attention：这里如果用线程来表现2和3的独立性，就需要开两个线程，然后在每个线程上分别运行2和3。然后等待两个线程完成后，再将两者join起来：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dof_handler.<span class="built_in">distribute_dofs</span> (fe);</span><br><span class="line">Threads::Thread&lt;<span class="keyword">void</span>&gt;</span><br><span class="line">thread_1 = Threads::<span class="built_in">new_thread</span> (&amp;DoFTools::make_hanging_node_constraints,</span><br><span class="line">        dof_handler, hanging_node_constraints);</span><br><span class="line">Threads::Thread&lt;<span class="keyword">void</span>&gt;</span><br><span class="line">thread_2 = Threads::<span class="built_in">new_thread</span> (&amp;DoFTools::make_sparsity_pattern,</span><br><span class="line">        dof_handler, sparsity_pattern);</span><br><span class="line">thread_1.<span class="built_in">join</span>();</span><br><span class="line">thread_2.<span class="built_in">join</span>();</span><br><span class="line">hanging_node_constraints.<span class="built_in">condense</span> (sparsity_pattern);</span><br></pre></td></tr></table></figure>
<p>那么问题来了：如果只有一个处理器核心，或者有两个，但早就有程序的另外部分在用着？这些情况下，上面的代码仍然会开两个线程，但因为没有额外的计算资源，所以程序运行得不会更快，其实反而更慢，因为线程的创建和销毁需要时间，同时系统还需要调度线程给过载的计算资源。<br>一个更好的方法是：识别独立的任务，然后创建一个任务与计算资源相对应的调度程序scheduler，根据它来切换任务。这样，程序将会在每个核心上创建一个线程，然后开始计算，任务将会一直运行到结束，而不是都同时运行，防止突然打断的线程使计算切换到另一个线程上。在此例中，如果有两个核心，2和3将会同时运行，如果只有一个，调度程序将会先计算完2，然后再切换到3上，或者反过来。这种方法在有大量任务时会很有效率，见下面的WorkStream。<br>deal.II自己不建立调度程序，而是使用TBB库函数。<br>如果使用task来并行，则代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Threads::Task&lt;<span class="keyword">void</span>&gt;</span><br><span class="line">thread</span><br><span class="line">= Threads::<span class="built_in">new_task</span> (&amp;DoFTools::make_hanging_node_constraints,</span><br><span class="line">        dof_handler,</span><br><span class="line">        hanging_node_constraints);</span><br></pre></td></tr></table></figure>
<p>这里使用new_task来创建一个任务，跟之前的new_thread类似。<br>如果有很多tasks，得等它们都停下以后才能往后运行，这时每个都写join会很麻烦，可以把它们放进一个group中，一次等待所有的任务：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dof_handler.<span class="built_in">distribute_dofs</span> (fe);</span><br><span class="line">Threads::TaskGroup&lt;<span class="keyword">void</span>&gt; task_group;</span><br><span class="line">task_group += Threads::<span class="built_in">new_task</span> (&amp;DoFTools::make_hanging_node_constraints,</span><br><span class="line">        dof_handler, hanging_node_constraints);</span><br><span class="line">task_group += Threads::<span class="built_in">new_task</span> (&amp;DoFTools::make_sparsity_pattern,</span><br><span class="line">        dof_handler, sparsity_pattern);</span><br><span class="line">task_group.<span class="built_in">join_all</span> ();</span><br><span class="line">hanging_node_constraints.<span class="built_in">condense</span> (sparsity_pattern);</span><br></pre></td></tr></table></figure>
<p>至于如何调度任务，是在TBB库内部实现的。TBB的文档给出了如何将任务调度给线程，让其执行的详细过程，但没有明确说创建了多少线程。然而，合理猜测是TBB根据核数创建了相同数量的线程，这样就能充分使用整个系统，也没有过多的线程导致频繁的打断。TBB调度程序分配了任务，然后让线程运行它们，线程会充分运行，直到任务结束，而不会中途打断。这意味着缓存永远是时刻使用着的。<br>但是基于任务的并行也有缺点，CPU只在以下两者情况都满足的情况下才满负荷运转：一是有足够数目的任务；二是这些任务确实在做事。比如如果任务数目不够或数目够了但一些任务在闲着，比如等待写入硬盘或等待读入数据，都使CPU没有充分利用。其他情形还有任务在等待外部事件，比如与其他任务的同步等。上述情形下可以创建基于线程的并行，来充分利用CPU。</p>
<h3 id="工作流-Work-Streams"><a href="#工作流-Work-Streams" class="headerlink" title="工作流 Work Streams"></a>工作流 Work Streams</h3><p>在上面例子中，任务的数目大于或等于CPU的核数，以使它们满负荷运行，但也没有太多量，比如只有4个核却有百万个任务。然而也会有百万量级任务的情形，比如将单元上的贡献叠加到整体刚度矩阵中;估计每个单元上的误差指示子等。这些情形可以使用一种称为“WorkStream”的软件设计模式。<br>详情见相应的帮助文档。</p>
<h2 id="基于线程的并行"><a href="#基于线程的并行" class="headerlink" title="基于线程的并行"></a>基于线程的并行</h2><p>有时候基于任务的并行不能发挥CPU的百分百性能，这时可以使用基于线程的并行。比如下面的这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> MyClass&lt;dim&gt;::<span class="built_in">output_and_estimate_error</span> () <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    DataOut&lt;dim&gt; data_out;</span><br><span class="line">    data_out.<span class="built_in">attach_dof_handler</span> (dof_handler);</span><br><span class="line">    data_out.<span class="built_in">add_data_vector</span> (solution, <span class="string">&quot;solution&quot;</span>);</span><br><span class="line">    data_out.<span class="built_in">build_patches</span> ();</span><br><span class="line">    <span class="function">std::ofstream <span class="title">output</span> <span class="params">(<span class="string">&quot;solution.vtk&quot;</span>)</span></span>;</span><br><span class="line">    Threads::Thread&lt;<span class="keyword">void</span>&gt;</span><br><span class="line">        thread = Threads::<span class="built_in">new_thread</span> (&amp;DataOut&lt;dim&gt;::write_vtk, data_out, output);</span><br><span class="line">    <span class="function">Vector&lt;<span class="keyword">float</span>&gt; <span class="title">error_per_cell</span> <span class="params">(triangulation.n_active_cells())</span></span>;</span><br><span class="line">    KellyErrorEstimator&lt;dim&gt;::<span class="built_in">estimate</span> (dof_handler,</span><br><span class="line">            QGauss&lt;dim<span class="number">-1</span>&gt;(<span class="number">3</span>),</span><br><span class="line">            <span class="keyword">typename</span> FunctionMap&lt;dim&gt;::<span class="built_in">type</span>(),</span><br><span class="line">            solution,</span><br><span class="line">            estimated_error_per_cell);</span><br><span class="line">    thread.<span class="built_in">join</span> ();</span><br></pre></td></tr></table></figure>
<p>new_thread新开了一个线程用来输出图片，它跟后面的误差估计并行。这里用线程，是因为往硬盘中写数据不会使得CPU很忙，所以没必要把它做成一个任务。<br>正如上面所说，deal.II使用的是TBB来调度线程，TBB不建议明确地给定线程数目。但是有时候也需要明确指定线程数目，比如在有一个资源管理器的机器上或在获取某些计算资源很费劲的机器上，这时需要限制数目，防止TBB调用过多CPU。还有一种情况是有多个MPI并行任务时，每个任务也只能调用一个子集的计算资源。</p>
<h2 id="细化准则"><a href="#细化准则" class="headerlink" title="细化准则"></a>细化准则</h2><p>之前在有自适应网格的例子中，都是使用了Kelly等人提出的误差指示子，其实际使用的是类似解的二阶导数作为判据。所以应用这个指示子的前提是解有二阶导数。但在有些情况下，比如本例中，解甚至在某些地方没有一阶导数，所以Kelly指示子不再适用。这里提出一种判断梯度的公式。注意到给定两个单元和连结两个单元中心的向量，那么解的梯度可以近似表示为：<br>$$<br>\frac{\mathbf y_{KK’}^T}{|\mathbf y_{KK’}|} \nabla u \approx \frac{u(K’) - u(K)}{|\mathbf y_{KK’}|},<br>$$<br>那么：<br>$$<br>\underbrace{ \left(\sum_{K’} \frac{\mathbf y_{KK’} \mathbf y_{KK’}^T} {|\mathbf y_{KK’}|^2}\right)}_{=:Y} \nabla u \approx \sum_{K’} \frac{\mathbf y_{KK’}}{|\mathbf y_{KK’}|} \frac{u(K’) - u(K)}{|\mathbf y_{KK’}|}.<br>$$<br>再推导有：<br>$$<br>\nabla u \approx Y^{-1} \left( \sum_{K’} \frac{\mathbf y_{KK’}}{|\mathbf y_{KK’}|} \frac{u(K’) - u(K)}{|\mathbf y_{KK’}|} \right).<br>$$<br>右端用$\nabla_h u(K)$来表示，细化准则则为：<br>$$<br>\eta_K = h^{1+d/2} |\nabla_h u_h(K)|,<br>$$</p>
<h1 id="程序解析"><a href="#程序解析" class="headerlink" title="程序解析"></a>程序解析</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/quadrature_lib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/function.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/logstream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/vector.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/full_matrix.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/sparse_matrix.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/solver_bicgstab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/precondition.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/constraint_matrix.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/grid_generator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/grid_refinement.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria_accessor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria_iterator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_handler.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_accessor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_tools.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/fe/fe_values.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/vector_tools.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/matrix_tools.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/data_out.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/fe/fe_q.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/grid_out.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>以上是之前提过的一些头文件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/work_stream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/multithread_info.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>第一个头文件是WorkStream命名空间，包含并行计算时所用的函数和类。第二个头文件是获得电脑的处理器核数，从而确定并行时开多少线程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/tensor_function.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/error_estimator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>还有一个新头文件是TensorFunction，不同于之前的Function类，它返回的是个张量值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Step9</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> dealii;</span><br></pre></td></tr></table></figure>
<p>然后就开始具体问题的Step9命名空间定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdvectionProblem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">AdvectionProblem</span> ();</span><br><span class="line">        ~<span class="built_in">AdvectionProblem</span> ();</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setup_system</span> <span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>上面开始声明问题类。<br>然后开始组装矩阵：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AssemblyScratchData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">AssemblyScratchData</span> (<span class="keyword">const</span> FiniteElement&lt;dim&gt; &amp;fe);</span><br><span class="line">    <span class="built_in">AssemblyScratchData</span> (<span class="keyword">const</span> AssemblyScratchData &amp;scratch_data);</span><br><span class="line">    FEValues&lt;dim&gt; fe_values;</span><br><span class="line">    FEFaceValues&lt;dim&gt; fe_face_values;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AssemblyCopyData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    FullMatrix&lt;<span class="keyword">double</span>&gt; cell_matrix;</span><br><span class="line">    Vector&lt;<span class="keyword">double</span>&gt; cell_rhs;</span><br><span class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assemble_system</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">local_assemble_system</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator &amp;cell,</span></span></span><br><span class="line"><span class="function"><span class="params">        AssemblyScratchData &amp;scratch,</span></span></span><br><span class="line"><span class="function"><span class="params">        AssemblyCopyData &amp;copy_data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_local_to_global</span> <span class="params">(<span class="keyword">const</span> AssemblyCopyData &amp;copy_data)</span></span>;</span><br></pre></td></tr></table></figure>
<p>组装矩阵时可以很好地应用并行，因为单元矩阵运算可以自己进行，与其他单元无关，只需要在组装时同步就行。其中的ScratchData是临时数据。<br>然后就是之前的一些声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">refine_grid</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_results</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> cycle)</span> <span class="keyword">const</span></span>;</span><br><span class="line">Triangulation&lt;dim&gt; triangulation;</span><br><span class="line">DoFHandler&lt;dim&gt; dof_handler;</span><br><span class="line">FE_Q&lt;dim&gt; fe;</span><br><span class="line">ConstraintMatrix hanging_node_constraints;</span><br><span class="line">SparsityPattern sparsity_pattern;</span><br><span class="line">SparseMatrix&lt;<span class="keyword">double</span>&gt; system_matrix;</span><br><span class="line">Vector&lt;<span class="keyword">double</span>&gt; solution;</span><br><span class="line">Vector&lt;<span class="keyword">double</span>&gt; system_rhs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面就是声明一个对流场的类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdvectionField</span> :</span> <span class="keyword">public</span> TensorFunction&lt;<span class="number">1</span>,dim&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">AdvectionField</span> () : TensorFunction&lt;<span class="number">1</span>,dim&gt; () &#123;&#125;</span><br><span class="line">        virtual Tensor&lt;1,dim&gt; value (const Point&lt;dim&gt; &amp;p) const;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">value_list</span> <span class="params">(<span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt; &gt; &amp;points,</span></span></span><br><span class="line"><span class="function"><span class="params">                std::vector&lt;Tensor&lt;<span class="number">1</span>,dim&gt; &gt; &amp;values)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="built_in">DeclException2</span> (ExcDimensionMismatch,</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>,</span><br><span class="line">                &lt;&lt; <span class="string">&quot;The vector has size &quot;</span> &lt;&lt; arg1 &lt;&lt; <span class="string">&quot; but should have &quot;</span></span><br><span class="line">                &lt;&lt; arg2 &lt;&lt; <span class="string">&quot; elements.&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个类明显是个矢量，因为有对应于空间维度数目的分量。可以像以前一样使用Function类，不过这里使用的是描述张量函数的TensorFunction类。这里面也设置了捕捉异常的函数，用来判断两个矢量的大小是否相同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">Tensor&lt;<span class="number">1</span>,dim&gt;</span><br><span class="line">AdvectionField&lt;dim&gt;::<span class="built_in">value</span> (<span class="keyword">const</span> Point&lt;dim&gt; &amp;p) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Point&lt;dim&gt; value;</span><br><span class="line">    value[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">1</span>; i&lt;dim; ++i)</span><br><span class="line">        value[i] = <span class="number">1</span>+<span class="number">0.8</span>*std::<span class="built_in">sin</span>(<span class="number">8</span>*numbers::PI*p[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">AdvectionField&lt;dim&gt;::<span class="built_in">value_list</span> (<span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt; &gt; &amp;points,</span><br><span class="line">        std::vector&lt;Tensor&lt;<span class="number">1</span>,dim&gt; &gt; &amp;values) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Assert</span> (values.<span class="built_in">size</span>() == points.<span class="built_in">size</span>(),</span><br><span class="line">            <span class="built_in">ExcDimensionMismatch</span> (values.<span class="built_in">size</span>(), points.<span class="built_in">size</span>()));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;points.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        values[i] = AdvectionField&lt;dim&gt;::<span class="built_in">value</span> (points[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是value和value_list的具体实现。第二个函数中有矢量的尺寸大小判断，加上这么一个Assert语句能有效防止错误。<br>下面就是描述源项：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RightHandSide</span> :</span> <span class="keyword">public</span> Function&lt;dim&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">RightHandSide</span> () : Function&lt;dim&gt;() &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">value</span> <span class="params">(<span class="keyword">const</span> Point&lt;dim&gt; &amp;p,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">value_list</span> <span class="params">(<span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt; &gt; &amp;points,</span></span></span><br><span class="line"><span class="function"><span class="params">                std::vector&lt;<span class="keyword">double</span>&gt; &amp;values,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> Point&lt;dim&gt; center_point;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">const</span> Point&lt;<span class="number">1</span>&gt; RightHandSide&lt;<span class="number">1</span>&gt;::center_point = Point&lt;<span class="number">1</span>&gt; (<span class="number">-0.75</span>);</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">const</span> Point&lt;<span class="number">2</span>&gt; RightHandSide&lt;<span class="number">2</span>&gt;::center_point = Point&lt;<span class="number">2</span>&gt; (<span class="number">-0.75</span>, <span class="number">-0.75</span>);</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">const</span> Point&lt;<span class="number">3</span>&gt; RightHandSide&lt;<span class="number">3</span>&gt;::center_point = Point&lt;<span class="number">3</span>&gt; (<span class="number">-0.75</span>, <span class="number">-0.75</span>, <span class="number">-0.75</span>);</span><br></pre></td></tr></table></figure>
<p>从方程中可以看出，源项是围绕在某个源点附近，注意不是原点。这里定义了在不同维度下的源点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">double</span></span><br><span class="line">RightHandSide&lt;dim&gt;::<span class="built_in">value</span> (<span class="keyword">const</span> Point&lt;dim&gt; &amp;p,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Assert</span> (component == <span class="number">0</span>, <span class="built_in">ExcIndexRange</span> (component, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> diameter = <span class="number">0.1</span>;</span><br><span class="line">    <span class="keyword">return</span> ( (p-center_point).<span class="built_in">norm_square</span>() &lt; diameter*diameter ?</span><br><span class="line">            <span class="number">.1</span>/std::<span class="built_in">pow</span>(diameter,dim) :</span><br><span class="line">            <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">RightHandSide&lt;dim&gt;::<span class="built_in">value_list</span> (<span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt; &gt; &amp;points,</span><br><span class="line">        std::vector&lt;<span class="keyword">double</span>&gt; &amp;values,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Assert</span> (values.<span class="built_in">size</span>() == points.<span class="built_in">size</span>(),</span><br><span class="line">            <span class="built_in">ExcDimensionMismatch</span> (values.<span class="built_in">size</span>(), points.<span class="built_in">size</span>()));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;points.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        values[i] = RightHandSide&lt;dim&gt;::<span class="built_in">value</span> (points[i], component);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是具体实现。这里也加入了尺寸判断。<br>然后就是边界值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundaryValues</span> :</span> <span class="keyword">public</span> Function&lt;dim&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">BoundaryValues</span> () : Function&lt;dim&gt;() &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">value</span> <span class="params">(<span class="keyword">const</span> Point&lt;dim&gt; &amp;p,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">value_list</span> <span class="params">(<span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt; &gt; &amp;points,</span></span></span><br><span class="line"><span class="function"><span class="params">                std::vector&lt;<span class="keyword">double</span>&gt; &amp;values,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">double</span></span><br><span class="line">BoundaryValues&lt;dim&gt;::<span class="built_in">value</span> (<span class="keyword">const</span> Point&lt;dim&gt; &amp;p,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Assert</span> (component == <span class="number">0</span>, <span class="built_in">ExcIndexRange</span> (component, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> sine_term = std::<span class="built_in">sin</span>(<span class="number">16</span>*numbers::PI*std::<span class="built_in">sqrt</span>(p.<span class="built_in">norm_square</span>()));</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> weight = std::<span class="built_in">exp</span>(<span class="number">-5</span>*p.<span class="built_in">norm_square</span>()) / std::<span class="built_in">exp</span>(<span class="number">-5.</span>);</span><br><span class="line">    <span class="keyword">return</span> sine_term * weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">BoundaryValues&lt;dim&gt;::<span class="built_in">value_list</span> (<span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt; &gt; &amp;points,</span><br><span class="line">        std::vector&lt;<span class="keyword">double</span>&gt; &amp;values,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Assert</span> (values.<span class="built_in">size</span>() == points.<span class="built_in">size</span>(),</span><br><span class="line">            <span class="built_in">ExcDimensionMismatch</span> (values.<span class="built_in">size</span>(), points.<span class="built_in">size</span>()));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;points.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        values[i] = BoundaryValues&lt;dim&gt;::<span class="built_in">value</span> (points[i], component);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="梯度估计"><a href="#梯度估计" class="headerlink" title="梯度估计"></a>梯度估计</h2><p>下面开始计算单元上的梯度以及网格尺寸的乘方作为权重，就像引子中所示。这个类是DerivativeApproximation的简化版本，DerivativeApproximatio还能计算高阶的导数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GradientEstimation</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">            <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">estimate</span> <span class="params">(<span class="keyword">const</span> DoFHandler&lt;dim&gt; &amp;dof,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> Vector&lt;<span class="keyword">double</span>&gt; &amp;solution,</span></span></span><br><span class="line"><span class="function"><span class="params">                    Vector&lt;<span class="keyword">float</span>&gt; &amp;error_per_cell)</span></span>;</span><br><span class="line">        <span class="built_in">DeclException2</span> (ExcInvalidVectorLength,</span><br><span class="line">                <span class="keyword">int</span>, <span class="keyword">int</span>,</span><br><span class="line">                &lt;&lt; <span class="string">&quot;Vector has length &quot;</span> &lt;&lt; arg1 &lt;&lt; <span class="string">&quot;, but should have &quot;</span></span><br><span class="line">                &lt;&lt; arg2);</span><br><span class="line">        <span class="built_in">DeclException0</span> (ExcInsufficientDirections);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">EstimateScratchData</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                <span class="built_in">EstimateScratchData</span> (<span class="keyword">const</span> FiniteElement&lt;dim&gt; &amp;fe,</span><br><span class="line">                        <span class="keyword">const</span> Vector&lt;<span class="keyword">double</span>&gt; &amp;solution);</span><br><span class="line">                <span class="built_in">EstimateScratchData</span> (<span class="keyword">const</span> EstimateScratchData &amp;data);</span><br><span class="line">                FEValues&lt;dim&gt; fe_midpoint_value;</span><br><span class="line">                Vector&lt;<span class="keyword">double</span>&gt; solution;</span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">EstimateCopyData</span></span></span><br><span class="line"><span class="class">        &#123;</span>&#125;;</span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">            <span class="keyword">static</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">estimate_cell</span> <span class="params">(<span class="keyword">const</span> SynchronousIterators&lt;std_cxx11::tuple&lt;<span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator,</span></span></span><br><span class="line"><span class="function"><span class="params">                    Vector&lt;<span class="keyword">float</span>&gt;::iterator&gt; &gt; &amp;cell,</span></span></span><br><span class="line"><span class="function"><span class="params">                    EstimateScratchData&lt;dim&gt; &amp;scratch_data,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> EstimateCopyData &amp;copy_data)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个类有一个静态Public函数estimate来计算误差指示子，还有几个Private函数来做具体的工作。还有两个异常捕获函数，用来捕捉没有相邻单元的单元以及尺寸不对的参数。<br>还有两个事情需要注意：一是该类没有非静态的成员函数或变量，所以它不是一个真正的类，而是命名空间的功能。这里选择类而不是命名空间是因为想要声明私有函数。这也可以同样使用命名空间来实现，但这涉及多文件，这里只有一个文件，所以在此例中不能隐藏函数。二是维度参数没有放在类中，而是放在了函数上，这样不用手动加上维度这个参数，而是编译器能够从DoF等上自动推导。<br>还要讲一下并行策略：之前主类中已经说了，并行时需要定义：一是定义临时和复制对象；二是在单元上进行局部计算；三是将局部对象复制到整体对象中的函数。但是这里做一点改变。具体改变见帮助文档。</p>
<h2 id="主类的实现"><a href="#主类的实现" class="headerlink" title="主类的实现"></a>主类的实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">AdvectionProblem&lt;dim&gt;::<span class="built_in">AdvectionProblem</span> ()</span><br><span class="line">    :</span><br><span class="line">        <span class="built_in">dof_handler</span> (triangulation),</span><br><span class="line">        <span class="built_in">fe</span>(<span class="number">1</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">AdvectionProblem&lt;dim&gt;::~<span class="built_in">AdvectionProblem</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    dof_handler.<span class="built_in">clear</span> ();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> AdvectionProblem&lt;dim&gt;::<span class="built_in">setup_system</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    dof_handler.<span class="built_in">distribute_dofs</span> (fe);</span><br><span class="line">    hanging_node_constraints.<span class="built_in">clear</span> ();</span><br><span class="line">    DoFTools::<span class="built_in">make_hanging_node_constraints</span> (dof_handler,</span><br><span class="line">            hanging_node_constraints);</span><br><span class="line">    hanging_node_constraints.<span class="built_in">close</span> ();</span><br><span class="line">    <span class="function">DynamicSparsityPattern <span class="title">dsp</span><span class="params">(dof_handler.n_dofs(), dof_handler.n_dofs())</span></span>;</span><br><span class="line">    DoFTools::<span class="built_in">make_sparsity_pattern</span>(dof_handler,</span><br><span class="line">            dsp,</span><br><span class="line">            hanging_node_constraints,</span><br><span class="line">            / *keep_constrained_dofs = * / <span class="literal">true</span>);</span><br><span class="line">    sparsity_pattern.<span class="built_in">copy_from</span> (dsp);</span><br><span class="line">    system_matrix.<span class="built_in">reinit</span> (sparsity_pattern);</span><br><span class="line">    solution.<span class="built_in">reinit</span> (dof_handler.<span class="built_in">n_dofs</span>());</span><br><span class="line">    system_rhs.<span class="built_in">reinit</span> (dof_handler.<span class="built_in">n_dofs</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是主类的构造函数、析构函数和建立系统，不详述。<br>下面是组装系统的并行策略：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> AdvectionProblem&lt;dim&gt;::<span class="built_in">assemble_system</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    WorkStream::<span class="built_in">run</span>(dof_handler.<span class="built_in">begin_active</span>(),</span><br><span class="line">            dof_handler.<span class="built_in">end</span>(),</span><br><span class="line">            *<span class="keyword">this</span>,</span><br><span class="line">            &amp;AdvectionProblem::local_assemble_system,</span><br><span class="line">            &amp;AdvectionProblem::copy_local_to_global,</span><br><span class="line">            <span class="built_in">AssemblyScratchData</span>(fe),</span><br><span class="line">            <span class="built_in">AssemblyCopyData</span>());</span><br></pre></td></tr></table></figure>
<p>使用WorkStream来统一调度，能充分利用电脑的线程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hanging_node_constraints.<span class="built_in">condense</span> (system_matrix);</span><br><span class="line">hanging_node_constraints.<span class="built_in">condense</span> (system_rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样也需要消除悬点限制。因为不能分开在单个线程上进行，所以需要统一进行。<br>Attention！！跟之前不同，这里没有施加边界条件，当然这是因为已经把边界条件加在了弱形式中。！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">AdvectionProblem&lt;dim&gt;::AssemblyScratchData::</span><br><span class="line"><span class="built_in">AssemblyScratchData</span> (<span class="keyword">const</span> FiniteElement&lt;dim&gt; &amp;fe)</span><br><span class="line">    :</span><br><span class="line">        <span class="built_in">fe_values</span> (fe,</span><br><span class="line">                QGauss&lt;dim&gt;(<span class="number">2</span>),</span><br><span class="line">                update_values | update_gradients |</span><br><span class="line">                update_quadrature_points | update_JxW_values),</span><br><span class="line">        <span class="built_in">fe_face_values</span> (fe,</span><br><span class="line">                QGauss&lt;dim<span class="number">-1</span>&gt;(<span class="number">2</span>),</span><br><span class="line">                update_values | update_quadrature_points |</span><br><span class="line">                update_JxW_values | update_normal_vectors)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">AdvectionProblem&lt;dim&gt;::AssemblyScratchData::</span><br><span class="line"><span class="built_in">AssemblyScratchData</span> (<span class="keyword">const</span> AssemblyScratchData &amp;scratch_data)</span><br><span class="line">    :</span><br><span class="line">        <span class="built_in">fe_values</span> (scratch_data.fe_values.<span class="built_in">get_fe</span>(),</span><br><span class="line">                scratch_data.fe_values.<span class="built_in">get_quadrature</span>(),</span><br><span class="line">                update_values | update_gradients |</span><br><span class="line">                update_quadrature_points | update_JxW_values),</span><br><span class="line">        <span class="built_in">fe_face_values</span> (scratch_data.fe_face_values.<span class="built_in">get_fe</span>(),</span><br><span class="line">                scratch_data.fe_face_values.<span class="built_in">get_quadrature</span>(),</span><br><span class="line">                update_values | update_quadrature_points |</span><br><span class="line">                update_JxW_values | update_normal_vectors)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这是并行时用到的临时对象。这些对象包含FEValues和FEFaceValues，其中的flag一定要传递全面。<br>下面就是具体要干的事了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">AdvectionProblem&lt;dim&gt;::</span><br><span class="line"><span class="built_in">local_assemble_system</span> (<span class="keyword">const</span> <span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator &amp;cell,</span><br><span class="line">        AssemblyScratchData &amp;scratch_data,</span><br><span class="line">        AssemblyCopyData &amp;copy_data)</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>帮助文档中关于这里有一大段关于效率的问题，没看明白，留坑待填。<br>首先创建描述边界值、右端项和对流场的对象，这里声明为const，以便让编译器进行优化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AdvectionField&lt;dim&gt; advection_field;</span><br><span class="line"><span class="keyword">const</span> RightHandSide&lt;dim&gt; right_hand_side;</span><br><span class="line"><span class="keyword">const</span> BoundaryValues&lt;dim&gt; boundary_values;</span><br></pre></td></tr></table></figure>
<p>然后定义一些缩写，防止冗长的描述：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> dofs_per_cell = fe.dofs_per_cell;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> n_q_points = scratch_data.fe_values.<span class="built_in">get_quadrature</span>().<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> n_face_q_points = scratch_data.fe_face_values.<span class="built_in">get_quadrature</span>().<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>
<p>初始化单元刚度矩阵和单元右端项和单元自由度的全局标识：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">copy_data.cell_matrix.<span class="built_in">reinit</span> (dofs_per_cell, dofs_per_cell);</span><br><span class="line">copy_data.cell_rhs.<span class="built_in">reinit</span> (dofs_per_cell);</span><br><span class="line">copy_data.local_dof_indices.<span class="built_in">resize</span>(dofs_per_cell);</span><br></pre></td></tr></table></figure>
<p>还有创建对象来存储单元和边界积分中要用到的右端项、对流方向和边界的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="keyword">double</span>&gt; <span class="title">rhs_values</span> <span class="params">(n_q_points)</span></span>;</span><br><span class="line">std::vector&lt;Tensor&lt;1,dim&gt; &gt; <span class="built_in">advection_directions</span> (n_q_points);</span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">double</span>&gt; <span class="title">face_boundary_values</span> <span class="params">(n_face_q_points)</span></span>;</span><br><span class="line">std::vector&lt;Tensor&lt;1,dim&gt; &gt; <span class="built_in">face_advection_directions</span> (n_face_q_points);</span><br></pre></td></tr></table></figure>
<p>初始化FEValues对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scratch_data.fe_values.<span class="built_in">reinit</span> (cell);</span><br></pre></td></tr></table></figure>
<p>得到积分点上右端项和对流方向的值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">advection_field.<span class="built_in">value_list</span> (scratch_data.fe_values.<span class="built_in">get_quadrature_points</span>(),</span><br><span class="line">        advection_directions);</span><br><span class="line">right_hand_side.<span class="built_in">value_list</span> (scratch_data.fe_values.<span class="built_in">get_quadrature_points</span>(),</span><br><span class="line">        rhs_values);</span><br></pre></td></tr></table></figure>
<p>设置流线扩散法中参数的值，参见引子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> delta = <span class="number">0.1</span> * cell-&gt;<span class="built_in">diameter</span> ();</span><br></pre></td></tr></table></figure>
<p>然后计算单元刚度矩阵和右端项：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> q_point=<span class="number">0</span>; q_point&lt;n_q_points; ++q_point)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dofs_per_cell; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j=<span class="number">0</span>; j&lt;dofs_per_cell; ++j)</span><br><span class="line">            copy_data.<span class="built_in">cell_matrix</span>(i,j) += ((advection_directions[q_point] *</span><br><span class="line">                        scratch_data.fe_values.<span class="built_in">shape_grad</span>(j,q_point) *</span><br><span class="line">                        (scratch_data.fe_values.<span class="built_in">shape_value</span>(i,q_point) +</span><br><span class="line">                         delta *</span><br><span class="line">                         (advection_directions[q_point] *</span><br><span class="line">                          scratch_data.fe_values.<span class="built_in">shape_grad</span>(i,q_point)))) *</span><br><span class="line">                    scratch_data.fe_values.<span class="built_in">JxW</span>(q_point));</span><br><span class="line">        copy_data.<span class="built_in">cell_rhs</span>(i) += ((scratch_data.fe_values.<span class="built_in">shape_value</span>(i,q_point) +</span><br><span class="line">                    delta *</span><br><span class="line">                    (advection_directions[q_point] *</span><br><span class="line">                     scratch_data.fe_values.<span class="built_in">shape_grad</span>(i,q_point)) ) *</span><br><span class="line">                rhs_values[q_point] *</span><br><span class="line">                scratch_data.fe_values.<span class="built_in">JxW</span> (q_point));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Attention！！上面项中没有加入边界项。所以还要检查这个单元的边是否在入流边界上，如果是，那么必须把它的贡献也得叠加上去。注意仅仅是入流边界，所以还得知道积分点的绝对位置，及该点上的流动方向：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> face=<span class="number">0</span>; face&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face)</span><br><span class="line">    <span class="keyword">if</span> (cell-&gt;<span class="built_in">face</span>(face)-&gt;<span class="built_in">at_boundary</span>())</span><br><span class="line">    &#123;</span><br></pre></td></tr></table></figure>
<p>如果进入了上面的if，说明该单元的边是在边界上了，然而别忘了初始化FEFaceValues对象，然后获取入流函数的值和流动方向：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scratch_data.fe_face_values.<span class="built_in">reinit</span> (cell, face);</span><br><span class="line">boundary_values.<span class="built_in">value_list</span> (scratch_data.fe_face_values.<span class="built_in">get_quadrature_points</span>(),</span><br><span class="line">        face_boundary_values);</span><br><span class="line">advection_field.<span class="built_in">value_list</span> (scratch_data.fe_face_values.<span class="built_in">get_quadrature_points</span>(),</span><br><span class="line">        face_advection_directions);</span><br></pre></td></tr></table></figure>
<p>现在遍历所有积分点，判断是否入流边界：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> q_point=<span class="number">0</span>; q_point&lt;n_face_q_points; ++q_point)</span><br><span class="line">    <span class="keyword">if</span> (scratch_data.fe_face_values.<span class="built_in">normal_vector</span>(q_point) *</span><br><span class="line">            face_advection_directions[q_point]</span><br><span class="line">            &lt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>如果是入流边界，那么就计算这个边的贡献：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dofs_per_cell; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j=<span class="number">0</span>; j&lt;dofs_per_cell; ++j)</span><br><span class="line">        copy_data.<span class="built_in">cell_matrix</span>(i,j) -= (face_advection_directions[q_point] *</span><br><span class="line">                scratch_data.fe_face_values.<span class="built_in">normal_vector</span>(q_point) *</span><br><span class="line">                scratch_data.fe_face_values.<span class="built_in">shape_value</span>(i,q_point) *</span><br><span class="line">                scratch_data.fe_face_values.<span class="built_in">shape_value</span>(j,q_point) *</span><br><span class="line">                scratch_data.fe_face_values.<span class="built_in">JxW</span>(q_point));</span><br><span class="line">    copy_data.<span class="built_in">cell_rhs</span>(i) -= (face_advection_directions[q_point] *</span><br><span class="line">            scratch_data.fe_face_values.<span class="built_in">normal_vector</span>(q_point) *</span><br><span class="line">            face_boundary_values[q_point] *</span><br><span class="line">            scratch_data.fe_face_values.<span class="built_in">shape_value</span>(i,q_point) *</span><br><span class="line">            scratch_data.fe_face_values.<span class="built_in">JxW</span>(q_point));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终于到组装了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cell-&gt;<span class="built_in">get_dof_indices</span> (copy_data.local_dof_indices);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">AdvectionProblem&lt;dim&gt;::<span class="built_in">copy_local_to_global</span> (<span class="keyword">const</span> AssemblyCopyData &amp;copy_data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;copy_data.local_dof_indices.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j=<span class="number">0</span>; j&lt;copy_data.local_dof_indices.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            system_matrix.<span class="built_in">add</span> (copy_data.local_dof_indices[i],</span><br><span class="line">                    copy_data.local_dof_indices[j],</span><br><span class="line">                    copy_data.<span class="built_in">cell_matrix</span>(i,j));</span><br><span class="line">        <span class="built_in">system_rhs</span>(copy_data.local_dof_indices[i]) += copy_data.<span class="built_in">cell_rhs</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟之前的差不多。<br>然后就是求解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> AdvectionProblem&lt;dim&gt;::<span class="built_in">solve</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">SolverControl <span class="title">solver_control</span> <span class="params">(<span class="number">1000</span>, <span class="number">1e-12</span>)</span></span>;</span><br><span class="line">    SolverBicgstab&lt;&gt; <span class="built_in">bicgstab</span> (solver_control);</span><br><span class="line">    PreconditionJacobi&lt;&gt; preconditioner;</span><br><span class="line">    preconditioner.<span class="built_in">initialize</span>(system_matrix, <span class="number">1.0</span>);</span><br><span class="line">    bicgstab.<span class="built_in">solve</span> (system_matrix, solution, system_rhs,</span><br><span class="line">            preconditioner);</span><br><span class="line">    hanging_node_constraints.<span class="built_in">distribute</span> (solution);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为方程不再对称，所以使用了BICGStab算法。<br>然后就是细化网格：<br>template <int dim><br>void AdvectionProblem<dim>::refine_grid ()<br>{<br>    Vector<float> estimated_error_per_cell (triangulation.n_active_cells());<br>    GradientEstimation::estimate (dof_handler,<br>            solution,<br>            estimated_error_per_cell);<br>    GridRefinement::refine_and_coarsen_fixed_number (triangulation,<br>            estimated_error_per_cell,<br>            0.5, 0.03);<br>    triangulation.execute_coarsening_and_refinement ();<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">然后输出：</span><br><span class="line">&#96;&#96;&#96;cpp</span><br><span class="line">template &lt;int dim&gt;</span><br><span class="line">void AdvectionProblem&lt;dim&gt;::output_results (const unsigned int cycle) const</span><br><span class="line">&#123;</span><br><span class="line">    std::string filename &#x3D; &quot;grid-&quot;;</span><br><span class="line">    filename +&#x3D; (&#39;0&#39; + cycle);</span><br><span class="line">    Assert (cycle &lt; 10, ExcInternalError());</span><br><span class="line">    filename +&#x3D; &quot;.eps&quot;;</span><br><span class="line">    std::ofstream output (filename.c_str());</span><br><span class="line">    GridOut grid_out;</span><br><span class="line">    grid_out.write_eps (triangulation, output);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> AdvectionProblem&lt;dim&gt;::<span class="built_in">run</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> cycle=<span class="number">0</span>; cycle&lt;<span class="number">6</span>; ++cycle)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="string">&#x27;:&#x27;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (cycle == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GridGenerator::<span class="built_in">hyper_cube</span> (triangulation, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">            triangulation.<span class="built_in">refine_global</span> (<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">refine_grid</span> ();</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; Number of active cells: &quot;</span></span><br><span class="line">            &lt;&lt; triangulation.<span class="built_in">n_active_cells</span>()</span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">setup_system</span> ();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; Number of degrees of freedom: &quot;</span></span><br><span class="line">            &lt;&lt; dof_handler.<span class="built_in">n_dofs</span>()</span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">assemble_system</span> ();</span><br><span class="line">        <span class="built_in">solve</span> ();</span><br><span class="line">        <span class="built_in">output_results</span> (cycle);</span><br><span class="line">    &#125;</span><br><span class="line">    DataOut&lt;dim&gt; data_out;</span><br><span class="line">    data_out.<span class="built_in">attach_dof_handler</span> (dof_handler);</span><br><span class="line">    data_out.<span class="built_in">add_data_vector</span> (solution, <span class="string">&quot;solution&quot;</span>);</span><br><span class="line">    data_out.<span class="built_in">build_patches</span> ();</span><br><span class="line">    <span class="function">std::ofstream <span class="title">output</span> <span class="params">(<span class="string">&quot;final-solution.vtk&quot;</span>)</span></span>;</span><br><span class="line">    data_out.<span class="built_in">write_vtk</span> (output);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="梯度估计类的实现"><a href="#梯度估计类的实现" class="headerlink" title="梯度估计类的实现"></a>梯度估计类的实现</h2><p>先是构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">GradientEstimation::EstimateScratchData&lt;dim&gt;::</span><br><span class="line"><span class="built_in">EstimateScratchData</span> (<span class="keyword">const</span> FiniteElement&lt;dim&gt; &amp;fe,</span><br><span class="line">        <span class="keyword">const</span> Vector&lt;<span class="keyword">double</span>&gt; &amp;solution)</span><br><span class="line">    :</span><br><span class="line">        <span class="built_in">fe_midpoint_value</span>(fe,</span><br><span class="line">                QMidpoint&lt;dim&gt; (),</span><br><span class="line">                update_values | update_quadrature_points),</span><br><span class="line">        <span class="built_in">solution</span>(solution)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">GradientEstimation::EstimateScratchData&lt;dim&gt;::</span><br><span class="line"><span class="built_in">EstimateScratchData</span>(<span class="keyword">const</span> EstimateScratchData &amp;scratch_data)</span><br><span class="line">    :</span><br><span class="line">        <span class="built_in">fe_midpoint_value</span>(scratch_data.fe_midpoint_value.<span class="built_in">get_fe</span>(),</span><br><span class="line">                scratch_data.fe_midpoint_value.<span class="built_in">get_quadrature</span>(),</span><br><span class="line">                update_values | update_quadrature_points),</span><br><span class="line">        <span class="built_in">solution</span>(scratch_data.solution)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是estimate成员函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">GradientEstimation::<span class="built_in">estimate</span> (<span class="keyword">const</span> DoFHandler&lt;dim&gt; &amp;dof_handler,</span><br><span class="line">        <span class="keyword">const</span> Vector&lt;<span class="keyword">double</span>&gt; &amp;solution,</span><br><span class="line">        Vector&lt;<span class="keyword">float</span>&gt; &amp;error_per_cell)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Assert</span> (error_per_cell.<span class="built_in">size</span>() == dof_handler.<span class="built_in">get_triangulation</span>().<span class="built_in">n_active_cells</span>(),</span><br><span class="line">            <span class="built_in">ExcInvalidVectorLength</span> (error_per_cell.<span class="built_in">size</span>(),</span><br><span class="line">                dof_handler.<span class="built_in">get_triangulation</span>().<span class="built_in">n_active_cells</span>()));</span><br><span class="line">    <span class="keyword">typedef</span> std_cxx11::tuple&lt;<span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator,Vector&lt;<span class="keyword">float</span>&gt;::iterator&gt;</span><br><span class="line">        IteratorTuple;</span><br><span class="line">    SynchronousIterators&lt;IteratorTuple&gt;</span><br><span class="line">        <span class="built_in">begin_sync_it</span> (<span class="built_in">IteratorTuple</span> (dof_handler.<span class="built_in">begin_active</span>(),</span><br><span class="line">                    error_per_cell.<span class="built_in">begin</span>())),</span><br><span class="line">                      <span class="built_in">end_sync_it</span> (<span class="built_in">IteratorTuple</span> (dof_handler.<span class="built_in">end</span>(),</span><br><span class="line">                                  error_per_cell.<span class="built_in">end</span>()));</span><br><span class="line">    WorkStream::<span class="built_in">run</span> (begin_sync_it,</span><br><span class="line">            end_sync_it,</span><br><span class="line">            &amp;GradientEstimation::<span class="keyword">template</span> estimate_cell&lt;dim&gt;,</span><br><span class="line">            std_cxx11::function&lt;<span class="built_in"><span class="keyword">void</span></span> (<span class="keyword">const</span> EstimateCopyData &amp;)&gt; (),</span><br><span class="line">            EstimateScratchData&lt;dim&gt; (dof_handler.<span class="built_in">get_fe</span>(),</span><br><span class="line">                solution),</span><br><span class="line">            <span class="built_in">EstimateCopyData</span> ());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里也检查了矢量的尺寸是否正确，避免不易发现的错误。然后还设置了一些迭代器，没看明白。。<br>Attention！！然后计算梯度的有限差分近似：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std_cxx11::function&lt;<span class="built_in"><span class="keyword">void</span></span> (<span class="keyword">const</span> SynchronousIterators&lt;IteratorTuple&gt; &amp;,</span><br><span class="line">        EstimateScratchData&lt;dim&gt; &amp;,</span><br><span class="line">        EstimateCopyData &amp;)&gt;</span><br><span class="line">(std_cxx11::<span class="built_in">bind</span> (&amp;GradientEstimation::<span class="keyword">template</span> estimate_cell&lt;dim&gt;,</span><br><span class="line">                  std_cxx11::_1,</span><br><span class="line">                  std_cxx11::_2))</span><br></pre></td></tr></table></figure>
<p>整体思路是：首先计算当前单元的活跃邻居的列表，然后计算这些邻居单元上的量，参见引子。注意这里是活跃邻居单元，保证是在同一层级或更粗一级上。如果不活跃，还得看它的child。<br>具体为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">GradientEstimation::<span class="built_in">estimate</span> (<span class="keyword">const</span> DoFHandler&lt;dim&gt; &amp;dof_handler,</span><br><span class="line">        <span class="keyword">const</span> Vector&lt;<span class="keyword">double</span>&gt; &amp;solution,</span><br><span class="line">        Vector&lt;<span class="keyword">float</span>&gt; &amp;error_per_cell)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Assert</span> (error_per_cell.<span class="built_in">size</span>() == dof_handler.<span class="built_in">get_triangulation</span>().<span class="built_in">n_active_cells</span>(),</span><br><span class="line">            <span class="built_in">ExcInvalidVectorLength</span> (error_per_cell.<span class="built_in">size</span>(),</span><br><span class="line">                dof_handler.<span class="built_in">get_triangulation</span>().<span class="built_in">n_active_cells</span>()));</span><br><span class="line">    <span class="keyword">typedef</span> std_cxx11::tuple&lt;<span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator,Vector&lt;<span class="keyword">float</span>&gt;::iterator&gt;</span><br><span class="line">        IteratorTuple;</span><br><span class="line">    SynchronousIterators&lt;IteratorTuple&gt;</span><br><span class="line">        <span class="built_in">begin_sync_it</span> (<span class="built_in">IteratorTuple</span> (dof_handler.<span class="built_in">begin_active</span>(),</span><br><span class="line">                    error_per_cell.<span class="built_in">begin</span>())),</span><br><span class="line">                      <span class="built_in">end_sync_it</span> (<span class="built_in">IteratorTuple</span> (dof_handler.<span class="built_in">end</span>(),</span><br><span class="line">                                  error_per_cell.<span class="built_in">end</span>()));</span><br><span class="line">    WorkStream::<span class="built_in">run</span> (begin_sync_it,</span><br><span class="line">            end_sync_it,</span><br><span class="line">            &amp;GradientEstimation::<span class="keyword">template</span> estimate_cell&lt;dim&gt;,</span><br><span class="line">            std_cxx11::function&lt;<span class="built_in"><span class="keyword">void</span></span> (<span class="keyword">const</span> EstimateCopyData &amp;)&gt; (),</span><br><span class="line">            EstimateScratchData&lt;dim&gt; (dof_handler.<span class="built_in">get_fe</span>(),</span><br><span class="line">                solution),</span><br><span class="line">            <span class="built_in">EstimateCopyData</span> ());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">GradientEstimation::<span class="built_in">estimate_cell</span> (<span class="keyword">const</span> SynchronousIterators&lt;std_cxx11::tuple&lt;<span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator,</span><br><span class="line">        Vector&lt;<span class="keyword">float</span>&gt;::iterator&gt; &gt; &amp;cell,</span><br><span class="line">        EstimateScratchData&lt;dim&gt; &amp;scratch_data,</span><br><span class="line">        <span class="keyword">const</span> EstimateCopyData &amp;)</span><br><span class="line">&#123;</span><br><span class="line">    Tensor&lt;<span class="number">2</span>,dim&gt; Y;</span><br><span class="line">    std::vector&lt;<span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator&gt; active_neighbors;</span><br><span class="line">    active_neighbors.<span class="built_in">reserve</span> (GeometryInfo&lt;dim&gt;::faces_per_cell *</span><br><span class="line">            GeometryInfo&lt;dim&gt;::max_children_per_face);</span><br><span class="line">    <span class="keyword">typename</span> DoFHandler&lt;dim&gt;::<span class="function">active_cell_iterator <span class="title">cell_it</span><span class="params">(std_cxx11::get&lt;<span class="number">0</span>&gt;(cell.iterators))</span></span>;</span><br><span class="line">    scratch_data.fe_midpoint_value.<span class="built_in">reinit</span> (cell_it);</span><br><span class="line">    Tensor&lt;<span class="number">1</span>,dim&gt; projected_gradient;</span><br><span class="line">    active_neighbors.<span class="built_in">clear</span> ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> face_no=<span class="number">0</span>; face_no&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face_no)</span><br><span class="line">        <span class="keyword">if</span> (! std_cxx11::get&lt;<span class="number">0</span>&gt;(cell.iterators)-&gt;<span class="built_in">at_boundary</span>(face_no))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">typename</span> DoFHandler&lt;dim&gt;::face_iterator</span><br><span class="line">                face = std_cxx11::get&lt;<span class="number">0</span>&gt;(cell.iterators)-&gt;<span class="built_in">face</span>(face_no);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">typename</span> DoFHandler&lt;dim&gt;::cell_iterator</span><br><span class="line">                neighbor = std_cxx11::get&lt;<span class="number">0</span>&gt;(cell.iterators)-&gt;<span class="built_in">neighbor</span>(face_no);</span><br><span class="line">            <span class="keyword">if</span> (neighbor-&gt;<span class="built_in">active</span>())</span><br><span class="line">                active_neighbors.<span class="built_in">push_back</span> (neighbor);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (dim == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">typename</span> DoFHandler&lt;dim&gt;::cell_iterator</span><br><span class="line">                        neighbor_child = neighbor;</span><br><span class="line">                    <span class="keyword">while</span> (neighbor_child-&gt;<span class="built_in">has_children</span>())</span><br><span class="line">                        neighbor_child = neighbor_child-&gt;<span class="built_in">child</span> (face_no==<span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">                    <span class="built_in">Assert</span> (neighbor_child-&gt;<span class="built_in">neighbor</span>(face_no==<span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>)</span><br><span class="line">                            ==std_cxx11::get&lt;<span class="number">0</span>&gt;(cell.iterators),<span class="built_in">ExcInternalError</span>());</span><br><span class="line">                    active_neighbors.<span class="built_in">push_back</span> (neighbor_child);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> subface_no=<span class="number">0</span>; subface_no&lt;face-&gt;<span class="built_in">n_children</span>(); ++subface_no)</span><br><span class="line">                        active_neighbors.<span class="built_in">push_back</span> (</span><br><span class="line">                                std_cxx11::get&lt;<span class="number">0</span>&gt;(cell.iterators)-&gt;<span class="built_in">neighbor_child_on_subface</span>(face_no,subface_no));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">const</span> Point&lt;dim&gt; this_center = scratch_data.fe_midpoint_value.<span class="built_in">quadrature_point</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">double</span>&gt; <span class="title">this_midpoint_value</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    scratch_data.fe_midpoint_value.<span class="built_in">get_function_values</span> (scratch_data.solution, this_midpoint_value);</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">double</span>&gt; <span class="title">neighbor_midpoint_value</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">typename</span> std::vector&lt;<span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator&gt;::const_iterator</span><br><span class="line">        neighbor_ptr = active_neighbors.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (; neighbor_ptr!=active_neighbors.<span class="built_in">end</span>(); ++neighbor_ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator</span><br><span class="line">            neighbor = *neighbor_ptr;</span><br><span class="line">        scratch_data.fe_midpoint_value.<span class="built_in">reinit</span> (neighbor);</span><br><span class="line">        <span class="keyword">const</span> Point&lt;dim&gt; neighbor_center = scratch_data.fe_midpoint_value.<span class="built_in">quadrature_point</span>(<span class="number">0</span>);</span><br><span class="line">        scratch_data.fe_midpoint_value.<span class="built_in">get_function_values</span> (scratch_data.solution,</span><br><span class="line">                neighbor_midpoint_value);</span><br><span class="line">        Tensor&lt;<span class="number">1</span>,dim&gt; y = neighbor_center - this_center;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">double</span> distance = y.<span class="built_in">norm</span>();</span><br><span class="line">        y /= distance;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dim; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j=<span class="number">0</span>; j&lt;dim; ++j)</span><br><span class="line">                Y[i][j] += y[i] * y[j];</span><br><span class="line">        projected_gradient += (neighbor_midpoint_value[<span class="number">0</span>] -</span><br><span class="line">                this_midpoint_value[<span class="number">0</span>]) /</span><br><span class="line">            distance *</span><br><span class="line">            y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">AssertThrow</span> (<span class="built_in">determinant</span>(Y) != <span class="number">0</span>,</span><br><span class="line">            <span class="built_in">ExcInsufficientDirections</span>());</span><br><span class="line">    <span class="keyword">const</span> Tensor&lt;<span class="number">2</span>,dim&gt; Y_inverse = <span class="built_in">invert</span>(Y);</span><br><span class="line">    Tensor&lt;<span class="number">1</span>,dim&gt; gradient = Y_inverse * projected_gradient;</span><br><span class="line">    *(std_cxx11::get&lt;<span class="number">1</span>&gt;(cell.iterators)) = (std::<span class="built_in">pow</span>(std_cxx11::get&lt;<span class="number">0</span>&gt;(cell.iterators)-&gt;<span class="built_in">diameter</span>(),</span><br><span class="line">                <span class="number">1</span>+<span class="number">1.0</span>*dim/<span class="number">2</span>) *</span><br><span class="line">            std::<span class="built_in">sqrt</span>(gradient.<span class="built_in">norm_square</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>细节见帮助文档。简要说一下其中的几个特点：一是能判断单元是否活跃；二是能得到单元的子单元，甚至是它的左边子单元还是右边；三是能得到单元的中点上的函数值。<br>然后是main函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        ::MultithreadInfo::<span class="built_in">set_thread_limit</span>();</span><br><span class="line">        Step9::AdvectionProblem&lt;<span class="number">2</span>&gt; advection_problem_2d;</span><br><span class="line">        advection_problem_2d.<span class="built_in">run</span> ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (std::exception &amp;exc)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; exc.<span class="built_in">what</span>() &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟之前差不多，区别是使用MultithreadInfo来限制线程最大数目。</p>
<h1 id="计算结果"><a href="#计算结果" class="headerlink" title="计算结果"></a>计算结果</h1><p>自适应网格是：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjk098ejhj30mb0m0aii.jpg"><br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjk0jwpe3j30qx0k5wkl.jpg"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2016/09/06/dealii-learn-step8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Be interesting!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亓欣波">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/09/06/dealii-learn-step8/" class="post-title-link" itemprop="url">求解偏微分方程开源有限元软件deal.II学习--Step 8</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-09-06 00:00:00" itemprop="dateCreated datePublished" datetime="2016-09-06T00:00:00+08:00">2016-09-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 15:20:30" itemprop="dateModified" datetime="2021-03-25T15:20:30+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computational-material-science/" itemprop="url" rel="index"><span itemprop="name">computational material science</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2016/09/06/dealii-learn-step8/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/09/06/dealii-learn-step8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>真实生活中，大多数的偏微分方程都是一组方程，相应地，解也通常是矢量场。跟之前单方程的求解以及解是标量场相比，这种问题只是在组装矩阵和右端项时有些复杂，其他都一样。<br>本例中求解的是弹性问题：<br>$$<br>-\partial_j (c_{ijkl} \partial_k u_l) = f_i, \qquad i=1 \ldots d<br>$$<br>其中，$c_{ijkl}$是刚度系数，通常与空间坐标相关。<br>弹性方程是Laplace方程的一种扩散形式，其解$u_l$是矢量场，表示一个刚体在力的作用下的位移。力$f_i$也是矢量场。<br>$c_{ijkl}$是一个四阶张量，共有$3^4=81$个分量，但其实只有21个分量是独立的，这是因为：<br>首先因为$\sigma_{ij}$和$\epsilon_{ij}$都是对称张量，导致$c_{ijkl}=c_{jikl}$和$c_{ijkl}=c_{ijlk}$，这样就将独立的弹性常数减少到$(3*2*1)^2=36$个。<br>然后因为应变能密度函数与应力应变的关系，导致$c_{ijkl}=c_{klij}$，这样代表沿对角线对称，这样将弹性常数减少到21个。<br>这样三维情形下应力应变关系矩阵形式为：<br>$$<br>\begin{bmatrix}<br>\sigma_{11} \<br>\sigma_{22} \<br>\sigma_{33} \<br>\sigma_{12} \<br>\sigma_{23} \<br>\sigma_{31}<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>c_{1111} &amp; c_{1122} &amp; c_{1133} &amp; c_{1112} &amp; c_{1123} &amp; c_{1131} \<br>          &amp; c_{2222} &amp; c_{2233} &amp; c_{2212} &amp; c_{2223} &amp; c_{2231} \<br>          &amp;           &amp; c_{3333} &amp; c_{3312} &amp; c_{3323} &amp; c_{3331} \<br>          &amp;           &amp;           &amp; c_{1212} &amp; c_{1223} &amp; c_{1231} \<br>          &amp;           &amp;           &amp;           &amp; c_{2323} &amp; c_{2331} \<br>          &amp;           &amp;           &amp;           &amp;           &amp; c_{3131} \<br>\end{bmatrix}<br>\begin{bmatrix}<br>\epsilon_{11} \<br>\epsilon_{22} \<br>\epsilon_{33} \<br>2\epsilon_{12} \<br>2\epsilon_{23} \<br>2\epsilon_{31} \<br>\end{bmatrix}<br>$$</p>
<p>在各向同性材料中，通过引入两个系数，系数张量变成(可以通过理论证明，各向同性的均匀弹性体的弹性常数只有两个)：<br>$$<br>c_{ijkl} = \lambda \delta_{ij} \delta_{kl} + \mu (\delta_{ik} \delta_{jl} + \delta_{il} \delta_{jk}).<br>$$<br>比如，当$i=j=k=l=1$时：<br>$$<br>c_{1111} = \lambda + 2\mu<br>$$<br>当$i=j=k=1,l=2$时，<br>$$<br>c_{1112} = 0<br>$$<br>当$i=k=1,j=l=2$时，<br>$$<br>c_{1212} = \mu<br>$$<br>当$i=j=1,k=l=2$时，<br>$$<br>c_{1122} = \lambda<br>$$<br>这就是各向同性材料的应力应变关系矩阵：<br>$$<br>\begin{bmatrix}<br>\lambda+2\mu &amp; \lambda      &amp; \lambda      &amp; 0   &amp; 0   &amp; 0   \<br>             &amp; \lambda+2\mu &amp; \lambda      &amp; 0   &amp; 0   &amp; 0   \<br>             &amp;              &amp; \lambda+2\mu &amp; 0   &amp; 0   &amp; 0   \<br>             &amp;              &amp;              &amp; \mu &amp; 0   &amp; 0   \<br>             &amp;              &amp;              &amp;     &amp; \mu &amp; 0   \<br>             &amp;              &amp;              &amp;     &amp;     &amp; \mu<br>\end{bmatrix}<br>$$<br>回到力与位移的系数矩阵，按各个字母的序号循环可得：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjk3ow7k0j32eo37k4qq.jpg"><br>它的系数矩阵是一个$2*2$的矩阵，其中各个元素可由上图得到。<br>对于各向同性材料，代入上面的取值后，有：<br>$$<br>-\nabla\lambda(\nabla\cdot{\mathbf u})-(\nabla\cdot\mu\nabla){\mathbf u}-\nabla\cdot\mu (\nabla{\mathbf u})^T = {\mathbf f},<br>$$<br>其展开就是如图：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjk60wib7j32eo37khdu.jpg"><br>注意各种标量、矢量和张量的梯度和散度运算。<br>其弱形式为：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjk70cfz7j32eo37ke82.jpg"></p>
<p>下面就是怎样组装这个线性系统。第一件事情就是需要知道在矢量值的有限元中形函数是怎样工作的。大体过程这样：设$n$为要建立的矢量单元的分量，即标量单元，的形函数的个数，比如之前用的双线性单元，二维情形下$n=4$。设$N$是矢量单元的形函数的个数，二维情形下，$N=2n$，那么矢量单元的第i个形函数的形式为：<br>$$<br>\Phi_i({\mathbf x})=\varphi_{\text{base}(i)}({\mathbf x}){\mathbf e}_{\text{comp}(i)},<br>$$<br>其中，$\text{comp}(i)$是告诉我们$\Phi_i$的哪个分量非0(对每一个矢量形函数，只有一个分量非0，其余分量都为0)，比如$\text{comp}(1)=0$表示第1个矢量形函数的第0个分量非0。$\varphi_{\text{base}(i)}(x)$描述形函数与坐标的关系，就是标量单元的第$\text{base}(i)$个形函数，比如具体形式是这样的：<br>$$<br>\begin{equation}<br>\begin{split}<br>\Phi_0({\mathbf x}) &amp;=<br>\begin{bmatrix}<br>\varphi_0({\mathbf x}) \<br>0<br>\end{bmatrix}, \<br>\Phi_1({\mathbf x}) &amp;=<br>\begin{bmatrix}<br>0 \\<br>\varphi_0({\mathbf x})<br>\end{bmatrix}, \<br>\Phi_2({\mathbf x}) &amp;=<br>\begin{bmatrix}<br>\varphi_1({\mathbf x}) \<br>0<br>\end{bmatrix}, \<br>\Phi_3({\mathbf x}) &amp;=<br>\begin{bmatrix}<br>0 \\<br>\varphi_1({\mathbf x})<br>\end{bmatrix}, …<br>\end{split}<br>\end{equation}<br>$$<br>其中：<br>$$<br>\text{comp}(0)=0, \quad \text{comp}(1)=1, \quad \text{comp}(2)=0, \quad \text{comp}(3)=1, \quad \ldots \<br>\text{base}(0)=0, \quad \text{base}(1)=0, \quad \text{base}(2)=1, \quad \text{base}(3)=1, \quad \ldots<br>$$<br>在绝大多数情况下，不需要知道哪个$\varphi_{\text{base}(i)}$属于$\Phi_i$，于是定义：<br>$$<br>\phi_i = \varphi_{\text{base}(i)}<br>$$<br>所以，矢量形函数表示为：<br>$$<br>\Phi_i({\mathbf x}) = \phi_{i}({\mathbf x}){\mathbf e}_{\text{comp}(i)}.<br>$$<br>使用上述矢量形函数，构造出离散有限元解：<br>$$<br>{\mathbf u}_h({\mathbf x}) = \sum_i \Phi_i({\mathbf x})\ U_i<br>$$<br>其中，$U_i$是系数，是标量。定义一个类似的函数${\mathbf v}_h$作为试探函数，那么问题就变为：找到系数$U_i$，使得：<br>$$<br>a({\mathbf u}_h, {\mathbf v}_h) = ({\mathbf f}, {\mathbf v}_h) \qquad \forall {\mathbf v}_h.<br>$$<br>将双线性的具体形式代入，可得：<br>$$<br>\sum_{i,j} U_i V_j \sum_{k,l}[ \left( \lambda \partial_l (\Phi_i)_l, \partial_k (\Phi_j)_k \right)_\Omega + \left( \mu \partial_l (\Phi_i)_k, \partial_l (\Phi_j)_k \right)_\Omega+\left( \mu \partial_l (\Phi_i)_k, \partial_k (\Phi_j)_l \right)_\Omega ] \<br>= \sum_j V_j \sum_l \left( f_l, (\Phi_j)_l \right)_\Omega.<br>$$<br>注意到：下标k和l是对所有空间方向进行循环，$0\le k,l &lt; d$，而下标i和j是对所有自由度进行循环。<br>那么，单元K上的单元刚度矩阵就是：<br>$$<br>A_{ij}^K= \sum_{k,l}[ \left( \lambda \partial_l (\Phi_i)_l, \partial_k (\Phi_j)_k \right)_K + \left( \mu \partial_l (\Phi_i)_k, \partial_l (\Phi_j)_k \right)_K + \left( \mu \partial_l (\Phi_i)_k, \partial_k (\Phi_j)_l \right)_K]<br>$$<br>这里，i和j是局部自由度，有$0\le i,j &lt; N$。<br>在这些公式中，我们通常取矢量形函数的部分分量，根据定义，有：<br>$$<br>(\Phi_i)_l = \phi_i \delta_{l,\text{comp}(i)},<br>$$<br>那么，进一步简化得到：<br>$$<br>\begin{equation}<br>\begin{split}<br>A^K_{ij} &amp;=\sum_{k,l}[ \left(\lambda\partial_l \phi_i\delta_{l,\text{comp}(i)}, \partial_k \phi_j\delta_{k,\text{comp}(j)} \right)_K<br>+\left(\mu\partial_l \phi_i\delta_{k,\text{comp}(i)}, \partial_l \phi_j\delta_{k,\text{comp}(j)} \right)_K + \left(\mu\partial_l \phi_i\delta_{k,\text{comp}(i)},\partial_k \phi_j\delta_{l,\text{comp}(j)} \right)_K ] \<br>&amp;= \left(\lambda\partial_{\text{comp}(i)} \phi_i, \partial_{\text{comp}(j)}\phi_j \right)_K + \sum_l \left(\mu\partial_l \phi_i, \partial_l \phi_j \right)_K \delta_{\text{comp}(i),\text{comp}(j)} + \left(\mu\partial_{\text{comp}(j)} \phi_i, \partial_{\text{comp}(i)} \phi_j \right)_K \<br>&amp;= \left( \lambda \partial_{\text{comp}(i)} \phi_i, \partial_{\text{comp}(j)} \phi_j \right)_K + \left( \mu \nabla \phi_i, \nabla \phi_j \right)_K \delta_{\text{comp}(i),\text{comp}(j)} + \left( \mu \partial_{\text{comp}(j)} \phi_i, \partial_{\text{comp}(i)} \phi_j \right)_K.<br>\end{split}<br>\end{equation}<br>$$<br>同样地，单元对右端项的贡献为：<br>$$<br>\begin{equation}<br>\begin{split}<br>f^K_j &amp;=\sum_l \left( f_l, (\Phi_j)_l \right)_K \<br>&amp;= \sum_l \left( f_l, \phi_j \delta_{l,\text{comp}(j)} \right)_K \<br>&amp;= \left( f_{\text{comp}(j)}, \phi_j \right)_K.<br>\end{split}<br>\end{equation}<br>$$</p>
<h1 id="程序解析"><a href="#程序解析" class="headerlink" title="程序解析"></a>程序解析</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/quadrature_lib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/function.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/logstream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/vector.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/full_matrix.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/sparse_matrix.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/solver_cg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/precondition.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/constraint_matrix.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/grid_generator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/grid_refinement.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria_accessor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria_iterator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_handler.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_accessor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_tools.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/fe/fe_values.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/vector_tools.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/matrix_tools.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/data_out.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/error_estimator.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>以上是以前用过的头文件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/fe/fe_system.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>该头文件提供对矢量值的有限元的支持。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/fe/fe_q.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>从常规的Q1单元组合得到矢量值的有限元，Q1单元在以上头文件中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>C++的标准库。<br>建立step8的命名空间：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Step8</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> dealii;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ElasticProblem</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">ElasticProblem</span> ();</span><br><span class="line">            ~<span class="built_in">ElasticProblem</span> ();</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">setup_system</span> <span class="params">()</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">assemble_system</span> <span class="params">()</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">refine_grid</span> <span class="params">()</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">output_results</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> cycle)</span> <span class="keyword">const</span></span>;</span><br><span class="line">            Triangulation&lt;dim&gt; triangulation;</span><br><span class="line">            DoFHandler&lt;dim&gt; dof_handler;</span><br><span class="line">            FESystem&lt;dim&gt; fe;</span><br><span class="line">            ConstraintMatrix hanging_node_constraints;</span><br><span class="line">            SparsityPattern sparsity_pattern;</span><br><span class="line">            SparseMatrix&lt;<span class="keyword">double</span>&gt; system_matrix;</span><br><span class="line">            Vector&lt;<span class="keyword">double</span>&gt; solution;</span><br><span class="line">            Vector&lt;<span class="keyword">double</span>&gt; system_rhs;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>step8的类跟step6差不多，唯一一个变化是fe的类型，这里使用的是FESystem，不再是FE_Q。实际上FESystem本身不是一个有限元类型，不提供形函数。它就是将多个单元集合起来形成一个矢量的有限单元。<br>然后建立右端项：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RightHandSide</span> :</span> <span class="keyword">public</span> Function&lt;dim&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">RightHandSide</span> ();</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vector_value</span> <span class="params">(<span class="keyword">const</span> Point&lt;dim&gt; &amp;p,</span></span></span><br><span class="line"><span class="function"><span class="params">                Vector&lt;<span class="keyword">double</span>&gt; &amp;values)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vector_value_list</span> <span class="params">(<span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt; &gt; &amp;points,</span></span></span><br><span class="line"><span class="function"><span class="params">                std::vector&lt;Vector&lt;<span class="keyword">double</span>&gt; &gt; &amp;value_list)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>vector_value是取得某个位置的矢量值，vector_value_list是一下取得很多。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">RightHandSide&lt;dim&gt;::<span class="built_in">RightHandSide</span> ()</span><br><span class="line">    :</span><br><span class="line">        Function&lt;dim&gt; (dim)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>析构函数中给Function传递了参数，代表分量的个数，这里就是dim。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">void</span> RightHandSide&lt;dim&gt;::<span class="built_in">vector_value</span> (<span class="keyword">const</span> Point&lt;dim&gt; &amp;p,</span><br><span class="line">        Vector&lt;<span class="keyword">double</span>&gt; &amp;values) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Assert</span> (values.<span class="built_in">size</span>() == dim,</span><br><span class="line">            <span class="built_in">ExcDimensionMismatch</span> (values.<span class="built_in">size</span>(), dim));</span><br><span class="line">    <span class="built_in">Assert</span> (dim &gt;= <span class="number">2</span>, <span class="built_in">ExcNotImplemented</span>());</span><br></pre></td></tr></table></figure>
<p>这里加入了几个提前判断，用来保证维数和矢量大小正确。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Point&lt;dim&gt; point_1, point_2;</span><br><span class="line"><span class="built_in">point_1</span>(<span class="number">0</span>) = <span class="number">0.5</span>;</span><br><span class="line"><span class="built_in">point_2</span>(<span class="number">0</span>) = <span class="number">-0.5</span>;</span><br><span class="line"><span class="keyword">if</span> (((p-point_1).<span class="built_in">norm_square</span>() &lt; <span class="number">0.2</span>*<span class="number">0.2</span>) ||</span><br><span class="line">        ((p-point_2).<span class="built_in">norm_square</span>() &lt; <span class="number">0.2</span>*<span class="number">0.2</span>))</span><br><span class="line">    <span class="built_in">values</span>(<span class="number">0</span>) = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">values</span>(<span class="number">0</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果在离两个圆心一定范围内，就把x方向的力设为1，否则设为0。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p.<span class="built_in">norm_square</span>() &lt; <span class="number">0.2</span>*<span class="number">0.2</span>)</span><br><span class="line">    <span class="built_in">values</span>(<span class="number">1</span>) = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">values</span>(<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果离原点一定范围内，就把y方向的力设为1，否则设为0。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> RightHandSide&lt;dim&gt;::<span class="built_in">vector_value_list</span> (<span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt; &gt; &amp;points,</span><br><span class="line">        std::vector&lt;Vector&lt;<span class="keyword">double</span>&gt; &gt; &amp;value_list) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Assert</span> (value_list.<span class="built_in">size</span>() == points.<span class="built_in">size</span>(),</span><br><span class="line">            <span class="built_in">ExcDimensionMismatch</span> (value_list.<span class="built_in">size</span>(), points.<span class="built_in">size</span>()));</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> n_points = points.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> p=<span class="number">0</span>; p&lt;n_points; ++p)</span><br><span class="line">        RightHandSide&lt;dim&gt;::<span class="built_in">vector_value</span> (points[p],</span><br><span class="line">                value_list[p]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是一下取得好多点上的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">ElasticProblem&lt;dim&gt;::<span class="built_in">ElasticProblem</span> ()</span><br><span class="line">    :</span><br><span class="line">        <span class="built_in">dof_handler</span> (triangulation),</span><br><span class="line">        <span class="built_in">fe</span> (FE_Q&lt;dim&gt;(<span class="number">1</span>), dim)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">ElasticProblem&lt;dim&gt;::~<span class="built_in">ElasticProblem</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    dof_handler.<span class="built_in">clear</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是求解类的构造和析构函数。在构造函数中，给fe传递两个参数：一个是构造矢量有限元所基于的标量有限元，另一个就是多少个标量堆起来等于1个矢量，这里就是dim。知道这些信息后，FESystem就知道该怎么合成矢量有限元了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> ElasticProblem&lt;dim&gt;::<span class="built_in">setup_system</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    dof_handler.<span class="built_in">distribute_dofs</span> (fe);</span><br><span class="line">    hanging_node_constraints.<span class="built_in">clear</span> ();</span><br><span class="line">    DoFTools::<span class="built_in">make_hanging_node_constraints</span> (dof_handler,</span><br><span class="line">            hanging_node_constraints);</span><br><span class="line">    hanging_node_constraints.<span class="built_in">close</span> ();</span><br><span class="line">    <span class="function">DynamicSparsityPattern <span class="title">dsp</span><span class="params">(dof_handler.n_dofs(), dof_handler.n_dofs())</span></span>;</span><br><span class="line">    DoFTools::<span class="built_in">make_sparsity_pattern</span>(dof_handler,</span><br><span class="line">            dsp,</span><br><span class="line">            hanging_node_constraints,</span><br><span class="line">            / *keep_constrained_dofs = * / <span class="literal">true</span>);</span><br><span class="line">    sparsity_pattern.<span class="built_in">copy_from</span> (dsp);</span><br><span class="line">    system_matrix.<span class="built_in">reinit</span> (sparsity_pattern);</span><br><span class="line">    solution.<span class="built_in">reinit</span> (dof_handler.<span class="built_in">n_dofs</span>());</span><br><span class="line">    system_rhs.<span class="built_in">reinit</span> (dof_handler.<span class="built_in">n_dofs</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建立系统。过程跟step6相同，这里的这些类都能处理矢量的单元，实际无论矢量还是标量单元，这些类都一视同仁。<br>重头戏就是组装系统了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> ElasticProblem&lt;dim&gt;::<span class="built_in">assemble_system</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">QGauss&lt;dim&gt; <span class="title">quadrature_formula</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">FEValues&lt;dim&gt; <span class="title">fe_values</span> <span class="params">(fe, quadrature_formula,</span></span></span><br><span class="line"><span class="function"><span class="params">            update_values | update_gradients |</span></span></span><br><span class="line"><span class="function"><span class="params">            update_quadrature_points | update_JxW_values)</span></span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> dofs_per_cell = fe.dofs_per_cell;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> n_q_points = quadrature_formula.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">FullMatrix&lt;<span class="keyword">double</span>&gt; <span class="title">cell_matrix</span> <span class="params">(dofs_per_cell, dofs_per_cell)</span></span>;</span><br><span class="line">    <span class="function">Vector&lt;<span class="keyword">double</span>&gt; <span class="title">cell_rhs</span> <span class="params">(dofs_per_cell)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;types::global_dof_index&gt; <span class="title">local_dof_indices</span> <span class="params">(dofs_per_cell)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第一部分跟之前的相同：设置合适的积分公式、初始化FEValues对象、声明一些附加数组等。其中，获取每个单元上的自由度数，是从合成过的有限单元上取得，而不是那个标量Q1对象。这里，自由度数等于dim乘以Q1单元的每个单元上的自由度数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="keyword">double</span>&gt; <span class="title">lambda_values</span> <span class="params">(n_q_points)</span></span>;</span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">double</span>&gt; <span class="title">mu_values</span> <span class="params">(n_q_points)</span></span>;</span><br></pre></td></tr></table></figure>
<p>然后存储所有积分点上两个系数的值。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConstantFunction&lt;dim&gt; lambda(1.), mu(1.);</span><br></pre></td></tr></table></figure>
<p>这里将两个系数都设为定值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RightHandSide&lt;dim&gt; right_hand_side;</span><br><span class="line">std::vector&lt;Vector&lt;<span class="keyword">double</span>&gt; &gt; <span class="built_in">rhs_values</span> (n_q_points,</span><br><span class="line">        Vector&lt;<span class="keyword">double</span>&gt;(dim));</span><br></pre></td></tr></table></figure>
<p>建立右端项的对象。因为是矢量，所以rhs_values的类型也变化了。<br>然后开始单元循环：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator cell = dof_handler.<span class="built_in">begin_active</span>(),</span><br><span class="line">         endc = dof_handler.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">for</span> (; cell!=endc; ++cell)</span><br><span class="line">&#123;</span><br><span class="line">    cell_matrix = <span class="number">0</span>;</span><br><span class="line">    cell_rhs = <span class="number">0</span>;</span><br><span class="line">    fe_values.<span class="built_in">reinit</span> (cell);</span><br><span class="line">    lambda.<span class="built_in">value_list</span> (fe_values.<span class="built_in">get_quadrature_points</span>(), lambda_values);</span><br><span class="line">    mu.<span class="built_in">value_list</span> (fe_values.<span class="built_in">get_quadrature_points</span>(), mu_values);</span><br><span class="line">    right_hand_side.<span class="built_in">vector_value_list</span> (fe_values.<span class="built_in">get_quadrature_points</span>(),</span><br><span class="line">            rhs_values);</span><br></pre></td></tr></table></figure>
<p>上面计算系数和右端项在积分点上的值。<br>然后就是计算单元刚度矩阵和右端项：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dofs_per_cell; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">        component_i = fe.<span class="built_in">system_to_component_index</span>(i).first;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j=<span class="number">0</span>; j&lt;dofs_per_cell; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">            component_j = fe.<span class="built_in">system_to_component_index</span>(j).first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> q_point=<span class="number">0</span>; q_point&lt;n_q_points;</span><br><span class="line">                ++q_point)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cell_matrix</span>(i,j)</span><br><span class="line">                +=</span><br></pre></td></tr></table></figure>
<p>整个计算过程完全对应前面引子中的推导。component_i就是非0分量的指标，它通过fe.system_to_component_index(i).first这个函数取得，实际上first取得矢量形函数的非0分量的指标，而second取得具体这个形函数的值，即引子中的base。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line"> (fe_values.<span class="built_in">shape_grad</span>(i,q_point)[component_i] *</span><br><span class="line">  fe_values.<span class="built_in">shape_grad</span>(j,q_point)[component_j] *</span><br><span class="line">  lambda_values[q_point])</span><br><span class="line"> +</span><br><span class="line"> (fe_values.<span class="built_in">shape_grad</span>(i,q_point)[component_j] *</span><br><span class="line">  fe_values.<span class="built_in">shape_grad</span>(j,q_point)[component_i] *</span><br><span class="line">  mu_values[q_point])</span><br><span class="line"> +</span><br></pre></td></tr></table></figure>
<p>这一项计算的是(lambda d_i u_i, d_j v_j) + (mu d_i u_j, d_j v_i)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">((component_i == component_j) ?</span><br><span class="line"> (fe_values.<span class="built_in">shape_grad</span>(i,q_point) *</span><br><span class="line">  fe_values.<span class="built_in">shape_grad</span>(j,q_point) *</span><br><span class="line">  mu_values[q_point]) :</span><br><span class="line"> <span class="number">0</span>)</span><br><span class="line">)</span><br><span class="line">*</span><br><span class="line">fe_values.<span class="built_in">JxW</span>(q_point);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一项计算的是(mu nabla u_i, nabla v_j)。注意这里的grad没有加后面的方括号，用了重载的乘号。<br>且使用了条件表达式，判断两个下标是否相同。<br>单元右端项的计算：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dofs_per_cell; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">        component_i = fe.<span class="built_in">system_to_component_index</span>(i).first;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> q_point=<span class="number">0</span>; q_point&lt;n_q_points; ++q_point)</span><br><span class="line">        <span class="built_in">cell_rhs</span>(i) += fe_values.<span class="built_in">shape_value</span>(i,q_point) *</span><br><span class="line">            rhs_values[q_point](component_i) *</span><br><span class="line">            fe_values.<span class="built_in">JxW</span>(q_point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>组装：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cell-&gt;<span class="built_in">get_dof_indices</span> (local_dof_indices);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dofs_per_cell; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j=<span class="number">0</span>; j&lt;dofs_per_cell; ++j)</span><br><span class="line">        system_matrix.<span class="built_in">add</span> (local_dof_indices[i],</span><br><span class="line">                local_dof_indices[j],</span><br><span class="line">                <span class="built_in">cell_matrix</span>(i,j));</span><br><span class="line">    <span class="built_in">system_rhs</span>(local_dof_indices[i]) += <span class="built_in">cell_rhs</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">hanging_node_constraints.<span class="built_in">condense</span> (system_matrix);</span><br><span class="line">hanging_node_constraints.<span class="built_in">condense</span> (system_rhs);</span><br></pre></td></tr></table></figure>
<p>施加边界条件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;types::global_dof_index,<span class="keyword">double</span>&gt; boundary_values;</span><br><span class="line">VectorTools::<span class="built_in">interpolate_boundary_values</span> (dof_handler,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        ZeroFunction&lt;dim&gt;(dim),</span><br><span class="line">        boundary_values);</span><br><span class="line">MatrixTools::<span class="built_in">apply_boundary_values</span> (boundary_values,</span><br><span class="line">        system_matrix,</span><br><span class="line">        solution,</span><br><span class="line">        system_rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里做了一些小修改，因为解是矢量的，所以边界条件施加的也应该是矢量的。而ZeroFunction可以接收参数来形成不同类型的量，这里传递的是dim。<br>求解器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> ElasticProblem&lt;dim&gt;::<span class="built_in">solve</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">SolverControl <span class="title">solver_control</span> <span class="params">(<span class="number">1000</span>, <span class="number">1e-12</span>)</span></span>;</span><br><span class="line">    SolverCG&lt;&gt; <span class="built_in">cg</span> (solver_control);</span><br><span class="line">    PreconditionSSOR&lt;&gt; preconditioner;</span><br><span class="line">    preconditioner.<span class="built_in">initialize</span>(system_matrix, <span class="number">1.2</span>);</span><br><span class="line">    cg.<span class="built_in">solve</span> (system_matrix, solution, system_rhs,</span><br><span class="line">            preconditioner);</span><br><span class="line">    hanging_node_constraints.<span class="built_in">distribute</span> (solution);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求解过程不变，求解器不管具体问题是什么，只要线性系统是正定且对称的，CG算法就能用。<br>细化网格：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> ElasticProblem&lt;dim&gt;::<span class="built_in">refine_grid</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Vector&lt;<span class="keyword">float</span>&gt; <span class="title">estimated_error_per_cell</span> <span class="params">(triangulation.n_active_cells())</span></span>;</span><br><span class="line">    KellyErrorEstimator&lt;dim&gt;::<span class="built_in">estimate</span> (dof_handler,</span><br><span class="line">            QGauss&lt;dim<span class="number">-1</span>&gt;(<span class="number">2</span>),</span><br><span class="line">            <span class="keyword">typename</span> FunctionMap&lt;dim&gt;::<span class="built_in">type</span>(),</span><br><span class="line">            solution,</span><br><span class="line">            estimated_error_per_cell);</span><br><span class="line">    GridRefinement::<span class="built_in">refine_and_coarsen_fixed_number</span> (triangulation,</span><br><span class="line">            estimated_error_per_cell,</span><br><span class="line">            <span class="number">0.3</span>, <span class="number">0.03</span>);</span><br><span class="line">    triangulation.<span class="built_in">execute_coarsening_and_refinement</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指示子是用的所有方向上的位移具有相同的权重。<br>结果输出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> ElasticProblem&lt;dim&gt;::<span class="built_in">output_results</span> (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> cycle) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string filename = <span class="string">&quot;solution-&quot;</span>;</span><br><span class="line">    filename += (<span class="string">&#x27;0&#x27;</span> + cycle);</span><br><span class="line">    <span class="built_in">Assert</span> (cycle &lt; <span class="number">10</span>, <span class="built_in">ExcInternalError</span>());</span><br><span class="line">    filename += <span class="string">&quot;.vtk&quot;</span>;</span><br><span class="line">    <span class="function">std::ofstream <span class="title">output</span> <span class="params">(filename.c_str())</span></span>;</span><br><span class="line">    DataOut&lt;dim&gt; data_out;</span><br><span class="line">    data_out.<span class="built_in">attach_dof_handler</span> (dof_handler);</span><br><span class="line">    std::vector&lt;std::string&gt; solution_names;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (dim)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            solution_names.<span class="built_in">push_back</span> (<span class="string">&quot;displacement&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            solution_names.<span class="built_in">push_back</span> (<span class="string">&quot;x_displacement&quot;</span>);</span><br><span class="line">            solution_names.<span class="built_in">push_back</span> (<span class="string">&quot;y_displacement&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            solution_names.<span class="built_in">push_back</span> (<span class="string">&quot;x_displacement&quot;</span>);</span><br><span class="line">            solution_names.<span class="built_in">push_back</span> (<span class="string">&quot;y_displacement&quot;</span>);</span><br><span class="line">            solution_names.<span class="built_in">push_back</span> (<span class="string">&quot;z_displacement&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">Assert</span> (<span class="literal">false</span>, <span class="built_in">ExcNotImplemented</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    data_out.<span class="built_in">add_data_vector</span> (solution, solution_names);</span><br><span class="line">    data_out.<span class="built_in">build_patches</span> ();</span><br><span class="line">    data_out.<span class="built_in">write_vtk</span> (output);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为结果是矢量，所以给每个分量都有一个名字。<br>运行函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> ElasticProblem&lt;dim&gt;::<span class="built_in">run</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> cycle=<span class="number">0</span>; cycle&lt;<span class="number">8</span>; ++cycle)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="string">&#x27;:&#x27;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (cycle == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GridGenerator::<span class="built_in">hyper_cube</span> (triangulation, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">            triangulation.<span class="built_in">refine_global</span> (<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">refine_grid</span> ();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; Number of active cells: &quot;</span></span><br><span class="line">            &lt;&lt; triangulation.<span class="built_in">n_active_cells</span>()</span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">setup_system</span> ();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; Number of degrees of freedom: &quot;</span></span><br><span class="line">            &lt;&lt; dof_handler.<span class="built_in">n_dofs</span>()</span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">assemble_system</span> ();</span><br><span class="line">        <span class="built_in">solve</span> ();</span><br><span class="line">        <span class="built_in">output_results</span> (cycle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Attention!!<br>这里有个小问题，刚开始产生网格后，就全局细化了两次。这是因为这里选择的右端项相当局域化，如果只细化一次，网格的积分点很稀疏，它捕捉的右端项的值全是0，这样就计算错误了。所以，要考虑到网格细化对值的正确捕捉。<br>Attention完毕！！<br>main函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        Step8::ElasticProblem&lt;<span class="number">2</span>&gt; elastic_problem_2d;</span><br><span class="line">        elastic_problem_2d.<span class="built_in">run</span> ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (std::exception &amp;exc)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; exc.<span class="built_in">what</span>() &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="计算结果"><a href="#计算结果" class="headerlink" title="计算结果"></a>计算结果</h1><p>x分量为：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjk7bplf8j30qx0k5dhl.jpg"><br>y分量为：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjk7ml9eij30qx0k5dhh.jpg"><br>注意，虽然这两个分量组合起来是位移，即它们两个不是完全孤立的，比如说是压力和浓度的关系，而是一个量的两个分量，但现在的output方式没法将两者组合起来，即这里还是将两者看成两个孤立的量，真正组合起来显示矢量的例子是step22，到时再说。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2016/09/02/dealii-learn-step7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Be interesting!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亓欣波">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/09/02/dealii-learn-step7/" class="post-title-link" itemprop="url">求解偏微分方程开源有限元软件deal.II学习--Step 7</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-09-02 00:00:00" itemprop="dateCreated datePublished" datetime="2016-09-02T00:00:00+08:00">2016-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 15:20:30" itemprop="dateModified" datetime="2021-03-25T15:20:30+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computational-material-science/" itemprop="url" rel="index"><span itemprop="name">computational material science</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2016/09/02/dealii-learn-step7/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/09/02/dealii-learn-step7/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>在本例中，将会着眼于以下两方面：</p>
<ol>
<li>验证程序的正确性，生成收敛性统计表格;</li>
<li>对于Helmholtz方程施加非齐次Neumann边界条件。</li>
</ol>
<p>另外还有一些小的优化点。</p>
<h2 id="验证程序正确性"><a href="#验证程序正确性" class="headerlink" title="验证程序正确性"></a>验证程序正确性</h2><p>也许从来不会有任何一个有限元程序一开始就是正确的，所以找到方法来验证计算的解是否正确就很有必要。通常选择已知精确解析解，并且比较精确解析解和计算离散解两者之间差别来求证。如果随着误差次数提高，两者之间差别逐渐趋于0，就说明程序的正确性。deal.II中就提供了这样一个函数：VectorTools::integrate_difference()，它提供了很多种范数的计算：<br>$$<br>\begin{equation}<br>\begin{split}<br>{|| u-u_h ||}_{L_1(K)} &amp;=\int_K |u-u_h| dx, \<br>{|| u-u_h ||}_{L_2(K)} &amp;=\left( \int_K |u-u_h|^2 dx \right)^{1/2}, \<br>{|| u-u_h ||}_{L_\infty(K)} &amp;=\max_{x \in K} |u(x) - u_h(x)|, \<br>{| u-u_h |}_{H^1(K)} &amp;=\left( \int_K |\nabla(u-u_h)|^2 dx \right)^{1/2}, \<br>{|| u-u_h ||}_{H^1(K)} &amp;=\left( {|| u-u_h ||}^2_{L_2(K)} +{| u-u_h |}^2_{H^1(K)} \right)^{1/2}<br>\end{split}<br>\end{equation}<br>$$<br>这些公式也适用于矢量函数。就像其他的积分一样，我们也需要用数值积分公式来计算这些范数，那么合适的积分公式对这些误差的计算就很重要，特别是对$L_\infty$范数，因为需要在积分点上计算数值解和精确解的最大差别。该函数计算每个单元上的范数，然后返回一个vector存储每个单元上的这些值，从局部的范数，可以得到全局范数，如全局$L_2$范数为：<br>$$<br>E=||e||=(\sum_i e_i^2)^{1/2}<br>$$<br>在本例中，将会展示怎样计算和使用这些量，同时监控随着网格细化其怎样变化。同时还将展示从得到的数据生成漂亮的表格，来自动计算收敛速率，而且将比较不同策略的网格细化。</p>
<h2 id="非齐次Neumann边界条件"><a href="#非齐次Neumann边界条件" class="headerlink" title="非齐次Neumann边界条件"></a>非齐次Neumann边界条件</h2><p>非齐次边界条件，即包括边界值及其梯度的条件，它们存在于边界积分中，然后计算时需要被组装进右端项中。具体到本例来说，要求解的方程是Holmholtz方程：<br>$$<br>-\Delta u+u=f<br>$$<br>计算域是$[-1,1]^2$。边界条件分两部分，在整体边界$\Gamma$的$\Gamma_1$部分：<br>$$<br>u=g_1<br>$$<br>在剩下的$\Gamma_2$部分：<br>$$<br>{\mathbf n}\cdot \nabla u = g_2<br>$$<br>具体边界划分为：$\Gamma_1=\Gamma \cap ((x=1) \cup (y=1))$。<br>根据Method of Manufactured Solutions，得到本例的精确解为：<br>$$<br>\bar u(x) = \sum_{i=1}^3 \exp\left(-\frac{|x-x_i|^2}{\sigma^2}\right)<br>$$<br>其中:$ x_1=(-\frac{1}{2},\frac{1}{2}),x_2=(-\frac{1}{2},-\frac{1}{2}),x_3=(\frac{1}{2},-\frac{1}{2}),\sigma=\frac{1}{8}$<br>弱形式为：<br>$$<br>(\nabla u, \nabla v)_\Omega + (u,v)_\Omega = (f,v)_\Omega + (g_2,v)_{\Gamma_2}<br>$$<br>其中，边界积分项$(g_2,v)_{\Gamma_2}$已经考虑了在$\Gamma_1$上$v=0$。<br>离散后单元上的矩阵和向量的形式为：<br>$$<br>\begin{equation}<br>\begin{split}<br>A_{ij}^K &amp;=\left(\nabla \varphi_i, \nabla \varphi_j\right)_K +\left(\varphi_i, \varphi_j\right)_K, \<br>f_i^K &amp;=\left(f,\varphi_i\right)_K +\left(g_2, \varphi_i\right)_{\partial K\cap \Gamma_2}<br>\end{split}<br>\end{equation}<br>$$<br>对于区域积分，之前已经有了很多介绍，就是用FEValues类来给出单元上的形函数的值及其梯度，以及Jacobian行列式及积分点等。而相对应地，对于边界上曲线积分，用FEFaceValues来做以上工作，只不过它的维度比domain要小1。</p>
<h2 id="一个良好的编程习惯"><a href="#一个良好的编程习惯" class="headerlink" title="一个良好的编程习惯"></a>一个良好的编程习惯</h2><p>一个良好的编程习惯就是使用命名空间，这样可以有效地预防命名冲突。格式为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">... <span class="meta">#includes</span></span><br><span class="line"><span class="keyword">namespace</span> Step7</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> dealii;</span><br><span class="line">    ...everything to <span class="keyword">do</span> with the program...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...<span class="function"><span class="keyword">do</span> whatever <span class="title">main</span><span class="params">()</span> does...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="程序解析"><a href="#程序解析" class="headerlink" title="程序解析"></a>程序解析</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/quadrature_lib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/function.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/logstream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/vector.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/full_matrix.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/sparse_matrix.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/solver_cg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/precondition.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/constraint_matrix.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/grid_generator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/grid_refinement.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria_accessor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria_iterator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_handler.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_accessor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_tools.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/fe/fe_q.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/matrix_tools.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/error_estimator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/data_out.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>以上头文件不解释。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_renumbering.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>这里使用Cuthill-McKee算法对自由度重新排号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/smartpointer.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>以上头文件保证对象在被使用时不被删除。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/vector_tools.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/convergence_table.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>第一个头文件包含了VectorTools::integrate_difference()函数，第二个则是生成表格用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/fe/fe_values.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>还要使用FEValues类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>下面开启step7命名空间，同时引入dealii空间：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Step7</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> dealii;</span><br></pre></td></tr></table></figure>
<p>首先创建一个类来存储精确解，这里把它作成一个基类，是为了以后跟右端项分享一些相同的特征(因为此例中右端项就是解的组合)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SolutionBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> n_source_centers = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> Point&lt;dim&gt; source_centers[n_source_centers];</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> width;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其特征包括三项：指数项的个数及其中心及其半宽度。此类与维度无关，先看它怎样对一维实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">const</span> Point&lt;<span class="number">1</span>&gt;</span><br><span class="line">SolutionBase&lt;<span class="number">1</span>&gt;::source_centers[SolutionBase&lt;<span class="number">1</span>&gt;::n_source_centers]</span><br><span class="line">= &#123; Point&lt;<span class="number">1</span>&gt;(<span class="number">-1.0</span> / <span class="number">3.0</span>),</span><br><span class="line">    Point&lt;<span class="number">1</span>&gt;(<span class="number">0.0</span>),</span><br><span class="line">    Point&lt;<span class="number">1</span>&gt;(+<span class="number">1.0</span> / <span class="number">3.0</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里涉及模板显式特化语法。<br>二维是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">const</span> Point&lt;<span class="number">2</span>&gt;</span><br><span class="line">SolutionBase&lt;<span class="number">2</span>&gt;::source_centers[SolutionBase&lt;<span class="number">2</span>&gt;::n_source_centers]</span><br><span class="line">= &#123; Point&lt;<span class="number">2</span>&gt;(<span class="number">-0.5</span>, +<span class="number">0.5</span>),</span><br><span class="line">    Point&lt;<span class="number">2</span>&gt;(<span class="number">-0.5</span>, <span class="number">-0.5</span>),</span><br><span class="line">    Point&lt;<span class="number">2</span>&gt;(+<span class="number">0.5</span>, <span class="number">-0.5</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后设定半宽度：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> SolutionBase&lt;dim&gt;::width = <span class="number">1.</span>/<span class="number">8.</span>;</span><br></pre></td></tr></table></figure>
<p>在声明和定义了右端项和解的特征以后，就需要真正声明这两个类了。它们都代表了连续函数，因此继承自Function<dim>基类，同时也继承上面的SolutionBase类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> :</span> <span class="keyword">public</span> Function&lt;dim&gt;,</span><br><span class="line">    <span class="keyword">protected</span> SolutionBase&lt;dim&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Solution</span> () : Function&lt;dim&gt;() &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">value</span> <span class="params">(<span class="keyword">const</span> Point&lt;dim&gt; &amp;p,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        virtual Tensor&lt;1,dim&gt; gradient (const Point&lt;dim&gt; &amp;p,</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component = <span class="number">0</span>) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意：为了计算离散解和连续解的误差，就必须提供精确解的值和梯度。Function类提供了关于值和梯度的虚函数，所以要做的就是对相应的虚函数进行重载。再次注意：在dim维空间的函数，它的梯度是具有dim维的一阶张量，如上所示。<br>值和梯度的计算如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">double</span> Solution&lt;dim&gt;::<span class="built_in">value</span> (<span class="keyword">const</span> Point&lt;dim&gt; &amp;p,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> return_value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>-&gt;n_source_centers; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> Tensor&lt;<span class="number">1</span>,dim&gt; x_minus_xi = p - <span class="keyword">this</span>-&gt;source_centers[i];</span><br><span class="line">        return_value += std::<span class="built_in">exp</span>(-x_minus_xi.<span class="built_in">norm_square</span>() /</span><br><span class="line">                (<span class="keyword">this</span>-&gt;width * <span class="keyword">this</span>-&gt;width));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> return_value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">Tensor&lt;<span class="number">1</span>,dim&gt; Solution&lt;dim&gt;::<span class="built_in">gradient</span> (<span class="keyword">const</span> Point&lt;dim&gt; &amp;p,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Tensor&lt;<span class="number">1</span>,dim&gt; return_value;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>-&gt;n_source_centers; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> Tensor&lt;<span class="number">1</span>,dim&gt; x_minus_xi = p - <span class="keyword">this</span>-&gt;source_centers[i];</span><br><span class="line"></span><br><span class="line">        return_value += (<span class="number">-2</span> / (<span class="keyword">this</span>-&gt;width * <span class="keyword">this</span>-&gt;width) *</span><br><span class="line">                std::<span class="built_in">exp</span>(-x_minus_xi.<span class="built_in">norm_square</span>() /</span><br><span class="line">                    (<span class="keyword">this</span>-&gt;width * <span class="keyword">this</span>-&gt;width)) *</span><br><span class="line">                x_minus_xi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> return_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了精确解，还需要一个右端项函数来组装离散方程的线性系统：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RightHandSide</span> :</span> <span class="keyword">public</span> Function&lt;dim&gt;,</span><br><span class="line">    <span class="keyword">protected</span> SolutionBase&lt;dim&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">RightHandSide</span> () : Function&lt;dim&gt;() &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">value</span> <span class="params">(<span class="keyword">const</span> Point&lt;dim&gt; &amp;p,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">double</span> RightHandSide&lt;dim&gt;::<span class="built_in">value</span> (<span class="keyword">const</span> Point&lt;dim&gt; &amp;p,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> return_value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>-&gt;n_source_centers; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> Tensor&lt;<span class="number">1</span>,dim&gt; x_minus_xi = p - <span class="keyword">this</span>-&gt;source_centers[i];</span><br><span class="line">        return_value += ((<span class="number">2</span>*dim - <span class="number">4</span>*x_minus_xi.<span class="built_in">norm_square</span>()/</span><br><span class="line">                    (<span class="keyword">this</span>-&gt;width * <span class="keyword">this</span>-&gt;width)) /</span><br><span class="line">                (<span class="keyword">this</span>-&gt;width * <span class="keyword">this</span>-&gt;width) *</span><br><span class="line">                std::<span class="built_in">exp</span>(-x_minus_xi.<span class="built_in">norm_square</span>() /</span><br><span class="line">                    (<span class="keyword">this</span>-&gt;width * <span class="keyword">this</span>-&gt;width)));</span><br><span class="line">        return_value += std::<span class="built_in">exp</span>(-x_minus_xi.<span class="built_in">norm_square</span>() /</span><br><span class="line">                (<span class="keyword">this</span>-&gt;width * <span class="keyword">this</span>-&gt;width));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> return_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只用到它的值，用不着计算梯度。具体计算时解是由两部分构成：解的负laplace项和解本身。<br>然后就是求解这个问题的类了。它的界面跟之前的例子大体相同，但是有以下几点不同：<br>(1)用于不同的有限单元;(2)既可以自适应细化，也可以全局细化，具体怎样细化是在构造函数中判断。同时还有分析各种误差的<br>函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelmholtzProblem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">RefinementMode</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            global_refinement, adaptive_refinement</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">HelmholtzProblem</span> (<span class="keyword">const</span> FiniteElement&lt;dim&gt; &amp;fe,</span><br><span class="line">                <span class="keyword">const</span> RefinementMode refinement_mode);</span><br><span class="line">        ~<span class="built_in">HelmholtzProblem</span> ();</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setup_system</span> <span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">assemble_system</span> <span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">refine_grid</span> <span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">process_solution</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> cycle)</span></span>;</span><br></pre></td></tr></table></figure>
<p>下面是类的成员变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Triangulation&lt;dim&gt; triangulation;</span><br><span class="line">DoFHandler&lt;dim&gt; dof_handler;</span><br><span class="line">SmartPointer&lt;<span class="keyword">const</span> FiniteElement&lt;dim&gt; &gt; fe;</span><br><span class="line">ConstraintMatrix hanging_node_constraints;</span><br><span class="line">SparsityPattern sparsity_pattern;</span><br><span class="line">SparseMatrix&lt;<span class="keyword">double</span>&gt; system_matrix;</span><br><span class="line">Vector&lt;<span class="keyword">double</span>&gt; solution;</span><br><span class="line">Vector&lt;<span class="keyword">double</span>&gt; system_rhs;</span><br></pre></td></tr></table></figure>
<p>其中比较特殊的是有限单元对象fe。从上面的类的构造函数可以看出，fe是传给它作为参数的。<br>考虑在所有程序中都会出现的情况：我们有一个triangulation对象，也有一个fe对象，当然也有一个同时使用它俩的DoFHandler对象。明显这三个对象的寿命要比其他对象要长。但问题是：我们能保证triangulation和fe的寿命足够长来供DoFHandler使用吗？这意味着DoFHandler要对这两者施加某些锁，只有在它已经清除了所有对这两者的使用后才能释放这些锁。正如step6所示，如果违反，则有异常抛出。<br>我们将要展示库是怎样找到是否还有对对象的使用的。过程大体是这样的：所有可能置于这些有潜在危险指针之下的对象都派生自Subscriptor类，比如Triangulation类、DoFHandler类、FiniteElement类。这个类不提供很多功能，但它有一个内置的计数器。一旦我们初始化一个指向该对象的指针，该计数器就加1，当移除指针或不再需要它时，就减1，这样就能检查还有多少对象仍然使用该对象。<br>另一方面，如果一个派生自Subscriptor类的类的对象销毁了，它也必须调用Subscriptor的析构函数。在这个析构函数中，也将检查那个计数器是否为0，如果是，那么就没有对该对象的引用，那么我们就可以安全地销毁它，否则，就会产生危险的指针，库就抛出一个异常来提醒程序员检查代码。<br>上面一切听起来都挺美好，但在使用上有一些问题：万一我忘了对计数器加1怎么办？万一我又忘了减1呢？这在调试程序时会很麻烦。解决这个问题的方法是使用C++的一个特性：SmartPointer智能指针。我们创建的类的对象让它就像一个指针一样。正如上面程序中fe的定义一样。<br>还有一个变量是存储细化方式，是一个枚举常量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RefinementMode refinement_mode;</span><br></pre></td></tr></table></figure>
<p>另一个变量是收敛性表格：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ConvergenceTable convergence_table;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">HelmholtzProblem&lt;dim&gt;::<span class="built_in">HelmholtzProblem</span> (<span class="keyword">const</span> FiniteElement&lt;dim&gt; &amp;fe,</span><br><span class="line">        <span class="keyword">const</span> RefinementMode refinement_mode) :</span><br><span class="line">    <span class="built_in">dof_handler</span> (triangulation),</span><br><span class="line">    <span class="built_in">fe</span> (&amp;fe),</span><br><span class="line">    <span class="built_in">refinement_mode</span> (refinement_mode)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>类的析构函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">HelmholtzProblem&lt;dim&gt;::~<span class="built_in">HelmholtzProblem</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    dof_handler.<span class="built_in">clear</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建立系统：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> HelmholtzProblem&lt;dim&gt;::<span class="built_in">setup_system</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    dof_handler.<span class="built_in">distribute_dofs</span> (*fe);</span><br><span class="line">    DoFRenumbering::<span class="built_in">Cuthill_McKee</span> (dof_handler);</span><br><span class="line">    hanging_node_constraints.<span class="built_in">clear</span> ();</span><br><span class="line">    DoFTools::<span class="built_in">make_hanging_node_constraints</span> (dof_handler,</span><br><span class="line">            hanging_node_constraints);</span><br><span class="line">    hanging_node_constraints.<span class="built_in">close</span> ();</span><br><span class="line">    <span class="function">DynamicSparsityPattern <span class="title">dsp</span> <span class="params">(dof_handler.n_dofs(), dof_handler.n_dofs())</span></span>;</span><br><span class="line">    DoFTools::<span class="built_in">make_sparsity_pattern</span> (dof_handler, dsp);</span><br><span class="line">    hanging_node_constraints.<span class="built_in">condense</span> (dsp);</span><br><span class="line">    sparsity_pattern.<span class="built_in">copy_from</span> (dsp);</span><br><span class="line">    system_matrix.<span class="built_in">reinit</span> (sparsity_pattern);</span><br><span class="line">    solution.<span class="built_in">reinit</span> (dof_handler.<span class="built_in">n_dofs</span>());</span><br><span class="line">    system_rhs.<span class="built_in">reinit</span> (dof_handler.<span class="built_in">n_dofs</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用了算法对自由度序号重排，同时又有悬点问题，所以注意上面代码的顺序。<br>组装系统：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> HelmholtzProblem&lt;dim&gt;::<span class="built_in">assemble_system</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">QGauss&lt;dim&gt; <span class="title">quadrature_formula</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    QGauss&lt;dim-1&gt; face_quadrature_formula(3);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> n_q_points = quadrature_formula.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> n_face_q_points = face_quadrature_formula.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> dofs_per_cell = fe-&gt;dofs_per_cell;</span><br><span class="line">    <span class="function">FullMatrix&lt;<span class="keyword">double</span>&gt; <span class="title">cell_matrix</span> <span class="params">(dofs_per_cell, dofs_per_cell)</span></span>;</span><br><span class="line">    <span class="function">Vector&lt;<span class="keyword">double</span>&gt; <span class="title">cell_rhs</span> <span class="params">(dofs_per_cell)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;types::global_dof_index&gt; <span class="title">local_dof_indices</span> <span class="params">(dofs_per_cell)</span></span>;</span><br></pre></td></tr></table></figure>
<p>跟之前不同的是，因为需要计算边界积分，所以需要声明边界积分公式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FEValues&lt;dim&gt; <span class="title">fe_values</span> <span class="params">(*fe, quadrature_formula,</span></span></span><br><span class="line"><span class="function"><span class="params">        update_values | update_gradients |</span></span></span><br><span class="line"><span class="function"><span class="params">        update_quadrature_points | update_JxW_values)</span></span>;</span><br><span class="line"><span class="function">FEFaceValues&lt;dim&gt; <span class="title">fe_face_values</span> <span class="params">(*fe, face_quadrature_formula,</span></span></span><br><span class="line"><span class="function"><span class="params">        update_values | update_quadrature_points |</span></span></span><br><span class="line"><span class="function"><span class="params">        update_normal_vectors | update_JxW_values)</span></span>;</span><br></pre></td></tr></table></figure>
<p>然后是计算积分点上形函数的值、梯度，这些量需要在单元内部和边界上都得计算，两者有一个很大的差别，即单元内部的积分的权重需要测量单元，而边界积分需要在更低维度的流形上测量边界，无论如何，两者的界面是差不多的。注意：内部积分用的是FEValues类，这里需要计算积分点上的值、梯度、权重等，而边界积分用的是FEFaceValues，计算的是积分点上的形函数的值、权重，因为还要计算Neumann边值，所以还要计算法向量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RightHandSide&lt;dim&gt; right_hand_side;</span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">double</span>&gt; <span class="title">rhs_values</span> <span class="params">(n_q_points)</span></span>;</span><br><span class="line"><span class="keyword">const</span> Solution&lt;dim&gt; exact_solution;</span><br></pre></td></tr></table></figure>
<p>然后是存储右端项和精确解的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator</span><br><span class="line">cell = dof_handler.<span class="built_in">begin_active</span>(),</span><br><span class="line">     endc = dof_handler.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">for</span> (; cell!=endc; ++cell)</span><br><span class="line">&#123;</span><br><span class="line">    cell_matrix = <span class="number">0</span>;</span><br><span class="line">    cell_rhs = <span class="number">0</span>;</span><br><span class="line">    fe_values.<span class="built_in">reinit</span> (cell);</span><br><span class="line">    right_hand_side.<span class="built_in">value_list</span> (fe_values.<span class="built_in">get_quadrature_points</span>(),</span><br><span class="line">            rhs_values);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> q_point=<span class="number">0</span>; q_point&lt;n_q_points; ++q_point)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dofs_per_cell; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j=<span class="number">0</span>; j&lt;dofs_per_cell; ++j)</span><br><span class="line">                <span class="built_in">cell_matrix</span>(i,j) += ((fe_values.<span class="built_in">shape_grad</span>(i,q_point) *</span><br><span class="line">                            fe_values.<span class="built_in">shape_grad</span>(j,q_point)</span><br><span class="line">                            +</span><br><span class="line">                            fe_values.<span class="built_in">shape_value</span>(i,q_point) *</span><br><span class="line">                            fe_values.<span class="built_in">shape_value</span>(j,q_point)) *</span><br><span class="line">                        fe_values.<span class="built_in">JxW</span>(q_point));</span><br><span class="line">            <span class="built_in">cell_rhs</span>(i) += (fe_values.<span class="built_in">shape_value</span>(i,q_point) *</span><br><span class="line">                    rhs_values [q_point] *</span><br><span class="line">                    fe_values.<span class="built_in">JxW</span>(q_point));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>以上是对每个单元的循环，单元刚度矩阵中已经根据Holmholtz方程进行了调整。同时上面的右端项的计算仅仅只包含了一项，下面是右端项的第二部分边界积分：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> face_number=<span class="number">0</span>; face_number&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face_number)</span><br><span class="line">    <span class="keyword">if</span> (cell-&gt;<span class="built_in">face</span>(face_number)-&gt;<span class="built_in">at_boundary</span>()</span><br><span class="line">            &amp;&amp;</span><br><span class="line">            (cell-&gt;<span class="built_in">face</span>(face_number)-&gt;<span class="built_in">boundary_id</span>() == <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br></pre></td></tr></table></figure>
<p>首先得找到$\Gamma_2$的边界：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> face_number=<span class="number">0</span>; face_number&lt;GeometryInfo&lt;dim&gt;::faces_per_cell; ++face_number)</span><br><span class="line">    <span class="keyword">if</span> (cell-&gt;<span class="built_in">face</span>(face_number)-&gt;<span class="built_in">at_boundary</span>()</span><br><span class="line">            &amp;&amp;</span><br><span class="line">            (cell-&gt;<span class="built_in">face</span>(face_number)-&gt;<span class="built_in">boundary_id</span>() == <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br></pre></td></tr></table></figure>
<p>这里是判断单元的边界的标识是不是1，我们知道边界默认标识是0，而在后面的run函数中将$\Gamma_2$人为指定成1。如果确认是它，那么就计算形函数的值，这通过reinit才实现，跟FEValues一样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fe_face_values.<span class="built_in">reinit</span> (cell, face_number);</span><br></pre></td></tr></table></figure>
<p>然后就是对积分点的循环：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> q_point=<span class="number">0</span>; q_point&lt;n_face_q_points; ++q_point)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> neumann_value</span><br><span class="line">        = (exact_solution.<span class="built_in">gradient</span> (fe_face_values.<span class="built_in">quadrature_point</span>(q_point)) *</span><br><span class="line">                fe_face_values.<span class="built_in">normal_vector</span>(q_point));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dofs_per_cell; ++i)</span><br><span class="line">        <span class="built_in">cell_rhs</span>(i) += (neumann_value *</span><br><span class="line">                fe_face_values.<span class="built_in">shape_value</span>(i,q_point) *</span><br><span class="line">                fe_face_values.<span class="built_in">JxW</span>(q_point));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，法向导数的值是根据精确解的梯度和法向量的乘积计算得到。<br>然后就是组装系统：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cell-&gt;<span class="built_in">get_dof_indices</span> (local_dof_indices);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dofs_per_cell; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j=<span class="number">0</span>; j&lt;dofs_per_cell; ++j)</span><br><span class="line">        system_matrix.<span class="built_in">add</span> (local_dof_indices[i],</span><br><span class="line">                local_dof_indices[j],</span><br><span class="line">                <span class="built_in">cell_matrix</span>(i,j));</span><br><span class="line">    <span class="built_in">system_rhs</span>(local_dof_indices[i]) += <span class="built_in">cell_rhs</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>施加边界条件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">hanging_node_constraints.<span class="built_in">condense</span> (system_matrix);</span><br><span class="line">hanging_node_constraints.<span class="built_in">condense</span> (system_rhs);</span><br><span class="line">std::map&lt;types::global_dof_index,<span class="keyword">double</span>&gt; boundary_values;</span><br><span class="line">VectorTools::<span class="built_in">interpolate_boundary_values</span> (dof_handler,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        Solution&lt;dim&gt;(),</span><br><span class="line">        boundary_values);</span><br><span class="line">MatrixTools::<span class="built_in">apply_boundary_values</span> (boundary_values,</span><br><span class="line">        system_matrix,</span><br><span class="line">        solution,</span><br><span class="line">        system_rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：上面的边界中只包含了$\Gamma_1$，这正是我们想要的。<br>求解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> HelmholtzProblem&lt;dim&gt;::<span class="built_in">solve</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">SolverControl <span class="title">solver_control</span> <span class="params">(<span class="number">1000</span>, <span class="number">1e-12</span>)</span></span>;</span><br><span class="line">    SolverCG&lt;&gt; <span class="built_in">cg</span> (solver_control);</span><br><span class="line">    PreconditionSSOR&lt;&gt; preconditioner;</span><br><span class="line">    preconditioner.<span class="built_in">initialize</span>(system_matrix, <span class="number">1.2</span>);</span><br><span class="line">    cg.<span class="built_in">solve</span> (system_matrix, solution, system_rhs,</span><br><span class="line">            preconditioner);</span><br><span class="line">    hanging_node_constraints.<span class="built_in">distribute</span> (solution);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是细化网格。根据传递给构造函数的参数决定是自适应细化还是全局细化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> HelmholtzProblem&lt;dim&gt;::<span class="built_in">refine_grid</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (refinement_mode)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> global_refinement:</span><br><span class="line">            &#123;</span><br><span class="line">                triangulation.<span class="built_in">refine_global</span> (<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> adaptive_refinement:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function">Vector&lt;<span class="keyword">float</span>&gt; <span class="title">estimated_error_per_cell</span> <span class="params">(triangulation.n_active_cells())</span></span>;</span><br><span class="line">                KellyErrorEstimator&lt;dim&gt;::<span class="built_in">estimate</span> (dof_handler,</span><br><span class="line">                        QGauss&lt;dim<span class="number">-1</span>&gt;(<span class="number">3</span>),</span><br><span class="line">                        <span class="keyword">typename</span> FunctionMap&lt;dim&gt;::<span class="built_in">type</span>(),</span><br><span class="line">                        solution,</span><br><span class="line">                        estimated_error_per_cell);</span><br><span class="line">                GridRefinement::<span class="built_in">refine_and_coarsen_fixed_number</span> (triangulation,</span><br><span class="line">                        estimated_error_per_cell,</span><br><span class="line">                        <span class="number">0.3</span>, <span class="number">0.03</span>);</span><br><span class="line">                triangulation.<span class="built_in">execute_coarsening_and_refinement</span> ();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Assert</span> (<span class="literal">false</span>, <span class="built_in">ExcNotImplemented</span>());</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>细化方案跟之前相同，不多说，注意最后的缺省情形不要忘加。<br>下一步就是对解的处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> HelmholtzProblem&lt;dim&gt;::<span class="built_in">process_solution</span> (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> cycle)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Vector&lt;<span class="keyword">float</span>&gt; <span class="title">difference_per_cell</span> <span class="params">(triangulation.n_active_cells())</span></span>;</span><br><span class="line">    VectorTools::<span class="built_in">integrate_difference</span> (dof_handler,</span><br><span class="line">            solution,</span><br><span class="line">            Solution&lt;dim&gt;(),</span><br><span class="line">            difference_per_cell,</span><br><span class="line">            QGauss&lt;dim&gt;(<span class="number">3</span>),</span><br><span class="line">            VectorTools::L2_norm);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> L2_error = difference_per_cell.<span class="built_in">l2_norm</span>();</span><br></pre></td></tr></table></figure>
<p>首先是计算误差范数。创建一个Vector来存放每个单元上的误差值。然后计算L2范数，接收的参数是DoFHandler对象、数值解的节点值、精确解、存放每个单元上的误差值的量、计算该范数的积分公式、范数类型。<br>然后计算H1范数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ectorTools::<span class="built_in">integrate_difference</span> (dof_handler,</span><br><span class="line">        solution,</span><br><span class="line">        Solution&lt;dim&gt;(),</span><br><span class="line">        difference_per_cell,</span><br><span class="line">        QGauss&lt;dim&gt;(<span class="number">3</span>),</span><br><span class="line">        VectorTools::H1_seminorm);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> H1_error = difference_per_cell.<span class="built_in">l2_norm</span>();</span><br></pre></td></tr></table></figure>
<p>然后计算最大范数，当然也是在积分点上的最大范数，不可能是全局最大范数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> QTrapez&lt;<span class="number">1</span>&gt; q_trapez;</span><br><span class="line"><span class="function"><span class="keyword">const</span> QIterated&lt;dim&gt; <span class="title">q_iterated</span> <span class="params">(q_trapez, <span class="number">5</span>)</span></span>;</span><br><span class="line">VectorTools::<span class="built_in">integrate_difference</span> (dof_handler,</span><br><span class="line">        solution,</span><br><span class="line">        Solution&lt;dim&gt;(),</span><br><span class="line">        difference_per_cell,</span><br><span class="line">        q_iterated,</span><br><span class="line">        VectorTools::Linfty_norm);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Linfty_error = difference_per_cell.<span class="built_in">linfty_norm</span>();</span><br></pre></td></tr></table></figure>
<p>然后将所有结果输出到表格中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> n_active_cells=triangulation.<span class="built_in">n_active_cells</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> n_dofs=dof_handler.<span class="built_in">n_dofs</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="string">&#x27;:&#x27;</span></span><br><span class="line">    &lt;&lt; std::endl</span><br><span class="line">    &lt;&lt; <span class="string">&quot; Number of active cells: &quot;</span></span><br><span class="line">    &lt;&lt; n_active_cells</span><br><span class="line">    &lt;&lt; std::endl</span><br><span class="line">    &lt;&lt; <span class="string">&quot; Number of degrees of freedom: &quot;</span></span><br><span class="line">    &lt;&lt; n_dofs</span><br><span class="line">    &lt;&lt; std::endl;</span><br><span class="line">convergence_table.<span class="built_in">add_value</span>(<span class="string">&quot;cycle&quot;</span>, cycle);</span><br><span class="line">convergence_table.<span class="built_in">add_value</span>(<span class="string">&quot;cells&quot;</span>, n_active_cells);</span><br><span class="line">convergence_table.<span class="built_in">add_value</span>(<span class="string">&quot;dofs&quot;</span>, n_dofs);</span><br><span class="line">convergence_table.<span class="built_in">add_value</span>(<span class="string">&quot;L2&quot;</span>, L2_error);</span><br><span class="line">convergence_table.<span class="built_in">add_value</span>(<span class="string">&quot;H1&quot;</span>, H1_error);</span><br><span class="line">convergence_table.<span class="built_in">add_value</span>(<span class="string">&quot;Linfty&quot;</span>, Linfty_error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是run函数，控制程序的运行过程。与之前不同的是，需要先设定好边界标识，这里是根据坐标值来确定。而且是对所有单元循环，不仅仅是活动单元，这是因为细化时子网格会继承父网格的边界标识，如果仅细化活动单元，之前定义的边界就继承不下来。当然也可以在细化之前对最初的粗网格进行标识，然后再细化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> HelmholtzProblem&lt;dim&gt;::<span class="built_in">run</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> n_cycles = (refinement_mode==global_refinement)?<span class="number">5</span>:<span class="number">9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> cycle=<span class="number">0</span>; cycle&lt;n_cycles; ++cycle)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cycle == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GridGenerator::<span class="built_in">hyper_cube</span> (triangulation, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">            triangulation.<span class="built_in">refine_global</span> (<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">typename</span> Triangulation&lt;dim&gt;::cell_iterator</span><br><span class="line">                cell = triangulation.<span class="built_in">begin</span> (),</span><br><span class="line">                     endc = triangulation.<span class="built_in">end</span>();</span><br><span class="line">            <span class="keyword">for</span> (; cell!=endc; ++cell)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> face_number=<span class="number">0</span>;</span><br><span class="line">                        face_number&lt;GeometryInfo&lt;dim&gt;::faces_per_cell;</span><br><span class="line">                        ++face_number)</span><br><span class="line">                    <span class="keyword">if</span> ((std::<span class="built_in">fabs</span>(cell-&gt;<span class="built_in">face</span>(face_number)-&gt;<span class="built_in">center</span>()(<span class="number">0</span>) - (<span class="number">-1</span>)) &lt; <span class="number">1e-12</span>)</span><br><span class="line">                            ||</span><br><span class="line">                            (std::<span class="built_in">fabs</span>(cell-&gt;<span class="built_in">face</span>(face_number)-&gt;<span class="built_in">center</span>()(<span class="number">1</span>) - (<span class="number">-1</span>)) &lt; <span class="number">1e-12</span>))</span><br><span class="line">                        cell-&gt;<span class="built_in">face</span>(face_number)-&gt;<span class="built_in">set_boundary_id</span> (<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">refine_grid</span> ();</span><br><span class="line">        <span class="built_in">setup_system</span> ();</span><br><span class="line">        <span class="built_in">assemble_system</span> ();</span><br><span class="line">        <span class="built_in">solve</span> ();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">process_solution</span> (cycle);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在最后一步迭代后，输出最细网格上的解。输出文件根据细化方式、单元类型来命名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">std::string vtk_filename;</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (refinement_mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> global_refinement:</span><br><span class="line">        vtk_filename = <span class="string">&quot;solution-global&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> adaptive_refinement:</span><br><span class="line">        vtk_filename = <span class="string">&quot;solution-adaptive&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">Assert</span> (<span class="literal">false</span>, <span class="built_in">ExcNotImplemented</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (fe-&gt;degree)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        vtk_filename += <span class="string">&quot;-q1&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        vtk_filename += <span class="string">&quot;-q2&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">Assert</span> (<span class="literal">false</span>, <span class="built_in">ExcNotImplemented</span>());</span><br><span class="line">&#125;</span><br><span class="line">vtk_filename += <span class="string">&quot;.vtk&quot;</span>;</span><br><span class="line"><span class="function">std::ofstream <span class="title">output</span> <span class="params">(vtk_filename.c_str())</span></span>;</span><br><span class="line">DataOut&lt;dim&gt; data_out;</span><br><span class="line">data_out.<span class="built_in">attach_dof_handler</span> (dof_handler);</span><br><span class="line">data_out.<span class="built_in">add_data_vector</span> (solution, <span class="string">&quot;solution&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>下面就是建立中间格式的数据。跟以前不同的是，我们这里有时会使用双二次单元。但大多数的输出格式仅支持双线性数据，如果强行转换就会丢失部分数据。当然我们不能改变图像处理程序的输入文件的格式，但可以变着花样写出来。比如把每个单元分成有双线性数据的四个单元。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data_out.<span class="built_in">build_patches</span> (fe-&gt;degree);</span><br><span class="line">data_out.<span class="built_in">write_vtk</span> (output);</span><br></pre></td></tr></table></figure>
<p>build_patches接收一个参数，表明每个单元的单个方向上应该划分成几个子单元。<br>然后是输出误差表格：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">convergence_table.<span class="built_in">set_precision</span>(<span class="string">&quot;L2&quot;</span>, <span class="number">3</span>);</span><br><span class="line">convergence_table.<span class="built_in">set_precision</span>(<span class="string">&quot;H1&quot;</span>, <span class="number">3</span>);</span><br><span class="line">convergence_table.<span class="built_in">set_precision</span>(<span class="string">&quot;Linfty&quot;</span>, <span class="number">3</span>);</span><br><span class="line">convergence_table.<span class="built_in">set_scientific</span>(<span class="string">&quot;L2&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">convergence_table.<span class="built_in">set_scientific</span>(<span class="string">&quot;H1&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">convergence_table.<span class="built_in">set_scientific</span>(<span class="string">&quot;Linfty&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">convergence_table.<span class="built_in">set_tex_caption</span>(<span class="string">&quot;cells&quot;</span>, <span class="string">&quot;\\# cells&quot;</span>);</span><br><span class="line">convergence_table.<span class="built_in">set_tex_caption</span>(<span class="string">&quot;dofs&quot;</span>, <span class="string">&quot;\\# dofs&quot;</span>);</span><br><span class="line">convergence_table.<span class="built_in">set_tex_caption</span>(<span class="string">&quot;L2&quot;</span>, <span class="string">&quot;L^2-error&quot;</span>);</span><br><span class="line">convergence_table.<span class="built_in">set_tex_caption</span>(<span class="string">&quot;H1&quot;</span>, <span class="string">&quot;H^1-error&quot;</span>);</span><br><span class="line">convergence_table.<span class="built_in">set_tex_caption</span>(<span class="string">&quot;Linfty&quot;</span>, <span class="string">&quot;L^\\infty-error&quot;</span>);</span><br><span class="line">convergence_table.<span class="built_in">set_tex_format</span>(<span class="string">&quot;cells&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">convergence_table.<span class="built_in">set_tex_format</span>(<span class="string">&quot;dofs&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line">convergence_table.<span class="built_in">write_text</span>(std::cout);</span><br><span class="line">std::string error_filename = <span class="string">&quot;error&quot;</span>;</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (refinement_mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> global_refinement:</span><br><span class="line">        error_filename += <span class="string">&quot;-global&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> adaptive_refinement:</span><br><span class="line">        error_filename += <span class="string">&quot;-adaptive&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">Assert</span> (<span class="literal">false</span>, <span class="built_in">ExcNotImplemented</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (fe-&gt;degree)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        error_filename += <span class="string">&quot;-q1&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        error_filename += <span class="string">&quot;-q2&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">Assert</span> (<span class="literal">false</span>, <span class="built_in">ExcNotImplemented</span>());</span><br><span class="line">&#125;</span><br><span class="line">error_filename += <span class="string">&quot;.tex&quot;</span>;</span><br><span class="line"><span class="function">std::ofstream <span class="title">error_table_file</span><span class="params">(error_filename.c_str())</span></span>;</span><br><span class="line">convergence_table.<span class="built_in">write_tex</span>(error_table_file);</span><br></pre></td></tr></table></figure>
<p>这里面包含了输出成TeX的格式。<br>对于全局细化的话，还可以输出收敛速率：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (refinement_mode==global_refinement)</span><br><span class="line">&#123;</span><br><span class="line">    convergence_table.<span class="built_in">add_column_to_supercolumn</span>(<span class="string">&quot;cycle&quot;</span>, <span class="string">&quot;n cells&quot;</span>);</span><br><span class="line">    convergence_table.<span class="built_in">add_column_to_supercolumn</span>(<span class="string">&quot;cells&quot;</span>, <span class="string">&quot;n cells&quot;</span>);</span><br><span class="line">    std::vector&lt;std::string&gt; new_order;</span><br><span class="line">    new_order.<span class="built_in">push_back</span>(<span class="string">&quot;n cells&quot;</span>);</span><br><span class="line">    new_order.<span class="built_in">push_back</span>(<span class="string">&quot;H1&quot;</span>);</span><br><span class="line">    new_order.<span class="built_in">push_back</span>(<span class="string">&quot;L2&quot;</span>);</span><br><span class="line">    convergence_table.<span class="built_in">set_column_order</span> (new_order);</span><br><span class="line">    convergence_table</span><br><span class="line">        .<span class="built_in">evaluate_convergence_rates</span>(<span class="string">&quot;L2&quot;</span>, ConvergenceTable::reduction_rate);</span><br><span class="line">    convergence_table</span><br><span class="line">        .<span class="built_in">evaluate_convergence_rates</span>(<span class="string">&quot;L2&quot;</span>, ConvergenceTable::reduction_rate_log2);</span><br><span class="line">    convergence_table</span><br><span class="line">        .<span class="built_in">evaluate_convergence_rates</span>(<span class="string">&quot;H1&quot;</span>, ConvergenceTable::reduction_rate);</span><br><span class="line">    convergence_table</span><br><span class="line">        .<span class="built_in">evaluate_convergence_rates</span>(<span class="string">&quot;H1&quot;</span>, ConvergenceTable::reduction_rate_log2);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    convergence_table.<span class="built_in">write_text</span>(std::cout);</span><br><span class="line">    std::string conv_filename = <span class="string">&quot;convergence&quot;</span>;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (refinement_mode)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> global_refinement:</span><br><span class="line">            conv_filename += <span class="string">&quot;-global&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> adaptive_refinement:</span><br><span class="line">            conv_filename += <span class="string">&quot;-adaptive&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">Assert</span> (<span class="literal">false</span>, <span class="built_in">ExcNotImplemented</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (fe-&gt;degree)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            conv_filename += <span class="string">&quot;-q1&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            conv_filename += <span class="string">&quot;-q2&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">Assert</span> (<span class="literal">false</span>, <span class="built_in">ExcNotImplemented</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    conv_filename += <span class="string">&quot;.tex&quot;</span>;</span><br><span class="line">    <span class="function">std::ofstream <span class="title">table_file</span><span class="params">(conv_filename.c_str())</span></span>;</span><br><span class="line">    convergence_table.<span class="built_in">write_tex</span>(table_file);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是main函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> dim = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> dealii;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> Step7;</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Solving with Q1 elements, adaptive refinement&quot;</span> &lt;&lt; std::endl</span><br><span class="line">                &lt;&lt; <span class="string">&quot;=============================================&quot;</span> &lt;&lt; std::endl</span><br><span class="line">                &lt;&lt; std::endl;</span><br><span class="line">            <span class="function">FE_Q&lt;dim&gt; <span class="title">fe</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">            HelmholtzProblem&lt;dim&gt;</span><br><span class="line">                <span class="built_in">helmholtz_problem_2d</span> (fe, HelmholtzProblem&lt;dim&gt;::adaptive_refinement);</span><br><span class="line">            helmholtz_problem_2d.<span class="built_in">run</span> ();</span><br><span class="line">            std::cout &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Solving with Q1 elements, global refinement&quot;</span> &lt;&lt; std::endl</span><br><span class="line">                &lt;&lt; <span class="string">&quot;===========================================&quot;</span> &lt;&lt; std::endl</span><br><span class="line">                &lt;&lt; std::endl;</span><br><span class="line">            <span class="function">FE_Q&lt;dim&gt; <span class="title">fe</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">            HelmholtzProblem&lt;dim&gt;</span><br><span class="line">                <span class="built_in">helmholtz_problem_2d</span> (fe, HelmholtzProblem&lt;dim&gt;::global_refinement);</span><br><span class="line">            helmholtz_problem_2d.<span class="built_in">run</span> ();</span><br><span class="line">            std::cout &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Solving with Q2 elements, global refinement&quot;</span> &lt;&lt; std::endl</span><br><span class="line">                &lt;&lt; <span class="string">&quot;===========================================&quot;</span> &lt;&lt; std::endl</span><br><span class="line">                &lt;&lt; std::endl;</span><br><span class="line">            <span class="function">FE_Q&lt;dim&gt; <span class="title">fe</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">            HelmholtzProblem&lt;dim&gt;</span><br><span class="line">                <span class="built_in">helmholtz_problem_2d</span> (fe, HelmholtzProblem&lt;dim&gt;::global_refinement);</span><br><span class="line">            helmholtz_problem_2d.<span class="built_in">run</span> ();</span><br><span class="line">            std::cout &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Solving with Q2 elements, adaptive refinement&quot;</span> &lt;&lt; std::endl</span><br><span class="line">                &lt;&lt; <span class="string">&quot;===========================================&quot;</span> &lt;&lt; std::endl</span><br><span class="line">                &lt;&lt; std::endl;</span><br><span class="line">            <span class="function">FE_Q&lt;dim&gt; <span class="title">fe</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">            HelmholtzProblem&lt;dim&gt;</span><br><span class="line">                <span class="built_in">helmholtz_problem_2d</span> (fe, HelmholtzProblem&lt;dim&gt;::adaptive_refinement);</span><br><span class="line">            helmholtz_problem_2d.<span class="built_in">run</span> ();</span><br><span class="line">            std::cout &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (std::exception &amp;exc)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; exc.<span class="built_in">what</span>() &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="计算结果"><a href="#计算结果" class="headerlink" title="计算结果"></a>计算结果</h1><p>以下是使用双二次单元的自适应计算的结果：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjk8u4xgkj30qx0k50tt.jpg"><br>收敛性结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">Solving with Q1 elements, adaptive refinement</span><br><span class="line">=============================================</span><br><span class="line">Cycle <span class="number">0</span>:</span><br><span class="line">Number of active cells: <span class="number">64</span></span><br><span class="line">Number of degrees of freedom: <span class="number">81</span></span><br><span class="line">Cycle <span class="number">1</span>:</span><br><span class="line">Number of active cells: <span class="number">124</span></span><br><span class="line">Number of degrees of freedom: <span class="number">157</span></span><br><span class="line">Cycle <span class="number">2</span>:</span><br><span class="line">Number of active cells: <span class="number">280</span></span><br><span class="line">Number of degrees of freedom: <span class="number">341</span></span><br><span class="line">Cycle <span class="number">3</span>:</span><br><span class="line">Number of active cells: <span class="number">577</span></span><br><span class="line">Number of degrees of freedom: <span class="number">690</span></span><br><span class="line">Cycle <span class="number">4</span>:</span><br><span class="line">Number of active cells: <span class="number">1099</span></span><br><span class="line">Number of degrees of freedom: <span class="number">1264</span></span><br><span class="line">Cycle <span class="number">5</span>:</span><br><span class="line">Number of active cells: <span class="number">2191</span></span><br><span class="line">Number of degrees of freedom: <span class="number">2452</span></span><br><span class="line">Cycle <span class="number">6</span>:</span><br><span class="line">Number of active cells: <span class="number">4165</span></span><br><span class="line">Number of degrees of freedom: <span class="number">4510</span></span><br><span class="line">Cycle <span class="number">7</span>:</span><br><span class="line">Number of active cells: <span class="number">7915</span></span><br><span class="line">Number of degrees of freedom: <span class="number">8440</span></span><br><span class="line">Cycle <span class="number">8</span>:</span><br><span class="line">Number of active cells: <span class="number">15196</span></span><br><span class="line">Number of degrees of freedom: <span class="number">15912</span></span><br><span class="line">cycle cells dofs L2 H1 Linfty</span><br><span class="line"><span class="number">0</span> <span class="number">64</span> <span class="number">81</span> <span class="number">1.576e-01</span> <span class="number">1.418e+00</span> <span class="number">2.707e-01</span></span><br><span class="line"><span class="number">1</span> <span class="number">124</span> <span class="number">157</span> <span class="number">4.285e-02</span> <span class="number">1.285e+00</span> <span class="number">1.469e-01</span></span><br><span class="line"><span class="number">2</span> <span class="number">280</span> <span class="number">341</span> <span class="number">1.593e-02</span> <span class="number">7.909e-01</span> <span class="number">8.034e-02</span></span><br><span class="line"><span class="number">3</span> <span class="number">577</span> <span class="number">690</span> <span class="number">9.359e-03</span> <span class="number">5.096e-01</span> <span class="number">2.784e-02</span></span><br><span class="line"><span class="number">4</span> <span class="number">1099</span> <span class="number">1264</span> <span class="number">2.865e-03</span> <span class="number">3.038e-01</span> <span class="number">9.822e-03</span></span><br><span class="line"><span class="number">5</span> <span class="number">2191</span> <span class="number">2452</span> <span class="number">1.480e-03</span> <span class="number">2.106e-01</span> <span class="number">5.679e-03</span></span><br><span class="line"><span class="number">6</span> <span class="number">4165</span> <span class="number">4510</span> <span class="number">6.907e-04</span> <span class="number">1.462e-01</span> <span class="number">2.338e-03</span></span><br><span class="line"><span class="number">7</span> <span class="number">7915</span> <span class="number">8440</span> <span class="number">4.743e-04</span> <span class="number">1.055e-01</span> <span class="number">1.442e-03</span></span><br><span class="line"><span class="number">8</span> <span class="number">15196</span> <span class="number">15912</span> <span class="number">1.920e-04</span> <span class="number">7.468e-02</span> <span class="number">7.259e-04</span></span><br><span class="line">Solving with Q1 elements, global refinement</span><br><span class="line">===========================================</span><br><span class="line">Cycle <span class="number">0</span>:</span><br><span class="line">Number of active cells: <span class="number">64</span></span><br><span class="line">Number of degrees of freedom: <span class="number">81</span></span><br><span class="line">Cycle <span class="number">1</span>:</span><br><span class="line">Number of active cells: <span class="number">256</span></span><br><span class="line">Number of degrees of freedom: <span class="number">289</span></span><br><span class="line">Cycle <span class="number">2</span>:</span><br><span class="line">Number of active cells: <span class="number">1024</span></span><br><span class="line">Number of degrees of freedom: <span class="number">1089</span></span><br><span class="line">Cycle <span class="number">3</span>:</span><br><span class="line">Number of active cells: <span class="number">4096</span></span><br><span class="line">Number of degrees of freedom: <span class="number">4225</span></span><br><span class="line">Cycle <span class="number">4</span>:</span><br><span class="line">Number of active cells: <span class="number">16384</span></span><br><span class="line">Number of degrees of freedom: <span class="number">16641</span></span><br><span class="line">cycle cells dofs L2 H1 Linfty</span><br><span class="line"><span class="number">0</span> <span class="number">64</span> <span class="number">81</span> <span class="number">1.576e-01</span> <span class="number">1.418e+00</span> <span class="number">2.707e-01</span></span><br><span class="line"><span class="number">1</span> <span class="number">256</span> <span class="number">289</span> <span class="number">4.280e-02</span> <span class="number">1.285e+00</span> <span class="number">1.444e-01</span></span><br><span class="line"><span class="number">2</span> <span class="number">1024</span> <span class="number">1089</span> <span class="number">1.352e-02</span> <span class="number">7.556e-01</span> <span class="number">7.772e-02</span></span><br><span class="line"><span class="number">3</span> <span class="number">4096</span> <span class="number">4225</span> <span class="number">3.423e-03</span> <span class="number">3.822e-01</span> <span class="number">2.332e-02</span></span><br><span class="line"><span class="number">4</span> <span class="number">16384</span> <span class="number">16641</span> <span class="number">8.586e-04</span> <span class="number">1.917e-01</span> <span class="number">6.097e-03</span></span><br><span class="line">n cells H1 L2</span><br><span class="line"><span class="number">0</span> <span class="number">64</span> <span class="number">1.418e+00</span> - - <span class="number">1.576e-01</span> - -</span><br><span class="line"><span class="number">1</span> <span class="number">256</span> <span class="number">1.285e+00</span> <span class="number">1.10</span> <span class="number">0.14</span> <span class="number">4.280e-02</span> <span class="number">3.68</span> <span class="number">1.88</span></span><br><span class="line"><span class="number">2</span> <span class="number">1024</span> <span class="number">7.556e-01</span> <span class="number">1.70</span> <span class="number">0.77</span> <span class="number">1.352e-02</span> <span class="number">3.17</span> <span class="number">1.66</span></span><br><span class="line"><span class="number">3</span> <span class="number">4096</span> <span class="number">3.822e-01</span> <span class="number">1.98</span> <span class="number">0.98</span> <span class="number">3.423e-03</span> <span class="number">3.95</span> <span class="number">1.98</span></span><br><span class="line"><span class="number">4</span> <span class="number">16384</span> <span class="number">1.917e-01</span> <span class="number">1.99</span> <span class="number">1.00</span> <span class="number">8.586e-04</span> <span class="number">3.99</span> <span class="number">2.00</span></span><br><span class="line">Solving with Q2 elements, global refinement</span><br><span class="line">===========================================</span><br><span class="line">Cycle <span class="number">0</span>:</span><br><span class="line">Number of active cells: <span class="number">64</span></span><br><span class="line">Number of degrees of freedom: <span class="number">289</span></span><br><span class="line">Cycle <span class="number">1</span>:</span><br><span class="line">Number of active cells: <span class="number">256</span></span><br><span class="line">Number of degrees of freedom: <span class="number">1089</span></span><br><span class="line">Cycle <span class="number">2</span>:</span><br><span class="line">Number of active cells: <span class="number">1024</span></span><br><span class="line">Number of degrees of freedom: <span class="number">4225</span></span><br><span class="line">Cycle <span class="number">3</span>:</span><br><span class="line">Number of active cells: <span class="number">4096</span></span><br><span class="line">Number of degrees of freedom: <span class="number">16641</span></span><br><span class="line">Cycle <span class="number">4</span>:</span><br><span class="line">Number of active cells: <span class="number">16384</span></span><br><span class="line">Number of degrees of freedom: <span class="number">66049</span></span><br><span class="line">cycle cells dofs L2 H1 Linfty</span><br><span class="line"><span class="number">0</span> <span class="number">64</span> <span class="number">289</span> <span class="number">1.606e-01</span> <span class="number">1.278e+00</span> <span class="number">3.029e-01</span></span><br><span class="line"><span class="number">1</span> <span class="number">256</span> <span class="number">1089</span> <span class="number">7.638e-03</span> <span class="number">5.248e-01</span> <span class="number">4.816e-02</span></span><br><span class="line"><span class="number">2</span> <span class="number">1024</span> <span class="number">4225</span> <span class="number">8.601e-04</span> <span class="number">1.086e-01</span> <span class="number">4.827e-03</span></span><br><span class="line"><span class="number">3</span> <span class="number">4096</span> <span class="number">16641</span> <span class="number">1.107e-04</span> <span class="number">2.756e-02</span> <span class="number">7.802e-04</span></span><br><span class="line"><span class="number">4</span> <span class="number">16384</span> <span class="number">66049</span> <span class="number">1.393e-05</span> <span class="number">6.915e-03</span> <span class="number">9.971e-05</span></span><br><span class="line">n cells H1 L2</span><br><span class="line"><span class="number">0</span> <span class="number">64</span> <span class="number">1.278e+00</span> - - <span class="number">1.606e-01</span> - -</span><br><span class="line"><span class="number">1</span> <span class="number">256</span> <span class="number">5.248e-01</span> <span class="number">2.43</span> <span class="number">1.28</span> <span class="number">7.638e-03</span> <span class="number">21.03</span> <span class="number">4.39</span></span><br><span class="line"><span class="number">2</span> <span class="number">1024</span> <span class="number">1.086e-01</span> <span class="number">4.83</span> <span class="number">2.27</span> <span class="number">8.601e-04</span> <span class="number">8.88</span> <span class="number">3.15</span></span><br><span class="line"><span class="number">3</span> <span class="number">4096</span> <span class="number">2.756e-02</span> <span class="number">3.94</span> <span class="number">1.98</span> <span class="number">1.107e-04</span> <span class="number">7.77</span> <span class="number">2.96</span></span><br><span class="line"><span class="number">4</span> <span class="number">16384</span> <span class="number">6.915e-03</span> <span class="number">3.99</span> <span class="number">1.99</span> <span class="number">1.393e-05</span> <span class="number">7.94</span> <span class="number">2.99</span></span><br><span class="line">Solving with Q2 elements, adaptive refinement</span><br><span class="line">===========================================</span><br><span class="line">Cycle <span class="number">0</span>:</span><br><span class="line">Number of active cells: <span class="number">64</span></span><br><span class="line">Number of degrees of freedom: <span class="number">289</span></span><br><span class="line">Cycle <span class="number">1</span>:</span><br><span class="line">Number of active cells: <span class="number">124</span></span><br><span class="line">Number of degrees of freedom: <span class="number">577</span></span><br><span class="line">Cycle <span class="number">2</span>:</span><br><span class="line">Number of active cells: <span class="number">289</span></span><br><span class="line">Number of degrees of freedom: <span class="number">1353</span></span><br><span class="line">Cycle <span class="number">3</span>:</span><br><span class="line">Number of active cells: <span class="number">547</span></span><br><span class="line">Number of degrees of freedom: <span class="number">2531</span></span><br><span class="line">Cycle <span class="number">4</span>:</span><br><span class="line">Number of active cells: <span class="number">1057</span></span><br><span class="line">Number of degrees of freedom: <span class="number">4919</span></span><br><span class="line">Cycle <span class="number">5</span>:</span><br><span class="line">Number of active cells: <span class="number">2059</span></span><br><span class="line">Number of degrees of freedom: <span class="number">9223</span></span><br><span class="line">Cycle <span class="number">6</span>:</span><br><span class="line">Number of active cells: <span class="number">3913</span></span><br><span class="line">Number of degrees of freedom: <span class="number">17887</span></span><br><span class="line">Cycle <span class="number">7</span>:</span><br><span class="line">Number of active cells: <span class="number">7441</span></span><br><span class="line">Number of degrees of freedom: <span class="number">33807</span></span><br><span class="line">Cycle <span class="number">8</span>:</span><br><span class="line">Number of active cells: <span class="number">14212</span></span><br><span class="line">Number of degrees of freedom: <span class="number">64731</span></span><br><span class="line">cycle cells dofs L2 H1 Linfty</span><br><span class="line"><span class="number">0</span> <span class="number">64</span> <span class="number">289</span> <span class="number">1.606e-01</span> <span class="number">1.278e+00</span> <span class="number">3.029e-01</span></span><br><span class="line"><span class="number">1</span> <span class="number">124</span> <span class="number">577</span> <span class="number">7.891e-03</span> <span class="number">5.256e-01</span> <span class="number">4.852e-02</span></span><br><span class="line"><span class="number">2</span> <span class="number">289</span> <span class="number">1353</span> <span class="number">1.070e-03</span> <span class="number">1.155e-01</span> <span class="number">4.868e-03</span></span><br><span class="line"><span class="number">3</span> <span class="number">547</span> <span class="number">2531</span> <span class="number">5.962e-04</span> <span class="number">5.101e-02</span> <span class="number">1.876e-03</span></span><br><span class="line"><span class="number">4</span> <span class="number">1057</span> <span class="number">4919</span> <span class="number">1.977e-04</span> <span class="number">3.094e-02</span> <span class="number">7.923e-04</span></span><br><span class="line"><span class="number">5</span> <span class="number">2059</span> <span class="number">9223</span> <span class="number">7.738e-05</span> <span class="number">1.974e-02</span> <span class="number">7.270e-04</span></span><br><span class="line"><span class="number">6</span> <span class="number">3913</span> <span class="number">17887</span> <span class="number">2.925e-05</span> <span class="number">8.772e-03</span> <span class="number">1.463e-04</span></span><br><span class="line"><span class="number">7</span> <span class="number">7441</span> <span class="number">33807</span> <span class="number">1.024e-05</span> <span class="number">4.121e-03</span> <span class="number">8.567e-05</span></span><br><span class="line"><span class="number">8</span> <span class="number">14212</span> <span class="number">64731</span> <span class="number">3.761e-06</span> <span class="number">2.108e-03</span> <span class="number">2.167e-05</span> </span><br></pre></td></tr></table></figure>

<h1 id="进一步扩展"><a href="#进一步扩展" class="headerlink" title="进一步扩展"></a>进一步扩展</h1><h2 id="更高阶的单元"><a href="#更高阶的单元" class="headerlink" title="更高阶的单元"></a>更高阶的单元</h2><p>如果使用更高阶的单元，如Q3、Q4，可能就会触发一些异常，比如文件保存阶段。即使把这些错误修正了，也不能产生理论预测的正确的收敛结果，这是因为积分公式的次数不够，而这是在程序中硬编码的。那么如何动态地选择这个次数呢？</p>
<h2 id="收敛性对比"><a href="#收敛性对比" class="headerlink" title="收敛性对比"></a>收敛性对比</h2><p>Q1单元和Q2哪个更好？自适应细化和全局细化哪个更好？<br>注意：峰的半宽影响自适应或全局细化哪个更好。如果解足够光滑，那么局部细化比全局细化没有优势。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Xin-Bo Qi(亓欣波)"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Xin-Bo Qi(亓欣波)</p>
  <div class="site-description" itemprop="description">Be interesting!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">120</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/qixinbo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;qixinbo" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:qixinbo@gmail.com" title="E-Mail → mailto:qixinbo@gmail.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.tsinghua.edu.cn/" title="https:&#x2F;&#x2F;www.tsinghua.edu.cn" rel="noopener" target="_blank">THU</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.imr.cas.cn/" title="http:&#x2F;&#x2F;www.imr.cas.cn" rel="noopener" target="_blank">IMR</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.sdu.edu.cn/" title="http:&#x2F;&#x2F;www.sdu.edu.cn" rel="noopener" target="_blank">SDU</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://liam0205.me/" title="http:&#x2F;&#x2F;liam0205.me&#x2F;" rel="noopener" target="_blank">黄晨成</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xin-Bo Qi(亓欣波)</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://qixinbo.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
