<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"qixinbo.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Be interesting!">
<meta property="og:type" content="website">
<meta property="og:title" content="亓欣波">
<meta property="og:url" content="http://qixinbo.github.io/page/8/index.html">
<meta property="og:site_name" content="亓欣波">
<meta property="og:description" content="Be interesting!">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Xin-Bo Qi(亓欣波)">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://qixinbo.github.io/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>亓欣波</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">亓欣波</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Hi, I am Xin-Bo Qi (亓欣波)</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-scholar">

    <a href="/scholar/" rel="section"><i class="bar-chart fa-fw"></i>scholar</a>

  </li>
        <li class="menu-item menu-item-sources">

    <a href="/sources/" rel="section"><i class="rss fa-fw"></i>sources</a>

  </li>
        <li class="menu-item menu-item-gallery">

    <a href="/gallery/" rel="section"><i class="file-image-o fa-fw"></i>gallery</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404.html" rel="section"><i class="heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2017/07/09/cplusplus-template/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Be interesting!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亓欣波">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/07/09/cplusplus-template/" class="post-title-link" itemprop="url">C++模板深度解析 (转载)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-07-09 00:00:00" itemprop="dateCreated datePublished" datetime="2017-07-09T00:00:00+08:00">2017-07-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 15:20:30" itemprop="dateModified" datetime="2021-03-25T15:20:30+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">programming</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2017/07/09/cplusplus-template/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/09/cplusplus-template/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文转载自<a target="_blank" rel="noopener" href="http://www.cnblogs.com/L-hq815/archive/2012/08/01/2619135.html">这里</a>，修正了一些格式和文字错误。</p>
<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>在C++发明阶段，C++之父Stroustrup和贝尔实验室的C++小组对原先的宏方法进行了修订，对其进行了简化并将它从预处理范围移入了编译器。这种新的代码替换装置被称为模板，而且它变现了完全不同的代码重用方法：模板对源代码重用，而不是通过继承和组合重用对象代码。当用户使用模板时，参数由编译器来替换，这非常像原来的宏方法，却更清晰，更容易使用。</p>
<p>模板使类和函数可在编译时定义所需处理和返回的数据类型，一个模板并非一个实实在在的类或函数，仅仅是一个类和函数的描述。由于模板可以实现逻辑相同、数据类型不同的程序代码复制，所以使用模板机制可以减轻编程和维护的工作量和难度。模板一般分为模板函数和类模板。以所处理的数据类型的说明作为参数的类就叫类模板，或者模板类，而以所处理的数据类型的说明作为参数的函数，则称为函数模板。</p>
<p>本文包含函数模板和类模板，有些可能会交错设计两个模块的细节。</p>
<h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><p>函数模板定义了参数化的非成员函数，这使得程序员能够用不同类型的参数调用相同的函数，由编译器决定调用哪一种类型，并且从模板中生成相应的代码。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Template﹤类型参数表﹥返回类型 函数名 （形参表）{函数体}</p>
<p>简单实例，调用函数打印字符串或数字等。</p>
<p>普通函数形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printstring</span><span class="params">(<span class="keyword">const</span> std::string&amp; str)</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="function">std::string <span class="title">str</span><span class="params">(<span class="string">&quot;Hello World&quot;</span>)</span></span>;    </span><br><span class="line">    <span class="built_in">printstring</span>(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//输出：Hello World</span></span><br></pre></td></tr></table></figure>

<p>模板函数形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> T&amp; var)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    cout &lt;&lt; var &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;Hello World&quot;</span>)</span></span>;    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> num=<span class="number">1234</span>;</span><br><span class="line">    <span class="built_in">print</span>(str);</span><br><span class="line">    <span class="built_in">print</span>(num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：Hello World </span></span><br><span class="line"><span class="comment">//       1234</span></span><br></pre></td></tr></table></figure>
<p>可以看出使用模板后的函数不仅可以输出字符串形式还可以输出数字形式的内容。</p>
<p>上面两个例子介绍了函数模板的简单使用方法，但只有一个参数，如果需要多个参数，相应的函数模板应采用以下形式定义：</p>
<p>Template﹤类型1 变量1，类型2 变量2 ，…﹥返回类型 函数名（形参表）{函数体}</p>
<p>现在，为了看到模板时如何称为函数的，我们假定min()函数接受各种类型的参数，并找出其中的最小者，如果不采用模板技术，则只能接受一个特定类型的参数，如果希望也能接受其他类型的参数，就需要对每一种类型的参数都定义一个同功能的函数，其实为函数的重载，这里不在讨论，但这将是一件非常让人麻烦的事情。如：</p>
<p>普通定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="comment">// 定义多态函数，找出三个整数中最小的数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min0</span><span class="params">(<span class="keyword">int</span> ii, <span class="keyword">int</span> jj, <span class="keyword">int</span> kk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">if</span>((ii&lt;jj)&amp;&amp;(ii&lt;kk))&#123;temp=ii;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((jj&lt;ii)&amp;&amp;(jj&lt;kk))&#123;temp=jj;    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;    temp=kk;    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义多态函数，找出三个小数中最小的数</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">min1</span><span class="params">(<span class="keyword">float</span> ii, <span class="keyword">float</span> jj, <span class="keyword">float</span> kk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> temp;</span><br><span class="line">    <span class="keyword">if</span>((ii&lt;jj)&amp;&amp;(ii&lt;kk))&#123;temp=ii;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((jj&lt;ii)&amp;&amp;(jj&lt;kk))&#123;temp=jj;    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;    temp=kk;    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义多态函数，找出三个子符中最小的字符</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">min2</span><span class="params">(<span class="keyword">char</span> ii, <span class="keyword">char</span> jj, <span class="keyword">char</span> kk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line">    <span class="keyword">if</span>((ii&lt;jj)&amp;&amp;(ii&lt;kk))    &#123;temp=ii;    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((jj&lt;ii)&amp;&amp;(jj&lt;kk))&#123;temp=jj;&#125;    </span><br><span class="line">    <span class="keyword">else</span>&#123;temp=kk;&#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp1=<span class="built_in">min0</span>(<span class="number">100</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line">    cout&lt;&lt;temp1&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">float</span> temp2=<span class="built_in">min1</span>(<span class="number">10.60</span>,<span class="number">10.64</span>,<span class="number">53.21</span>);</span><br><span class="line">    cout&lt;&lt;temp2&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">char</span> temp3=<span class="built_in">min2</span>(<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    cout&lt;&lt;temp3&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以换行形式输出20  10.6  C</span></span><br></pre></td></tr></table></figure>

<p>使用模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="comment">// 定义函数模板，找出三个值中最小的值，与数据类型无关</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T ii, T jj, T kk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp;</span><br><span class="line">    <span class="keyword">if</span>((ii&lt;jj)&amp;&amp;(ii&lt;kk))&#123;temp=ii;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((jj&lt;ii)&amp;&amp;(jj&lt;kk))&#123;temp=jj;&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;    temp=kk; &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面是主函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">min</span>(<span class="number">100</span>,<span class="number">20</span>,<span class="number">30</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">min</span>(<span class="number">10.60</span>,<span class="number">10.64</span>,<span class="number">53.21</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">min</span>(<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;C&#x27;</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果同上，但可以清楚的看到二者之间的工作量大小之差距。</p>
<p>函数模板功能非常强大，但是有时候可能会陷入困境，假如待比较的函数模板没有提供正确的操作符，则程序不会对此进行编译。为了避免这种错误，可以使用函数模板和同名的非模板函数重载，这就是函数定制。函数模板与同名的非模板函数重载必须遵守以下规定：</p>
<ul>
<li>寻找一个参数完全匹配的函数，如有，则调用它</li>
<li>如果失败，寻找一个函数模板，使其实例化，产生一个匹配的模板函数，若有，则调用它</li>
<li>如果失败，再试低一级的对函数重载的方法，例如通过类型转换可产生的参数匹配等，若找到匹配的函数，调用它</li>
<li>如果失败，则证明这是一个错误的调用</li>
</ul>
<p>现在用上例的模板函数比较两个字符串，但会出现问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="comment">// 定义函数模板，找出三个值中最小的值，与数据类型无关</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T ii, T jj, T kk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp;</span><br><span class="line">    <span class="keyword">if</span>((ii&lt;jj)&amp;&amp;(ii&lt;kk))&#123;     temp=ii; &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((jj&lt;ii)&amp;&amp;(jj&lt;kk))&#123; temp=jj; &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;    temp=kk;&#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">min</span>(<span class="string">&quot;anderson&quot;</span>,<span class="string">&quot;Washington&quot;</span>,<span class="string">&quot;Smith&quot;</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出anderson与实际结果不符，原因在于编译器会生成对字符串指针做比较的函数，但比较字符串和比较字符串指针是不一样的，为了解决此问题，我们可以定制函数模板，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 定义函数模板，找出三个值中最小的值，与数据类型无关</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T ii, T jj, T kk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp;</span><br><span class="line">    <span class="keyword">if</span>((ii&lt;jj)&amp;&amp;(ii&lt;kk))&#123;        temp=ii;    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((jj&lt;ii)&amp;&amp;(jj&lt;kk))&#123;        temp=jj;    &#125;</span><br><span class="line">    <span class="keyword">else</span>    &#123;        temp=kk;    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非模板函数重载</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">min</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ch1, <span class="keyword">const</span> <span class="keyword">char</span>* ch2,<span class="keyword">const</span> <span class="keyword">char</span>* ch3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* temp;</span><br><span class="line">    <span class="keyword">int</span> result1 = <span class="built_in">strcmp</span>(ch1,ch2);</span><br><span class="line">    <span class="keyword">int</span> result2 = <span class="built_in">strcmp</span>(ch1,ch3);</span><br><span class="line">    <span class="keyword">int</span> result3 = <span class="built_in">strcmp</span>(ch2,ch1);</span><br><span class="line">    <span class="keyword">int</span> result4 = <span class="built_in">strcmp</span>(ch2,ch3);</span><br><span class="line">    <span class="keyword">if</span>((result1&lt;<span class="number">0</span>)&amp;&amp;(result2&lt;<span class="number">0</span>))    &#123;        temp = ch1;    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((result3&lt;<span class="number">0</span>)&amp;&amp;(result4&lt;<span class="number">0</span>))    &#123;        temp=ch2;    &#125;</span><br><span class="line">    <span class="keyword">else</span>    &#123;        temp=ch3;    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">min</span>(<span class="number">100</span>,<span class="number">20</span>,<span class="number">30</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">min</span>(<span class="number">10.60</span>,<span class="number">10.64</span>,<span class="number">53.21</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">min</span>(<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;C&#x27;</span>)&lt;&lt;endl;    </span><br><span class="line">    cout&lt;&lt;<span class="built_in">min</span>(<span class="string">&quot;anderson&quot;</span>,<span class="string">&quot;Washington&quot;</span>,<span class="string">&quot;Smith&quot;</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在VS2010中，最后一行会输出Smith，与结果相符。<br>注意：若上例在VC++ 6.0 中运行，其结果最后一行仍会输出anderson，读者可自己上机查看情况并分析原因。</p>
<p>下面给出一些实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HEADER_MY</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEADER_MY</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">T <span class="title">fromString</span><span class="params">(<span class="keyword">const</span> std::string &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::istringstream <span class="title">is</span><span class="params">(s)</span></span>;</span><br><span class="line">    T t;</span><br><span class="line">    is&gt;&gt;t;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">std::string <span class="title">toString</span><span class="params">(<span class="keyword">const</span> T &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ostringstream t;</span><br><span class="line">    t&lt;&lt;s;</span><br><span class="line">    <span class="keyword">return</span> t.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;HEADER.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;complex&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1234</span>; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i == \&quot;&quot;</span> &lt;&lt; <span class="built_in">toString</span>(i) &lt;&lt; <span class="string">&quot;\&quot;\n&quot;</span>; </span><br><span class="line">    <span class="keyword">float</span> x = <span class="number">567.89</span>; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x == \&quot;&quot;</span> &lt;&lt; <span class="built_in">toString</span>(x) &lt;&lt; <span class="string">&quot;\&quot;\n&quot;</span>; </span><br><span class="line">    <span class="function">complex&lt;<span class="keyword">float</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>)</span></span>; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c == \&quot;&quot;</span> &lt;&lt; <span class="built_in">toString</span>(c) &lt;&lt; <span class="string">&quot;\&quot;\n&quot;</span>; </span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line">    i = fromString&lt;<span class="keyword">int</span>&gt;(<span class="built_in">string</span>(<span class="string">&quot;1234&quot;</span>)); </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i == &quot;</span> &lt;&lt; i &lt;&lt; endl; </span><br><span class="line">    x = fromString&lt;<span class="keyword">float</span>&gt;(<span class="built_in">string</span>(<span class="string">&quot;567.89&quot;</span>)); </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x == &quot;</span> &lt;&lt; x &lt;&lt; endl; </span><br><span class="line">    c = fromString&lt; complex&lt;<span class="keyword">float</span>&gt; &gt;(<span class="built_in">string</span>(<span class="string">&quot;(1.0,2.0)&quot;</span>)); </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c == &quot;</span> &lt;&lt; c &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板实参推演"><a href="#模板实参推演" class="headerlink" title="模板实参推演"></a>模板实参推演</h2><p>当函数模板被调用时，对函数实参类型的检查决定了模板实参的类型和值的这个过程叫做模板实参推演。如template <code>&lt;class T&gt;</code> void h(T a){}; h(1); h(0.2);第一个调用因为实参是int型的，所以模板形参T被推演为int型，第二个T的类型则为double。</p>
<p>在使用函数模板时，请注意以下几点：</p>
<ul>
<li>在模板被实例化后，就会生成一个新的实例，这个新生成的实例不存在类型转换。比如有函数模板template <code>&lt;class T&gt;</code>void H(T a){};int a=2; short b=3;第一个调用H(a)生成一个int型的实例版本，但是当调用h(b)的时候不会使用上次生成的int实例把short转换为int，而是会另外生成一个新的short型的实例。</li>
<li>在模板实参推演的过程中有时类型并不会完全匹配，这时编译器允许以下几种实参到模板形参的转换，这些转换不会生成新的实例。<br>(1) 数组到指针的转换或函数到指针的转换：比如template<code>&lt;class T&gt;</code> void h(T * a){}，int b[3]={1,2,3}；h(b);这时数组b和类型T <em>不是完全匹配，但允许从数组到指针的转换，因此数组b被转换成int <em>，而类型形参T被转换成int，也就是说函数体中的T被替换成int。<br>(2) 限制修饰符转换：即把const或volatile限定符加到指针上。比如template<code>&lt;class T&gt;</code> void h(const T</em> a){}，int b=3; h(&amp;b);虽然实参&amp;b与形参const T</em>不完全匹配，但因为允许限制修饰符的转换，结果就把&amp;b转换成const int *。而类形型参T被转换成int。如果模板形参是非const类型，则无论实参是const类型还是非const类型调用都不会产生新的实例。<br>(3) 到一个基类的转换(该基类根据一个类模板实例化而来)：比如tessmplate<code>&lt;class T1&gt;</code> class A{}; template<code>&lt;class T1&gt;</code> class B:public A<code>&lt;T1&gt;</code>{}; template<code>&lt;class T2&gt;</code> void h(A<code>&lt;T2&gt;</code>&amp; m){}，在main函数中有B<code>&lt;int&gt;</code> n; h(n);函数调用的子类对象n与函数的形参A<code>&lt;T2&gt;</code>不完全匹配，但允许到一个基类的转换。在这里转换的顺序为，首先把子类对象n转换为基类对象A<code>&lt;int&gt;</code>，然后再用A<code>&lt;int&gt;</code>去匹配函数的形参A<code>&lt;T2&gt;</code>&amp;，所以最后T2被转换为int，也就是说函数体中的T将被替换为int。</li>
<li>对于函数模板而言不存在h(int,int)这样的调用，不能在函数调用的参数中指定模板形参的类型，对函数模板的调用应使用实参推演来进行，即只能进行h(2,3)这样的调用，或者int a, b; h(a,b)。</li>
</ul>
<p>模板实参推演实例，说明内容较长，采用注释形式，但代码较乱：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span><span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">(T a)</span></span>&#123;cout&lt;&lt;<span class="string">&quot; h()&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(T).<span class="built_in">name</span>()&lt;&lt;endl;&#125;  <span class="comment">//带有一个类型形参T的模板函数的定义方法，typeid(变量名).name()为测试变量类型的语句。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span><span class="function"><span class="keyword">void</span> <span class="title">k</span><span class="params">(T a,T b)</span></span>&#123;T c;cout&lt;&lt;<span class="string">&quot; k()&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(T).<span class="built_in">name</span>()&lt;&lt;endl;&#125; <span class="comment">//注意语句T c。模板类型形参T可以用来声明变量，作为函数的返回类型，函数形参等凡是类类型能使用的地方。</span></span><br><span class="line">template&lt;class T1,class T2&gt; void f(T1 a, T2 b)&#123;cout&lt;&lt;&quot; f()&quot;&lt;&lt;typeid(T1).name()&lt;&lt;&quot;,&quot;&lt;&lt;typeid(T2).name()&lt;&lt;endl;&#125;   //定义带有两个类型形参T1，T2的模板函数的方法template&lt;class T&gt; void g(const T* a)&#123;T b;cout&lt;&lt;&quot; g()&quot;&lt;&lt;typeid(b).name()&lt;&lt;endl;&#125; </span><br><span class="line"><span class="comment">//template&lt;class T1,class T2=int&gt; void g()&#123;&#125;  //错误，默认模板类型形参不能用于函数模板，只能用于类模板上。</span></span><br><span class="line"><span class="comment">//main函数开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// template&lt;class T&gt;void h()&#123;&#125; //错误，模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行。</span></span><br><span class="line"><span class="comment">//函数模板实参推演示例。</span></span><br><span class="line"><span class="comment">// h(int); //错误，对于函数模板而言不存在h(int,int)这样的调用，不能在函数调用的参数中指定模板形参的类型，对函数模板的调用应使用实参推演来进行，即只能进行h(2,3)这样的调用，或者int a, b; h(a,b)。</span></span><br><span class="line"><span class="comment">//h函数形式为：template&lt;class T&gt;void h(T a)</span></span><br><span class="line"><span class="built_in">h</span>(<span class="number">2</span>);<span class="comment">//输出&quot; h() int&quot;使用函数模板推演，在这里数值2为int型，所以把类型形参T推演为int型。</span></span><br><span class="line"><span class="built_in">h</span>(<span class="number">2.0</span>);<span class="comment">//输出&quot; h() double&quot;，因为2.0为double型，所以将函数模板的类型形参推演为double型</span></span><br><span class="line"><span class="comment">//k函数形式为：template&lt;class T&gt;void k(T a,T b)</span></span><br><span class="line"><span class="built_in">k</span>(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//输出&quot; k() int&quot;</span></span><br><span class="line"><span class="comment">//k(2,3.0);错误，模板形参T的类型不明确，因为k()函数第一个参数类型为int，第二个为double型，两个形参类型不一致。</span></span><br><span class="line"><span class="comment">//f函数的形式为：template&lt;class T1,class T2&gt; void f(T1 a, T2 b)</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">3</span>,<span class="number">4.0</span>);<span class="comment">//输出&quot; f() int,double&quot;，这里不存在模板形参推演错误的问题，因为模板函数有两个类型形参T1和T2。在这里将T1推演为int，将T2推演为double。</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">3</span>;<span class="keyword">double</span> b=<span class="number">4</span>;</span><br><span class="line"><span class="built_in">f</span>(a,b); <span class="comment">//输出同上，这里用变量名实现推板实参的推演。</span></span><br><span class="line"><span class="comment">//模板函数推演允许的转换示例，g函数的形式为template&lt;class T&gt; void g(const T* a)</span></span><br><span class="line"><span class="keyword">int</span> a1[<span class="number">2</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;<span class="built_in">g</span>(a1); <span class="comment">//输出&quot; g() int&quot;，数组的地址和形参const T*不完全匹配，所以将a1的地址T &amp;转换为const T*，而a1是int型的，所以最后T推演为int。</span></span><br><span class="line"><span class="built_in">g</span>(&amp;b); <span class="comment">//输出&quot; g() double&quot;,这里和上面的一样，只是把类型T转换为double型。</span></span><br><span class="line"><span class="built_in">h</span>(&amp;b); <span class="comment">//输出&quot; h() double *&quot;这里把模参类型T推演为double *类型。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数模板的显式实例化"><a href="#函数模板的显式实例化" class="headerlink" title="函数模板的显式实例化"></a>函数模板的显式实例化</h2><ul>
<li>隐式实例化：比如有模板函数template<code>&lt;class T&gt;</code> void h(T a){}。h(2)这时h函数的调用就是隐式实例化，即参数T的类型是隐式确定的。</li>
<li>函数模板显式实例化声明：其语法是：template 函数返回类型 函数名 <code>&lt;实例化的类型&gt;</code> (函数形参表); 注意这是声明语句，要以分号结束。例如：template void h<code>&lt;int&gt;</code> (int a);这样就创建了一个h函数的int 实例。再如有模板函数template<code>&lt;class T&gt;</code> T h(T a){}，注意这里h函数的返回类型为T，显式实例化的方法为template int h<code>&lt;int&gt;</code>(int a); 把h模板函数实例化为int型。</li>
<li>对于给定的函数模板实例，显式实例化声明在一个文件中只能出现一次。</li>
<li>在显式实例化声明所在的文件中，函数模板的定义必须给出，如果定义不可见，就会发生错误。</li>
</ul>
<p>注意：不能在局部范围类显式实例化模板，实例化模板应放在全局范围内，即不能在main函数等局部范围中实例化模板。因为模板的声明或定义不能在局部范围或函数内进行。</p>
<h2 id="显式模板实参"><a href="#显式模板实参" class="headerlink" title="显式模板实参"></a>显式模板实参</h2><ol>
<li>显式模板实参：适用于函数模板，即在调用函数时显式指定要调用的实参的类型。</li>
<li>格式：显式模板实参的格式为在调用模板函数的时候在函数名后用<code>&lt;&gt;</code>尖括号括住要显示表示的类型，比如有模板函数template<code>&lt;class T&gt;</code> void h(T a, T b){}。则h<code>&lt;double&gt;</code>(2, 3.2)就把模板形参T显式实例化为double类型。</li>
<li>显式模板实参用于同一个模板形参的类型不一致的情况。比如template<code>&lt;class T&gt;</code> void h(T a, T b){}，则h(2, 3.2)的调用会出错，因为两个实参类型不一致，第一个为int 型，第二个为double型。而用h<code>&lt;double&gt;</code>(2, 3.2)就是正确的，虽然两个模板形参的类型不一致但这里把模板形参显式实例化为double类型，这样的话就允许进行标准的隐式类型转换，即这里把第一个int 参数转换为double类型的参数。</li>
<li>显式模板实参用法二：用于函数模板的返回类型中。例如有模板函数template<code>&lt;class T1, class T2, class T3&gt;</code> T1 h(T2 a, T3 b){}，则语句int a=h(2,3)或h(2,4)就会出现模板形参T1无法推导的情况。而语句int h(2,3)也会出错。用显式模板实参就能轻松解决这个问题，比如h<code>&lt;int, int, int&gt;</code>(2,3)即把模板形参T1实例化为int 型，T2和T3也实例化为int 型。</li>
<li>显式模板实参用法三：应用于模板函数的参数中没有出现模板形参的情况。比如template<code>&lt;class T&gt;</code>void h(){}如果在main函数中直接调用h函数如h()就会出现无法推演类型形参T的类型的错误，这时用显式模板实参就不会出现这种错误，调用方法为h<code>&lt;int&gt;</code>()，把h函数的模板形参实例化为int 型，从而避免这种错误。</li>
<li>显式模板实参用法四：用于函数模板的非类型形参。比如template<code>&lt;class T,int a&gt;</code> void h(T b){}，而调用h(3)将出错，因为这个调用无法为非类型形参推演出正确的参数。这时正确调用这个函数模板的方法为h<code>&lt;int, 3&gt;</code>(4)，首先把函数模板的类型形参T推演为int 型，然后把函数模板的非类型形参int a用数值3来推演，把变量a设置为3，然后再把4传递给函数的形参b，把b设置为4。注意，因为int a是非类型形参，所以调用非类型形参的实参应是编译时常量表达式，不然就会出错。</li>
<li>在使用显式模板实参时，我们只能省略掉尾部的实参。比如template<code>&lt;class T1, class T2, class T3&gt;</code> T1 h(T2 a, T3 b){}在显式实例化时h<code>&lt;int&gt;</code>(3, 3.4)省略了最后两个模板实参T2和T3，T2和T3由调用时的实参3和3.4隐式确定为int 型和double型，而T1被显示确定为int 型。h<code>&lt;int, , double&gt;``&lt;2,3.4&gt;</code>是错误的，只能省略尾部的实参。</li>
<li>显式模板实参最好用在存在二义性或模板实参推演不能进行的情况下。</li>
</ol>
<p>下面来看看实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span><span class="function"><span class="keyword">void</span> <span class="title">g1</span><span class="params">(T a, T b)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;hansu g1()&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(T).<span class="built_in">name</span>()&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>,<span class="keyword">class</span> <span class="title">T3</span>&gt;</span><span class="function">T1 <span class="title">g2</span><span class="params">(T2 a,T3 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;T1 c=a;cout&lt;&lt;<span class="string">&quot;hansug2()&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(T1).<span class="built_in">name</span>()&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(T2).<span class="built_in">name</span>()&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(T3).<span class="built_in">name</span>()&lt;&lt;endl; <span class="keyword">return</span> c;&#125;</span><br><span class="line">template&lt;class T1,class T2&gt; void g3 ( T1 a ) &#123;cout&lt;&lt;&quot;hansu g3()&quot;&lt;&lt;typeid(T1).name()&lt;&lt;typeid(T2).name()&lt;&lt;endl;&#125;</span><br><span class="line">template&lt;class T1,int a&gt; void g4(T1 b, double c)&#123;cout&lt;&lt;&quot;hansu g4()&quot;&lt;&lt;typeid(T1).name()&lt;&lt;typeid(a).name()&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span><span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;&#125;;</span><br><span class="line"><span class="comment">//模板显示实例化示例。</span></span><br><span class="line"><span class="comment">//因为模板的声明或定义不能在局部范围或函数内进行。所以模板实例化都应在全局范围内进行。</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">void</span> g1&lt;<span class="keyword">double</span>&gt;(<span class="keyword">double</span> a,<span class="keyword">double</span> b); <span class="comment">//把函数模板显示实例化为int型。</span></span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;</span><span class="keyword">double</span>,<span class="keyword">double</span>&gt;; <span class="comment">//显示实例化类模板，注意后面没有对象名，也没有&#123;&#125;大括号。</span></span><br><span class="line"><span class="comment">//template class A&lt;int,int&gt;&#123;&#125;;  //错误，显示实例化类模板后面不能有大括号&#123;&#125;。</span></span><br><span class="line"><span class="comment">//template class A&lt;int,int&gt; m;  //错误，显示实例化类模板后面不能有对象名。</span></span><br><span class="line"><span class="comment">//main函数开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//显示模板实参示例。显示模板实参适合于函数模板</span></span><br><span class="line"><span class="comment">//1、显示模板实参用于同一个模板形参的类型不一致的情况。函数g1形式为template&lt;class T&gt;void g1(T a, T b)</span></span><br><span class="line">g1&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>,<span class="number">3.2</span>);<span class="comment">//输出&quot;hansu g1() int&quot;两个实参类型不一致，第一个为int第二个为double。但这里用显示模板实参把类型形参T指定为double，所以第一个int型的实参数值2被转换为double类型。</span></span><br><span class="line"><span class="comment">//g1(2,3.2);错误，这里没有用显式模板实参。所以两个实参类型不一致。</span></span><br><span class="line"><span class="comment">//2、用于函数模板的反回类型中。函数g2形式为template&lt;class T1,class T2,class T3&gt; T1 g2(T2 a,T3 b)</span></span><br><span class="line"><span class="comment">//g2(2,3);错误，无法推演类型形参T1。</span></span><br><span class="line"><span class="comment">//int g2(2,3);错误，不能以这种方法试图推导类型形参T1为int型。</span></span><br><span class="line"><span class="comment">//int a=g2(2,3);错误，以这种方式试图推演出T1的类型为int也是错误的。</span></span><br><span class="line">g2&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//正确，将T1，T2，T3 显示指定为int型。输出&quot;hansu g2() intintint&quot;</span></span><br><span class="line"><span class="comment">//3、应用于模板函数的参数中没有出现模板形参的情况其中包括省略的用法，函数g3的形式为template&lt;class T1,class T2&gt; void g3(T1 a)</span></span><br><span class="line"><span class="comment">//g3(2);错误，无法为函数模板的类型形参T2推演出正确的类型</span></span><br><span class="line"><span class="comment">//g3(2,3);错误，岂图以这种方式为T2指定int型是错误的，因为函数只有一个参数。</span></span><br><span class="line"><span class="comment">//g3&lt;,int&gt;(2);错误，这里起图用数值2来推演出T1为int型,而省略掉第一个的显示模板实参，这种方法是错误的。在用显示模板实参时，只能省略掉尾部的实参。</span></span><br><span class="line"><span class="comment">//g3&lt;int&gt;(2);错误，虽然用了显示模板实参方法，省略掉了尾部的实参，但该方法只是把T1指定为int型，仍然无法为T2推演正确的类型。</span></span><br><span class="line">g3&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(<span class="number">2</span>);<span class="comment">//正确，显示指定T1和T2的类型都为int型。</span></span><br><span class="line"><span class="comment">//4、用于函数模板的非类型形参。g4函数的形式为template&lt;class T1,int a&gt; void g4(T1 b,double c)</span></span><br><span class="line"><span class="comment">//g4(3,3.2);错误，虽然指定了两个参数，但是这里仍然无法为函数模板的非类型形参int a推演出正确的实参。因为第二个函数参数x.2是传递给函数的参数double c的，而不是函数模板的非类型形参int a。</span></span><br><span class="line"><span class="comment">//g4(3,2);错误，起图以整型值把实参传递给函数模板的非类型形参是不行的，这里数值2会传递给函数形参double c并把int型转换为double型。所以非类型形参int a仍然无实参。</span></span><br><span class="line"><span class="comment">//int d=1; g4&lt;int ,d &gt;(3,3.2); //错误，调用方法正确，但对于非类型形参要求实参是一个常量表达式，而局部变量c是非常量表达式，不能做为非类型形参的实参，所以错误。</span></span><br><span class="line">g4&lt;<span class="keyword">int</span>,<span class="number">1</span>&gt;(<span class="number">2</span>,<span class="number">3.2</span>);<span class="comment">//正确，用显示模板实参，把函数模板的类型形参T1设为int型，把数值1传给非类型形参int a，并把a设为1，把数值2 传给函数的第一个形参T1 b并把b设为2，数值?.2传给函数的第二个形参double c并把c设为?.2。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> d=<span class="number">1</span>; g4&lt;<span class="keyword">int</span>,d&gt;(<span class="number">2</span>,<span class="number">3.2</span>);<span class="comment">//正确，这里变量d是const常量，能作为非类型形参的实参，这里参数的传递方法同上面的语句。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="显式具体化-模板特化，模板说明-和函数模板的重载"><a href="#显式具体化-模板特化，模板说明-和函数模板的重载" class="headerlink" title="显式具体化(模板特化，模板说明) 和函数模板的重载"></a>显式具体化(模板特化，模板说明) 和函数模板的重载</h2><ol>
<li>具体化或特化或模板说明指的是一个意思，就是把模板特殊化，比如有模板template<code>&lt;class T&gt;</code>void h(T a){}，这个模板适用于所有类型，但是有些特殊类型不需要与这个模板相同的操作或者定义，比如int 型的h实现的功能和这个模板的功能不一样，这样的话我们就要重定义一个h模板函数的int版本，即特化版本。<h3 id="特化函数模板："><a href="#特化函数模板：" class="headerlink" title="特化函数模板："></a>特化函数模板：</h3></li>
<li>显式特化格式为：template<code>&lt;&gt;</code> 返回类型函数名<code>&lt;要特化的类型&gt;</code>(参数列表) {函数体}，显式特化以template<code>&lt;&gt;</code>开头，表明要显式特化一个模板，在函数名后<code>&lt;&gt;</code>用尖括号括住要特化的类型版本。比如template <code>&lt;class T&gt;</code> void h(T a){}，其int 类型的特化版本为template<code>&lt;&gt;</code> void h<code>&lt;int&gt;</code>(int a){}，当出现int 类型的调用时就会调用这个特化版本，而不会调用通用的模板，比如h(2)，就会调用int 类型的特化版本。</li>
<li>如果可以从实参中推演出模板的形参，则可以省略掉显示模板实参的部分。比如：template<code>&lt;&gt;</code> void h(int a){}。注意函数h后面没有<code>&lt;&gt;</code>符号，即显式模板实参部分。</li>
<li>对于返回类型为模板形参时，调用该函数的特化版本必须要用显式模板实参调用，如果不这样的话就会出现其中一个形参无法推演的情况。如template<code>&lt;class T1,class T2,class T3&gt;</code> T1 h(T2 a,T3 b){}，有几种特化情况：<br>情况一：template<code>&lt;&gt;</code> int h<code>&lt;int,int&gt;</code>(int a, in b){}该情况下把T1，T2，T3的类型推演为int 型。在主函数中的调用方式应为h<code>&lt;int&gt;</code>(2,3)。<br>情况二：template<code>&lt;&gt;</code> int h(int a, int b){}，这里把T2,T3推演为int 型，而T1为int 型，但在调用时必须用显式模板实参调用，且在<code>&lt;&gt;</code>尖括号内必须指定为int 型，不然就会调用到通用函数模板，如h<code>&lt;int&gt;</code>(2,3)就会调用函数模板的特化版本，而h(2,3)调用会出错。h<code>&lt;double&gt;</code>(2,3)调用则会调用到通用的函数模板版本。<br>这几种情况的特化版本是错误的，如template<code>&lt;&gt;</code> T1 h(int a,int b){}，这种情况下T1会成为不能识别的名字，因而出现错误，template<code>&lt;&gt;</code> int h<code>&lt;double&gt;</code>(int a,int b){}在这种情况下返回类型为int 型，把T1确定为int 而尖括号内又把T1确定为double型，这样就出现了冲突。</li>
<li>具有相同名字和相同数量返回类型的非模板函数(即普通函数)，也是函数模板特化的一种情况，这种情况将在后面参数匹配问题时讲解。<h3 id="特化类模板："><a href="#特化类模板：" class="headerlink" title="特化类模板："></a>特化类模板：</h3></li>
<li>特化整个类模板：比如有template<code>&lt;class T1,class T2&gt;</code> class A{};其特化形式为template<code>&lt;&gt;</code> class A<code>&lt;int, int&gt;</code>{};特化形式以template<code>&lt;&gt;</code>开始，这和模板函数的形式相同，在类名A后跟上要特化的类型。</li>
<li>在类特化的外部定义成员的方法：比如template<code>&lt;class T&gt;</code> class A{public: void h();};类A特化为template<code>&lt;&gt;</code> class A<code>&lt;int&gt;</code>{public: void h();};在类外定义特化的类的成员函数h的方法为：void A<code>&lt;int&gt;</code>::h(){}。在外部定义类特化的成员时应省略掉template<code>&lt;&gt;</code>。</li>
<li>类的特化版本应与类模板版本有相同的成员定义，如果不相同的话那么当类特化的对象访问到类模板的成员时就会出错。因为当调用类的特化版本创建实例时创建的是特化版本的实例，不会创建类模板的实例，特化版本如果和类的模板版本的成员不一样就有可能出现这种错误。比如：模板类A中有成员函数h()和f()，而特化的类A中没有定义成员函数f()，这时如果有一个特化的类的对象访问到模板类中的函数f()时就会出错，因为在特化类的实例中找不到这个成员。</li>
<li>类模板的部分特化：比如有类模板template<code>&lt;class T1, class T2&gt;</code> class A{};则部分特化的格式为template<code>&lt;class T1&gt;</code> class A<code>&lt;T1, int&gt;</code>{};将模板形参T2特化为int 型，T1保持不变。部分特化以template开始，在<code>&lt;&gt;</code>中的模板形参是不用特化的模板形参，在类名A后面跟上要特化的类型。如果要特化第一个模板形参T1，则格式为template<code>&lt;class T2&gt;</code> class A<code>&lt;int, T2&gt;</code>{};部分特化的另一用法是template<code>&lt;class T1&gt;</code> class A<code>&lt;T1,T1&gt;</code>{};将模板形参T2也特化为模板形参T1的类型。</li>
<li>在类部分特化的外面定义类成员的方法：比如有部分特化类template<code>&lt;class T1&gt;</code> class A<code>&lt;T1,int&gt;</code>{public: void h();};则在类外定义的形式为template<code>&lt;class T1&gt;</code> void A<code>&lt;T1,int&gt;</code>::h(){}。注意当在类外面定义类的成员时template 后面的模板形参应与要定义的类的模板形参一样，这里就与部分特化的类A的一样template<code>&lt;class T1&gt;</code>。</li>
</ol>
<p>其他说明：<br>11. 可以对模板的特化版本只进行声明，而不定义。比如template<code>&lt;&gt;</code> void h<code>&lt;int&gt;</code>(int a);注意，声明时后面有个分号。<br>12. 在调用模板实例之前必须要先对特化的模板进行声明或定义。一个程序不允许同一模板实参集的同一模板既有显式特化又有实例化。比如有模板template<code>&lt;class T&gt;</code> void h(T a){}在h(2)之前没有声明该模板的int 型特化版本，而是在调用该模板后定义该模板的int 型特化版本，这时程序不会调用该模板的特化版本，而是调用该模板产生一个新的实例。这里就有一个问题，到底是调用由h(2)产生的实例版本呢还是调用程序中的特化版本。<br>13. 注意：因为模板的声明或定义不能在局部范围或函数内进行。所以特化类模板或函数模板都应在全局范围内进行。<br>14. 在特化版本中模板的类型形参是不可见的。比如template<code>&lt;&gt;</code> void h<code>&lt;int,int&gt;</code>(int a,int b){T1 a;}就会出现错误，在这里模板的类型形参T1在函数模板的特化版本中是不可见的，所以在这里T1是未知的标识符，是错误的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//函数模板特化和类模板特化示例</span></span><br><span class="line"><span class="comment">//定义函数g1，g2和类A</span></span><br><span class="line">template&lt;class T1,class T2&gt; void g1(T1 a,T2 b)&#123;cout&lt;&lt;&quot;g1&quot;&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>,<span class="keyword">class</span> <span class="title">T3</span>&gt;</span><span class="function">T1 <span class="title">g2</span><span class="params">(T2 a,T3 b)</span></span>&#123;  <span class="keyword">int</span> c=<span class="number">1</span>;cout&lt;&lt;<span class="string">&quot;g2&quot;</span>&lt;&lt;endl;<span class="keyword">return</span> c;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>,<span class="keyword">class</span> <span class="title">T3</span>&gt;</span><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span><span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;&#125;</span><br><span class="line"><span class="comment">//函数模板的特化定义。函数模板的特化可以理解为函数模板重载的另一种形式。</span></span><br><span class="line"><span class="comment">//下式为g1的类型形参显示指定其类型，把T1，T2在模板实参的尖括号中设为int型。</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">void</span> g1&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;cout&lt;&lt;<span class="string">&quot;g1一&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="comment">//下式显示设定g1的类型形参T1，并设为int型，T2由函数参数double推演为double型。</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">void</span> g1&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span> a,<span class="keyword">double</span> b)&#123;cout&lt;&lt;<span class="string">&quot;g1二&quot;</span>&lt;&lt;endl;&#125;  </span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">g1</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;g1三&quot;</span>&lt;&lt;endl;&#125; <span class="comment">//g1的类型形参都由g1的形参推演出来。</span></span><br><span class="line"><span class="comment">//template&lt;&gt; void g1&lt;int&gt;(double a,int b)&#123;cout&lt;&lt;&quot;g•一&quot;&lt;&lt;endl;&#125;  //错误，在显示模板实参的尖括号中显示把类型形参T1的类型设为int型，而又在函数的形参中把类型形参T1的类型推演为double型，这样就发生了冲突，出现错误。</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">int</span> g2&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;<span class="keyword">int</span> c=<span class="number">1</span>;cout&lt;&lt;<span class="string">&quot;g2一&quot;</span>&lt;&lt;endl;<span class="keyword">return</span> c;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="function"><span class="keyword">double</span> <span class="title">g2</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">int</span> c=<span class="number">1</span>;cout&lt;&lt;<span class="string">&quot;g2二&quot;</span>&lt;&lt;endl;<span class="keyword">return</span> c;&#125;</span><br><span class="line"><span class="comment">//注意，下式正确，该式并不是对函数模板g2的部分特化，而是g2的重载。</span></span><br><span class="line"><span class="comment">//template&lt;class T2&gt; int g2(int a, T2 b)&#123;int c=1;cout&lt;&lt;&quot;g2三&quot;&lt;&lt;endl;return c;&#125;</span></span><br><span class="line"><span class="comment">//下式错误，函数反回类型和&lt;double&gt;尖括号中的double类型不同，发生冲突。</span></span><br><span class="line"><span class="comment">//template&lt;&gt; int g2&lt;double&gt;(int a,int b)&#123;int c=1;cout&lt;&lt;&quot;two&quot;&lt;&lt;endl;return c;&#125; </span></span><br><span class="line"><span class="comment">//下式错误，函数模板的类型形参在特化版本中是不可见的，也就是说这里的会把类型形参T1理解为未声明的标识符</span></span><br><span class="line"><span class="comment">//template&lt;&gt; T1 g2&lt;int&gt;(int a,int b)&#123;int c=1;cout&lt;&lt;&quot;two&quot;&lt;&lt;endl;return c;&#125; </span></span><br><span class="line"><span class="comment">//类模板的特化和部分特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;</span><span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&#123;<span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;&#125;<span class="comment">//特化整个类模板的格式，注意类名后的尖括号中必须指定所有的类模板的类型形参。</span></span><br><span class="line"><span class="comment">//template&lt;&gt; class A&lt;int&gt;&#123;&#125;; //错误，在特化的类名后的尖括号中指定的类模板类型形参的数量不够。要想只特化其中一个类模板的类型形参，就要使用类模板的部分特化。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T3</span>&gt;</span><span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;</span>T1,<span class="keyword">double</span>,T3&gt;&#123;<span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;&#125;<span class="comment">//特化T2，而T1和T?不特化，注意尖括号中的类型形参是不特化的形参。</span></span><br><span class="line"><span class="comment">//在类模板的特化或部分特化版本的外部定义成员函数的方法。</span></span><br><span class="line"><span class="keyword">void</span> A&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::<span class="built_in">h</span>()&#123;cout&lt;&lt;<span class="string">&quot;class A tehua&quot;</span>&lt;&lt;endl;&#125; <span class="comment">/*  T1 c; 错误，在特化版本中模板的类型形参是不可见的，也就是说在这里</span></span><br><span class="line"><span class="comment">T1是未声明的标识符。*/</span></span><br><span class="line"><span class="comment">//template&lt;&gt; void A&lt;int,int,int&gt;::h()&#123;&#125; //错误，在类模板的特化版本外面定义类模板的成员时应省略掉template&lt;&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T3</span>&gt;</span><span class="keyword">void</span> A&lt;T1,<span class="keyword">double</span>,T3)::<span class="built_in">h</span>()&#123;cout&lt;&lt;<span class="string">&quot;class A bute&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>,<span class="keyword">class</span> <span class="title">T3</span>&gt;</span><span class="keyword">void</span> A&lt;T1,T2,T3&gt;::<span class="built_in">h</span>()&#123;cout&lt;&lt;<span class="string">&quot;class A putong&quot;</span>&lt;&lt;endl;&#125; <span class="comment">//定义普通类模板中的成员函数。</span></span><br><span class="line"><span class="comment">//main函数开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//特化的函数模板的调用方式。</span></span><br><span class="line">    <span class="built_in">g1</span>(<span class="number">2</span>,<span class="number">2</span>); <span class="comment">//输出&quot;g1一&quot;，调用函数模板g1的第一个特化版本template&lt;&gt; void g1&lt;int,int&gt;(int a,int b)&#123;cout&lt;&lt;&quot;g1一&quot;&lt;&lt;endl;&#125;</span></span><br><span class="line">    <span class="built_in">g1</span>(<span class="number">2</span>,<span class="number">3.2</span>); <span class="comment">//输出&quot;g1二&quot;，调用函数模板g1的第二个特化版本template&lt;&gt; void g1&lt;int&gt;(int a,double b)&#123;cout&lt;&lt;&quot;g1二&quot;&lt;&lt;endl;&#125;</span></span><br><span class="line">    <span class="built_in">g1</span>(<span class="number">3.3</span>,<span class="number">4.4</span>); <span class="comment">//输出&quot;g1三&quot;，调用函数模板g1的第三个特化版本template&lt;&gt; void g1(double a,double b)&#123;cout&lt;&lt;&quot;g1三&quot;&lt;&lt;endl;&#125;</span></span><br><span class="line">    g1&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>,<span class="number">2.3</span>);<span class="comment">//输出&quot;g1三&quot;，这里用显示模板实参把第一个实参指定为double型，这样g1的两个实参都是double型，所以将调用g1的第三个特化版本。</span></span><br><span class="line">    <span class="comment">//g2(3,3); 错误，在调用反回类型为类型形参的时候必须用显示模板实参的形式为反回类型的形参显示指定类型。在这里就会出现无法为T1确定类型的情况。</span></span><br><span class="line">    g2&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//正确，把g2的类型形参T1设显示指定为int，调用g2的第一个特化版本。template&lt;&gt; int g2&lt;int&gt;(int a,int b)&#123;int c=1;cout&lt;&lt;&quot;g2一&quot;&lt;&lt;endl;return c;&#125;</span></span><br><span class="line">    g2&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//正确，把g2的类型形参T1设显示指定为double，调用g2的第二个特化版本。template&lt;&gt; double g2(int a,int b)&#123;int c=1;cout&lt;&lt;&quot;g2二&quot;&lt;&lt;endl;return c;&#125;</span></span><br><span class="line">    g2&lt;<span class="keyword">char</span>&gt;(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//正确，把g2的类型形参T1设显示指定为char，对于char版本的g2函数没有特化版本，因此调用g2的通用版本。</span></span><br><span class="line">    <span class="comment">//    template&lt;class T1,class T2,class T3&gt;T1 g2(T2 a,T3 b) &#123;int c=1;cout&lt;&lt;&quot;g2&quot;&lt;&lt;endl;return c;&#125;</span></span><br><span class="line">   <span class="comment">// 类模板特化和部分特化的调用。</span></span><br><span class="line">     A&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m1; m1.<span class="built_in">h</span>();<span class="comment">//正确，调用类模板的特化版本。</span></span><br><span class="line">     A&lt;<span class="keyword">int</span>,<span class="keyword">double</span>,<span class="keyword">int</span>&gt; m; m.<span class="built_in">h</span>(); <span class="comment">//正确，调用类模板的部分特化版本。</span></span><br><span class="line">           <span class="comment">//A&lt;int,int&gt; m2; //错误，类模板有三个类型形参，这里只提供了两个，数量不够，错误。</span></span><br><span class="line">     A&lt;<span class="keyword">double</span>,<span class="keyword">double</span>,<span class="keyword">int</span>&gt; m3; m3.<span class="built_in">h</span>();<span class="comment">//调用类A的部分特化版本。</span></span><br><span class="line">     A&lt;<span class="keyword">double</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m4; m4.<span class="built_in">h</span>();<span class="comment">//调用类A的普通版本，在这里没有A&lt;double,int,int&gt;型的特化或者部分特化版本可用。</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数模板重载（函数定制）："><a href="#函数模板重载（函数定制）：" class="headerlink" title="函数模板重载（函数定制）："></a>函数模板重载（函数定制）：</h3><ol>
<li>函数模板可以重载，注意类模板不存在重载问题，也就是说出现这两条语句时template<code>&lt;class  T&gt;</code>class A{};template<code>&lt;classT1,class T2&gt;</code>class A{};将出错。</li>
<li>模板函数重载的形式为：template<code>&lt;class T&gt;</code> void h(T a, int b){}。Template<code>&lt;class T&gt;</code>void h(T a, double b){}等。</li>
<li>重载模板函数要注意二义性问题，比如template<code>&lt;class T&gt;</code> void h(T a, int b){}和template<code>&lt;class T&gt;</code>void h(T a, T b){}这两个版本就存在二义性问题，当出现语句h(2,3)时就不知道调用哪个才正确，在程序中应避免这种情况出现。</li>
<li>重载函数模板的第二个二义性问题是template<code>&lt;class T&gt;</code>void h(T a, T b){}与template<code>&lt;class T1, class T2&gt;</code>void h(T1 a,T2 b){}，当出现h(2,4)这样的调用时就会出现二义性。解决这个问题的方法是使用显式模板实参，比如要调用第一个h函数，可以使用语法h<code>&lt;int&gt;</code>(2,3)，调用第二个h函数的方法为h<code>&lt;int, int&gt;</code>(2,3)。</li>
<li>函数模板的特化也可以理解为函数模板重载的一种形式。只是特化以template<code>&lt;&gt;</code>开始。</li>
<li>重载的特殊情况：比如template<code>&lt;class T1,class T2&gt;</code> void h(T1 a, T2 b){}，还有个版本如template<code>&lt;class T1&gt;</code>void h(T1 a, int b){}这里两个函数具有两同的名字和相同的形参数量，但形参的类型不同，可以认为第二个版本是第一个版本的重载版本。</li>
<li>函数模板的重载和特化很容易混淆，因为特化很像是一个函数的重载版本，只是开头以template<code>&lt;&gt;</code>开始而已。</li>
</ol>
<h1 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h1><p>在此之前我们来看看模板的形参。因为函数模板的参数相对比较简单，故将此内容放置于类模板中。模板形参有三种类型：类型形参、非类型形参和模板形参。先分别解释如下：</p>
<ul>
<li>类型形参。即由关键字class 或 typename后接的说明符构成，如template <code>&lt;class T&gt;</code>void function(T a);其中T就是类型形参。类型形参的名字由用户自定义，只要是合法的标识符即可。</li>
<li>非类型形参。模板的非类型形参也就是内置类型形参，如template<code>&lt;class T,int a&gt;</code>class B{};其中int a就是非类型形参。非类型形参在模板定义的内部是常量值，也就是说非类型形参在模板内部是常量。使用非类型形参应注意以下几点：</li>
</ul>
<ol>
<li>非类型形参只能是整型、指针和引用。如：double,string,string **等都是不允许的，但是double &amp; ,double *是正确的。</li>
<li>调用非类型模板形参的实参必须是一个常量表达式，即在编译时就能确定其结果。任何局部对象、局部变量、局部变量地址、局部对象地址等都不是一个常量表达式，都不能用作非类型模板形参的实参。全局指针类型、全局变量、全局对象也不是一个常量表达式，不能用作非类型形参的实参。但全局变量的地址、全局对象的地址或应用const类型的变量时常量表达式，可用作非类型模板形参的实参。Sizeof表达式的结果也是一个常量表达式，同样也可以用作非类型模板形参的实参。如：Template <code>&lt;class T,int a&gt;</code>class A{};如果有int b，这时A<code>&lt;int,b&gt;</code> m;就会出错，因为b不是常量，如果有const int b;这时A<code>&lt;int ,b&gt;</code>就是正确的。</li>
<li>非类型形参一般不用于函数模板中。比如有函数模板template <code>&lt;class T,int a&gt;</code>void h(T,b){};若使用h(2)调用就会出错，无法为非类型形参a推演出参数的错误。对这种函数模板可以采用显示模板实参来解决，如h<code>&lt;int ,3&gt;</code>(2)，这样就把非类型形参a设置为整数3。显示模板参数将在后面介绍。</li>
<li>非类型模板形参和实参间允许转换。具体如下；<br>(1) 允许从数组到指针，从函数到指针的转换。如template <code>&lt;int *a&gt;</code>class A{};int c[1];A<code>&lt;c&gt;</code>m。<br>(2) Const修饰符的转换。如template <code>&lt;const int *a&gt;</code>class A{};int c;A<code>&lt;&amp;c&gt;</code>m;即从int * 到const int *的转换。<br>(3) 提升转换。如template <code>&lt;int a&gt;</code> class A{};const short c;A<code>&lt;c&gt;</code>m;即从short到int的提升转换。<br>(4) 整值转换。如template <code>&lt;unsigned int a&gt;</code> class A{};A<code>&lt;3&gt;</code> m;即从int到unsigned int的转换。</li>
</ol>
<ul>
<li>可以为类模板的类型形参提供默认值，但不能为函数模板的类型形参提供默认值。函数模板和类模板都可以为模板的非类型形参提供默认值。如template <code>&lt;class T1,class T2=int&gt;</code>class A{};为第二个模板类型形参提供int型的默认值。</li>
<li>类模板的类型形参默认值和函数的默认参数一样，如果有多个类型形参则从第一个设定了默认值之后所以的模板形参都应设定默认值。如template <code>&lt;class T1=int,class T2&gt;</code>class D{};就是错误的，因为没有给T2设定默认值。但在外部定义类中的成员时，应省去默认的形参类型。如template <code>&lt;class T1,class T2=int&gt;</code>class A{public:void H();};定义方法是template <code>&lt;class T1,class T2&gt;</code>void A<code>&lt;T1,T2&gt;</code>::H(){};</li>
</ul>
<p>现将以上小节总结于以下一例，并通过vs2010调试，请读者仔细相关知识点的应用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行，比如不能在main函数中声明或定义一个模板。</span></span><br><span class="line"><span class="comment">//类模板的定义</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span><span class="keyword">public</span>:<span class="function">T <span class="title">g</span><span class="params">(T a, T b)</span></span>; <span class="built_in">A</span>();&#125;;  <span class="comment">//定义带有一个类模板类型形参T的类A</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span><span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;&#125;; <span class="comment">//定义带有两个类模板类型形参T1，T2的类B</span></span><br><span class="line"><span class="comment">//定义类模板的默认类型形参，默认类型形参不适合于函数模板。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>=</span><span class="keyword">int</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">D</span>&#123;</span><span class="keyword">public</span>: <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;&#125;; <span class="comment">//定义带默认类型形参的类模板。这里把T2默认设置为int型。</span></span><br><span class="line"><span class="comment">//template&lt;class T1=int, class T2&gt;class E&#123;&#125;; //错误，为T1设了默认类型形参则T1后面的所有形参都必须设置认默值。</span></span><br><span class="line"><span class="comment">//以下为非类型形参的定义</span></span><br><span class="line"><span class="comment">//非类型形参只能是整型，指针和引用，像double，String, String **这样的类型是不允许的。但是double &amp;，double *对象的引用或指针是正确的。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">int</span> <span class="title">a</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">Ci</span>&#123;</span><span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;&#125;; <span class="comment">//定义模板的非类型形参，形参为整型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">int</span> &amp;<span class="title">a</span>&gt;</span><span class="class"><span class="keyword">class</span> <span class="title">Cip</span>&#123;</span><span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;&#125;; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">A</span>&lt;</span><span class="keyword">int</span>&gt;* m&gt; <span class="class"><span class="keyword">class</span> <span class="title">Cc</span>&#123;</span><span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;&#125;; <span class="comment">//定义模板的模板类型形参，形参为int型的类A的对象的指针。</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">double</span>*<span class="title">a</span>&gt;</span><span class="class"><span class="keyword">class</span> <span class="title">Cd</span>&#123;</span><span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;&#125;;  <span class="comment">//定义模板的非类型形参，形参为double类型的引用。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span>&#123;</span>&#125;; <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">E</span> &amp;<span class="title">m</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">Ce</span>&#123;</span>&#125;; <span class="comment">//非类型模板形参为对象的引用。</span></span><br><span class="line"><span class="comment">//以下非类型形参的声明是错误的。</span></span><br><span class="line"><span class="comment">//template&lt;class T1,A m&gt;class Cc&#123;&#125;; //错误，对象不能做为非类型形参，非类型模板形参的类型只能是对象的引用或指针。</span></span><br><span class="line"><span class="comment">//template&lt;class T1,double a&gt;class Cc&#123;&#125;; //错误，非类型模板的形参不能是double类型，可以是double的引用。</span></span><br><span class="line"><span class="comment">//template&lt;class T1,A&lt;int&gt; m&gt;class Cc&#123;&#125;; //错误，非类型模板的形参不能是对象，必须是对象的引用或指针。这条规则对于模板型参也不例外。</span></span><br><span class="line"><span class="comment">//在类模板外部定义各种类成员的方法，</span></span><br><span class="line"><span class="comment">//typeid(变量名).name()的作用是提取变量名的类型，如int a，则cout&lt;&lt;typeid(a).name()将输出int</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>   A&lt;T&gt;::<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;class A goucao&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(T).<span class="built_in">name</span>()&lt;&lt;endl;&#125; <span class="comment">//在类模板外部定义类的构造函数的方法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> T A&lt;T&gt;::<span class="built_in">g</span>(T a,T b)&#123;cout&lt;&lt;<span class="string">&quot;class A g(T a,T b)&quot;</span>&lt;&lt;endl;&#125; <span class="comment">//在类模板外部定义类模板的成员</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span>  <span class="keyword">void</span> B&lt;T1,T2&gt;::<span class="built_in">g</span>()&#123;cout&lt;&lt;<span class="string">&quot;class g f()&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(T1).<span class="built_in">name</span>()&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(T2).<span class="built_in">name</span>()&lt;&lt;endl;&#125;</span><br><span class="line"><span class="comment">//在类外面定义类的成员时template后面的模板形参应与要定义的类的模板形参一致</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">int</span> <span class="title">a</span>&gt;</span>     <span class="keyword">void</span> Ci&lt;T1,a&gt;::<span class="built_in">g</span>()&#123;cout&lt;&lt;<span class="string">&quot;class Ci g()&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(T1).<span class="built_in">name</span>()&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">int</span> &amp;<span class="title">a</span>&gt;</span>    <span class="keyword">void</span> Cip&lt;T1,a&gt;::<span class="built_in">g</span>()&#123;cout&lt;&lt;<span class="string">&quot;class Cip g()&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(T1).<span class="built_in">name</span>()&lt;&lt;endl;&#125; </span><br><span class="line"><span class="comment">//在类外部定义类的成员时，template后的模板形参应与要定义的类的模板形参一致</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">A</span>&lt;</span><span class="keyword">int</span>&gt; *m&gt; <span class="keyword">void</span> Cc&lt;T1,m&gt;::<span class="built_in">g</span>()&#123;cout&lt;&lt;<span class="string">&quot;class Cc g()&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(T1).<span class="built_in">name</span>()&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">double</span>* <span class="title">a</span>&gt;</span> <span class="keyword">void</span> Cd&lt;T1,a&gt;::<span class="built_in">g</span>()&#123;cout&lt;&lt;<span class="string">&quot;class Cd g()&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(T1).<span class="built_in">name</span>()&lt;&lt;endl;&#125;</span><br><span class="line"><span class="comment">//带有默认类型形参的模板类，在类的外部定义成员的方法。</span></span><br><span class="line"><span class="comment">//在类外部定义类的成员时，template的形参表中默认值应省略</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span>  <span class="keyword">void</span> D&lt;T1,T2&gt;::<span class="built_in">g</span>()&#123;cout&lt;&lt;<span class="string">&quot;class D g()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="comment">//template&lt;class T1,class T2=int&gt; void D&lt;T1,T2&gt;::g()&#123;cout&lt;&lt;&quot;class D k()&quot;&lt;&lt;endl;&#125; //错误，在类模板外部定义带有默认类型的形参时，在template的形参表中默认值应省略。</span></span><br><span class="line"><span class="comment">//定义一些全局变量。</span></span><br><span class="line"><span class="keyword">int</span> e=<span class="number">2</span>;  <span class="keyword">double</span> ed=<span class="number">2.2</span>; <span class="keyword">double</span>*pe=&amp;ed;</span><br><span class="line">A&lt;<span class="keyword">int</span>&gt; mw; A&lt;<span class="keyword">int</span>&gt; *pec=&amp;mw; E me;</span><br><span class="line"><span class="comment">//main函数开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// template&lt;class T&gt;void h()&#123;&#125; //错误，模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行。</span></span><br><span class="line">    <span class="comment">//A&lt;2&gt; m; //错误，对类模板不存在实参推演问题，类模板必须在尖括号中明确指出其类型。</span></span><br><span class="line">    <span class="comment">//类模板调用实例</span></span><br><span class="line">    A&lt;<span class="keyword">int</span>&gt; ma; <span class="comment">//输出&quot;class A goucao int&quot;创建int型的类模板A的对象ma。</span></span><br><span class="line">    B&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mb; mb.<span class="built_in">g</span>(); <span class="comment">//输出&quot;class B g() int int&quot;创建类模板B的对象mb，并把类型形参T1和T2设计为int</span></span><br><span class="line">    <span class="comment">//非类型形参的调用</span></span><br><span class="line">    <span class="comment">//调用非类型模板形参的实参必须是一个常量表达式，即他必须能在编译时计算出结果。任何局部对象，局部变量，局部对象的地址，局部</span></span><br><span class="line">    <span class="comment">//变量的地址都不是一个常量表达式，都不能用作非类型模板形参的实参。全局指针类型，全局变量，全局对象也不是一个常量表达式，不能</span></span><br><span class="line">    <span class="comment">//用作非类型模板形参的实参。</span></span><br><span class="line">    <span class="comment">//全局变量的地址或引用，全局对象的地址或引用const类型变量是常量表达式，可以用作非类型模板形参的实参。</span></span><br><span class="line">    <span class="comment">//调用整型int型非类型形参的方法为名为Ci，声明形式为template&lt;class T1,int a&gt; class Ci        Ci&lt;int,GHIJKLMJKLNOPQMII//正确，数值R是一个int型常量，输出&quot;class Ci g() int&quot;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a2=<span class="number">3</span>;Ci&lt;<span class="keyword">int</span>,a2&gt; mci1; mci1.<span class="built_in">g</span>(); <span class="comment">//正确，因为a2在这里是const型的常量。输出&quot;class Ci g() int&quot;</span></span><br><span class="line">    <span class="comment">//Ci&lt;int,a&gt; mci; //错误，int型变量a是局部变量，不是一个常量表达式。</span></span><br><span class="line">    <span class="comment">//Ci&lt;int,e&gt; mci; //错误，全局int型变量e也不是一个常量表达式。</span></span><br><span class="line">    <span class="comment">//调用int&amp;型非类型形参的方法类名为Cip，声明形式为template&lt;class T1,int &amp;a&gt;class Cip</span></span><br><span class="line">    Cip&lt;<span class="keyword">int</span>,e&gt; mcip;  <span class="comment">//正确，对全局变量的引用或地址是常量表达式。</span></span><br><span class="line">    <span class="comment">//Cip&lt;int,a&gt; mcip1; //错误，局部变量的引用或地址不是常量表达式。</span></span><br><span class="line">    <span class="comment">//调用double*类型的非类形形参类名为Cd，声明形式为template&lt;class T1,double *a&gt;class Cd</span></span><br><span class="line">    Cd&lt;<span class="keyword">int</span>,&amp;ed&gt; mcd; <span class="comment">//正确，全局变量的引用或地址是常量表达式。</span></span><br><span class="line">    <span class="comment">//Cd&lt;int,pe&gt; mcd1; //错误，全局变量指针不是常量表达式。</span></span><br><span class="line">    <span class="comment">//double dd=aNGMIITbULcdefbbHIJKbgMIhh错误，局部变量的地址不是常量表达式，不能用作非类型形参的实参</span></span><br><span class="line">    <span class="comment">//Cd&lt;int,&amp;e&gt; mcd;  //错误，非类型形参虽允许一些转换，但这个转换不能实现。</span></span><br><span class="line">    <span class="comment">//调用模板类型形参对象A&lt;int&gt; *的方法类名为Cc，声名形式为template&lt;class T1,A&lt;int&gt;* m&gt; class Cc</span></span><br><span class="line">    Cc&lt;<span class="keyword">int</span>,&amp;mw&gt; mcc; mcc.<span class="built_in">g</span>(); <span class="comment">//正确，全局对象的地址或者引用是常量表达式</span></span><br><span class="line">    <span class="comment">//Cc&lt;int,&amp;ma&gt; mcc;  //错误，局部变量的地址或引用不是常量表达式。</span></span><br><span class="line">    <span class="comment">//Cc&lt;int,pec&gt; mcc2;  //错误，全局对象的指针不是常量表达式。</span></span><br><span class="line">    <span class="comment">//调用非类型形参E&amp;对象的引用的方法类名为Ce。声明形式为template&lt;class T1,E &amp;m&gt; class Ce</span></span><br><span class="line">    E me1; <span class="comment">//Ce&lt;int,me1&gt; mce1; //错误，局部对象不是常量表达式</span></span><br><span class="line">    Ce&lt;<span class="keyword">int</span>,me&gt; mce;  <span class="comment">//正确，全局对象的指针或引用是常量表达式。</span></span><br><span class="line">    <span class="comment">//非类型形参的转换示例，类名为Ci</span></span><br><span class="line">    <span class="comment">//非类型形参允许从数组到指针，从函数到指针的转换，const修饰符的转换，提升转换，整值转换，常规转换。</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">short</span> s=<span class="number">3</span> ;Ci&lt;<span class="keyword">int</span>,s&gt; mci ;<span class="comment">//正确，虽然short型和int不完全匹配，但这里可以将short型转换为int型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与函数模板相同，类模板的声明语句也必须至于类声明的前面。有两个以上模板参数时，应使用逗号分开。使用含类模板的类定义对象时也必须在类名的后面带上“﹤实际类型﹥”的参数列表。类模板最常用于各种类包容关系的设计模型中。</p>
<h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>Template ﹤类型参数表﹥ class 类名 {类声明体}</p>
<p>在使用类模板时，应注意以下几点：</p>
<ul>
<li>在所有出现类模板的地方不能直接用类名表示，都应加上﹤…﹥</li>
<li>在类模板定义体中，可以省略﹤…﹥</li>
<li>一个类模板的各个实例之间没有特殊的联系（形成一个独立的类）如：Queue<code>&lt;int&gt;</code> qi 和Queue<code>&lt;string&gt;</code> qs，分别表示整数队列和字符队列</li>
<li>实例化时机：在需要时实例化，比如定义指针或引用是不需要实例化，定义具体的变量或常量时会实例化，而访问对象的成员时会实例化。如 Queue<code>&lt;int&gt;</code> *q //不实例化Queue<code>&lt;&gt;</code> ,Queue<code>&lt;int&gt;</code> iq //实例化Queue<code>&lt;&gt;</code>，iq-&gt;<code>add(2) //实例化Queue</code>&lt;&gt;`</li>
<li>类模板的显式实例化：和函数模板的显式实例化一样都是以template开始。比如template class A<code>&lt;int,int&gt;</code>;将类A显式实例化为两个int型的类模板。这里要注意显式实例化后面不能有对象名，且以分号结束。显式实例化可以让程序员控制模板实例化发生的时间。</li>
</ul>
<h2 id="类模板中的友元："><a href="#类模板中的友元：" class="headerlink" title="类模板中的友元："></a>类模板中的友元：</h2><ul>
<li><p>非模板函数、类成为所有实例类的友元。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class Foo &#123; <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>;&#125;;</span><br><span class="line">Template &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line">Class QueueItem</span><br><span class="line">&#123;</span><br><span class="line">         Friend <span class="class"><span class="keyword">class</span> <span class="title">Foobar</span>;</span>  <span class="comment">//类Foobar不需要先定义或声明，并没有&lt;&gt;</span></span><br><span class="line">         <span class="function">Frined <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;    <span class="comment">//函数foo（）</span></span><br><span class="line">         <span class="function">Frined <span class="keyword">void</span> <span class="title">Foo::bar</span><span class="params">()</span></span>;<span class="comment">//类Foo必须先定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>模板函数、模板类成为同类型实例类的友元。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Template &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span>…&#125;;</span><br><span class="line">Template &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span> <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(QueueItem&lt;Type&gt;)</span></span>;</span><br><span class="line">Template &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&#123;</span> <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>;&#125;;</span><br><span class="line">Template &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueItem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">         Friend <span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&lt;</span>Type&gt;;  <span class="comment">//模板类Foo需要先定义或声明，并带有&lt;&gt;</span></span><br><span class="line">         <span class="function">Friend <span class="keyword">void</span> <span class="title">foo</span><span class="params">(QueueItem&lt;Type&gt;)</span></span>; <span class="comment">//模板函数foo()需要先定义或声明</span></span><br><span class="line">         Friend <span class="keyword">void</span> Queue&lt;Type&gt;::<span class="built_in">bar</span>();   <span class="comment">//模板类Queue必须先定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>模板函数、模板类成为不同类型实例类的友元。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueItem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">         Template &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span> <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span>;</span></span><br><span class="line">         Template &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span> <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(QueueItem&lt;Type&gt;)</span></span>;</span><br><span class="line">         Template &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span> <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Queue::bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>类模板中有普通友元函数，友元类，模板友元函数和友元类。</p>
</li>
<li><p>可以建立两种类模板的友元模板，即约束型的友元模板和非约束型的友元模板。</p>
</li>
<li><p>非约束型友元模板：即类模板的友元模板类或者友元模板函数的任一实例都是外围类的任一实例的友元，也就是外围类和友元模板类或友元模板函数之间是多对多的关系</p>
</li>
<li><p>约束型友元模板：即类模板的友元模板类或友元模板函数的一个特定实例只是外围类的相关的一个实例的友元。即外围类和友元模板类或友元模板函数之间是一对一的关系。</p>
</li>
<li><p>约束型友元模板函数或友元类的建立：比如有前向声明：template<code>&lt;class T1&gt;</code> void g(T1 a); template<code>&lt;class T2&gt;</code> void g1(); template<code>&lt;class T3&gt;</code>class B;则template<code>&lt;class T&gt;</code>class A{friend void g<code>&lt;&gt;</code>(T a); friend void g1<code>&lt;T&gt;</code>(); friend class B<code>&lt;T&gt;</code>;};就建立了三个约束型友元模板，其中g和g1是函数，而B是类。注意其中的语法。这里g<code>&lt;int&gt;</code>型和类A<code>&lt;int&gt;</code>型是一对一的友元关系，g<code>&lt;double&gt;</code>和A<code>&lt;double&gt;</code>是一个一对一的友元关系。</p>
</li>
<li><p>非约束型友元模板函数或友元类的建立：非约束型友元模板和外围类具有不同的模板形参，比如template<code>&lt;class T&gt;</code>class A{template<code>&lt;class T1&gt;</code> friend void g(T1 a); template<code>&lt;class T2&gt;</code> friend class B;}注意其中的语法，非约束型友元模板都要以template开头。要注意友元模板类，在类名B的后面没有尖括号。</p>
</li>
<li><p>不存在部分约束型的友元模板或者友元类：比如template<code>&lt;class T&gt;</code> class A{template<code>&lt;class T1&gt;</code>friend void g(T1 a, T b);<br>template<code>&lt;class T3&gt;</code>friend class B<code>&lt;T3,T&gt;</code>;}其中函数g具有template<code>&lt;class T1,class T2&gt;</code>void g(T1 a,T2 b)的形式。其中的函数g试图把第二个模板形参部分约束为类A的模板形参类型，但是这是无效的，这种语法的结果是g函数的非约束型类友元函数，而对类B的友元声明则是一种语法错误。</p>
</li>
</ul>
<h2 id="类模板中的模板成员-模板函数-模板类-和静态成员"><a href="#类模板中的模板成员-模板函数-模板类-和静态成员" class="headerlink" title="类模板中的模板成员(模板函数,模板类)和静态成员"></a>类模板中的模板成员(模板函数,模板类)和静态成员</h2><ol>
<li>类模板中的模板函数和模板类的声明：与普通模板的声明方式相同，即都是以template 开始</li>
<li>在类模板外定义类模板中的模板成员的方法：比如template<code>&lt;class T1&gt;</code> class A {public:template<code>&lt;class T2&gt;</code> class B; template<code>&lt;class T3&gt;</code> void g(T3 a);};则在类模板外定义模板成员的方法为,template<code>&lt;class  T1&gt;</code> template<code>&lt;class T2&gt;</code> class A<code>&lt;T1&gt;</code>::B{};定义模板函数的方法为：template<code>&lt;class T1&gt;</code> template<code>&lt;class T3&gt;</code> void A<code>&lt;T1&gt;</code>::g(T3 a){}其中第一个template指明外围类的模板形参，第二个template指定模板成员的模板形参，而作用域解析运算符指明是来自哪个类的成员。</li>
<li>实例化类模板的模板成员函数：比如上例中要实例化函数g()则方法为, A<code>&lt;int&gt;</code> m; m.g(2);这里外围类A的模板形参由尖括号中指出，而类中的模板函数的参数由整型值2推演出为int 型。</li>
<li>创建类模板中的模板成员类的对象的方法：比如上例中要创建模板成员类B的方法为，A<code>&lt;int&gt;</code>::B<code>&lt;int&gt;</code> m1；A<code>&lt;int&gt;</code>::B<code>&lt;doble&gt;</code>m2;  A<code>&lt;double&gt;</code>::B<code>&lt;int&gt;</code> m3;在类模板成员B的前面要使用作用域解析运算符以指定来自哪个外围类，并且在尖括号中要指定创建哪个外围类的实例的对象。这里说明在类模板中定义模板类成员时就意味意该外围模板类的一个实例比如int 实例将包含有多个模板成员类的实例。比如这里类A的int 实例就有两个模板成员类B的int 和double两个实例版本。</li>
<li>要访问类模板中的模板成员类的成员遵守嵌套类的规则，因为类模板中的模板成员类就是一个嵌套类。即外围类和嵌套类中的成员是相互独立的，要访问其中的成员只能通过嵌套类的指针，引用或对象的方式来访问。具体情况见嵌套类部分。</li>
<li>类模板中的静态成员是类模板的所有实例所共享的。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span><span class="keyword">public</span>:<span class="keyword">int</span> a,b; <span class="keyword">static</span> <span class="keyword">int</span> e;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T3</span>,<span class="keyword">class</span> <span class="title">T4</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line">template&lt;class T5,class T6&gt; void g(T5 a,T6 b);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&#123;</span><span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;class C gc()&quot;</span>&lt;&lt;endl;&#125;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g1</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;putong g1()&quot;</span>&lt;&lt;endl;&#125; &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T3</span>,<span class="keyword">class</span> <span class="title">T4</span>&#125;<span class="keyword">class</span> <span class="title">A</span>&lt;</span>T1,T2&gt;::B&#123;<span class="keyword">public</span>:<span class="function"><span class="keyword">void</span> <span class="title">gb</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;moban class B gb()&quot;</span>&lt;&lt;endl;&#125;&#125;</span><br><span class="line"><span class="comment">//在类模板外面定义类模板的模板成员类的方法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T5</span>,<span class="keyword">class</span> <span class="title">T6</span>&#125;<span class="title">void</span> <span class="title">A</span>&lt;</span>T1,T2&gt;::<span class="built_in">g</span>(T5 a,T6 b)&#123;cout&lt;&lt;<span class="string">&quot;moban g()&quot;</span>&lt;&lt;endl;&#125;<span class="comment">//在类模板外面定义类模板的模板成员函数的方法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="keyword">class</span> <span class="title">T2</span>&gt;</span> <span class="keyword">int</span> A&lt;T1,T2&gt;::e=<span class="number">0</span>;<span class="comment">//在类模板外面定义静态成员的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; ma;</span><br><span class="line">    ma.<span class="built_in">g</span>(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//创建模板类中模板成员函数的方法，在这里模板类A的模板形参被设为int，而模板成员函数的模板形参则由两个int型的整    数推演为int型。</span></span><br><span class="line">    ma.e=<span class="number">1</span>; A&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::e=<span class="number">2</span>;  <span class="comment">//把类模板A的int,int型实例的静态成员设为。</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;ma.e=&quot;</span>&lt;&lt;ma.e&lt;&lt;endl; </span><br><span class="line">    A&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; ma1;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;ma.e=&quot;</span>&lt;&lt;ma1.e&lt;&lt;A&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::e&lt;&lt;A&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt;::e&lt;&lt;endl; <span class="comment">//因为类模板A的int,int型实例和int,double实例是两个实例，所以这里的静态常量e的值不是三个二。</span></span><br><span class="line">    A&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::B&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mb;  <span class="comment">//声明模板类中模板成员类的方法。</span></span><br><span class="line">    mb.<span class="built_in">gb</span>();<span class="comment">//调用嵌套类B的成员函数</span></span><br><span class="line">    <span class="comment">//mb.g(); //错误，函数g()是外围类的成员，嵌套类不能访问外围类的成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">简单模板实例，参数列表为基本类型：</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span></span></span><br><span class="line"><span class="class">&#123;</span>    T *ar;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Array</span>(<span class="keyword">int</span> c)&#123;ar=<span class="keyword">new</span> T[c];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n,T x)</span></span>&#123;ar[n]=x;    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> n)&#123;<span class="keyword">return</span> ar[n];&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">Array&lt;<span class="keyword">int</span>&gt; <span class="title">array</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Please input every element&#x27;s value:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123; </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;No.&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&#x27;:&#x27;</span>;  </span><br><span class="line">        cin&gt;&gt;array[i];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">类模板参数是类：</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> x):<span class="built_in">j</span>(x)&#123;&#125;</span><br><span class="line">    <span class="built_in">A</span>(A *x)&#123;j=x-&gt;j;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>!()&#123;cout&lt;&lt;<span class="string">&quot;J=&quot;</span>&lt;&lt;j&lt;&lt;endl;&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">     T *x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="keyword">int</span> xa,T *p):<span class="built_in">i</span>(xa)&#123;x=<span class="keyword">new</span> <span class="built_in">T</span>(p);&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>!()&#123;cout&lt;&lt;<span class="string">&quot;I=&quot;</span>&lt;&lt;i&lt;&lt;endl;!*x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;        <span class="comment">//最后的显示结果为：</span></span><br><span class="line">    <span class="function">B&lt;A&gt; <span class="title">b</span><span class="params">(<span class="number">2</span>,&amp;a)</span></span>;  <span class="comment">//I=2</span></span><br><span class="line">    !b;           <span class="comment">//J=1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Typename的使用：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">X</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">typename</span> T::id i; <span class="comment">//如无typename看看情况如何</span></span><br><span class="line"><span class="keyword">public</span>: <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            i.<span class="built_in">g</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span>: <span class="class"><span class="keyword">class</span> <span class="title">id</span> </span></span><br><span class="line"><span class="class">        &#123;</span> </span><br><span class="line">            <span class="keyword">public</span>: <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">                    </span>&#123;</span><br><span class="line">                        std::cout&lt;&lt;<span class="string">&quot;Hello World!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">                    &#125; </span><br><span class="line">        &#125;; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//Y y;</span></span><br><span class="line">    X&lt;Y&gt; xy; </span><br><span class="line">    xy.<span class="built_in">f</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Typename关键字告诉编译器把一个特殊的名字解释成一个类型，在下列情况下必须对一个name使用typename关键字：</p>
<ul>
<li>一个唯一的name（可以作为类型理解），嵌套在另一个类型中。</li>
<li>依赖于一个模板参数，就是说，模板参数在某种程度上包含这个name。当模板参数使编译器在指认一个类型时便会产生误解。</li>
</ul>
<p>在定义模板时，typename和class作用基本相同，至于二者的其他关系没有什么区别，仅是历史原因，typename仅是一个新生代。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">复杂的模板类实例：</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">static</span> Student *ip;</span><br><span class="line">    Student *p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>()&#123;p=<span class="literal">NULL</span>;&#125;</span><br><span class="line">    <span class="built_in">Student</span>(<span class="keyword">int</span> n);</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Student* <span class="title">get_first</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> ip;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_number</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;number;&#125;</span><br><span class="line">    <span class="function">Student* <span class="title">get_next</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;p;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student::<span class="built_in">Student</span>(<span class="keyword">int</span> n):<span class="built_in">number</span>(n)  <span class="comment">//依据学号的大小顺序将学生对象插入链表</span></span><br><span class="line">&#123;</span><br><span class="line">    p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(ip==<span class="literal">NULL</span>)ip=<span class="keyword">this</span>;  <span class="comment">//如果是第一个则使头指针指向该对象</span></span><br><span class="line">    <span class="keyword">else</span>&#123;Student *temp=ip;      </span><br><span class="line">    <span class="keyword">if</span>(n&lt;ip-&gt;number)&#123;ip=<span class="keyword">this</span>;p=temp;&#125;<span class="comment">//如学号小于第一个学生对象的学号则使头指针指向该对象</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(temp)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(n&lt;temp-&gt;p-&gt;number)</span><br><span class="line">            &#123;</span><br><span class="line">                p=temp-&gt;p;  <span class="comment">//链中间对象的插入</span></span><br><span class="line">                temp-&gt;p=<span class="keyword">this</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> </span><br><span class="line">            &#123;    </span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;p-&gt;p==<span class="literal">NULL</span>)  <span class="comment">//最后一个链的插入</span></span><br><span class="line">                &#123;</span><br><span class="line">                    temp-&gt;p-&gt;p=<span class="keyword">this</span>;<span class="keyword">break</span>;</span><br><span class="line">                &#125;                    &#125;</span><br><span class="line">            temp=temp-&gt;p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Student* Student::ip=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    T *p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">Class</span>()&#123;&#125;</span><br><span class="line">       <span class="built_in">Class</span>(<span class="keyword">int</span> n):<span class="built_in">num</span>(n)&#123;p=<span class="literal">NULL</span>;&#125;</span><br><span class="line">       <span class="function">T* <span class="title">insert</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;p=<span class="keyword">new</span> <span class="built_in">T</span>(n);<span class="keyword">return</span> p;&#125;</span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">list_all_member</span><span class="params">(T* x)</span></span></span><br><span class="line"><span class="function">       </span>&#123;   T *temp=x;</span><br><span class="line">       <span class="keyword">while</span>(temp) &#123; cout&lt;&lt;temp-&gt;<span class="built_in">get_number</span>()&lt;&lt;<span class="string">&quot;,&quot;</span>;temp=temp-&gt;<span class="built_in">get_next</span>();&#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">Class&lt;Student&gt; <span class="title">x97x</span><span class="params">(<span class="number">9707</span>)</span></span>;</span><br><span class="line">    x97x.<span class="built_in">insert</span>(<span class="number">23</span>);</span><br><span class="line">    x97x.<span class="built_in">insert</span>(<span class="number">12</span>);</span><br><span class="line">    x97x.<span class="built_in">insert</span>(<span class="number">38</span>);</span><br><span class="line">    x97x.<span class="built_in">insert</span>(<span class="number">22</span>);</span><br><span class="line">    x97x.<span class="built_in">insert</span>(<span class="number">32</span>);</span><br><span class="line">    x97x.<span class="built_in">list_all_member</span>(Student::<span class="built_in">get_first</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板根据参数的类型进行实例化"><a href="#模板根据参数的类型进行实例化" class="headerlink" title="模板根据参数的类型进行实例化"></a>模板根据参数的类型进行实例化</h2><p>现在来讨论模板安全：模板根据参数的类型进行实例化。因为通常事先不知道其具体类型，所以也无法确切知道将在哪儿产生异常。程序员需要知道程序在什么地方发生了异常。下面看一个简单的模板类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Template &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Class Wrapper</span><br><span class="line">&#123;</span><br><span class="line">Public:</span><br><span class="line">         <span class="built_in">Wrapper</span>()&#123;&#125;</span><br><span class="line">         <span class="function">T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> value_;&#125;</span><br><span class="line">         <span class="function">T <span class="title">set</span><span class="params">(T <span class="keyword">const</span> &amp;value)</span></span>&#123;value_=value;&#125;</span><br><span class="line">Private:</span><br><span class="line">         T value_;</span><br><span class="line">         <span class="built_in">Wrapper</span>(Wrapper <span class="keyword">const</span> &amp;);</span><br><span class="line">         Wrapper &amp;<span class="keyword">operator</span>=(Wrapper <span class="keyword">const</span> &amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>实例化过程很简单，如Wrapper <code>&lt;int&gt;</code> i；因为Wrapper <code>&lt;int&gt;</code>只接受int或其引用，所以不会触及异常，Wrapper <code>&lt;int&gt;</code>不抛异常，也没有直接或者间接调用任何可能抛异常的函数，因此Wrapper <code>&lt;int&gt;</code>是异常安全的。<br>现在再来看Wrapper<code>&lt;X&gt;</code>x,这里X是一个类。在这个定义里，编译器实例化了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Template &lt;&gt; Class Wrapper&lt;X&gt;</span><br><span class="line">&#123;</span><br><span class="line">Public:</span><br><span class="line">         <span class="built_in">Wrapper</span>()&#123;&#125;</span><br><span class="line">         <span class="function">X <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> value_;&#125;</span><br><span class="line">         <span class="function">X <span class="title">set</span><span class="params">(X <span class="keyword">const</span> &amp;value)</span></span>&#123;value_=value;&#125;</span><br><span class="line">Private:</span><br><span class="line">         T value_;</span><br><span class="line">         <span class="built_in">Wrapper</span>(Wrapper <span class="keyword">const</span> &amp;);</span><br><span class="line">         Wrapper &amp;<span class="keyword">operator</span>=(Wrapper <span class="keyword">const</span> &amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在就有问题出现了：</p>
<ul>
<li>Wrapper<code>&lt;X&gt;</code> 包含了一个X的子对象。这个子对象需要构造，意味着调用X的构造函数，这个构造函数可能抛出异常。</li>
<li>Wrapper<code>&lt;X&gt;</code>::get()产生并返回了一个X的临时对象。为了这个临时对象，get()调用了X的拷贝构造函数，这个函数可能抛出异常。</li>
<li>Wrapper<code>&lt;X&gt;</code>::set()执行了表达式value_=value，他实际上调用了X的赋值运算。这个运算可能抛出异常。</li>
</ul>
<p>可以看到，同样的模板和同样的语句，但其含义不同。由于这样的不确定性，我们需要采用保守策略：假设Wrapper会根据类来实例化，而这些类在其成员上没有进行异常规格申明，则他们可能抛出异常。<br>再假设Wrapper的异常规格申明承诺其成员不产生异常。至少必须在其成员上加上异常规格申明throw()，所以需要修补掉这些可能导致异常的地方：</p>
<ul>
<li>在Wrapper：：Wrapper()中构造value_的过程。</li>
<li>在Wrapper::get()中返回value_的过程。</li>
<li>在Wrapper::set()中队value_的赋值过程。</li>
</ul>
<p>另外，在违背throw()的异常规格申明是，还要处理std::unexpected.</p>
<p>再来看默认构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Wrapper</span>() <span class="keyword">throw</span>()</span><br><span class="line">Try:<span class="built_in">T</span>() &#123;&#125;</span><br><span class="line"><span class="built_in">Catch</span> (…)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>虽然看上去不错，但它不能工作，根据C++标准：对构造函数或析构函数上的function-try-block，当控制权到达了异常处理函数的结束点是，被捕获的异常被再次抛出。对于一般的函数，此时是函数返回，等同于没有返回值的return 语句，对于定了返回类型的函数此时的行为未定义。换句话说，上面的程序相当于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X::<span class="built_in">X</span>() <span class="keyword">throw</span>()</span><br><span class="line">Try: <span class="built_in">T</span> ()&#123;&#125;</span><br><span class="line"><span class="built_in">Catch</span> (…)&#123; <span class="keyword">throw</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>这不是程序本来想要的结果，换成以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X::<span class="built_in">X</span>() <span class="keyword">throw</span>()</span><br><span class="line">Try: <span class="built_in">T</span> ()&#123;&#125;</span><br><span class="line"><span class="built_in">Catch</span> (…)&#123; <span class="keyword">return</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>但是它却违背了标准：如果在构造函数上的function-try-block的异常处理函数体中出现了return语句，则程序是病态的。最终：无法用function-try-block快来实现构造函数的接口安全。</p>
<ul>
<li>引申原则1：尽可能使用构造函数不抛异常的基类或成员子对象。</li>
<li>引申原则2：为了帮助别人实现原则1，不要从构造函数中抛出任何异常。</li>
</ul>
<p>其他方面的不再讨论，比如析构与关键字new等。总之，良好的设计必须满足以下两个原则：</p>
<ul>
<li>通过异常对象的存在来注视异常状态，并适当的做出反应。</li>
<li>确保创造和传播异常对象不会造成更大的破坏。</li>
</ul>
<p>最终代码的参考将如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">wrapper</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">wrapper</span>()     <span class="keyword">throw</span>() : <span class="built_in">value_</span>(<span class="literal">NULL</span>)</span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;    </span><br><span class="line">            value_ = <span class="keyword">new</span> T;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">catch</span></span> (...) &#123;      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">wrapper</span>() <span class="keyword">throw</span>()</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">delete</span> value_;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">catch</span></span> (...)&#123;<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(value_)</span></span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">get</span><span class="params">(T &amp;value)</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">assign</span>(value, *value_);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">set</span><span class="params">(T <span class="keyword">const</span> &amp;value)</span> <span class="title">throw</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">assign</span>(*value_, value);&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">assign</span><span class="params">(T &amp;to, T <span class="keyword">const</span> &amp;from)</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">error</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;to = from; &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">catch</span></span> (...) &#123; error = <span class="literal">true</span>;&#125;</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    T *value_;</span><br><span class="line">    <span class="built_in">wrapper</span>(wrapper <span class="keyword">const</span> &amp;);</span><br><span class="line">    wrapper &amp;<span class="keyword">operator</span>=(wrapper <span class="keyword">const</span> &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">wrapper&lt;<span class="keyword">int</span>&gt; <span class="title">mywrapper</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h2><p>可以像使用普通类的方法来使用模板类，这一点毫无疑问，例如：可以继承、创建一个从现有模板继承过来的并已经初始化的模板。现在，我们来看看模板的继承，如果vector已经为你做了很多事，但你还想加入sort()的功能，则可用下面代码来扩充。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SORTED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SORTED </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sorted</span>:</span><span class="keyword">public</span> std::vector&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Sorted&lt;T&gt;::<span class="built_in">sort</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="built_in">size</span>();i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">at</span>(j<span class="number">-1</span>)&gt;<span class="built_in">at</span>(j))</span><br><span class="line">            &#123;</span><br><span class="line">                T t=<span class="built_in">at</span>(j<span class="number">-1</span>);</span><br><span class="line">                <span class="built_in">at</span>(j<span class="number">-1</span>)=<span class="built_in">at</span>(j);</span><br><span class="line">                <span class="built_in">at</span>(j)=t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">实现文件</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;123.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">char</span>* words[] = &#123;<span class="string">&quot;is&quot;</span>, <span class="string">&quot;running&quot;</span>, <span class="string">&quot;big&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;a&quot;</span>&#125;; </span><br><span class="line"><span class="keyword">char</span>* words2[] = &#123; <span class="string">&quot;this&quot;</span>, <span class="string">&quot;that&quot;</span>, <span class="string">&quot;theother&quot;</span> &#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Sorted&lt;<span class="keyword">int</span>&gt; is; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">15</span>; i &gt;<span class="number">0</span>; i--)    is.<span class="built_in">push_back</span>(i); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; is.<span class="built_in">size</span>(); l++)  cout &lt;&lt; is[l] &lt;&lt; <span class="string">&#x27; &#x27;</span>; </span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line">    is.<span class="built_in">sort</span>(); </span><br><span class="line">    <span class="keyword">for</span>(l = <span class="number">0</span>; l &lt; is.<span class="built_in">size</span>(); l++) cout &lt;&lt; is[l] &lt;&lt; <span class="string">&#x27; &#x27;</span>; </span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line">    Sorted&lt;string*&gt; ss; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) ss.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">string</span>(words[i])); </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; ss.<span class="built_in">size</span>(); i++) cout &lt;&lt; *ss[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; </span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line">    ss.<span class="built_in">sort</span>(); </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; ss.<span class="built_in">size</span>(); i++) cout &lt;&lt; *ss[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; </span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line">    Sorted&lt;<span class="keyword">char</span>*&gt; scp; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) scp.<span class="built_in">push_back</span>(words2[i]); </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; scp.<span class="built_in">size</span>(); i++) cout &lt;&lt; scp[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; </span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line">    scp.<span class="built_in">sort</span>(); </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; scp.<span class="built_in">size</span>(); i++) cout &lt;&lt; scp[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>; </span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上简单实现了模板的继承，读者可自行编写相关代码进行测试，并分析模板继承情况下，析构函数和构造函数等的消坏和初始化情况，这里不这讨论。</p>
<p>注意：子类并不会从通用的模板基类继承而来，只能是从基类的某一个实例继承而来。</p>
<p>现将模板的继承方式总结以下几点：</p>
<ul>
<li>基类是模板类的一个特定实例化的版本。比如：template <code>&lt;class T1&gt;</code> class B:public A<code>&lt;int&gt;</code>{}.</li>
<li>基类是一个和子类相关的一个实例。比如：template <code>&lt;class T1&gt;</code>class B:public A<code>&lt;T1&gt;</code>{}。这时实例化基类就相应的被实例化一个和基类相同的实例版本，比如：B<code>&lt;int&gt;</code> b;模板B被实例化为int 版本，这时基类A也相应的被实例化为Int版本。</li>
<li>如果基类是一个特定的实例化版本，这时子类可以不是一个模板，比如：class B:public A<code>&lt;int&gt;</code>{};。</li>
</ul>
<p>每次实例化一个模板，模板的代码都会被重新生成（除了inline标记的函数），如果一个模板某些函数不依赖于特定的类型参数而存在，那它们就可以放置在一个通用的基础类中，来阻止无意义的代码重生。</p>
<p>Inline函数因不产生新的代码所以它们是自由的，在整个过程中，功能性的代码只是在我们创建基础类代码时产生了一次，而且，所属权的问题也因为增加了新的析构函数而解决。通常模板只有在需要的时候才实例化，对函数模板来说，这就意味着调用它时才被实例化，但对类模板来说，它更加明细化，只有在使用到模板中的某个函数式，函数才会被实例化，换句话说：只有用到的成员函数被实例化了。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">x</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;This is fuction x()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">y</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;This is fuction y()&quot;</span>&lt;&lt;endl; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Z</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T t; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123; t.<span class="built_in">x</span>(); &#125; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123; t.<span class="built_in">y</span>(); &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Z&lt;X&gt; zx; </span><br><span class="line">    zx.<span class="built_in">a</span>(); <span class="comment">// Doesn&#x27;t create Z&lt;X&gt;::b() </span></span><br><span class="line">    Z&lt;Y&gt; zy; </span><br><span class="line">    zy.<span class="built_in">b</span>(); <span class="comment">// Doesn&#x27;t create Z&lt;Y&gt;::a()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后用模板技术演示list的的使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Template class for storing list elements</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>                          <span class="comment">// Use template keyword</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListElement</span>                            //定义类<span class="title">ListElement</span>,用于表示<span class="title">list</span>对象</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T data;</span><br><span class="line">    ListElement&lt;T&gt; * next ;</span><br><span class="line">    <span class="built_in">ListElement</span>(T&amp; i_d, ListElement &lt;T&gt;* i_n)</span><br><span class="line">    : <span class="built_in">data</span>(i_d),<span class="built_in">next</span>(i_n) &#123; &#125;</span><br><span class="line">    <span class="function">ListElement&lt;T&gt;* <span class="title">copy</span><span class="params">()</span>                    <span class="comment">// copy includes all next elements</span></span></span><br><span class="line"><span class="function">    </span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ListElement</span>(data,(next?next-&gt;<span class="built_in">copy</span>():<span class="number">0</span>));    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListIterator</span>        //定义类<span class="title">ListIterator</span>,用于访问和操作<span class="title">list</span>对象</span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">                                            <span class="comment">//ListIterator(List&lt;T&gt;&amp; l) ;</span></span><br><span class="line">   <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>;</span><br><span class="line">   <span class="keyword">int</span> <span class="keyword">operator</span>++() ;</span><br><span class="line">   <span class="keyword">int</span> <span class="keyword">operator</span>!() ;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     ListElement&lt;T&gt;* rep ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T ListIterator&lt;T&gt;::<span class="built_in"><span class="keyword">operator</span></span>() ()</span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (rep) <span class="keyword">return</span> rep-&gt;data;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        T tmp ;    <span class="keyword">return</span> tmp ;                <span class="comment">// Default value  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> ListIterator&lt;T&gt;::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">if</span> (rep)</span><br><span class="line">        rep = rep-&gt;next ;   </span><br><span class="line">    <span class="keyword">return</span> (rep != <span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> ListIterator&lt;T&gt;::<span class="keyword">operator</span>!()</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">return</span> (rep != <span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span>                //定义类<span class="title">List</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIterator</span>&lt;</span>T&gt; ;</span><br><span class="line">    <span class="built_in">List</span>();</span><br><span class="line">    <span class="built_in">List</span>(<span class="keyword">const</span> List&amp;);</span><br><span class="line">    ~<span class="built_in">List</span>();</span><br><span class="line">    List&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> List&lt;T&gt;&amp;);</span><br><span class="line">                                            <span class="comment">// typical list ops</span></span><br><span class="line">    <span class="function">T <span class="title">head</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">tail</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T&amp;)</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;, <span class="keyword">const</span> List&lt;T&gt;&amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>;                            <span class="comment">// Delete all list elements</span></span><br><span class="line">    ListElement&lt;T&gt;* rep ;</span><br><span class="line">&#125;;</span><br><span class="line">                                            <span class="comment">// Default Constructor</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">List&lt;T&gt;::<span class="built_in">List</span>()&#123; rep = <span class="number">0</span> ; &#125;</span><br><span class="line">                                            <span class="comment">// Copy Constructor</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>List&lt;T&gt;::<span class="built_in">List</span>(<span class="keyword">const</span> List&lt;T&gt;&amp; l)</span><br><span class="line">&#123;     </span><br><span class="line">    rep = l.rep ? l.rep-&gt;<span class="built_in">copy</span>() : <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">                                            <span class="comment">// Overloaded assignment operator</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">List&lt;T&gt;&amp; List&lt;T&gt;::<span class="keyword">operator</span>=(<span class="keyword">const</span> List&lt;T&gt;&amp; l)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rep != l.rep)   </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="built_in">clear</span>() ;        </span><br><span class="line">        rep = l.rep ? l.rep-&gt;<span class="built_in">copy</span>() : <span class="number">0</span> ;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span> ;</span><br><span class="line">&#125;</span><br><span class="line">                                            <span class="comment">// Destructor</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">List&lt;T&gt;::~<span class="built_in">List</span>()&#123;  <span class="built_in">clear</span>() ;&#125;</span><br><span class="line">                                            <span class="comment">// Delete representation</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> List&lt;T&gt;::<span class="built_in">clear</span>()</span><br><span class="line">&#123;   <span class="keyword">while</span> (rep)</span><br><span class="line">    &#123;   ListElement&lt;T&gt;* tmp = rep ;</span><br><span class="line">        rep = rep-&gt;next ;</span><br><span class="line">        <span class="keyword">delete</span> tmp ;</span><br><span class="line">    &#125;</span><br><span class="line">    rep = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">                                            <span class="comment">// Add element to front of list</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> List&lt;T&gt;::<span class="built_in">add</span>(T&amp; i)</span><br><span class="line">&#123;   </span><br><span class="line">    rep = <span class="keyword">new</span> ListElement&lt;T&gt;(i,rep) ;</span><br><span class="line">&#125;</span><br><span class="line">                                            <span class="comment">// Return head of list or default value of type T</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T List&lt;T&gt;::<span class="built_in">head</span>()</span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (rep) <span class="keyword">return</span> rep-&gt;data ; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        T tmp ; </span><br><span class="line">        <span class="keyword">return</span> tmp ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">                                            <span class="comment">// Return tail of list or empty list</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">List&lt;T&gt; List&lt;T&gt;::<span class="built_in">tail</span>()</span><br><span class="line">&#123;    List&lt;T&gt; tmp ;</span><br><span class="line">     <span class="keyword">if</span> (rep)</span><br><span class="line">       <span class="keyword">if</span> (rep-&gt;next) tmp.rep = rep-&gt;next-&gt;<span class="built_in">copy</span>() ;</span><br><span class="line">     <span class="keyword">return</span> tmp ;</span><br><span class="line">&#125;</span><br><span class="line">                                            <span class="comment">// Output operator</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> List&lt;T&gt;&amp; l)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (l.rep)</span><br><span class="line">    &#123;</span><br><span class="line">        ListElement&lt;T&gt;* p = l.rep ;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;( &quot;</span> ;</span><br><span class="line">        <span class="keyword">while</span> (p)&#123; os &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span> ;   p = p-&gt;next ; &#125;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;)\n&quot;</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    os &lt;&lt; <span class="string">&quot;Empty list\n&quot;</span> ;</span><br><span class="line">    <span class="keyword">return</span> os ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   List&lt;<span class="keyword">int</span>&gt; l ;                            <span class="comment">// Integer list</span></span><br><span class="line">   cout &lt;&lt; l ;</span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">   l.<span class="built_in">add</span>(i) ;</span><br><span class="line">   i=<span class="number">2</span>;</span><br><span class="line">   l.<span class="built_in">add</span>(i) ;</span><br><span class="line">   i=<span class="number">3</span>;</span><br><span class="line">   l.<span class="built_in">add</span>(i) ;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;l is &quot;</span> &lt;&lt; l &lt;&lt; endl ;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;head of l is &quot;</span> &lt;&lt; l.<span class="built_in">head</span>() &lt;&lt; endl ;</span><br><span class="line">   List&lt;<span class="keyword">int</span>&gt; m = l.<span class="built_in">tail</span>() ;</span><br><span class="line">   List&lt;<span class="keyword">int</span>&gt; o ;</span><br><span class="line">   o = m;</span><br><span class="line">   i=<span class="number">4</span>;</span><br><span class="line">   m.<span class="built_in">add</span>(i);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;m is &quot;</span> &lt;&lt; m &lt;&lt; endl ;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;o is &quot;</span> &lt;&lt; o &lt;&lt; endl ;</span><br><span class="line">   List&lt;<span class="keyword">char</span>&gt; clist ;                        <span class="comment">// Character list</span></span><br><span class="line">   <span class="keyword">char</span> ch;</span><br><span class="line">   ch=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">   clist.<span class="built_in">add</span>(ch);</span><br><span class="line">   ch=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">   clist.<span class="built_in">add</span>(ch);</span><br><span class="line">   cout &lt;&lt; clist &lt;&lt; endl ;</span><br><span class="line">   List&lt;string&gt; ls ;                        <span class="comment">// string List</span></span><br><span class="line">   ls.<span class="built_in">add</span>(<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>)) ;</span><br><span class="line">   ls.<span class="built_in">add</span>(<span class="built_in">string</span>(<span class="string">&quot;world&quot;</span>)) ;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;List of strings&quot;</span> &lt;&lt; endl ;</span><br><span class="line">   cout &lt;&lt; ls &lt;&lt; endl ;</span><br><span class="line">   List&lt;List&lt;<span class="keyword">int</span>&gt; &gt; listlist ;                <span class="comment">// List of lists of integer. Notice that lists of lists are possible</span></span><br><span class="line">   listlist.<span class="built_in">add</span>(o) ;</span><br><span class="line">   listlist.<span class="built_in">add</span>(m) ;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;List of lists of ints\n&quot;</span> ;</span><br><span class="line">   cout &lt;&lt; listlist &lt;&lt; endl ;</span><br><span class="line">   List&lt;List&lt;List&lt;<span class="keyword">int</span>&gt; &gt; &gt; lllist ;            <span class="comment">// List of lists of lists of integer</span></span><br><span class="line">   lllist.<span class="built_in">add</span>(listlist) ;</span><br><span class="line">   lllist.<span class="built_in">add</span>(listlist) ;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;List of lists of lists of ints\n&quot;</span> ;</span><br><span class="line">   cout &lt;&lt; lllist &lt;&lt; <span class="string">&quot;\n&quot;</span> ;</span><br><span class="line">   List&lt;List&lt;string&gt; &gt; slist ;               <span class="comment">// List of list of strings</span></span><br><span class="line">   slist.<span class="built_in">add</span>(ls) ;</span><br><span class="line">   slist.<span class="built_in">add</span>(ls) ;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;List of lists of strings\n&quot;</span> ;</span><br><span class="line">   cout &lt;&lt; slist &lt;&lt; <span class="string">&quot;\n&quot;</span> ;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：以上某一个实例好像未通过调试，基于时间本人已忘记，读者发现后可查看相关情况自行更正。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2017/06/18/libmesh-introduction-learn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Be interesting!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亓欣波">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/18/libmesh-introduction-learn/" class="post-title-link" itemprop="url">libMesh的5个Introduction教学例子学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-06-18 00:00:00" itemprop="dateCreated datePublished" datetime="2017-06-18T00:00:00+08:00">2017-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 15:20:30" itemprop="dateModified" datetime="2021-03-25T15:20:30+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">programming</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2017/06/18/libmesh-introduction-learn/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/06/18/libmesh-introduction-learn/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro 1"></a>Intro 1</h1><p>第一个例子演示了怎样创建一个Mesh Object。<br>头文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libmesh/libmesh.h&quot;</span>  <span class="comment">//用来初始化库</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libmesh/mesh.h&quot;</span>  <span class="comment">//包含基本的mesh功能</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> libMesh;  <span class="comment">//所有的东西都在libMesh命名空间中</span></span><br></pre></td></tr></table></figure>
<p>入口函数代码： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LibMeshInit <span class="title">init</span> <span class="params">(argc, argv)</span></span>; <span class="comment">// 初始化，这是必要的一步，因为libMesh可能依赖其他的比如MPI、PETSc等函数库</span></span><br></pre></td></tr></table></figure>
<p>因为该程序的用法是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ex1 -d DIM input_mesh_name [-o output_mesh_name]</span><br></pre></td></tr></table></figure>
<p>所有这里会有一个参数个数的判断，如果少于4个参数，就会报错，提示正确的用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">libmesh_error_msg</span>(<span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; -d 2 in.mesh [-o out.mesh]&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>以下是对mesh object的操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Mesh <span class="title">mesh</span><span class="params">(init.comm())</span></span>;  <span class="comment">// 在默认通信子上创建一个Mesh</span></span><br><span class="line">mesh.<span class="built_in">read</span>(argv[<span class="number">3</span>]);  <span class="comment">//读入网格文件</span></span><br><span class="line">mesh.<span class="built_in">print_info</span>();  <span class="comment">//在屏幕上输出网格信息</span></span><br><span class="line">mesh.<span class="built_in">write</span>(argv[<span class="number">5</span>]);  <span class="comment">//输出网格文件</span></span><br></pre></td></tr></table></figure>
<h1 id="Intro-2"><a href="#Intro-2" class="headerlink" title="Intro 2"></a>Intro 2</h1><p>第二个例子演示了怎样创建一个标量方程。同时引入了PETSc，默认情形下方程数据都存入PETSc vector中。<br>头文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> <span class="comment">// C++头文件</span></span></span><br><span class="line"><span class="comment">//实现网格功能的基本头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libmesh/libmesh.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libmesh/mesh.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libmesh/mesh_generation.h&quot;</span> <span class="comment">// 定义多种生成网格的组件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libmesh/equation_systems.h&quot;</span> <span class="comment">// 定义方程系统</span></span></span><br><span class="line"><span class="comment">// 定义简单的稳态系统</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libmesh/linear_implicit_system.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libmesh/transient_system.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libmesh/explicit_system.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> libMesh;</span><br></pre></td></tr></table></figure>
<p>源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Mesh <span class="title">mesh</span><span class="params">(init.comm())</span></span>; <span class="comment">// 创建mesh</span></span><br><span class="line">MeshTools::Genertion::<span class="built_in">build_square</span> (mesh,<span class="number">5</span>,<span class="number">5</span>); <span class="comment">// 划分成5×5的方形grid</span></span><br></pre></td></tr></table></figure>
<p>这样创建的网格就有5<em>5=25个单元elements，6</em>6=36个节点nodes。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EquationSystems <span class="title">eqution_systems</span> <span class="params">(mesh)</span></span>; <span class="comment">// 创建方程，需要将mesh传递给equation</span></span><br><span class="line">equation_systems.add_system&lt;TransientLinearImplicitSystem&gt;(<span class="string">&quot;Simple System&quot;</span>); <span class="comment">// 往方程系统中添加一个方程，并命名</span></span><br><span class="line">equation_systems.<span class="built_in">get_system</span>(<span class="string">&quot;Simple System&quot;</span>).<span class="built_in">add_variable</span>(<span class="string">&quot;u&quot;</span>, FIRST); <span class="comment">// 给方程添加变量</span></span><br><span class="line">equation_systems.add_system&lt;ExplicitSystem&gt;(<span class="string">&quot;Complex System&quot;</span>); <span class="comment">// 再次添加一个方程</span></span><br><span class="line">equation_systems.<span class="built_in">get_system</span>(<span class="string">&quot;Complex System&quot;</span>).<span class="built_in">add_variable</span>(<span class="string">&quot;c&quot;</span>, FIRST); <span class="comment">// 添加c变量</span></span><br><span class="line">equation_systems.<span class="built_in">get_system</span>(<span class="string">&quot;Complex System&quot;</span>).<span class="built_in">add_variable</span>(<span class="string">&quot;T&quot;</span>, FIRST); <span class="comment">// 添加T变量</span></span><br><span class="line">equation_systems.<span class="built_in">get_system</span>(<span class="string">&quot;Complex System&quot;</span>).<span class="built_in">add_variable</span>(<span class="string">&quot;dv&quot;</span>, SECOND, MONONIAL); <span class="comment">// 添加dv变量</span></span><br><span class="line"></span><br><span class="line">equation_systems.<span class="built_in">init</span>(); <span class="comment">// 初始化方程系统的数据结构</span></span><br><span class="line"></span><br><span class="line">mesh.<span class="built_in">print_info</span>(); <span class="comment">// 在屏幕上打印网格信息</span></span><br><span class="line"></span><br><span class="line">equation_systems.<span class="built_in">print_info</span>(); <span class="comment">// 在屏幕上打印方程系统信息</span></span><br><span class="line"></span><br><span class="line">equation_systems.<span class="built_in">write</span>(argv[<span class="number">1</span>],WRITE); <span class="comment">// 将方程信息输出到文件中</span></span><br><span class="line">equation_systems.<span class="built_in">clear</span>(); <span class="comment">// 清除方程的数据结构</span></span><br><span class="line">equaiton_systems.<span class="built_in">read</span>(argv[<span class="number">1</span>],READ); <span class="comment">// 读入刚才的文件, 这三步可用于周期性地存储结果，并接着计算</span></span><br></pre></td></tr></table></figure>
<h1 id="Intro-3"><a href="#Intro-3" class="headerlink" title="Intro 3"></a>Intro 3</h1><p>这个例子演示了怎样求解Possion方程。同样展示了矩阵组装、解析解对比、单元迭代等功能。</p>
<p>头文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libmesh/fe.h&quot;</span> <span class="comment">// 定义有限元对象</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libmesh/quadrature_gauss.h&quot;</span> <span class="comment">// 定义高斯积分规则</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义有限元刚度矩阵和解向量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libmesh/sparse_matrix.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libmesh/numeric_vector.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libmesh/dense_matrix.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libmesh/dense_vector.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libmesh/elem.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libmesh/dof_map.h&quot;</span> <span class="comment">// 定义自由度映射</span></span></span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MeshTools::Generation::<span class="built_in">build_square</span>(mesh, <span class="number">15</span>,<span class="number">15</span>,<span class="number">-1.0</span>,<span class="number">1.0</span>,<span class="number">-1.0</span>,<span class="number">1.0</span>,QUAD9); <span class="comment">// 设定生成网格的计算域、网格密度和类型</span></span><br><span class="line"><span class="function">EquationSystems <span class="title">equation_systems</span><span class="params">(mesh)</span></span>;</span><br><span class="line">equation_systems.add_system&lt;LinearImplicitSystem&gt;(<span class="string">&quot;Possion&quot;</span>);</span><br><span class="line">equation_systems.<span class="built_in">get_system</span>(<span class="string">&quot;Possion&quot;</span>).<span class="built_in">add_variable</span>(<span class="string">&quot;u&quot;</span>, SECOND);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定一个指向矩阵组装功能的指针，具体的组装方法见函数实现</span></span><br><span class="line">equation_systems.<span class="built_in">get_system</span>(<span class="string">&quot;Possion&quot;</span>).<span class="built_in">attatch_assemble_function</span> (assemble_possion); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 求解Possion方程，这将组装线性系统，并调用数值求解器，对于PETSc来说，可以在命令行中指定求解器 -ksp_type cg</span></span><br><span class="line">equation_systems.<span class="built_in">get_system</span>(<span class="string">&quot;Possion&quot;</span>).<span class="built_in">solve</span>();</span><br></pre></td></tr></table></figure>
<p>具体的组装方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MeshBase &amp; mesh = es.<span class="built_in">get_mesh</span>(); <span class="comment">// 得到mesh对象的const引用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> dim = mesh.<span class="built_in">mesh_dimension</span>(); <span class="comment">// 得到dimension</span></span><br><span class="line">LinearImplicitsystem &amp; system = es.get_system&lt;LinearImplicitsystem&gt;(<span class="string">&quot;Possion&quot;</span>); <span class="comment">// 得到方程系统的引用</span></span><br><span class="line"><span class="keyword">const</span> DofMap &amp; dof_map = system.<span class="built_in">get_dof_map</span>(); <span class="comment">// 得到自由度映射</span></span><br><span class="line">FEType fe_type =  dof_map.<span class="built_in">variable_type</span>(<span class="number">0</span>); <span class="comment">// 得到系统的第一个且这里是唯一一个变量的有限单元类型的引用</span></span><br><span class="line"><span class="function">UniquePtr&lt;FEBase&gt; <span class="title">fe</span> <span class="params">(FEBase::build(dim,fe_type))</span></span>; <span class="comment">// 基于有限单元类型创建一个有限元对象</span></span><br><span class="line"><span class="function">QGauss <span class="title">qrule</span> <span class="params">(dim, FIFTH)</span></span>; <span class="comment">// 使用5次高斯积分准则</span></span><br><span class="line">fe -&gt; <span class="built_in">attatch_quadrature_rule</span> (&amp;qrule); <span class="comment">//告诉有限元对象使用该高斯积分准则</span></span><br><span class="line"></span><br><span class="line"><span class="function">UniquePtr&lt;FEBase&gt; <span class="title">fe_face</span> <span class="params">(FEBase::build(dim,fe_type))</span></span>; <span class="comment">// 创建一个特殊的有限元对象，用于边界积分</span></span><br><span class="line"><span class="function">QGauss <span class="title">qface</span> <span class="params">(dim<span class="number">-1</span>, FIFTH)</span></span>; <span class="comment">// 边界上的积分准则的dimension比单元的小1</span></span><br><span class="line">fe_face -&gt; <span class="built_in">attatch_quadrature_rule</span> (&amp;qface); <span class="comment">//告诉有限元对象使用该高斯积分准则</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> std::vector&lt;Real&gt; &amp; JxW = fe-&gt;<span class="built_in">get_JxW</span>(); <span class="comment">// 得到Jacobian矩阵与积分权重的乘积</span></span><br><span class="line"><span class="keyword">const</span> std::vector&lt;Point&gt; &amp; q_point = fe -&gt; <span class="built_in">get_xyz</span>(); <span class="comment">// 得到单元积分点的坐标</span></span><br><span class="line"><span class="keyword">const</span> std::vector&lt;std::vector&lt;Real&gt; &gt; &amp; phi = fe -&gt; <span class="built_in">get_phi</span>(); <span class="comment">// 得到积分点上的形函数</span></span><br><span class="line"><span class="keyword">const</span> std::vector&lt;std::vector&lt;RealGradient&gt; &gt; &amp; dphi = fe -&gt; <span class="built_in">get_dphi</span>(); <span class="comment">// 得到积分点上的形函数梯度</span></span><br><span class="line"></span><br><span class="line">DenseMatrix&lt;Number&gt; Ke; <span class="comment">// 定义存储单元刚度矩阵的数据结构</span></span><br><span class="line">DenseVector&lt;Number&gt; Fe; <span class="comment">// 定义存储单元右端项向量的数据结构</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;dof_id_type&gt; dof_indices; <span class="comment">// 存储自由度的全局标识</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是对所有单元进行循环，计算单元刚度矩阵和右端项对全局的贡献</span></span><br><span class="line">MeshBase::const_element_iterator el = mesh.<span class="built_in">active_local_elements_begin</span>(); <span class="comment">// 起始单元</span></span><br><span class="line"><span class="keyword">const</span> MeshBase::const_element_iterator end_el = mesh.<span class="built_in">active_local_element_end</span>();  <span class="comment">// 结束单元</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; el != end_el; ++el) <span class="comment">// for循环</span></span><br><span class="line">&#123; <span class="keyword">const</span> Elem * elem = *el; <span class="comment">// 存储一下当前单元的指针，便于后续的语法表示</span></span><br><span class="line">dof_map.<span class="built_in">dof_indices</span>(elem, dof_indices); <span class="comment">// 得到当前单元的全局自由度标识，从而知道该单元往哪个全局自由度上做贡献</span></span><br><span class="line">fe-&gt;<span class="built_in">reinit</span>(elem); <span class="comment">// 计算当前单元的特定信息，包括积分点的位置和形函数及其梯度。</span></span><br><span class="line">Ke.<span class="built_in">resize</span>(dof_indices.<span class="built_in">size</span>(),dof_indices.<span class="built_in">size</span>()); <span class="comment">// 在累加之前先置0</span></span><br><span class="line">Fe.<span class="built_in">resize</span>(dof_indices.<span class="built_in">size</span>()); <span class="comment">//在累加之前先置0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后在该单元的所有积分点上进行循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> qp=<span class="number">0</span>; qp &lt; qrule.<span class="built_in">n_points</span>(); qp++)&#123;</span><br><span class="line"><span class="comment">// 下面是构建单元刚度矩阵，包括一个嵌套循环</span></span><br><span class="line"><span class="keyword">for</span> (std::<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt; phi.<span class="built_in">size</span>(); i++)</span><br><span class="line">  <span class="keyword">for</span>(std::<span class="keyword">size_t</span> j=<span class="number">0</span>; j&lt; phi.<span class="built_in">size</span>(); j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">Ke</span>(i,j)+=JxW[qp]*(dphi[i][qp]*dphi[j][qp]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 下面是构建单元右端项</span></span><br><span class="line"><span class="keyword">for</span> (std::<span class="keyword">size_t</span> i=<span class="number">0</span>; i &lt; phi.<span class="built_in">size</span>(); i++)</span><br><span class="line"><span class="built_in">Fe</span>(i) += JxW[qp]*fxy*phi[i][qp]; <span class="comment">//fxy是源项</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还要施加边界条件，该部分详见原代码</span></span><br><span class="line"></span><br><span class="line">system.matrix-&gt;<span class="built_in">add_matrix</span>(Ke, dof_indices); <span class="comment">// 将单元刚度矩阵的贡献叠加到全局上</span></span><br><span class="line">system.rhs-&gt;<span class="built_in">add_vector</span>(Fe, dof_indices); <span class="comment">// 将单元右端项的贡献叠加导全局上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Intro-4"><a href="#Intro-4" class="headerlink" title="Intro 4"></a>Intro 4</h1><p>该例子是基于例子3，展示了通过很小的改动来实现与维度无关的编程。<br>同时引出PerfLog类来查看性能，从而确定瓶颈所在以实现优化。<br>头文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libmesh/perf_log.h&quot;</span> <span class="comment">// 是一个性能日志组件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libmesh/dirichlet_boundaries.h&quot;</span> <span class="comment">// 施加Dirichlet边界条件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libmesh/getpot.h&quot;</span> <span class="comment">// GetPot命令行解析</span></span></span><br></pre></td></tr></table></figure>
<p>源代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GetPot <span class="title">command_line</span> <span class="params">(argc, argv)</span></span>; <span class="comment">// 创建一个GetPot对象来解析命令行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dim = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(command_line.<span class="built_in">search</span>(<span class="number">1</span>, <span class="string">&quot;-d&quot;</span>)) </span><br><span class="line">  dim = command_line.<span class="built_in">next</span>(dim);  <span class="comment">// 读取命令行中设定的dim</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据不同的dimension来生成网格</span></span><br><span class="line">MeshTools::Generation::<span class="built_in">build_cube</span> (mesh,</span><br><span class="line">                                   ps,</span><br><span class="line">                                   (dim&gt;<span class="number">1</span>) ? ps : <span class="number">0</span>,</span><br><span class="line">                                   (dim&gt;<span class="number">2</span>) ? ps : <span class="number">0</span>,</span><br><span class="line">                                   <span class="number">-1.</span>, <span class="number">1.</span>,</span><br><span class="line">                                   -halfwidth, halfwidth,</span><br><span class="line">                                   -halfheight, halfheight,</span><br><span class="line">                                   (dim==<span class="number">1</span>)    ? EDGE2 :</span><br><span class="line">                                   ((dim == <span class="number">2</span>) ? QUAD4 : HEX8));</span><br><span class="line"></span><br><span class="line">perf_log.<span class="built_in">push</span>(<span class="string">&quot;elem init&quot;</span>); <span class="comment">// 开始记录形函数初始化过程</span></span><br><span class="line">perf_log.<span class="built_in">pop</span>(<span class="string">&quot;elem init&quot;</span>); <span class="comment">// 结束记录形函数初始化过程，push和pop成对出现，否则会报错</span></span><br></pre></td></tr></table></figure>
<h1 id="Intro-5"><a href="#Intro-5" class="headerlink" title="Intro 5"></a>Intro 5</h1><p>第五个例子展示了怎样方便调整积分准则。<br>源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QuadratureType quad_type = INVALID_Q_RULE; <span class="comment">// 定义积分类型</span></span><br><span class="line">quad_type = <span class="keyword">static_cast</span>&lt;QuadratureType&gt;(std::<span class="built_in">atoi</span>(argv[<span class="number">2</span>])); <span class="comment">// 从命令行中读取积分类型</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2017/02/14/moose-run/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Be interesting!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亓欣波">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/02/14/moose-run/" class="post-title-link" itemprop="url">多物理场面向对象模拟环境MOOSE运行过程分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-02-14 00:00:00" itemprop="dateCreated datePublished" datetime="2017-02-14T00:00:00+08:00">2017-02-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 15:20:30" itemprop="dateModified" datetime="2021-03-25T15:20:30+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computational-material-science/" itemprop="url" rel="index"><span itemprop="name">computational material science</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2017/02/14/moose-run/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/02/14/moose-run/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文尝试详细地走一遍MOOSE的运行路径，对其加深理解。</p>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>MOOSE是一个大型工程，从它的编译过程可以看出各个部分之间怎样联系起来。这里以MOOSE的第一个例子为研究对象，分析整个过程。其路径在：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moose/examples/ex01_inputfile</span><br></pre></td></tr></table></figure>
<p>整个编译过程都写在了Makefile文件中。</p>
<h2 id="定义环境变量"><a href="#定义环境变量" class="headerlink" title="定义环境变量"></a>定义环境变量</h2><p>首先先定义一下环境变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXAMPLE_DIR        ?= $(shell dirname `pwd`)</span><br><span class="line">MOOSE_DIR          ?= $(shell dirname $(EXAMPLE_DIR))</span><br><span class="line">FRAMEWORK_DIR      ?= $(MOOSE_DIR)/framework</span><br></pre></td></tr></table></figure>
<p>这些变量都是使用?=操作符来赋值，所以其实可以事先在终端中人为定义，如果之前没有指定，则这些语句就生效，基本思路就是通过调用shell的dirname命令来提取后面给定路径中的目录部分。<br>本例中，这三个变量经过赋值后就变为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXAMPLE_DIR = /home/qixinbo/moose/examples</span><br><span class="line">MOOSE_DIR = /home/qixinbo/moose</span><br><span class="line">FRAMEWORK_DIR = /home/qixinbo/moose/framework</span><br></pre></td></tr></table></figure>
<p>对于独立的fork出来的程序，一般路径是默认与moose并列，那么那个makefile就能正确地找到moose的路径，如果是放在别的地方，就可以人为定义该环境变量。</p>
<h2 id="包含MOOSE主程序的makefile"><a href="#包含MOOSE主程序的makefile" class="headerlink" title="包含MOOSE主程序的makefile"></a>包含MOOSE主程序的makefile</h2><p>MOOSE主程序包含基本框架framework和各种衍生模块modules。<br>基本框架framework肯定是要用到的，这里使用include调用framework下的makefile文件，将其放在此处。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># framework</span></span><br><span class="line">include $(FRAMEWORK_DIR)/build.mk</span><br><span class="line">include $(FRAMEWORK_DIR)/moose.mk</span><br></pre></td></tr></table></figure>
<p>将framework的编译另写，是模块化编译的思想，使得Makefile文件更加容易维护和扩展。这部分Makefile执行完后会在framework路径下生成moose的静态和动态链接库，比如如果以opt模式编译，就生成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/home/qixinbo/moose/framework/libmoose-opt.la</span><br><span class="line">/home/qixinbo/moose/framework/libmoose-opt.so</span><br><span class="line">/home/qixinbo/moose/framework/libmoose-opt.so<span class="number">.0</span></span><br><span class="line">/home/qixinbo/moose/framework/libmoose-opt.so<span class="number">.0</span><span class="number">.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<p>另外，本例是个简单例子，所以没有调用模块。如果是需要基于那些衍生模块进行开发，就需要将其包含进来：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># modules</span></span><br><span class="line">ALL_MODULES := yes</span><br><span class="line">include $(MOOSE_DIR)/modules/modules.mk</span><br></pre></td></tr></table></figure>
<p>同时在AnimalApp的源文件中注册所有模块：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ModulesApp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">StarfishApp::<span class="built_in">StarfishApp</span>(InputParameters parameters) :</span><br><span class="line">    <span class="built_in">MooseApp</span>(parameters)</span><br><span class="line">&#123;</span><br><span class="line">  Moose::<span class="built_in">registerObjects</span>(_factory);</span><br><span class="line">  ModulesApp::<span class="built_in">registerObjects</span>(_factory);</span><br><span class="line">  StarfishApp::<span class="built_in">registerObjects</span>(_factory);</span><br><span class="line"></span><br><span class="line">  Moose::<span class="built_in">associateSyntax</span>(_syntax, _action_factory);</span><br><span class="line">  ModulesApp::<span class="built_in">associateSyntax</span>(_syntax, _action_factory);</span><br><span class="line">  StarfishApp::<span class="built_in">associateSyntax</span>(_syntax, _action_factory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前从Stork中fork出的程序都是上面的设置，即默认将所有的模块包含。<br>如果只想包含特定模块，可以这样做，在Makefile中设置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PHASE_FIELD       := yes</span><br><span class="line">SOLID_MECHANICS   := yes</span><br><span class="line">TENSOR_MECHANICS  := yes</span><br><span class="line">HEAT_CONDUCTION   := yes</span><br><span class="line">MISC              := yes</span><br><span class="line">include           $(MOOSE_DIR)/modules/modules.mk</span><br></pre></td></tr></table></figure>
<p>然后在本程序的源文件中添加：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &quot;ModulesApp.h&quot; 这里要注释掉这个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Specific Modules</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TensorMechanicsApp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;PhaseFieldApp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MiscApp.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">AnimalApp::<span class="built_in">AnimalApp</span>(<span class="keyword">const</span> InputParameters &amp; parameters) :</span><br><span class="line">    <span class="built_in">MooseApp</span>(parameters)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">srand</span>(<span class="built_in">processor_id</span>());</span><br><span class="line"></span><br><span class="line">  Moose::<span class="built_in">registerObjects</span>(_factory);</span><br><span class="line">  Moose::<span class="built_in">associateSyntax</span>(_syntax, _action_factory);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ModulesApp::registerObjects(_factory);</span></span><br><span class="line">  <span class="comment">// ModulesApp::associateSyntax(_syntax, _action_factory);</span></span><br><span class="line"></span><br><span class="line">  TensorMechanicsApp::<span class="built_in">registerObjects</span>(_factory);</span><br><span class="line">  TensorMechanicsApp::<span class="built_in">associateSyntax</span>(_syntax, _action_factory);</span><br><span class="line"></span><br><span class="line">  PhaseFieldApp::<span class="built_in">registerObjects</span>(_factory);</span><br><span class="line">  PhaseFieldApp::<span class="built_in">associateSyntax</span>(_syntax, _action_factory);</span><br><span class="line"></span><br><span class="line">  MiscApp::<span class="built_in">registerObjects</span>(_factory);</span><br><span class="line">  MiscApp::<span class="built_in">associateSyntax</span>(_syntax, _action_factory);</span><br><span class="line"></span><br><span class="line">  AnimalApp::<span class="built_in">registerObjects</span>(_factory);</span><br><span class="line">  AnimalApp::<span class="built_in">associateSyntax</span>(_syntax, _action_factory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MOOSE主程序部分如果编译过一次以后，假如没有更改，就不会再次编译了，能够有效节省时间。</p>
<h2 id="编译本程序"><a href="#编译本程序" class="headerlink" title="编译本程序"></a>编译本程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># dep apps</span></span><br><span class="line">APPLICATION_DIR    := $(shell pwd)</span><br><span class="line">APPLICATION_NAME   := ex01</span><br><span class="line">BUILD_EXEC         := yes</span><br><span class="line">DEP_APPS           := $(shell $(FRAMEWORK_DIR)/scripts/find_dep_apps.py $(APPLICATION_NAME))</span><br><span class="line">include            $(FRAMEWORK_DIR)/app.mk</span><br></pre></td></tr></table></figure>
<p>这里使用framework下的app.mk这个makefile来编译本程序，涉及该程序的路径、名字等参数会传入该文件中。值得一提的是，如何对某个变量的值不清楚，可以通过自己写一个target来显示出来，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">showName:</span><br><span class="line">   @echo $(APPLICATION_DIR)</span><br></pre></td></tr></table></figure>
<p>然后make showName来执行。<br>本程序所依赖的源文件和头文件都会在以下路径：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(APPLICATION_DIR)/include</span><br><span class="line">$(APPLICATION_DIR)/src</span><br></pre></td></tr></table></figure>
<p>中寻找，目前猜测是遍历两个目录下的所有目录，然后寻找这些文件。<br>本例因为很简单，所以在这两个目录下仅包含base目录，对于稍大型的项目，牵扯到自己开发的模块时，还可添加其他目录，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auxkernels base bcs ics kernel materials timesteppers</span><br></pre></td></tr></table></figure>
<p>等。这些目录中的头文件用来声明类，源文件用来实现类。</p>
<h1 id="入口main函数"><a href="#入口main函数" class="headerlink" title="入口main函数"></a>入口main函数</h1><p>所有程序的入口都是main函数，所以从这里入手能比较清晰地把握整个程序的脉络。</p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ExampleApp.h&quot;</span></span></span><br><span class="line"><span class="comment">//Moose Includes</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MooseInit.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Moose.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MooseApp.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;AppFactory.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>首先包含该具体程序的头文件，然后再包含MOOSE的基本头文件。这里仅包含ExampleApp这一个头文件即可，之前include目录下的其他头文件是通过src目录下的ExampleApp的源文件来包含，比如Hyrax应用的HyraxApp的源文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Kernels</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ACBulkCoupled.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Auxiliary Kernels</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;AuxSupersaturation.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Dirac Kernels</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Boundary Conditions</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;StressBC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Materials</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;PFMobilityLandau.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Initial Conditions</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;PolySpecifiedSmoothCircleIC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Dampers</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Executioners</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;MeshSolutionModify.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Post Processors</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;NucleationPostprocessor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//TimeSteppers</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;InitialSolutionAdaptiveDT.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Actions</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//UserObjects</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;NucleationLocationUserObject.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Markers</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;NucleationMarker.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>所以，整个关系链是：main仅需要ExampleApp这个头文件，且链接ExampleApp这个源文件产生的目标文件，EampleApp又需要自定义的其他头文件，比如ExampleDiffusion等，且链接这些头文件对应的源文件产生的目标文件。所以，在自己开发程序时，不需要修改main文件，仅需要修改私有程序的base源文件以包含正确的头文件即可。</p>
<h2 id="创建性能日志"><a href="#创建性能日志" class="headerlink" title="创建性能日志"></a>创建性能日志</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PerfLog <span class="title">Moose::perf_log</span><span class="params">(<span class="string">&quot;Example&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>PerfLog是libMesh的一个类，用来创建性能日志。</p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize MPI, solvers and MOOSE</span></span><br><span class="line"><span class="function">MooseInit <span class="title">init</span><span class="params">(argc, argv)</span></span>;</span><br></pre></td></tr></table></figure>
<p>调用MooseInit类来进行初始化，实际上也调用了其父类LibMeshInit，从而对libMesh进行初始化。</p>
<h1 id="注册App"><a href="#注册App" class="headerlink" title="注册App"></a>注册App</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Register this application&#x27;s MooseApp and any it depends on</span></span><br><span class="line">ExampleApp::<span class="built_in">registerApps</span>();</span><br></pre></td></tr></table></figure>
<p>每个基于MOOSE的应用都是继承自MooseApp这个类，该类提供创建各种对象的工厂factories以及存放它们的仓库warehouses。创建了私有程序后，必须实现几个重要的静态函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">registerApps</span>()</span><br><span class="line"><span class="built_in">registerObjects</span>()</span><br><span class="line"><span class="built_in">associateSyntax</span>() (optional)</span><br></pre></td></tr></table></figure>
<h2 id="注册App-1"><a href="#注册App-1" class="headerlink" title="注册App"></a>注册App</h2><p>第一个是注册App，这个用简单的通用的一句话即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">ExampleApp::<span class="built_in">registerApps</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">registerApp</span>(ExampleApp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中registerApp不是一个函数或类，所以在doxygen中查不到，它是AppFactory中的一个宏定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> registerApp(name) AppFactory::instance().reg<span class="meta-string">&lt;name&gt;</span>(#name)</span></span><br></pre></td></tr></table></figure>
<h2 id="注册Objects"><a href="#注册Objects" class="headerlink" title="注册Objects"></a>注册Objects</h2><p>第二个是注册Objects。本例没有用到自定义的Objects，所以该函数是空白的。但如果自定义了某个object，比如在example2中新增了一个Kernel，那么就需要注册该object：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">ExampleApp::<span class="built_in">registerObjects</span>(Factory &amp; factory)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Register any custom objects you have built on the MOOSE Framework</span></span><br><span class="line">  <span class="built_in">registerKernel</span>(ExampleConvection);  <span class="comment">// &lt;- registration</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了注册Kernel这种object，还有其他类型的object，比如Hyrax应用中用到的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Kernels</span></span><br><span class="line"><span class="built_in">registerKernel</span>(CHBulkCoupled);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Auxiliary Kernels</span></span><br><span class="line"><span class="built_in">registerAux</span>(AuxSupersaturation);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Boundary Conditions</span></span><br><span class="line"><span class="built_in">registerBoundaryCondition</span>(StressBC);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Materials</span></span><br><span class="line"><span class="built_in">registerMaterial</span>(PFMobilityLandau);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Initial Conditions</span></span><br><span class="line"><span class="built_in">registerInitialCondition</span>(PolySpecifiedSmoothCircleIC);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dampers</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Executioners</span></span><br><span class="line"><span class="built_in">registerExecutioner</span>(MeshSolutionModify);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Postprocessors</span></span><br><span class="line"><span class="built_in">registerPostprocessor</span>(NucleationPostprocessor);</span><br><span class="line"></span><br><span class="line"><span class="comment">//TimeSteppers</span></span><br><span class="line"><span class="built_in">registerTimeStepper</span>(InitialSolutionAdaptiveDT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserObjects</span></span><br><span class="line"><span class="built_in">registerUserObject</span>(NucleationLocationUserObject);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Markers</span></span><br><span class="line"><span class="built_in">registerMarker</span>(NucleationMarker);</span><br></pre></td></tr></table></figure>
<h2 id="多个App耦合"><a href="#多个App耦合" class="headerlink" title="多个App耦合"></a>多个App耦合</h2><p>MOOSE中有多个衍生模块，比如相场、力学等，可以耦合这些模块，在其基础上进行开发。<br>在上面的编译过程中已经说明了怎样将其他的模块加入。默认是将全部模块加入。</p>
<h1 id="创建app"><a href="#创建app" class="headerlink" title="创建app"></a>创建app</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This creates dynamic memory that we&#x27;re responsible for deleting</span></span><br><span class="line">MooseApp * app = AppFactory::<span class="built_in">createApp</span>(<span class="string">&quot;ExampleApp&quot;</span>, argc, argv);</span><br></pre></td></tr></table></figure>
<p>这一步是创建一个动态存储的MooseApp。</p>
<h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app-&gt;<span class="built_in">run</span>();</span><br></pre></td></tr></table></figure>
<p>这个run函数是程序运行的总调度，其除了撰写性能日志，主要执行的动作有三个：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setupOptions</span>();</span><br><span class="line"><span class="built_in">runInputFile</span>();</span><br><span class="line"><span class="built_in">executeExecutioner</span>();</span><br></pre></td></tr></table></figure>
<h2 id="选项配置及读入输入文件"><a href="#选项配置及读入输入文件" class="headerlink" title="选项配置及读入输入文件"></a>选项配置及读入输入文件</h2><p>setupOptions读取执行程序时在命令行中输入的选项参数以及输入文件中的各个对象的信息。<br>首先是命令行中的选项参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Usage: ./ex01-opt [&lt;options&gt;]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --allow-deprecated                                Can be used in conjunction with --error to turn off deprecated errors</span><br><span class="line">  --check-<span class="function">input                                     Check the input <span class="title">file</span> <span class="params">(i.e. <span class="keyword">requires</span> -i &lt;filename&gt;)</span> <span class="keyword">and</span> quit.</span></span><br><span class="line">  --distributed-mesh                                The libMesh Mesh underlying MooseMesh should always be a DistributedMesh</span><br><span class="line">  --dump [search_string]                            Shows a dump of available input file syntax.</span><br><span class="line">  --error                                           Turn all warnings into errors</span><br><span class="line">  --error-deprecated                                Turn deprecated code messages into Errors</span><br><span class="line">  -o --error-<span class="keyword">override</span>                               Error when encountering overridden <span class="keyword">or</span> parameters supplied multiple times</span><br><span class="line">  -e --error-unused                                 Error when encountering unused input file options</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这里面用到的最重要的一个函数就是getParam，它先调用InputParameters类的getParamHelper函数，然后归根结底是调用了libMesh的parameters类的get函数。<br>本例中我们执行的命令是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ex01-opt -i ex01.i</span><br></pre></td></tr></table></figure>
<p>根据该命令选项，读取后某些变量的值变为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_distributed_mesh_on_command_line = <span class="literal">false</span>;</span><br><span class="line">_half_transient = <span class="literal">false</span>;</span><br><span class="line">Moose::_warnings_are_errors = <span class="literal">false</span>;</span><br><span class="line">Moose::_deprecated_is_error = <span class="literal">false</span>;</span><br><span class="line">Moose::_color_console = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">_input_filename = <span class="string">&quot;ex01.i&quot;</span></span><br></pre></td></tr></table></figure>
<p>这样就将输入文件成功读取了。MOOSE的输入文件的语法遵循<a target="_blank" rel="noopener" href="http://getpot.sourceforge.net/">GetPot</a>格式。<br>成功取得输入文件的名字后，再使用解析器来读入输入文件中的各个对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_parser.<span class="built_in">parse</span>(_input_filename);</span><br></pre></td></tr></table></figure>
<p>解析过程中，会根据语法将各个块的信息读入，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">section_names = &#123;<span class="string">&quot;Mesh/&quot;</span>, <span class="string">&quot;Variables/&quot;</span>, <span class="string">&quot;Variables/diffused/&quot;</span>, <span class="string">&quot;Kernels/&quot;</span>, <span class="string">&quot;Kernels/diff/&quot;</span>, <span class="string">&quot;BCs/&quot;</span>, <span class="string">&quot;BCs/bottom/&quot;</span>, <span class="string">&quot;BCs/top/&quot;</span>, <span class="string">&quot;Materials/&quot;</span>, <span class="string">&quot;Executioner/&quot;</span>, <span class="string">&quot;Outputs/&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>然后对所有的块进行遍历，查找每一个块下对应的属性，比如对于Mesh块，其包含的属性有：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">block_id block_name boundary_id boundary_name construct_side_list_from_node_list</span><br><span class="line">ghosted_boundaries ghosted_boundaries_inflation</span><br></pre></td></tr></table></figure>
<p>等等。<br>然后通过：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_action_warehouse.<span class="built_in">build</span>();</span><br></pre></td></tr></table></figure>
<p>来构建一系列动作，这些动作(通过build函数里的getSortedTask来获得)包括：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;setup_time_stepper&quot;</span>, <span class="string">&quot;setup_predictor&quot;</span>, <span class="string">&quot;setup_postprocessor_data&quot;</span>, <span class="string">&quot;init_displaced_problem&quot;</span>, <span class="string">&quot;add_aux_variable&quot;</span>, <span class="string">&quot;add_elemental_field_variable&quot;</span>, <span class="string">&quot;add_variable&quot;</span>, <span class="string">&quot;setup_variable_complete&quot;</span>, <span class="string">&quot;setup_quadrature&quot;</span>, <span class="string">&quot;add_function&quot;</span>, <span class="string">&quot;add_periodic_bc&quot;</span>, <span class="string">&quot;add_user_object&quot;</span>, <span class="string">&quot;setup_function_complete&quot;</span>, <span class="string">&quot;setup_adaptivity&quot;</span>, <span class="string">&quot;set_adaptivity_options&quot;</span>, <span class="string">&quot;add_ic&quot;</span>, <span class="string">&quot;add_constraint&quot;</span>, <span class="string">&quot;add_field_split&quot;</span>, <span class="string">&quot;add_preconditioning&quot;</span>, <span class="string">&quot;ready_to_init&quot;</span>, <span class="string">&quot;setup_dampers&quot;</span>, <span class="string">&quot;setup_residual_debug&quot;</span>, <span class="string">&quot;add_bounds_vectors&quot;</span>, <span class="string">&quot;add_multi_app&quot;</span>, <span class="string">&quot;add_transfer&quot;</span>, <span class="string">&quot;copy_nodal_aux_vars&quot;</span>, <span class="string">&quot;copy_nodal_vars&quot;</span>, <span class="string">&quot;add_material&quot;</span>, <span class="string">&quot;setup_material_output&quot;</span>, <span class="string">&quot;init_problem&quot;</span>, <span class="string">&quot;setup_debug&quot;</span>, <span class="string">&quot;add_output&quot;</span>, <span class="string">&quot;add_postprocessor&quot;</span>, <span class="string">&quot;add_vector_postprocessor&quot;</span>, <span class="string">&quot;add_aux_kernel&quot;</span>, <span class="string">&quot;add_aux_scalar_kernel&quot;</span>, <span class="string">&quot;add_bc&quot;</span>, <span class="string">&quot;add_damper&quot;</span>, <span class="string">&quot;add_dg_kernel&quot;</span>, <span class="string">&quot;add_dirac_kernel&quot;</span>, <span class="string">&quot;add_indicator&quot;</span>, <span class="string">&quot;add_interface_kernel&quot;</span>, <span class="string">&quot;add_kernel&quot;</span>, <span class="string">&quot;add_marker&quot;</span>, <span class="string">&quot;add_nodal_kernel&quot;</span>, <span class="string">&quot;add_scalar_kernel&quot;</span>, <span class="string">&quot;add_control&quot;</span>, <span class="string">&quot;check_output&quot;</span>, <span class="string">&quot;check_integrity&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="执行输入文件"><a href="#执行输入文件" class="headerlink" title="执行输入文件"></a>执行输入文件</h2><p>读入输入文件后，runInputFile来执行里面的动作，即上一步build得到的动作列表，对其进行循环遍历，然后运行下面的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; task : _ordered_names)</span><br><span class="line">  <span class="built_in">executeActionsWithAction</span>(task);</span><br></pre></td></tr></table></figure>
<p>它还会检查输入文件中是否有未辨别出的变量。输入文件中的所有变量通过以下函数获得：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all_vars = _parser.<span class="built_in">getPotHandle</span>()-&gt;<span class="built_in">get_variable_names</span>();</span><br></pre></td></tr></table></figure>
<p>得到的结果是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">all_vars = </span><br><span class="line">&#123;<span class="string">&quot;Mesh/type&quot;</span>, <span class="string">&quot;Mesh/file&quot;</span>, <span class="string">&quot;Variables/diffused/order&quot;</span>, <span class="string">&quot;Variables/diffused/family&quot;</span>, <span class="string">&quot;Kernels/diff/type&quot;</span>, <span class="string">&quot;Kernels/diff/variable&quot;</span>, <span class="string">&quot;BCs/bottom/type&quot;</span>, <span class="string">&quot;BCs/bottom/variable&quot;</span>, <span class="string">&quot;BCs/bottom/boundary&quot;</span>, <span class="string">&quot;BCs/bottom/value&quot;</span>, <span class="string">&quot;BCs/top/type&quot;</span>, <span class="string">&quot;BCs/top/variable&quot;</span>, <span class="string">&quot;BCs/top/boundary&quot;</span>, <span class="string">&quot;BCs/top/value&quot;</span>, <span class="string">&quot;Executioner/type&quot;</span>, <span class="string">&quot;Executioner/solve_type&quot;</span>, <span class="string">&quot;Outputs/execute_on&quot;</span>, <span class="string">&quot;Outputs/exodus&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="执行Executioner"><a href="#执行Executioner" class="headerlink" title="执行Executioner"></a>执行Executioner</h2><p>executeExecutioner就是执行所创建的Executioner对象。<br>先是初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_executioner-&gt;<span class="built_in">init</span>();</span><br></pre></td></tr></table></figure>
<p>其实在执行该初始化函数之前，还隐性地执行了该类的构造函数，显然在此之前先执行该构造函数的成员初始化器列表：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Executioner::<span class="built_in">Executioner</span>(<span class="keyword">const</span> InputParameters &amp; parameters) :</span><br><span class="line"> <span class="built_in">MooseObject</span>(parameters),</span><br><span class="line"> <span class="built_in">UserObjectInterface</span>(<span class="keyword">this</span>),</span><br><span class="line"> <span class="built_in">PostprocessorInterface</span>(<span class="keyword">this</span>),</span><br><span class="line"> <span class="built_in">Restartable</span>(parameters, <span class="string">&quot;Executioners&quot;</span>),</span><br><span class="line"> _fe_problem(*parameters.getCheckedPointerParam&lt;FEProblemBase *&gt;(<span class="string">&quot;_fe_problem_base&quot;</span>, <span class="string">&quot;This might happen if you don&#x27;t have a mesh&quot;</span>)),</span><br><span class="line"> _initial_residual_norm(std::numeric_limits&lt;Real&gt;::<span class="built_in">max</span>()),</span><br><span class="line"> _old_initial_residual_norm(std::numeric_limits&lt;Real&gt;::<span class="built_in">max</span>()),</span><br><span class="line"> _restart_file_base(getParam&lt;FileNameNoExtension&gt;(<span class="string">&quot;restart_file_base&quot;</span>)),</span><br><span class="line"> _splitting(getParam&lt;std::vector&lt;std::string&gt; &gt;(<span class="string">&quot;splitting&quot;</span>))</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>在执行这些构造函数过程中，有一步是调用Console的outputSystemInformation函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_system_info_flags.<span class="built_in">contains</span>(<span class="string">&quot;framework&quot;</span>))</span><br><span class="line">_console &lt;&lt; ConsoleUtils::<span class="built_in">outputFrameworkInformation</span>(_app);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_system_info_flags.<span class="built_in">contains</span>(<span class="string">&quot;mesh&quot;</span>))</span><br><span class="line">_console &lt;&lt; ConsoleUtils::<span class="built_in">outputMeshInformation</span>(*_problem_ptr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_system_info_flags.<span class="built_in">contains</span>(<span class="string">&quot;nonlinear&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">std::string output = ConsoleUtils::<span class="built_in">outputNonlinearSystemInformation</span>(*_problem_ptr);</span><br><span class="line"><span class="keyword">if</span> (!output.<span class="built_in">empty</span>())</span><br><span class="line">_console &lt;&lt; <span class="string">&quot;Nonlinear System:\n&quot;</span> &lt;&lt; output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还会构建整个有限元问题的系统，比如将问题中的变量读入到libMesh中，设定所使用的单元类型、插值次数等：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FEProblemBase::<span class="built_in">hasVariable</span> (<span class="keyword">this</span>=<span class="number">0x1028cc0</span>, var_name=<span class="string">&quot;diffused&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这样就会产生如下的信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Framework Information:</span><br><span class="line">MOOSE version:           git commit <span class="number">61910</span>cd on <span class="number">2016</span><span class="number">-12</span><span class="number">-22</span></span><br><span class="line">PETSc Version:           <span class="number">3.7</span><span class="number">.4</span></span><br><span class="line">Current Time:            Mon Feb <span class="number">13</span> <span class="number">21</span>:<span class="number">06</span>:<span class="number">54</span> <span class="number">2017</span></span><br><span class="line">Executable Timestamp:    Sat Feb <span class="number">11</span> <span class="number">04</span>:<span class="number">08</span>:<span class="number">24</span> <span class="number">2017</span></span><br><span class="line"></span><br><span class="line">Parallelism:</span><br><span class="line">  Num Processors:          <span class="number">1</span></span><br><span class="line">  Num Threads:             <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Mesh: </span><br><span class="line">  Parallel Type:           replicated</span><br><span class="line">  Mesh Dimension:          <span class="number">3</span></span><br><span class="line">  Spatial Dimension:       <span class="number">3</span></span><br><span class="line">  Nodes:                   </span><br><span class="line">    Total:                 <span class="number">6399</span></span><br><span class="line">    Local:                 <span class="number">6399</span></span><br><span class="line">  Elems:                   </span><br><span class="line">    Total:                 <span class="number">30224</span></span><br><span class="line">    Local:                 <span class="number">30224</span></span><br><span class="line">  Num Subdomains:          <span class="number">1</span></span><br><span class="line">  Num Partitions:          <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Nonlinear System:</span><br><span class="line">  Num DOFs:                <span class="number">6399</span></span><br><span class="line">  Num Local DOFs:          <span class="number">6399</span></span><br><span class="line">  Variables:               <span class="string">&quot;diffused&quot;</span> </span><br><span class="line">  Finite Element Types:    <span class="string">&quot;LAGRANGE&quot;</span> </span><br><span class="line">  Approximation Orders:    <span class="string">&quot;FIRST&quot;</span> </span><br><span class="line"></span><br><span class="line">Execution Information:</span><br><span class="line">  Executioner:             Steady</span><br><span class="line">  Solver Mode:             Preconditioned JFNK</span><br></pre></td></tr></table></figure>
<p>这里最重要的一个类就是FEProblemBase类，它包含整个有限元问题的数学信息。<br>Executioner本身的构造函数中主要就是获得求解器的信息，比如线性迭代和非线性迭代的精度、迭代步数等：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// solver params</span></span><br><span class="line">EquationSystems &amp; es = _fe_problem.<span class="built_in">es</span>();</span><br><span class="line">es.parameters.set&lt;Real&gt; (<span class="string">&quot;linear solver tolerance&quot;</span>)</span><br><span class="line">= getParam&lt;Real&gt;(<span class="string">&quot;l_tol&quot;</span>);</span><br><span class="line"></span><br><span class="line">es.parameters.set&lt;Real&gt; (<span class="string">&quot;linear solver absolute step tolerance&quot;</span>)</span><br><span class="line">= getParam&lt;Real&gt;(<span class="string">&quot;l_abs_step_tol&quot;</span>);</span><br><span class="line"></span><br><span class="line">es.parameters.set&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; (<span class="string">&quot;linear solver maximum iterations&quot;</span>)</span><br><span class="line">= getParam&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(<span class="string">&quot;l_max_its&quot;</span>);</span><br><span class="line"></span><br><span class="line">es.parameters.set&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; (<span class="string">&quot;nonlinear solver maximum iterations&quot;</span>)</span><br><span class="line">= getParam&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(<span class="string">&quot;nl_max_its&quot;</span>);</span><br><span class="line"></span><br><span class="line">es.parameters.set&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; (<span class="string">&quot;nonlinear solver maximum function evaluations&quot;</span>)</span><br><span class="line"> = getParam&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(<span class="string">&quot;nl_max_funcs&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>然后就是开始执行，这时Executioner真正开始工作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_executioner-&gt;<span class="built_in">execute</span>();</span><br></pre></td></tr></table></figure>
<p>该execute函数是个纯虚函数，需要根据具体的问题来工作，比如对于稳态问题，调用Steady类，对于瞬态问题，则是调用Transient类来求解。<br>Steady问题的求解过程是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (_app.<span class="built_in">isRecovering</span>())</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">preExecute</span>();</span><br><span class="line"></span><br><span class="line"> _problem.<span class="built_in">advanceState</span>();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// first step in any steady state solve is always 1 (preserving backwards compatibility)</span></span><br><span class="line"> _time_step = <span class="number">1</span>;</span><br><span class="line"> _time = _time_step; <span class="comment">// need to keep _time in sync with _time_step to get correct output</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LIBMESH_ENABLE_AMR</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// Define the refinement loop</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> steps = _problem.<span class="built_in">adaptivity</span>().<span class="built_in">getSteps</span>();</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> r_step=<span class="number">0</span>; r_step&lt;=steps; r_step++)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//LIBMESH_ENABLE_AMR</span></span></span><br><span class="line"> <span class="built_in">preSolve</span>();</span><br><span class="line"> _problem.<span class="built_in">timestepSetup</span>();</span><br><span class="line"> _problem.<span class="built_in">execute</span>(EXEC_TIMESTEP_BEGIN);</span><br><span class="line"> _problem.<span class="built_in">outputStep</span>(EXEC_TIMESTEP_BEGIN);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Update warehouse active objects</span></span><br><span class="line"> _problem.<span class="built_in">updateActiveObjects</span>();</span><br><span class="line"></span><br><span class="line"> _problem.<span class="built_in">solve</span>();</span><br><span class="line"> <span class="built_in">postSolve</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!<span class="built_in">lastSolveConverged</span>())</span><br><span class="line"> &#123;</span><br><span class="line"> _console &lt;&lt; <span class="string">&quot;Aborting as solve did not converge\n&quot;</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  _problem.<span class="built_in">onTimestepEnd</span>();</span><br><span class="line">  _problem.<span class="built_in">execute</span>(EXEC_TIMESTEP_END);</span><br><span class="line"> </span><br><span class="line">  _problem.<span class="built_in">computeIndicators</span>();</span><br><span class="line">  _problem.<span class="built_in">computeMarkers</span>();</span><br><span class="line"> </span><br><span class="line">  _problem.<span class="built_in">outputStep</span>(EXEC_TIMESTEP_END);</span><br><span class="line"> </span><br><span class="line"> <span class="meta">#<span class="meta-keyword">ifdef</span> LIBMESH_ENABLE_AMR</span></span><br><span class="line">  <span class="keyword">if</span> (r_step != steps)</span><br><span class="line">  &#123;</span><br><span class="line">  _problem.<span class="built_in">adaptMesh</span>();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  _time_step++;</span><br><span class="line">  _time = _time_step; <span class="comment">// need to keep _time in sync with _time_step to get correct output</span></span><br><span class="line">  &#125;</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">postExecute</span>();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这里面每一步又有很大的信息量，值得细思。</p>
<h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> app;</span><br></pre></td></tr></table></figure>
<p>问题求解结束，释放内存，Done！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2017/01/15/moose-tutorials/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Be interesting!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亓欣波">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/01/15/moose-tutorials/" class="post-title-link" itemprop="url">多物理场面向对象模拟环境MOOSE学习手册</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-01-15 00:00:00" itemprop="dateCreated datePublished" datetime="2017-01-15T00:00:00+08:00">2017-01-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 15:20:30" itemprop="dateModified" datetime="2021-03-25T15:20:30+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computational-material-science/" itemprop="url" rel="index"><span itemprop="name">computational material science</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2017/01/15/moose-tutorials/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/01/15/moose-tutorials/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>MOOSE，全名是Multiphysics Object Oriented Simulation Environment，是一套求解多物理场耦合的工程问题的框架。其设计规范，采用面向对象的编程范式，非常易于扩展和维护，而且尽可能地隐藏问题背后的计算数学问题，比如自适应网格算法、并行计算技术等，使得用户能够着眼于自己所要研究的科学问题。</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>其有如下特点：</p>
<ol>
<li>与维度无关的编程，用户代码不需要考虑维度问题</li>
<li>基于有限元，可以是连续有限元，也可以是间断有限元</li>
<li>多物理场耦合，隐藏编程细节</li>
<li>非规则网格，有多种形状：三角形、四边形、六边形、六面体、八面体等，可读入和输出多种形式。</li>
<li>自适应网格</li>
<li>并行计算</li>
<li>高次插值</li>
<li>内置后处理<br>等等。</li>
</ol>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>提前安装好的软件：</p>
<ul>
<li>gcc4.8(系统默认自带)</li>
<li>g++4.8(可以直接命令行安装，也可以使用新立得，如果默认源不匹配，要注意更新源和切换源，如果必要，也要安装build-essential)</li>
<li>gfortran4.8 (moose中有fortran程序，如waterStreamEos模块)</li>
<li>python相关库：python-dev、python-numpy、python-yaml、python-matplotlib、python-vtk</li>
<li>git</li>
<li>mpich3.2，不推荐openmpi，会出现以下问题：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">no underlying compiler was specified in the wrapper compiler data <span class="title">file</span> <span class="params">(e.g. mpicc-wrapper-data.txt)</span></span></span><br></pre></td></tr></table></figure></li>
<li>hypre 最好是装上，不装也可以，程序也能运行，但会出现以下问题：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unable to find requested PC type hypre</span><br></pre></td></tr></table></figure></li>
<li>PETSc3.7.4(注意记录安装完成后产生的路径和架构信息)，其参数可为：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--download-fblaslapack --with-mpi-dir=/usr/local/mpich --download-hypre</span><br></pre></td></tr></table></figure></li>
</ul>
<p>然后，按照官网教程来：</p>
<ol>
<li>克隆源码库<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/projects</span><br><span class="line">cd ~/projects</span><br><span class="line">git clone https:<span class="comment">//github.com/idaholab/moose.git</span></span><br><span class="line">cd ~/projects/moose</span><br><span class="line">git checkout master</span><br></pre></td></tr></table></figure></li>
<li>编译libMesh<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/projects/moose</span><br><span class="line">scripts/update_and_rebuild_libmesh.sh</span><br></pre></td></tr></table></figure></li>
<li>测试<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/projects/moose/test</span><br><span class="line">make -j8</span><br><span class="line">./run_tests -j8</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="创建程序"><a href="#创建程序" class="headerlink" title="创建程序"></a>创建程序</h1><p>要创建自己的程序，先去github上克隆官方给出的一个stork库，然后在自己的github里重命名该库，官方建议用动物名命名，然后再将自己的库克隆下来：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/&lt;username&gt;/&lt;app_name&gt;.git</span></span><br></pre></td></tr></table></figure>
<p>注意，克隆下来的库的位置要与moose库同级，原因可以查看后面生成的Makefile文件，其会在与当前库相同的路径下寻找moose库，就是下面这句话：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOOSE_DIR        ?= $(shell dirname `pwd`)/moose</span><br></pre></td></tr></table></figure>
<p>从上面的“问号等于”赋值语句来看，也可以任意放置该库位置，只需手动指定一下MOOSEDIR这个环境变量即可。<br>这时候克隆下来的库还是很凌乱的，不知道其组织结构是什么，再运行“创建新程序”这个脚本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;app_name&gt;</span><br><span class="line">./make_new_application.py</span><br></pre></td></tr></table></figure>
<p>这时候整个代码结构就焕然一新，通过查看git状态就可以知道该脚本干了什么：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#	renamed:    Makefile.app -&gt; Makefile</span></span><br><span class="line"><span class="meta">#	deleted:    Makefile.module</span></span><br><span class="line"><span class="meta">#	modified:   README.md</span></span><br><span class="line"><span class="meta">#	modified:   doc/doxygen/Doxyfile</span></span><br><span class="line"><span class="meta">#	new file:   <span class="meta-keyword">include</span>/base/StarfishApp.h</span></span><br><span class="line"><span class="meta">#	deleted:    <span class="meta-keyword">include</span>/base/StorkApp.h</span></span><br><span class="line"><span class="meta">#	deleted:    make_new_application.py</span></span><br><span class="line"><span class="meta">#	deleted:    make_new_module.py</span></span><br><span class="line"><span class="meta">#	renamed:    run_tests.app -&gt; run_tests</span></span><br><span class="line"><span class="meta">#	deleted:    run_tests.module</span></span><br><span class="line"><span class="meta">#	new file:   src/base/StarfishApp.C</span></span><br><span class="line"><span class="meta">#	new file:   src/base/StarfishApp.C.module</span></span><br><span class="line"><span class="meta">#	deleted:    src/base/StorkApp.C.app</span></span><br><span class="line"><span class="meta">#	deleted:    src/base/StorkApp.C.module</span></span><br><span class="line"><span class="meta">#	modified:   src/main.C</span></span><br><span class="line"><span class="meta">#	modified:   unit/Makefile</span></span><br><span class="line"><span class="meta">#	modified:   unit/run_tests</span></span><br><span class="line"><span class="meta">#	modified:   unit/src/main.C</span></span><br></pre></td></tr></table></figure>
<p>然后，再make一下，就可以得到可执行文件。用tests中的输入文件测试一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./starfish-opt -i /home/qixinbo/MyProjects/starfish/tests/kernels/simple_diffusion/simple_diffusion.i</span><br></pre></td></tr></table></figure>
<p>后续就是创建自己的输入文件。</p>
<h1 id="输入文件"><a href="#输入文件" class="headerlink" title="输入文件"></a>输入文件</h1><p>输入文件是“分级块状”形式，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Variables]</span><br><span class="line">  active = <span class="string">&#x27;u&#x27;</span></span><br><span class="line">  [./u]</span><br><span class="line">    order = FIRST</span><br><span class="line">    family = LAGRANGE</span><br><span class="line">  [../]</span><br><span class="line">  [./v]</span><br><span class="line">    order = FIRST</span><br><span class="line">    family = LAGRANGE</span><br><span class="line">  [../]</span><br><span class="line">[]</span><br><span class="line">[Kernels]</span><br><span class="line">  ...</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<p>可以看出，方括号括起来的就是一个块，且块里还可以包含块，这就是分级块状结构。<br>在moose的<a target="_blank" rel="noopener" href="http://mooseframework.com/docs/syntax/moose/">帮助文档</a>中，已经很直观地列出了各种块的结构。需要注意的是其颜色和符号表示：加粗的名称表示其是一个块，红色参数表示该参数必须人为指定。输入文件可以手动书写，也可以在Peacock孔雀中设定。Peacock是一个图形前端，使用户可以创建或修改输入文件，执行计算和可视化计算结果。Peacock中黑色字体的块可以双击以编辑，蓝色字体的块可以右键单击进行添加，出来编辑对话框后，最上面可以选择总的类型选择，Peacock中必须设定的字段是橘黄色填充，对应moose帮助文档中的红色参数。</p>
<p>重要的“块”有网格、变量、内核模型、边界条件、求解器、输出等。通常，用户程序需要自己创建网格，设定自己的变量及其有限元插值方式，编写自己的内核模型，当然对简单问题也可以直接调用moose的内核模型，设定边界条件，选择求解器，设置输出格式等。</p>
<h1 id="创建私有对象"><a href="#创建私有对象" class="headerlink" title="创建私有对象"></a>创建私有对象</h1><p>若想创建自己的程序，比如编写自己的物理模型或边界条件等，只需继承一个已有的moose对象，然后对其进行扩展。比如编写自己的内核模型，需要在本地程序中在头文件和源文件路径中都创建kernals路径，并分别创建相应的头文件和源文件，然后需要在这两个文件中做以下事情：</p>
<h2 id="定义有效参数和继承已有的moose对象："><a href="#定义有效参数和继承已有的moose对象：" class="headerlink" title="定义有效参数和继承已有的moose对象："></a>定义有效参数和继承已有的moose对象：</h2><p>在头文件中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Convection</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line">InputParameters validParams&lt;Convection&gt;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Convection</span> :</span> <span class="keyword">public</span> Kernel</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这里的Convection就是新定义的内核，其父类是moose的Kernel类。<br>每一个moose派生的对象都必须指定一个validParams函数，它必须先取出父类中的参数，然后再增加额外的参数。即在源文件中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line">InputParameters validParams&lt;Convection&gt;()</span><br><span class="line">&#123;</span><br><span class="line">  InputParameters params = validParams&lt;Kernel&gt;();  <span class="comment">// Must get from parent</span></span><br><span class="line">  params.addRequiredParam&lt;RealVectorValue&gt;(<span class="string">&quot;velocity&quot;</span>, <span class="string">&quot;Velocity Vector&quot;</span>);</span><br><span class="line">  params.addParam&lt;Real&gt;(<span class="string">&quot;coefficient&quot;</span>, <span class="string">&quot;Diffusion coefficient&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，在输入文件中就需要指定该对象所需要的参数。可以用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ex02-opt --dump [optional search string]</span><br></pre></td></tr></table></figure>
<p>来具体查看所需参数。</p>
<p>添加函数的语法为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addRequiredParam&lt;Real&gt;(<span class="string">&quot;required_const&quot;</span>, <span class="string">&quot;doc&quot;</span>);</span><br><span class="line">addParam&lt;<span class="keyword">int</span>&gt;(<span class="string">&quot;count&quot;</span>, <span class="number">1</span>, <span class="string">&quot;doc&quot;</span>); <span class="comment">// default supplied</span></span><br><span class="line">addParam&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(<span class="string">&quot;another_num&quot;</span>, <span class="string">&quot;doc&quot;</span>);</span><br><span class="line">addRequiredParam&lt;std::vector&lt;<span class="keyword">int</span>&gt; &gt;(<span class="string">&quot;vec&quot;</span>, <span class="string">&quot;doc&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>第一个参数是参数名，输入文件中要跟其相同，最后一个参数是注释。<br>对于非required的参数，可以设置其缺省值或取值范围，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addParam&lt;RealVectorValue&gt;(<span class="string">&quot;direction&quot;</span>, <span class="built_in">RealVectorValue</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>), <span class="string">&quot;doc&quot;</span>);</span><br><span class="line">addRangeCheckedParam&lt;Real&gt;(<span class="string">&quot;temp&quot;</span>, <span class="string">&quot;temp&gt;=300 &amp; temp&lt;=330&quot;</span>, <span class="string">&quot;doc&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="注册该对象"><a href="#注册该对象" class="headerlink" title="注册该对象"></a>注册该对象</h2><p>即在具体问题的app源文件中注册一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ExampleConvection.h&quot;</span> </span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ExampleApp::<span class="built_in">registerObjects</span>(Factory &amp; factory)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Register any custom objects you have built on the MOOSE Framework</span></span><br><span class="line"><span class="built_in">registerKernel</span>(ExampleConvection); <span class="comment">// &lt;- registration</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用该对象"><a href="#使用该对象" class="headerlink" title="使用该对象"></a>使用该对象</h2><p>在输入文件中使用该对象，比如这里的内核模型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Kernels]</span><br><span class="line">  [./diff]</span><br><span class="line">    type = Diffusion</span><br><span class="line">    variable = convected</span><br><span class="line">  [../]</span><br><span class="line">  [./conv]</span><br><span class="line">    type = ExampleConvection</span><br><span class="line">    variable = convected</span><br><span class="line">    velocity = &#x27;0.0 0.0 1.0&#x27;</span><br><span class="line">  [../]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<h1 id="网格"><a href="#网格" class="headerlink" title="网格"></a>网格</h1><p>网格块默认是读入网格文件，即默认：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type = FileMesh</span><br></pre></td></tr></table></figure>
<p>可以读入很多种格式的网格文件，比如libMesh、Tecplot、GMSH、Abaqus等。所以对于复杂形状的几何体，可以使用专业的网格生成软件，再由moose读入。</p>
<p>使用GMSH画网格时，注意按照“点-线-面-体”的步骤生成几何体，不要漏了某一步骤。<br>同时，Attention：还要生成”Physical Groups”，将面加上标识，用以设置边界条件，同时还要将体加上标识，否则在peacock中不能正确识别整个三维结构。</p>
<p>还可以是内置生成的网格，即：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type = GeneratedMesh</span><br></pre></td></tr></table></figure>
<p>可以用来创建一些简单的形状，如立方体等。<br>边界标识为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In <span class="number">1</span>D, left = <span class="number">0</span>, right = <span class="number">1</span></span><br><span class="line">In <span class="number">2</span>D, bottom = <span class="number">0</span>, right = <span class="number">1</span>, top = <span class="number">2</span>, left = <span class="number">3</span></span><br><span class="line">In <span class="number">3</span>D, back = <span class="number">0</span>, bottom = <span class="number">1</span>, right = <span class="number">2</span>, top = <span class="number">3</span>, left = <span class="number">4</span>, front = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>计算域的维度、长高宽、每个方向上单元个数等都可以人为指定：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Mesh]</span><br><span class="line">  type = GeneratedMesh</span><br><span class="line">  dim = <span class="number">2</span></span><br><span class="line">  nx = <span class="number">100</span></span><br><span class="line">  ny = <span class="number">100</span></span><br><span class="line">  xmax = <span class="number">60</span></span><br><span class="line">  ymax = <span class="number">60</span></span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<p>还有其他的网格类型，比如EBSDMesh、ImageMesh等。</p>
<h1 id="内核模型对象"><a href="#内核模型对象" class="headerlink" title="内核模型对象"></a>内核模型对象</h1><p>一个内核Kernel是一个物理模型，表示偏微分方程中的一个或多个算子。<br>一个内核必须重载computeQpResidual函数，可以视情况重载computeQpJacobian和computeQpOffDiagJacobian函数。<br>内核的常用数据成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_u,_grad_u: 该kernel所操作的变量的值和梯度</span><br><span class="line">_phi,_grad_phi: 基函数在积分点上的值和梯度</span><br><span class="line">_test,_grad_test: 试探函数在积分点上的值和梯度 </span><br><span class="line">_q_point: 当前积分点的xyz坐标</span><br><span class="line">_i,_j: 分别是试探函数和有限元插值函数的当前形函数</span><br><span class="line">_qp: 当前积分点标识</span><br><span class="line">_current_elem: 指向当前单元的指针</span><br></pre></td></tr></table></figure>
<p>在伽辽金有限元法中，试探函数和有限元函数的基函数相同。<br>MOOSE中默认把控制方程写成右端项为0，即将所有项都移到左端，称为残差向量Residual Vector。</p>
<p>对于时间发展方程，moose的内核是TimeDerivative。常用的数据成员是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_u_dot: u对时间的导数</span><br><span class="line">_du_dot_du: u对时间的导数对u的导数，用于计算雅各比矩阵</span><br></pre></td></tr></table></figure>

<h1 id="初始条件对象"><a href="#初始条件对象" class="headerlink" title="初始条件对象"></a>初始条件对象</h1><p>时间相关的问题需要设置初始条件，如果使用ExodusII网格，还可以将之前模拟中的变量的值作为初始条件。<br>首先在头文件中创建有效参数和继承已有moose对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> EXAMPLEIC_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXAMPLEIC_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;InitialCondition.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleIC</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"># InputParameters validParams&lt;ExampleIC&gt;();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleIC</span> :</span> <span class="keyword">public</span> InitialCondition</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"># <span class="built_in">ExampleIC</span>(<span class="keyword">const</span> std::string | name,</span><br><span class="line">          InputParameters parameters);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Real <span class="title">value</span><span class="params">(<span class="keyword">const</span> Point | p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Real _coefficient;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//EXAMPLEIC_H</span></span></span><br></pre></td></tr></table></figure>
<p>父类是moose的InitialCondition类，派生类必须重载value函数，可以选择性重载gradient函数。<br>然后在源文件中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ExampleIC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"># InputParameters validParams&lt;ExampleIC&gt;()</span><br><span class="line">&#123;</span><br><span class="line">  InputParameters params = validParams&lt;InitialCondition&gt;();</span><br><span class="line">  params.addRequiredParam&lt;Real&gt;(<span class="string">&quot;coefficient&quot;</span>, <span class="string">&quot;A coef&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> params;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># ExampleIC::<span class="built_in">ExampleIC</span>(<span class="keyword">const</span> std::string | name,</span><br><span class="line">                     InputParameters parameters):</span><br><span class="line">  <span class="built_in">InitialCondition</span>(name, parameters),</span><br><span class="line">  _coefficient(getParam&lt;Real&gt;(<span class="string">&quot;coefficient&quot;</span>))</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"># Real</span><br><span class="line"># ExampleIC::<span class="built_in">value</span>(<span class="keyword">const</span> Point | p)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 2.0 * c * |x|</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">2.0</span>*_coefficient*std::<span class="built_in">abs</span>(<span class="built_in">p</span>(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，注册该初始条件对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ExampleIC.h&quot;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">registerInitialCondition</span>(ExampleIC);</span><br></pre></td></tr></table></figure>
<p>在输入文件中使用时可以有多种形式：<br>第一种：直接使用ICs块：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[ICs]</span><br><span class="line">  [./mat_1]</span><br><span class="line">    type = ExampleIC</span><br><span class="line">    variable = u</span><br><span class="line">    coefficient = <span class="number">2.0</span></span><br><span class="line">    block = <span class="number">1</span></span><br><span class="line">  [../]</span><br><span class="line"></span><br><span class="line">  [./mat_2]</span><br><span class="line">    type = ExampleIC</span><br><span class="line">    variable = u</span><br><span class="line">    coefficient = <span class="number">10.0</span></span><br><span class="line">    block = <span class="number">2</span></span><br><span class="line">  [../]</span><br></pre></td></tr></table></figure>
<p>第二种：在variable块下使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Variables]</span><br><span class="line">  [./diffused]</span><br><span class="line">    order = FIRST</span><br><span class="line">    family = LAGRANGE</span><br><span class="line">    # Use the initial Condition block underneath the variable</span><br><span class="line">    <span class="meta"># for which we want to apply this initial condition</span></span><br><span class="line">    [./InitialCondition]</span><br><span class="line">      type = ExampleIC</span><br><span class="line">      coefficient = <span class="number">2.0</span>;</span><br><span class="line">    [../]</span><br><span class="line">  [../]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<p>如果是简单的初始条件，设置不需要额外创建该对象，直接：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Variables]</span><br><span class="line">  active = <span class="string">&#x27;u&#x27;</span></span><br><span class="line"></span><br><span class="line">  [./u]</span><br><span class="line">    order = FIRST</span><br><span class="line">    family = LAGRANGE</span><br><span class="line">    # For simple constant ICs</span><br><span class="line">    initial_condition = <span class="number">10</span></span><br><span class="line">  [../]</span><br></pre></td></tr></table></figure>
<p>第三种：导入之前求解的解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Variables]</span><br><span class="line">  active = <span class="string">&#x27;u&#x27;</span></span><br><span class="line"></span><br><span class="line">  [./u]</span><br><span class="line">    order = FIRST</span><br><span class="line">    family = LAGRANGE</span><br><span class="line">    # For reading a solution</span><br><span class="line">    <span class="meta"># from an ExodusII file</span></span><br><span class="line">    initial_from_file_var = diffused&#125;</span><br><span class="line">    initial_from_file_timestep = <span class="number">2</span></span><br><span class="line">  [../]</span><br></pre></td></tr></table></figure>

<h1 id="边界条件对象"><a href="#边界条件对象" class="headerlink" title="边界条件对象"></a>边界条件对象</h1><p>边界条件的结构与内核模型类似，不同是，有些边界条件在边界上积分，其继承moose的IntegratedBC类，而有些边界条件不在边界上积分，即Dirichlet边界条件，其继承NodalBC类。<br>对于边界条件可以使用的内部函数有：<br>对于积分的边界条件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_u, _grad_u: 此边界条件所操作的值和梯度</span><br><span class="line">_phi, _grad_phi: 基函数的值和梯度</span><br><span class="line">_test, _grad_test: 试探函数的值和梯度</span><br><span class="line">_q_point: XYZ坐标</span><br><span class="line">_i, _j: 形函数索引</span><br><span class="line">_qp: 当前积分点索引</span><br><span class="line">_normals: 法向量</span><br><span class="line">_boundary_id: 边界标识</span><br><span class="line">_current_elem: 指向当前单元的指针</span><br><span class="line">_current_side: 当前单元的边的标识</span><br></pre></td></tr></table></figure>
<p>对于非积分的边界条件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_u</span><br><span class="line">_qp</span><br><span class="line">_boundary_id</span><br><span class="line">_current_node: 指向当前节点的指针</span><br></pre></td></tr></table></figure>
<p>不同的边界可以有不同的边界条件，所以相互之间可以耦合使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">coupledValue</span>()</span><br><span class="line"><span class="built_in">coupledValueOld</span>()</span><br><span class="line"><span class="built_in">coupledValueOlder</span>()</span><br><span class="line"><span class="built_in">coupledGradient</span>()</span><br><span class="line"><span class="built_in">coupledGradientOld</span>()</span><br><span class="line"><span class="built_in">coupledGradientOlder</span>()</span><br><span class="line"><span class="built_in">coupledDot</span>()</span><br></pre></td></tr></table></figure>

<p>周期性边界条件对于守恒物理量在近似无限大的计算域中的演化非常有用。moose对于边界条件有非常强大的支持：可以设置不同维度、网格自适应、对于特定变量施加、设置任意变换矢量来设定周期性(可以与坐标系平行也可以成角度)。</p>
<h1 id="材料属性对象"><a href="#材料属性对象" class="headerlink" title="材料属性对象"></a>材料属性对象</h1><p>首先还是创建有效参数和继承moose对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line">InputParameters validParams&lt;ExampleMaterial&gt;();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleMaterial</span> :</span> <span class="keyword">public</span> Material</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ExampleMaterial</span>(<span class="keyword">const</span> InputParameters &amp; parameters);</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">computeQpProperties</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">这里的父类是moose的Material类，必须重载computeQpProperties函数。</span><br><span class="line">Material类定义了材料属性后，其他对象通过getMaterialProperty函数来获取它们：</span><br><span class="line">```cpp</span><br><span class="line">ExampleConvection::<span class="built_in">ExampleConvection</span>(<span class="keyword">const</span> InputParameters &amp; parameters) :</span><br><span class="line"><span class="built_in">Kernel</span>(parameters),</span><br><span class="line"><span class="comment">// Retrieve a gradient material property to use for the convection</span></span><br><span class="line"><span class="comment">// velocity</span></span><br><span class="line">_velocity(getMaterialProperty&lt;RealGradient&gt;(<span class="string">&quot;convection_velocity&quot;</span>))</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="后处理对象"><a href="#后处理对象" class="headerlink" title="后处理对象"></a>后处理对象</h1><p>一个后处理对象是对所得的解进行加工再处理的过程，比如得到每条边上的平均通量，结果是一个标量值。<br>其何时计算取决于这个参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">execute_on = timestep_end</span><br><span class="line">execute_on = linear</span><br><span class="line">execute_on = nonlinear</span><br><span class="line">execute_on = timestep_begin</span><br><span class="line">execute_on = custom</span><br></pre></td></tr></table></figure>
<p>其可以限制在计算域的特定区域、边或节点的特定集合上:</p>
<ol>
<li>作用在单元上：可以是整个计算域上的单元，也可是通过设定一个或多个block标识来限制子区域，继承自ElementPostprocessor类;</li>
<li>作用在节点上：可以是整个计算域上的节点，也可通过设定一个或多个boundary标识来限制点集，继承自NodalPostprocessor类;</li>
<li>作用在边上：必须设定一个或多个boundary标识来决定在哪个边上计算，继承自SidePostprocessor类;</li>
<li>通用设置：根据自己需求设置，继承自GeneralPostprocessor。</li>
</ol>
<p>一些内置的后处理模块有：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ElementIntegral 单元积分, ElementAverageValue 单元平均值</span><br><span class="line">SideIntegral 边积分, SideAverageValue 边平均值</span><br><span class="line">ElementL2Error 单元L2误差, ElementH1Error 单元H1误差</span><br><span class="line">NumDOFs 自由度个数, NumNodes 节点个数, NumVars 变量个数</span><br></pre></td></tr></table></figure>
<p>上述这些都可以继承并扩展。<br>后处理结果可以输出在屏幕上，也能写入一个CSV或Tecplot文件中，或者作为全局数据输出到Exodus文件中</p>
<h1 id="求解器对象"><a href="#求解器对象" class="headerlink" title="求解器对象"></a>求解器对象</h1><p>有两种主要的求解器类型：稳态和瞬态。moose提供很多内置求解器，也可以自己创建。<br>控制求解器的常用参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l_tol 	   线性忍量</span><br><span class="line">l_max_its  最大线性迭代次数</span><br><span class="line">nl_rel_tol 非线性相对忍量</span><br><span class="line">nl_max_its 最大非线性迭代次数</span><br></pre></td></tr></table></figure>
<p>对于瞬态问题，还有一些与时间相关的设置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dt          起始时间步长(后续可以变时间步长)</span><br><span class="line">num_steps   时间步数</span><br><span class="line">start_time  起始时间</span><br><span class="line">end_time    终止时间</span><br><span class="line">scheme      时间积分算法</span><br></pre></td></tr></table></figure>
<p>moose提供了多种时间积分算法，包括下面的隐式时间积分算法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Backward <span class="title">Euler</span> <span class="params">(缺省值)</span></span></span><br><span class="line"><span class="function">BDF2</span></span><br><span class="line">Crank-Nicolson</span><br><span class="line">Implicit-Euler</span><br><span class="line"><span class="function">Implicit <span class="title">Midpoint</span> <span class="params">(implemented as two-stage RK method)</span></span></span><br><span class="line">Diagonally-Implicit Runge-Kutta (DIRK) methods of order 2 and 3.</span><br></pre></td></tr></table></figure>
<p>以及显式时间积分算法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Explicit-Euler</span><br><span class="line">Various two-stage <span class="keyword">explicit</span> Runge-<span class="function">Kutta <span class="title">methods</span> <span class="params">(Midpoint, Heun, Ralston, TVD)</span></span></span><br></pre></td></tr></table></figure>
<p>以上算法都支持自适应时间步进。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2017/01/11/moose-phase-field-kernel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Be interesting!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亓欣波">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/01/11/moose-phase-field-kernel/" class="post-title-link" itemprop="url">MOOSE相场模块的内核模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-01-11 00:00:00" itemprop="dateCreated datePublished" datetime="2017-01-11T00:00:00+08:00">2017-01-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 15:20:30" itemprop="dateModified" datetime="2021-03-25T15:20:30+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computational-material-science/" itemprop="url" rel="index"><span itemprop="name">computational material science</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2017/01/11/moose-phase-field-kernel/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/01/11/moose-phase-field-kernel/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>moose的相场模块提供了通用的求解相场模型的算法，其通式采用的是自由能泛函的原始形式，只要用户要求解的模型满足这里内置的方程形式，那么用户仅需要提供自由能的导数和材料参数，就可以迅速进行模拟。比如教程中的调幅分解模型。<br>如果用户不能知道相场的原始形式，也可以自己开发模型，比如用于模拟枝晶生长的Kobayashi模型，就不满足上述规则，此时可以自己创建模型。</p>
<h1 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h1><p>moose内核模型的表达形式是将原来的控制方程中的右端项都移动到左端，得到这样的形式：<br>$$<br>R_i(u)=0, \qquad i=1,\ldots, N<br>$$<br>其中，N是分量的个数。<br>如果写成有限元函数的形式：<br>$$<br>R_i(u_h)=0, \qquad i=1,\ldots, N<br>$$<br>其中：<br>$$<br>u \approx u_h = \sum_{j=1}^N u_j \phi_j<br>$$<br>即，原来的连续的场变量由节点上的离散的系数来代替。</p>
<h2 id="单变量求根"><a href="#单变量求根" class="headerlink" title="单变量求根"></a>单变量求根</h2><p>现在仅考虑单变量情形：<br>$$<br>f(x)=0<br>$$<br>moose采用Newton迭代法来对其求根，该方法的基本思想是：将非线性方程的求根问题，转化成某个线性方程的求根。比如，对该方程的左端项进行泰勒展开，且只取其线性主部：<br>$$<br>0=f(x)=f(x_0)+f’(x_0)(x-x_0)<br>$$<br>那么，解就是：<br>$$<br>x_1=x_0-\frac{f(x_0)}{f’(x_0)}<br>$$<br>这样就得到根的新的近似值。进一步迭代：<br>$$<br>x_{k+1}=x_k-\frac{f(x_k)}{f’(x_k)}<br>$$<br>当前后两步解的差值达到某个精度时，就认为该解就是方程的根。</p>
<h2 id="多变量求根"><a href="#多变量求根" class="headerlink" title="多变量求根"></a>多变量求根</h2><p>回到有限元法中，因为场函数由分布在节点上的有限元函数值所代替，所以此时变量就有多个。那么，对应于单变量情形，可得出多变量时的表达式：<br>$$<br>\mathbf{J}(\vec{u}_0) (\vec{u}_1-\vec{u}_0) = -\vec{R}(\vec{u}_0)<br>$$<br>其中，$\mathbf{J}(\vec{u}_0)$是当前迭代步的雅各比矩阵。上方带箭头的变量表示其是一个矢量，矢量大小就是节点的个数。<br>通用的迭代格式就是：<br>$$<br>\mathbf{J}(\vec{u}_k) (\vec{u}_{k+1}-\vec{u}_k) = -\vec{R}(\vec{u}_k)<br>$$<br>其中雅各比矩阵的具体形式为：<br>$$<br>J_{ij}(\vec{u}_k) = \frac{\partial R_i(\vec{u}_k)}{\partial u_j}<br>$$<br>在求雅各比矩阵时，有两个基本公式是非常重要的：<br>$$<br>\frac{\partial u_h}{\partial u_j} =<br>      \sum_k\frac{\partial }{\partial u_j}(u_k \phi_k) = \phi_j<br>    \qquad<br>\frac{\partial (\nabla u_h)}{\partial u_j} =<br>      \sum_k \frac{\partial }{\partial u_j}(u_k \nabla \phi_k)=\nabla \phi_j<br>$$</p>
<h2 id="线性迭代和非线性迭代"><a href="#线性迭代和非线性迭代" class="headerlink" title="线性迭代和非线性迭代"></a>线性迭代和非线性迭代</h2><p>首先将<br>$$<br>\mathbf{J}(\vec{u}_0) (\vec{u}_1-\vec{u}_0) = -\vec{R}(\vec{u}_0)<br>$$<br>等效成：<br>$$<br>Ax=b<br>$$<br>线性迭代：对于某一个Newton迭代步，比如上面的k+1步，Ax=b是一个大型线性方程组。在求解这个线性方程组的过程中A和b保持不变，仅是不断地迭代x，使其收敛，这个过程叫线性迭代Linear Iteration，每步迭代的残差称为线性残差Linear Residual，第i步迭代的残差表达式为\rhoi=Axi-b。如果设置print_linear_residuals=true，那么MOOSE就会打印该残差向量的范数。</p>
<p>JFNK算法：在上面的线性迭代过程中，想要高效地求解x，这里使用Krylov子空间，将Ax=b转换为Kxi+1=Kxi+b-Axi的迭代形式来求解，具体的算法可以是GMRES或共轭梯度法等。这个算法中不明确地需要Jacobi矩阵，仅仅需要J对向量的作用。下面有详细介绍。</p>
<p>非线性迭代：也是在一个Newton迭代步中，针对的是总的残差R的迭代，从而使其收敛，进入下一个时间步，该残差称为非线性残差Nonlinear Residuals。</p>
<p>那么总的思路就是：对于某个时间步，首先给定一个R的初值R0，然后计算出一个x0，从而对x进行迭代，直到x收敛到给定线性迭代精度，这时候也就计算出了新的R值，即R1，如果R1和R0不满足非线性迭代精度要求，那么将R1再代入Ax=b中，再次对x迭代，直到再次达到线性迭代精度，再计算出R2，再判定是否达到非线性迭代精度。  </p>
<h2 id="牛刀小试"><a href="#牛刀小试" class="headerlink" title="牛刀小试"></a>牛刀小试</h2><p>对于一个经典的对流-扩散方程：<br>$$<br>-\nabla\cdot k\nabla u + \vec{\beta} \cdot \nabla u = f<br>$$<br>其残差向量的第i个分量为：<br>$$<br>R_i(u_h) = (\nabla\psi_i, k\nabla u_h)-\langle\psi_i, k\nabla u_h\cdot \hat{n} \rangle + (\psi_i, \vec{\beta} \cdot \nabla u_h)-(\psi_i, f)<br>$$<br>雅各比矩阵的某个元素为：<br>$$<br>J_{ij}(u_h)= (\nabla\psi_i,\frac{\partial k}{\partial u_j}\nabla u_h) +(\nabla\psi_i, k \nabla \phi_j ) - \langle\psi_i, \frac{\partial k}{\partial u_j}\nabla u_h\cdot \hat{n} \rangle - \langle\psi_i, k\nabla \phi_j\cdot \hat{n} \rangle + (\psi_i, \frac{\partial \vec{\beta}}{\partial u_j} \cdot\nabla u_h) + (\psi_i, \vec{\beta} \cdot \nabla \phi_j) - (\psi_i, \frac{\partial f}{\partial u_j})<br>$$<br>注意，这里假定扩散系数、对流速度、源项等都是变量，所以形式会比较复杂。<br>尤其是对于多个方程相互耦合，或材料属性比较复杂的情形，雅各比矩阵的计算会很困难。</p>
<h2 id="链式法则"><a href="#链式法则" class="headerlink" title="链式法则"></a>链式法则</h2><p>有时候，可以应用链式法则来简化一下，比如：<br>$$<br>\frac{\partial f}{\partial u_j} = \frac{\partial f}{\partial u_h} \frac{\partial u_h}{\partial u_j}=\frac{\partial f}{\partial u_h} \phi_j<br>$$<br>如果f的表达式已知，比如$f(u) = \sin(u)$，那么：<br>$$<br>\frac{\partial f}{\partial u_j} = \cos(u_h) \phi_j<br>$$</p>
<h2 id="JFNK算法"><a href="#JFNK算法" class="headerlink" title="JFNK算法"></a>JFNK算法</h2><p>JFNK算法，全称是Jacobian Free Newton Krylov methods，是数值求解非线性问题的一种先进方法，其核心思想是将Newton非线性迭代法嵌入到Krylov空间法求解线性代数方程组的过程中，其显著优点是避免了传统Newton迭代法中的Jacobian矩阵生成环节，有利于降低内存占用率，缩短计算时长。<br>JFNK算法将Newton迭代法与Krylov空间法结合的方式是将Newton迭代法中的Jacobian矩阵$\mathbf{J}$与Krylov空间法的解向量$\vec{v}$之间进行向量积操作，其近似为：<br>$$<br>\mathbf{J}\vec{v} \approx \frac{\vec{R}(\vec{u} + \epsilon\vec{v}) - \vec{R}(\vec{u})}{\epsilon}<br>$$<br>这个算法的优点有：</p>
<ul>
<li>无需计算偏导数来得到雅各比矩阵</li>
<li>无需直接计算雅各比矩阵</li>
<li>无需空间来存储雅各比矩阵</li>
</ul>
<h1 id="调幅分解所用的Cahn-Hilliard方程"><a href="#调幅分解所用的Cahn-Hilliard方程" class="headerlink" title="调幅分解所用的Cahn-Hilliard方程"></a>调幅分解所用的Cahn-Hilliard方程</h1><p>这里将含有四阶导数的原CH方程，拆分成两个，这样每个都只含有二阶导数，易于求解，两个方程的变量分别是化学势和浓度。</p>
<h2 id="化学势的残差"><a href="#化学势的残差" class="headerlink" title="化学势的残差"></a>化学势的残差</h2><p>其表达式及其求解内核分为两个：</p>
<h3 id="第一项"><a href="#第一项" class="headerlink" title="第一项"></a>第一项</h3><p>$$<br>(\frac{\partial c}{\partial t},\psi)<br>$$<br>该项中变量是化学势，耦合的变量是浓度，使用的内核是CoupledTimeDerivative。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Real</span><br><span class="line">CoupledTimeDerivative::<span class="built_in">computeQpResidual</span>()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> _test[_i][_qp] * _v_dot[_qp];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Real</span><br><span class="line">CoupledTimeDerivative::<span class="built_in">computeQpJacobian</span>()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="第二项"><a href="#第二项" class="headerlink" title="第二项"></a>第二项</h3><p>$$<br>(M\nabla\mu,\nabla \psi)<br>$$<br>该项中变量是化学势，使用的内核是SplitCHWRes，实际使用的是SplitCHWResBase：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Real</span><br><span class="line">SplitCHWResBase&lt;T&gt;::<span class="built_in">computeQpResidual</span>()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> _mob[_qp] * _grad_u[_qp] * _grad_test[_i][_qp];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Real</span><br><span class="line">SplitCHWResBase&lt;T&gt;::<span class="built_in">computeQpJacobian</span>()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> _mob[_qp] * _grad_phi[_j][_qp] * _grad_test[_i][_qp];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="浓度的残差"><a href="#浓度的残差" class="headerlink" title="浓度的残差"></a>浓度的残差</h2><p>残差表达式为：<br>$$<br>(\nabla c, \nabla(\kappa \psi))+((\frac{\partial f_{loc}}{\partial c}+\frac{\partial E_d}{\partial c} - \mu ), \psi)<br>$$<br>变量是浓度，还需耦合化学势$\mu$，使用的内核是SplitCHParsed，实际使用的内核是SplitCHCRes：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Real</span><br><span class="line">SplitCHCRes::<span class="built_in">computeQpResidual</span>()</span><br><span class="line">&#123;</span><br><span class="line"> Real residual = SplitCHBase::<span class="built_in">computeQpResidual</span>(); <span class="comment">//(f_prime_zero+e_prime)*_test[_i][_qp] from SplitCHBase</span></span><br><span class="line"></span><br><span class="line"> residual += -_w[_qp] * _test[_i][_qp];</span><br><span class="line"> residual += _kappa[_qp] * _grad_u[_qp] * _grad_test[_i][_qp];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> residual;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Real</span><br><span class="line">SplitCHCRes::<span class="built_in">computeQpJacobian</span>()</span><br><span class="line">&#123;</span><br><span class="line"> Real jacobian = SplitCHBase::<span class="built_in">computeQpJacobian</span>(); <span class="comment">//(df_prime_zero_dc+de_prime_dc)*_test[_i][_qp]; from SplitCHBase</span></span><br><span class="line"></span><br><span class="line"> jacobian += _kappa[_qp] * _grad_phi[_j][_qp] * _grad_test[_i][_qp];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> jacobian;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，在computeQpResidual函数中，可以很容易地找出第一项和第三项的计算过程，但对于第二项，可能不容易发现，其实第二项的计算放在了最前面：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Real residual = SplitCHBase::<span class="built_in">computeQpResidual</span>(); <span class="comment">//(f_prime_zero+e_prime)*_test[_i][_qp] from SplitCHBase</span></span><br></pre></td></tr></table></figure>
<p>然后：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Real</span><br><span class="line">SplitCHBase::<span class="built_in">computeQpResidual</span>()</span><br><span class="line">&#123;</span><br><span class="line"> Real f_prime_zero = <span class="built_in">computeDFDC</span>(Residual);</span><br><span class="line"> Real e_prime = <span class="built_in">computeDEDC</span>(Residual);</span><br><span class="line"></span><br><span class="line"> Real residual = (f_prime_zero + e_prime) *_test[_i][_qp];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> residual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后computeDFDC和computeDEDC就是计算自由能密度和其他能量对浓度的一阶导数，即：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Real</span><br><span class="line">SplitCHParsed::<span class="built_in">computeDFDC</span>(PFFunctionType type)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in"><span class="keyword">switch</span></span> (type)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">case</span> Residual:</span><br><span class="line"> <span class="keyword">return</span> _dFdc[_qp];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">case</span> Jacobian:</span><br><span class="line"> <span class="keyword">return</span> _d2Fdc2[_qp] * _phi[_j][_qp];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">mooseError</span>(<span class="string">&quot;Internal error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_dFdc(getMaterialPropertyDerivative&lt;Real&gt;(<span class="string">&quot;f_name&quot;</span>, _var.<span class="built_in">name</span>())),</span><br><span class="line">_d2Fdc2(getMaterialPropertyDerivative&lt;Real&gt;(<span class="string">&quot;f_name&quot;</span>, _var.<span class="built_in">name</span>(), _var.<span class="built_in">name</span>()))</span><br></pre></td></tr></table></figure>
<p>注意取一阶导数和二阶导数时，是由后面的参数个数来控制。</p>
<p>具体的自由能形式则是在输入文件中输入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[Materials]</span><br><span class="line">  [./local_energy]</span><br><span class="line">    # Defines the function <span class="keyword">for</span> the local free energy density as given in the</span><br><span class="line">    <span class="meta"># problem, then converts units and adds scaling factor.</span></span><br><span class="line">    type = DerivativeParsedMaterial</span><br><span class="line">    block = <span class="number">0</span></span><br><span class="line">    f_name = f_loc</span><br><span class="line">    args = c</span><br><span class="line">    constant_names = &#x27;A   B   C   D   E   F   G  eV_J  d&#x27;</span><br><span class="line">    constant_expressions = &#x27;-2.446831e+04 -2.827533e+04 4.167994e+03 7.052907e+03</span><br><span class="line">                            <span class="number">1.208993e+04</span> <span class="number">2.568625e+03</span> <span class="number">-2.354293e+03</span></span><br><span class="line">                            <span class="number">6.24150934e+18</span> <span class="number">1e-27&#x27;</span></span><br><span class="line">    function = &#x27;eV_J*d*(A*c+B*(1-c)+C*c*log(c)+D*(1-c)*log(1-c)+</span><br><span class="line">                E*c*(<span class="number">1</span>-c)+F*c*(<span class="number">1</span>-c)*(<span class="number">2</span>*c<span class="number">-1</span>)+G*c*(<span class="number">1</span>-c)*(<span class="number">2</span>*c<span class="number">-1</span>)^<span class="number">2</span>)&#x27;</span><br><span class="line">  [../]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<h1 id="枝晶生长所用的Kobayashi模型"><a href="#枝晶生长所用的Kobayashi模型" class="headerlink" title="枝晶生长所用的Kobayashi模型"></a>枝晶生长所用的Kobayashi模型</h1><h2 id="相场的残差"><a href="#相场的残差" class="headerlink" title="相场的残差"></a>相场的残差</h2><p>包括以下几项：</p>
<h3 id="第一项-1"><a href="#第一项-1" class="headerlink" title="第一项"></a>第一项</h3><p>$$<br>(\frac{\partial w}{\partial t},\psi)<br>$$<br>内核使用TimeDerivative：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TimeDerivative.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Assembly.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// libmesh includes</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;libmesh/quadrature.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line">InputParameters validParams&lt;TimeDerivative&gt;()</span><br><span class="line">&#123;</span><br><span class="line"> InputParameters params = validParams&lt;TimeKernel&gt;();</span><br><span class="line"> params.addParam&lt;<span class="keyword">bool</span>&gt;(<span class="string">&quot;lumping&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;True for mass matrix lumping, false otherwise&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> params;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TimeDerivative::<span class="built_in">TimeDerivative</span>(<span class="keyword">const</span> InputParameters &amp; parameters) :</span><br><span class="line"> <span class="built_in">TimeKernel</span>(parameters),</span><br><span class="line"> _lumping(getParam&lt;<span class="keyword">bool</span>&gt;(<span class="string">&quot;lumping&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Real</span><br><span class="line">TimeDerivative::<span class="built_in">computeQpResidual</span>()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> _test[_i][_qp]*_u_dot[_qp];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Real</span><br><span class="line">TimeDerivative::<span class="built_in">computeQpJacobian</span>()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> _test[_i][_qp]*_phi[_j][_qp]*_du_dot_du[_qp];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">TimeDerivative::<span class="built_in">computeJacobian</span>()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (_lumping)</span><br><span class="line"> &#123;</span><br><span class="line"> DenseMatrix&lt;Number&gt; &amp; ke = _assembly.<span class="built_in">jacobianBlock</span>(_var.<span class="built_in">number</span>(), _var.<span class="built_in">number</span>());</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (_i = <span class="number">0</span>; _i &lt; _test.<span class="built_in">size</span>(); _i++)</span><br><span class="line"> <span class="keyword">for</span> (_j = <span class="number">0</span>; _j &lt; _phi.<span class="built_in">size</span>(); _j++)</span><br><span class="line"> <span class="keyword">for</span> (_qp = <span class="number">0</span>; _qp &lt; _qrule-&gt;<span class="built_in">n_points</span>(); _qp++)</span><br><span class="line"> <span class="built_in">ke</span>(_i, _i) += _JxW[_qp] * _coord[_qp] * <span class="built_in">computeQpJacobian</span>();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> TimeKernel::<span class="built_in">computeJacobian</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二项-1"><a href="#第二项-1" class="headerlink" title="第二项"></a>第二项</h3><p>注意将残差都移动到方程左端，注意符号变化。<br>$$<br>(-L\epsilon\epsilon\prime\frac{\partial w}{\partial y},\frac{\partial \psi}{\partial x})+(L\epsilon\epsilon\prime\frac{\partial w}{\partial x},\frac{\partial \psi}{\partial y})<br>$$<br>这两项使用内核ACInterfaceKobayashi1.h，其实际使用KernelGrad：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">RealGradient</span><br><span class="line">ACInterfaceKobayashi1::<span class="built_in">precomputeQpResidual</span>()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// Set modified gradient vector</span></span><br><span class="line"> <span class="function"><span class="keyword">const</span> RealGradient <span class="title">v</span><span class="params">(- _grad_u[_qp](<span class="number">1</span>), _grad_u[_qp](<span class="number">0</span>), <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Define anisotropic interface residual</span></span><br><span class="line"> <span class="keyword">return</span> _eps[_qp] * _deps[_qp] * _L[_qp] * v;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">KernelGrad::<span class="built_in">computeResidual</span>()</span><br><span class="line">&#123;</span><br><span class="line"> DenseVector&lt;Number&gt; &amp; re = _assembly.<span class="built_in">residualBlock</span>(_var.<span class="built_in">number</span>());</span><br><span class="line"> _local_re.<span class="built_in">resize</span>(re.<span class="built_in">size</span>());</span><br><span class="line"> _local_re.<span class="built_in">zero</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> n_test = _test.<span class="built_in">size</span>();</span><br><span class="line"> <span class="keyword">for</span> (_qp = <span class="number">0</span>; _qp &lt; _qrule-&gt;<span class="built_in">n_points</span>(); _qp++)</span><br><span class="line"> &#123;</span><br><span class="line"> RealGradient value = <span class="built_in">precomputeQpResidual</span>() * _JxW[_qp] * _coord[_qp];</span><br><span class="line"> <span class="keyword">for</span> (_i = <span class="number">0</span>; _i &lt; n_test; _i++) <span class="comment">// target for auto vectorization</span></span><br><span class="line"> _local_re(_i) += value * _grad_test[_i][_qp];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> re += _local_re;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (_has_save_in)</span><br><span class="line"> &#123;</span><br><span class="line"> Threads::<span class="function">spin_mutex::scoped_lock <span class="title">lock</span><span class="params">(Threads::spin_mtx)</span></span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; var : _save_in)</span><br><span class="line"> var-&gt;<span class="built_in">sys</span>().<span class="built_in">solution</span>().<span class="built_in">add_vector</span>(_local_re, var-&gt;<span class="built_in">dofIndices</span>());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三项"><a href="#第三项" class="headerlink" title="第三项"></a>第三项</h3><p>$$<br>(L\epsilon^2\nabla w,\nabla \psi)<br>$$<br>注意，内核中不是直接使用该形式，该形式是自由能对相场参量的一阶导数，实际程序中使用的也是一阶导数，所以需要输入的是自由能，即该形式的积分。<br>其使用的内核是ACInterfaceKobayashi2，实际也是KernelGrad：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">RealGradient</span><br><span class="line">ACInterfaceKobayashi2::<span class="built_in">precomputeQpResidual</span>()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// Set interfacial part of residual</span></span><br><span class="line"> <span class="keyword">return</span> _eps[_qp] * _eps[_qp] * _L[_qp] * _grad_u[_qp];</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">KernelGrad::<span class="built_in">computeResidual</span>()</span><br><span class="line">&#123;</span><br><span class="line"> DenseVector&lt;Number&gt; &amp; re = _assembly.<span class="built_in">residualBlock</span>(_var.<span class="built_in">number</span>());</span><br><span class="line"> _local_re.<span class="built_in">resize</span>(re.<span class="built_in">size</span>());</span><br><span class="line"> _local_re.<span class="built_in">zero</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> n_test = _test.<span class="built_in">size</span>();</span><br><span class="line"> <span class="keyword">for</span> (_qp = <span class="number">0</span>; _qp &lt; _qrule-&gt;<span class="built_in">n_points</span>(); _qp++)</span><br><span class="line"> &#123;</span><br><span class="line"> RealGradient value = <span class="built_in">precomputeQpResidual</span>() * _JxW[_qp] * _coord[_qp];</span><br><span class="line"> <span class="keyword">for</span> (_i = <span class="number">0</span>; _i &lt; n_test; _i++) <span class="comment">// target for auto vectorization</span></span><br><span class="line"> _local_re(_i) += value * _grad_test[_i][_qp];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> re += _local_re;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (_has_save_in)</span><br><span class="line"> &#123;</span><br><span class="line"> Threads::<span class="function">spin_mutex::scoped_lock <span class="title">lock</span><span class="params">(Threads::spin_mtx)</span></span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; var : _save_in)</span><br><span class="line"> var-&gt;<span class="built_in">sys</span>().<span class="built_in">solution</span>().<span class="built_in">add_vector</span>(_local_re, var-&gt;<span class="built_in">dofIndices</span>());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(4)<br>$$<br>(-Lw(1-w)(w-0.5+m),\psi)<br>$$<br>使用的内核是AllenCahn，实际间接使用了ACBulk，最终使用KernelValue：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">_dFdEta(getMaterialPropertyDerivative&lt;Real&gt;(<span class="string">&quot;f_name&quot;</span>, _var.<span class="built_in">name</span>())),</span><br><span class="line">_d2FdEta2(getMaterialPropertyDerivative&lt;Real&gt;(<span class="string">&quot;f_name&quot;</span>, _var.<span class="built_in">name</span>(), _var.<span class="built_in">name</span>())),</span><br><span class="line">...</span><br><span class="line">Real</span><br><span class="line">AllenCahn::<span class="built_in">computeDFDOP</span>(PFFunctionType type)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in"><span class="keyword">switch</span></span> (type)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">case</span> Residual:</span><br><span class="line"> <span class="keyword">return</span> _dFdEta[_qp];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">case</span> Jacobian:</span><br><span class="line"> <span class="keyword">return</span> _d2FdEta2[_qp] * _phi[_j][_qp];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">mooseError</span>(<span class="string">&quot;Internal error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Real</span><br><span class="line">ACBulk&lt;T&gt;::<span class="built_in">precomputeQpResidual</span>()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// Get free energy derivative from function</span></span><br><span class="line"> Real dFdop = <span class="built_in">computeDFDOP</span>(Residual);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Set residual</span></span><br><span class="line"> <span class="keyword">return</span> _L[_qp] * dFdop;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">KernelValue::<span class="built_in">computeResidual</span>()</span><br><span class="line">&#123;</span><br><span class="line"> DenseVector&lt;Number&gt; &amp; re = _assembly.<span class="built_in">residualBlock</span>(_var.<span class="built_in">number</span>());</span><br><span class="line"> _local_re.<span class="built_in">resize</span>(re.<span class="built_in">size</span>());</span><br><span class="line"> _local_re.<span class="built_in">zero</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> n_test = _test.<span class="built_in">size</span>();</span><br><span class="line"> <span class="keyword">for</span> (_qp = <span class="number">0</span>; _qp &lt; _qrule-&gt;<span class="built_in">n_points</span>(); _qp++)</span><br><span class="line"> &#123;</span><br><span class="line"> Real value = <span class="built_in">precomputeQpResidual</span>() * _JxW[_qp] * _coord[_qp];</span><br><span class="line"> <span class="keyword">for</span> (_i = <span class="number">0</span>; _i &lt; n_test; _i++) <span class="comment">// target for auto vectorization</span></span><br><span class="line"> _local_re(_i) += value * _test[_i][_qp];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> re += _local_re;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (_has_save_in)</span><br><span class="line"> &#123;</span><br><span class="line"> Threads::<span class="function">spin_mutex::scoped_lock <span class="title">lock</span><span class="params">(Threads::spin_mtx)</span></span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; var : _save_in)</span><br><span class="line"> var-&gt;<span class="built_in">sys</span>().<span class="built_in">solution</span>().<span class="built_in">add_vector</span>(_local_re, var-&gt;<span class="built_in">dofIndices</span>());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="温度场的残差"><a href="#温度场的残差" class="headerlink" title="温度场的残差"></a>温度场的残差</h2><p>由以下几项构成：</p>
<h3 id="第一项-2"><a href="#第一项-2" class="headerlink" title="第一项"></a>第一项</h3><p>$$<br>(\frac{\partial T}{\partial t},\psi)<br>$$<br>所以使用的内核是TimeDerivative。</p>
<h3 id="第二项-2"><a href="#第二项-2" class="headerlink" title="第二项"></a>第二项</h3><p>$$<br>(\nabla T,\nabla \psi)<br>$$<br>所以使用的内核是Diffusion。</p>
<h3 id="第三项-1"><a href="#第三项-1" class="headerlink" title="第三项"></a>第三项</h3><p>$$<br>(-K\frac{\partial w}{\partial t},\psi)<br>$$<br>使用的内核是CoefCoupledTimeDerivative，实际就是CoupledTimeDerivative再乘以一个系数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Real</span><br><span class="line">CoefCoupledTimeDerivative::<span class="built_in">computeQpResidual</span>()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> CoupledTimeDerivative::<span class="built_in">computeQpResidual</span>() * _coef;</span><br><span class="line">&#125;</span><br><span class="line">Real</span><br><span class="line">CoupledTimeDerivative::<span class="built_in">computeQpResidual</span>()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> _test[_i][_qp] * _v_dot[_qp];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2016/12/26/dealii-learn-step37/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Be interesting!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亓欣波">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/26/dealii-learn-step37/" class="post-title-link" itemprop="url">求解偏微分方程开源有限元软件deal.II学习--Step 37</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-12-26 00:00:00" itemprop="dateCreated datePublished" datetime="2016-12-26T00:00:00+08:00">2016-12-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 15:20:30" itemprop="dateModified" datetime="2021-03-25T15:20:30+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computational-material-science/" itemprop="url" rel="index"><span itemprop="name">computational material science</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2016/12/26/dealii-learn-step37/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/12/26/dealii-learn-step37/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2016-12-26更新：<br>将方程求解过程更加细致地表述。</p>
<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>本例展示了一种无矩阵(matrix-free)方法的使用，即不明确存储矩阵元素来求解二阶变系数Possion方程。同时求解时使用了多重网格算法。<br>应用无矩阵方法的原因是：当前科学计算的一个瓶颈是对于内存而不是高速缓存中的数据的读取：比如对于一个矩阵和一个向量的乘法运算，现在的CPU能很快地计算浮点数的乘法和加法，但通常需要很长时间等待数据从内存中传入。因此，如果我们不再从内存中寻找矩阵元素，而是重新计算它们，那么可能整体时间就能减少。<br>这个无矩阵方法中还涉及向量化/矢量化编程：把for循环的操作，用矩阵操作的形式代替。在向量化编程中，程序设计以向量为基本操作单位,采用向量运算代替循环操作以提高运行效率，这里的“向量”不同于一般数学中的概念, 它指的是数组或矩阵。该类具体进行向量化时，将一些单元合并成一个宏单元，这样用一条指令就可以同时对多个单元进行操作。</p>
<h2 id="算例"><a href="#算例" class="headerlink" title="算例"></a>算例</h2><p>这里要求解的是变系数Possion方程：<br>\begin{equation}<br>\begin{split}<br>-\nabla \cdot a (\mathbf x) \nabla u &amp;= 1, \<br>u &amp;= 0 \quad \text{on}\ \partial \Omega<br>\end{split}<br>\end{equation}<br>计算域是$\Omega=[0,1]^3$，变系数是$a(\mathbf x)=\frac{1}{0.05+2|\mathbf x |^2}$。系数虽然是以原点对称，但计算域不是，所以得到的结果也是不对称的。</p>
<p>方程的弱形式为：<br>\begin{equation}<br>\begin{split}<br>a (\mathbf x) \nabla u \nabla w &amp;= 1.0*w, \<br>u &amp;= 0 \quad \text{on}\ \partial \Omega<br>\end{split}<br>\end{equation}</p>
<p>所以，各项对应到程序中就是：<br>左端项：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">phi.<span class="built_in">submit_gradient</span> (<span class="built_in">coefficient</span>(cell,q) *</span><br><span class="line">phi.<span class="built_in">get_gradient</span>(q), q);</span><br></pre></td></tr></table></figure>
<p>右端项：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rhs_val += (fe_values.<span class="built_in">shape_value</span>(i,q) * <span class="number">1.0</span> *</span><br><span class="line">fe_values.<span class="built_in">JxW</span>(q));</span><br></pre></td></tr></table></figure>
<p>注意，上述左端项中仅有试探函数的梯度，而没有试探函数的值，所以，程序中是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">phi.<span class="built_in">evaluate</span> (<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">phi.<span class="built_in">integrate</span> (<span class="literal">false</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>如果仅用到试探函数的值，那么就得变成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">phi.<span class="built_in">evaluate</span> (<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>);</span><br><span class="line">phi.<span class="built_in">submit_value</span>(...);</span><br><span class="line">phi.<span class="built_in">integrate</span> (<span class="literal">true</span>,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h2 id="矩阵与向量的乘法"><a href="#矩阵与向量的乘法" class="headerlink" title="矩阵与向量的乘法"></a>矩阵与向量的乘法</h2><p>求解一个方程，形如：<br>$$<br>Au=b<br>$$<br>时，如果按照传统思路，需要求一个稀疏矩阵A与一个向量u的乘积。</p>
<p>先来看看有限元矩阵A是怎样组装的：<br>$$<br>A=\sum_{\mathrm{cell}=1}^{\mathrm{n_{cells}}} P_{\mathrm{cell,{loc-glob}}}^T A_{\mathrm{cell}} P_{\mathrm{cell,{loc-glob}}}<br>$$<br>上式中，长方矩阵$P_{\mathrm {cell,{loc-glob}}}$定义当前单元从局部自由度到全局自由度的指标映射。<br>如果想要对上述矩阵A乘以一个向量u，即：<br>$$<br>\begin{split}<br>y &amp;= A\cdot u = (\sum_{\text{cell}=1}^{\mathrm{n_cells}} P_\mathrm{cell,{loc-glob}}^T A_\mathrm{cell} P_\mathrm{cell,{loc-glob}}) \cdot u \\<br>&amp;= \sum_{\mathrm{cell}=1}^{\mathrm{n_cells}} P_\mathrm{cell,{loc-glob}}^T A_\mathrm{cell} u_\mathrm{cell} \\<br>&amp;= \sum_{\mathrm{cell}=1}^{\mathrm{n_cells}} P_\mathrm{cell,{loc-glob}}^T v_\mathrm{cell}<br>\end{split}<br>$$<br>编程思路是这样的：先建立单元矩阵，即$A_{cell}$，然后用局部自由度和全局自由度之间的映射将真实空间中的u转换成单元上的量$u_{cell}$。再用vmult函数实现单元矩阵与单元向量的乘法，即：<br>$$<br>A_{cell}u_{cell}=v_{cell}<br>$$，得到目标向量后，再用局部到全局的映射将该向量转换到真实空间中。</p>
<p>这个思路很正确，但是很慢。对于每个单元，都要用三个嵌套循环来构建单元矩阵，然后再用两个嵌套循环作乘法。一个改进的方法是意识到单元矩阵可在概念上视为三个矩阵的乘积：<br>$$<br>A_\mathrm{cell} = B_\mathrm{cell}^T D_\mathrm{cell} B_\mathrm{cell}<br>$$<br>这个形式跟力学中的单元刚度矩阵就是完全相同的了，矩阵B是形函数梯度矩阵，D是弹性矩阵。<br>当这个矩阵跟一个向量相乘时：<br>$$<br>A_\mathrm{cell}\cdot u_\mathrm{cell} = B_\mathrm{cell}^T D_\mathrm{cell} B_\mathrm{cell}\cdot u_\mathrm{cell}<br>$$<br>这样，就是从右往左做三次矩阵-向量乘法。这避免了在构建单元矩阵时的三次嵌套循环。<br>上述代码中一个瓶颈在于对每个单元都做FEValues::reinit，这个操作所用的时间可能跟其他所有操作加起来相同(至少对非规则网格是这样的，规则网格上的梯度通常不变)。这明显不理想，所以最好是优化一下。reinit所做的工作是：通过雅各比矩阵将参考单元上的梯度进行变换，从而计算真实空间上的梯度。这在每个单元上的每个积分点上对每个形函数都要操作。通常雅各比矩阵不依赖于形函数，但它在不同的积分点上不同。在之前的算例中，矩阵只构建一次，那么就没有必要对这个reinit函数做什么，因此在计算局部矩阵元素时必须得做这个雅各比变换。<br>然而，在应用无矩阵运算时，我们对只使用矩阵一次没有兴趣，而是想要对矩阵多次使用。所以，就想能不能缓存什么东西用于加速计算，但也不能缓存太多数据，否则就会陷入之前获取内存中数据缓慢的瓶颈。<br>这里用的方法就是识别出那个雅各比变换，然后仅在一个参考单元上应用一次。<br>即：<br>$$<br>v_\mathrm{cell} = B_\mathrm{ref_cell}^T J_\mathrm{cell}^T D J_\mathrm{cell} B_\mathrm{ref_cell} u_\mathrm{cell}, \quad v = \sum_{\mathrm{cell}=1}^{\mathrm{n_cells}} P_\mathrm{cell,{loc-glob}}^T v_\mathrm{cell}.<br>$$</p>
<p>使用一个无矩阵、基于单元的有限元算子，需要使用跟之前代码不同的设计思路，deal.II中存储这种数据结构的类是MatrixFree类，然后FEEvaluation类来具体使用它。</p>
<h2 id="无矩阵对象的使用"><a href="#无矩阵对象的使用" class="headerlink" title="无矩阵对象的使用"></a>无矩阵对象的使用</h2><p>本例中，除了问题类的定义，还有一个类，LaplaceOperator，用来表示差分算子。为了通用性，将它设计成一个矩阵，即你可以获得它的大小，也可以将它用在一个向量上。跟真实的矩阵不同点在于：它不存储矩阵的元素，仅仅知道当它用于一个向量时应该怎么做。在这个类中用来存储数据的类是MatrixFree，它包含了局部自由度与整体自由度之间的映射关系，即雅各比矩阵，也能在并行计算时遍历所有单元，它能保证只对不共享自由度的单元进行操作，这就保证了线程安全性，它比之前提到的WorkStream类更加先进。<br>然后就是这个类中对MatrixFree类型数据的使用，包括以下功能：返回数据的维度、多种形式的矩阵-向量乘法、初始化数据等。这个类需要三个参数：维度(所以能处理不同维度的问题)、有限元的度(这是为了后续FEEvaluation的快速计算)、潜在的标量类型(我们想要对于最终矩阵使用double类型，而对于多重网格上的矩阵使用float类型)。<br>这个类的数据成员包括：真正使用的MatrixFree对象、在所有积分点上计算的变系数(这样在矩阵-向量乘法中就不用重复计算)、存储矩阵对角元素的容器(用于多重网格平滑)。</p>
<p>初始化数据时，最重要的是创建了MatrixFree的对象实例，同时计算了积分点上的系数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">additional_data.mapping_update_flags = (update_gradients | update_JxW_values |</span><br><span class="line">update_quadrature_points);</span><br><span class="line">data.<span class="built_in">reinit</span> (dof_handler, constraints, QGauss&lt;<span class="number">1</span>&gt;(fe_degree+<span class="number">1</span>),</span><br><span class="line">additional_data);</span><br><span class="line"><span class="built_in">evaluate_coefficient</span>(Coefficient&lt;dim&gt;());</span><br></pre></td></tr></table></figure>
<p>注意，上面在MatrixFree的AdditionalData中需要设定要更新的flag。</p>
<p>然后就是这个类的主要功能所在：计算矩阵-向量乘积。注意：该类中的单元范围通常不等于triangulation的单元数。事实上，这里的“单元”可能是个错误的概念，因为它实际上是多个单元上的积分点的集合，MatrixFree对象将多个单元的积分点分组，变成一个块，形成一个新的向量化高度。这些“单元”的个数可以通过MatrixFree类的MatrixFree::n_macro_cells()获得。与之前的单元迭代器相比，MatrixFree类的所有单元都在同一层级的数组中，这样就可以直接通过整数指标来索引它们。<br>LaplaceOperator算子的使用步骤如下：<br>先创建一个FEEvaluation对象，用来进行后续对MatrixFree对象的计算。这个对象接收五个参数，分别是：维度、有限单元的degree、每个方向上积分点的个数(默认是fe.degree+1)、分量的个数(可以是向量，但这里是标量)、数据类型(因为想对多重网格预条件子只设置float类型)。然后就对给定的“单元”范围进行循环，在每个“macro cell”上具体所做的事情如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">phi.<span class="built_in">reinit</span> (cell);</span><br><span class="line">phi.<span class="built_in">read_dof_values</span>(src);</span><br><span class="line">phi.<span class="built_in">evaluate</span> (<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> q=<span class="number">0</span>; q&lt;phi.n_q_points; ++q)</span><br><span class="line">phi.<span class="built_in">submit_gradient</span> (<span class="built_in">coefficient</span>(cell,q) *</span><br><span class="line">phi.<span class="built_in">get_gradient</span>(q), q);</span><br><span class="line">phi.<span class="built_in">integrate</span> (<span class="literal">false</span>,<span class="literal">true</span>);</span><br><span class="line">phi.<span class="built_in">distribute_local_to_global</span> (dst);</span><br></pre></td></tr></table></figure>
<p>(1)告诉那个FEEvaluation对象它要作用的单元,<br>(2)读入源向量的值，即上面分析中的$u_{cell}$,<br>(3)计算参考单元的梯度。因为FEEvaluation既能计算函数值，也能计算梯度，所以它提供了一个统一的界面来计算从0阶到2阶的梯度(0阶梯度即值本身)。因为这里只需计算梯度，所以就在第二个参数位置设置为true，在第一个和第三个参数位置设置为false。这一步的复杂度比传统的用FEValues来计算的复杂度要降低很多。<br>(4)然后就是雅各比矩阵变换、与变系数和积分权重的相乘。FEEvaluation有个函数getGradient能应用雅各比变换，同时获得真实空间中的梯度，那么就用它乘以变系数。再用submitGradient施加第二个雅各比矩阵和积分权重。注意：这里不要对积分点重复，否则会造成在此积分点上多次运算。<br>(5)然后就是积分。使用函数integrate，它的两个参数分别是说明是否对值、梯度进行积分。因为这里仅需对梯度积分，所以将第一个设置为false，第二个设置为true。<br>(6)最后就是将单元贡献叠加到整体上去。</p>
<h1 id="程序解析"><a href="#程序解析" class="headerlink" title="程序解析"></a>程序解析</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>头文件需要增加两个：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/matrix_free/matrix_free.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/matrix_free/fe_evaluation.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="驱动程序"><a href="#驱动程序" class="headerlink" title="驱动程序"></a>驱动程序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Step37;</span><br><span class="line">LaplaceProblem&lt;dimension&gt; laplace_problem;</span><br><span class="line">laplace_problem.<span class="built_in">run</span> ();</span><br></pre></td></tr></table></figure>
<p>创建问题类，注意这个类中不再使用稀疏矩阵，而是使用无矩阵方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> LaplaceOperator&lt;dim,degree_finite_element,<span class="keyword">double</span>&gt; SystemMatrixType;</span><br><span class="line"><span class="keyword">typedef</span> LaplaceOperator&lt;dim,degree_finite_element,<span class="keyword">float</span>&gt; LevelMatrixType;</span><br><span class="line">SystemMatrixType system_matrix;</span><br><span class="line">MGLevelObject&lt;LevelMatrixType&gt; mg_matrices;</span><br></pre></td></tr></table></figure>
<p>其中无矩阵对象是LaplaceOperator类中的一个数据成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MatrixFree&lt;dim,number&gt; data;</span><br></pre></td></tr></table></figure>
<p>问题类中还提供一个用于输出每段程序进行多长时间的输出流：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConditionalOStream time_details;</span><br></pre></td></tr></table></figure>
<p>在程序中其默认是关闭的，需要在构造函数初始化时更改一下让其起作用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">LaplaceProblem&lt;dim&gt;::<span class="built_in">LaplaceProblem</span> ()</span><br><span class="line">:</span><br><span class="line"><span class="built_in">fe</span> (degree_finite_element),</span><br><span class="line"><span class="built_in">dof_handler</span> (triangulation),</span><br><span class="line"><span class="built_in">time_details</span> (std::cout, <span class="literal">true</span>)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>然后执行run函数。</p>
<h2 id="运行函数"><a href="#运行函数" class="headerlink" title="运行函数"></a>运行函数</h2><p>run函数控制程序运行的整个流程，包括创建并加密网格、创建系统、组装系统、组装多重网格、求解、输出结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cycle == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">GridGenerator::<span class="built_in">hyper_cube</span> (triangulation, <span class="number">0.</span>, <span class="number">1.</span>);</span><br><span class="line">triangulation.<span class="built_in">refine_global</span> (<span class="number">3</span>-dim);</span><br><span class="line">&#125;</span><br><span class="line">triangulation.<span class="built_in">refine_global</span> (<span class="number">1</span>);</span><br><span class="line"><span class="built_in">setup_system</span> ();</span><br><span class="line"><span class="built_in">assemble_system</span> ();</span><br><span class="line"><span class="built_in">assemble_multigrid</span> ();</span><br><span class="line"><span class="built_in">solve</span> ();</span><br><span class="line"><span class="built_in">output_results</span> (cycle);</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<h2 id="创建系统"><a href="#创建系统" class="headerlink" title="创建系统"></a>创建系统</h2><p>注意是做一些初始化工作，初始化无矩阵对象、解向量、右端项等。<br>比如，初始化无矩阵对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system_matrix.<span class="built_in">reinit</span> (dof_handler, constraints);</span><br></pre></td></tr></table></figure>
<p>此处只有一句话，实际做的东西很多：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim, <span class="keyword">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">LaplaceOperator&lt;dim,fe_degree,number&gt;::<span class="built_in">reinit</span> (<span class="keyword">const</span> DoFHandler&lt;dim&gt; &amp;dof_handler,</span><br><span class="line"><span class="keyword">const</span> ConstraintMatrix &amp;constraints,</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> level)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typename</span> MatrixFree&lt;dim,number&gt;::AdditionalData additional_data;</span><br><span class="line">additional_data.tasks_parallel_scheme =</span><br><span class="line">MatrixFree&lt;dim,number&gt;::AdditionalData::partition_color;</span><br><span class="line">additional_data.level_mg_handler = level;</span><br><span class="line">additional_data.mapping_update_flags = (update_gradients | update_JxW_values |</span><br><span class="line">update_quadrature_points);</span><br><span class="line">data.<span class="built_in">reinit</span> (dof_handler, constraints, QGauss&lt;<span class="number">1</span>&gt;(fe_degree+<span class="number">1</span>),</span><br><span class="line">additional_data);</span><br><span class="line"><span class="built_in">evaluate_coefficient</span>(Coefficient&lt;dim&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上可以看出，主要做的就是对无矩阵对象的data初始化，同时最后一句话还将算子类中的系数进行了赋值，具体来说就是先用一个FEEvaluation对象将data中的信息提取出来，用其取得积分点位置，这样就能通过系数函数确定积分点上的系数值，然后赋值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim, <span class="keyword">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">LaplaceOperator&lt;dim,fe_degree,number&gt;::</span><br><span class="line"><span class="built_in">evaluate_coefficient</span> (<span class="keyword">const</span> Coefficient&lt;dim&gt; &amp;coefficient_function)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> n_cells = data.<span class="built_in">n_macro_cells</span>();</span><br><span class="line">FEEvaluation&lt;dim,fe_degree,fe_degree+1,1,number&gt; phi (data);</span><br><span class="line">coefficient.<span class="built_in">reinit</span> (n_cells, phi.n_q_points);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> cell=<span class="number">0</span>; cell&lt;n_cells; ++cell)</span><br><span class="line">&#123;</span><br><span class="line">phi.<span class="built_in">reinit</span> (cell);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> q=<span class="number">0</span>; q&lt;phi.n_q_points; ++q)</span><br><span class="line"><span class="built_in">coefficient</span>(cell,q) =</span><br><span class="line">coefficient_function.<span class="built_in">value</span>(phi.<span class="built_in">quadrature_point</span>(q));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组装系统"><a href="#组装系统" class="headerlink" title="组装系统"></a>组装系统</h2><p>这一步不需要组装矩阵，只需要组装右端项，做法跟传统的组装右端项相同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> LaplaceProblem&lt;dim&gt;::<span class="built_in">assemble_system</span> ()</span><br><span class="line">&#123;</span><br><span class="line">Timer time;</span><br><span class="line"><span class="function">QGauss&lt;dim&gt; <span class="title">quadrature_formula</span><span class="params">(fe.degree+<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">FEValues&lt;dim&gt; <span class="title">fe_values</span> <span class="params">(fe, quadrature_formula,</span></span></span><br><span class="line"><span class="function"><span class="params">update_values | update_JxW_values)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> dofs_per_cell = fe.dofs_per_cell;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> n_q_points = quadrature_formula.<span class="built_in">size</span>();</span><br><span class="line"><span class="function">std::vector&lt;types::global_dof_index&gt; <span class="title">local_dof_indices</span> <span class="params">(dofs_per_cell)</span></span>;</span><br><span class="line"><span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator cell = dof_handler.<span class="built_in">begin_active</span>(),</span><br><span class="line">endc = dof_handler.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">for</span> (; cell!=endc; ++cell)</span><br><span class="line">&#123;</span><br><span class="line">cell-&gt;<span class="built_in">get_dof_indices</span> (local_dof_indices);</span><br><span class="line">fe_values.<span class="built_in">reinit</span> (cell);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dofs_per_cell; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> rhs_val = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> q=<span class="number">0</span>; q&lt;n_q_points; ++q)</span><br><span class="line">rhs_val += (fe_values.<span class="built_in">shape_value</span>(i,q) * <span class="number">1.0</span> *</span><br><span class="line">fe_values.<span class="built_in">JxW</span>(q));</span><br><span class="line"><span class="built_in">system_rhs</span>(local_dof_indices[i]) += rhs_val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">constraints.<span class="built_in">condense</span>(system_rhs);</span><br><span class="line">setup_time += time.<span class="built_in">wall_time</span>();</span><br><span class="line">time_details &lt;&lt; <span class="string">&quot;Assemble right hand side (CPU/wall) &quot;</span></span><br><span class="line">&lt;&lt; <span class="built_in">time</span>() &lt;&lt; <span class="string">&quot;s/&quot;</span> &lt;&lt; time.<span class="built_in">wall_time</span>() &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组装多重网格"><a href="#组装多重网格" class="headerlink" title="组装多重网格"></a>组装多重网格</h2><h2 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h2><p>用共轭梯度法求解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cg.<span class="built_in">solve</span> (system_matrix, solution, system_rhs,</span><br><span class="line">preconditioner);</span><br></pre></td></tr></table></figure>
<p>可以看出，求解形式跟之前的有矩阵的形式是相同的，这个地方是个坑，看似相同，但奥秘隐藏在算子类的vmult函数中。实际，共轭梯度法在计算时会调用这个函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim, <span class="keyword">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">LaplaceOperator&lt;dim,fe_degree,number&gt;::<span class="built_in">vmult</span> (Vector&lt;<span class="keyword">double</span>&gt; &amp;dst,</span><br><span class="line"><span class="keyword">const</span> Vector&lt;<span class="keyword">double</span>&gt; &amp;src) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">dst = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vmult_add</span> (dst, src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim, <span class="keyword">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">LaplaceOperator&lt;dim,fe_degree,number&gt;::<span class="built_in">vmult_add</span> (Vector&lt;<span class="keyword">double</span>&gt; &amp;dst,</span><br><span class="line"><span class="keyword">const</span> Vector&lt;<span class="keyword">double</span>&gt; &amp;src) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">data.<span class="built_in">cell_loop</span> (&amp;LaplaceOperator::local_apply, <span class="keyword">this</span>, dst, src);</span><br><span class="line"><span class="keyword">const</span> std::vector&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; &amp;</span><br><span class="line">constrained_dofs = data.<span class="built_in">get_constrained_dofs</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;constrained_dofs.<span class="built_in">size</span>(); ++i)</span><br><span class="line"><span class="built_in">dst</span>(constrained_dofs[i]) += <span class="built_in">src</span>(constrained_dofs[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim, <span class="keyword">int</span> fe_degree, <span class="keyword">typename</span> number&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">LaplaceOperator&lt;dim,fe_degree,number&gt;::</span><br><span class="line"><span class="built_in">local_apply</span> (<span class="keyword">const</span> MatrixFree&lt;dim,number&gt; &amp;data,</span><br><span class="line">Vector&lt;<span class="keyword">double</span>&gt; &amp;dst,</span><br><span class="line"><span class="keyword">const</span> Vector&lt;<span class="keyword">double</span>&gt; &amp;src,</span><br><span class="line"><span class="keyword">const</span> std::pair&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>,<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; &amp;cell_range) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">FEEvaluation&lt;dim,fe_degree,fe_degree+1,1,number&gt; phi (data);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> cell=cell_range.first; cell&lt;cell_range.second; ++cell)</span><br><span class="line">&#123;</span><br><span class="line">phi.<span class="built_in">reinit</span> (cell);</span><br><span class="line">phi.<span class="built_in">read_dof_values</span>(src);</span><br><span class="line">phi.<span class="built_in">evaluate</span> (<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> q=<span class="number">0</span>; q&lt;phi.n_q_points; ++q)</span><br><span class="line">phi.<span class="built_in">submit_gradient</span> (<span class="built_in">coefficient</span>(cell,q) *</span><br><span class="line">phi.<span class="built_in">get_gradient</span>(q), q);</span><br><span class="line">phi.<span class="built_in">integrate</span> (<span class="literal">false</span>,<span class="literal">true</span>);</span><br><span class="line">phi.<span class="built_in">distribute_local_to_global</span> (dst);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，这个地方是个连环调用。</p>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>要深刻理解方程中各项在程序中是怎样实现的，这样才能扩展。<br>本例的求解过程实际是prisms-pf中椭圆型方程的求解思路，仔细领会之。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2016/12/20/prisms-pf-adaptivity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Be interesting!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亓欣波">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/20/prisms-pf-adaptivity/" class="post-title-link" itemprop="url">PRISMS-PF v1.0 学习手册——自适应网格</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-12-20 00:00:00" itemprop="dateCreated datePublished" datetime="2016-12-20T00:00:00+08:00">2016-12-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 15:20:30" itemprop="dateModified" datetime="2021-03-25T15:20:30+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computational-material-science/" itemprop="url" rel="index"><span itemprop="name">computational material science</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2016/12/20/prisms-pf-adaptivity/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/12/20/prisms-pf-adaptivity/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>自适应网格是一项很重要的减小计算量、提高计算效率的方法。</p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="求解步"><a href="#求解步" class="headerlink" title="求解步"></a>求解步</h2><p>在求解步时，传入时间步数来判断是否自适应：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">adaptiveRefine</span>(currentIncrement);</span><br></pre></td></tr></table></figure>
<p>如果时间步数满足要自适应的间隔，那么就开始自适应：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((currentIncrement&gt;<span class="number">0</span>) &amp;&amp; (currentIncrement%skipRemeshingSteps==<span class="number">0</span>))&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">refineMesh</span>(currentIncrement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个refineMesh函数会调用init函数参数是非0的情形：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">init</span>(_currentIncrement<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
<h2 id="初始化参数非零情形"><a href="#初始化参数非零情形" class="headerlink" title="初始化参数非零情形"></a>初始化参数非零情形</h2><p>初始化参数如果是0，那么做的就是整个问题的初始化工作，如果非零，那么就是自适应重建整个系统了。</p>
<h3 id="自适应网格"><a href="#自适应网格" class="headerlink" title="自适应网格"></a>自适应网格</h3><p>如果非零，首先之前的创建网格、边界标定、全局加密等工作都不做了，转而做：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">refineGrid</span>();</span><br></pre></td></tr></table></figure>
<p>此函数会调用adaptiveRefineCriterion来设置细化判据，将解向量暂存在残差向量中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*residualSet[fieldIndex])=(*solutionSet[fieldIndex]);</span><br></pre></td></tr></table></figure>
<p>然后接着执行细化操作。</p>
<h3 id="重建系统"><a href="#重建系统" class="headerlink" title="重建系统"></a>重建系统</h3><p>这一步在初始化时要做，自适应网格后也要做，但两者也有不同。主要工作就是构建有限单元、分配自由度、施加悬点限制等。</p>
<h3 id="重建无矩阵对象"><a href="#重建无矩阵对象" class="headerlink" title="重建无矩阵对象"></a>重建无矩阵对象</h3><p>与初始化时相同。</p>
<h3 id="重建解向量"><a href="#重建解向量" class="headerlink" title="重建解向量"></a>重建解向量</h3><p>此处要需要先把解向量清零，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">U=solutionSet.<span class="built_in">at</span>(fieldIndex); </span><br><span class="line">oldU=oldSolutionSet.<span class="built_in">at</span>(fieldIndex); </span><br><span class="line">matrixFreeObject.<span class="built_in">initialize_dof_vector</span>(*U,  fieldIndex); *U=<span class="number">0</span>;</span><br><span class="line">matrixFreeObject.<span class="built_in">initialize_dof_vector</span>(*oldU,  fieldIndex); *oldU=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>注意，不能将中间变量清零，否则后面内插的时候就是零向量，即将它们定义在参数为0的地方，而不是参数非零的地方：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (iter==<span class="number">0</span>)&#123;</span><br><span class="line">  R=<span class="keyword">new</span> vectorType;</span><br><span class="line">  tempU=<span class="keyword">new</span> vectorType;</span><br><span class="line">  residualSet.<span class="built_in">push_back</span>(R); </span><br><span class="line">  tempSolutionSet.<span class="built_in">push_back</span>(tempU);</span><br><span class="line">  matrixFreeObject.<span class="built_in">initialize_dof_vector</span>(*R,  fieldIndex); *R=<span class="number">0</span>;</span><br><span class="line">  matrixFreeObject.<span class="built_in">initialize_dof_vector</span>(*tempU,  fieldIndex); *tempU=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是将中间变量的值传递回原变量中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> fieldIndex=<span class="number">0</span>; fieldIndex&lt;fields.<span class="built_in">size</span>(); fieldIndex++)&#123;</span><br><span class="line">  <span class="comment">//interpolate and clear used solution transfer sets</span></span><br><span class="line">  soltransSet[fieldIndex]-&gt;<span class="built_in">interpolate</span>(*solutionSet[fieldIndex]);</span><br><span class="line">  oldSoltransSet[fieldIndex]-&gt;<span class="built_in">interpolate</span>(*oldSolutionSet[fieldIndex]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> soltransSet[fieldIndex];</span><br><span class="line">  <span class="keyword">delete</span> oldSoltransSet[fieldIndex];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//reset residual vector</span></span><br><span class="line">  vectorType *R=residualSet.<span class="built_in">at</span>(fieldIndex);</span><br><span class="line">  matrixFreeObject.<span class="built_in">initialize_dof_vector</span>(*R, fieldIndex); *R=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  vectorType *tempU=tempSolutionSet.<span class="built_in">at</span>(fieldIndex);</span><br><span class="line">  matrixFreeObject.<span class="built_in">initialize_dof_vector</span>(*tempU, fieldIndex); *tempU=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重建向量传递函数"><a href="#重建向量传递函数" class="headerlink" title="重建向量传递函数"></a>重建向量传递函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">soltransSet.<span class="built_in">clear</span>();</span><br><span class="line">oldSoltransSet.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> fieldIndex=<span class="number">0</span>; fieldIndex&lt;fields.<span class="built_in">size</span>(); fieldIndex++)&#123;</span><br><span class="line">  soltransSet.<span class="built_in">push_back</span>(<span class="keyword">new</span> parallel::distributed::SolutionTransfer&lt;dim, vectorType&gt;(*dofHandlersSet_nonconst[fieldIndex]));</span><br><span class="line">  oldSoltransSet.<span class="built_in">push_back</span>(<span class="keyword">new</span> parallel::distributed::SolutionTransfer&lt;dim, vectorType&gt;(*dofHandlersSet_nonconst[fieldIndex]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Ghost解向量"><a href="#Ghost解向量" class="headerlink" title="Ghost解向量"></a>Ghost解向量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ghost the vectors. Also apply the Dirichet BC&#x27;s (if any) on the solution vectors </span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> fieldIndex=<span class="number">0</span>; fieldIndex&lt;fields.<span class="built_in">size</span>(); fieldIndex++)&#123;</span><br><span class="line">     constraintsDirichletSet[fieldIndex]-&gt;<span class="built_in">distribute</span>(*solutionSet[fieldIndex]);</span><br><span class="line">     solutionSet[fieldIndex]-&gt;<span class="built_in">update_ghost_values</span>();</span><br><span class="line"></span><br><span class="line">     constraintsDirichletSet[fieldIndex]-&gt;<span class="built_in">distribute</span>(*oldSolutionSet[fieldIndex]);</span><br><span class="line">     oldSolutionSet[fieldIndex]-&gt;<span class="built_in">update_ghost_values</span>();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="第一步即加密"><a href="#第一步即加密" class="headerlink" title="第一步即加密"></a>第一步即加密</h2><p>这一步稍微修改下自适应过程，让其全局加密后，第一步就加密：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> MatrixFreePDE&lt;dim&gt;::<span class="built_in">refineMesh</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> _currentIncrement)&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> hAdaptivity==true </span></span><br><span class="line">  <span class="built_in">init</span>(_currentIncrement);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即参数不再减1，同时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> generalizedProblem&lt;dim&gt;::<span class="built_in">adaptiveRefine</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> currentIncrement)&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> hAdaptivity == true</span></span><br><span class="line">  <span class="keyword">if</span> (currentIncrement == <span class="number">1</span> || ((currentIncrement&gt;<span class="number">0</span>) &amp;&amp; (currentIncrement%skipRemeshingSteps==<span class="number">0</span>)))&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">refineMesh</span>(currentIncrement);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将判断条件也改一下。</p>
<h1 id="计算结果"><a href="#计算结果" class="headerlink" title="计算结果"></a>计算结果</h1><p><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvji2w5oh7g30hs0f2e81.gif"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2016/12/16/prisms-pf-dendrite/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Be interesting!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亓欣波">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/16/prisms-pf-dendrite/" class="post-title-link" itemprop="url">使用PRISMS-PF模拟二维和三维枝晶生长</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-12-16 00:00:00" itemprop="dateCreated datePublished" datetime="2016-12-16T00:00:00+08:00">2016-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 15:20:30" itemprop="dateModified" datetime="2021-03-25T15:20:30+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computational-material-science/" itemprop="url" rel="index"><span itemprop="name">computational material science</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2016/12/16/prisms-pf-dendrite/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/12/16/prisms-pf-dendrite/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>本例将使用PRISMS-PF模拟凝固过程中的枝晶生长。因为原先的PRISMS-PF架构中在构建右端项时只有接收一步解，而枝晶的浓度场控制方程与相场参量的变化率相关，即需要用到相场的前后两步解，所以需要扩展PRISMS-PF的原先架构，本例也主要是说明怎样对原程序进行扩展。</p>
<h1 id="获得源码"><a href="#获得源码" class="headerlink" title="获得源码"></a>获得源码</h1><p>源码在<a target="_blank" rel="noopener" href="https://github.com/qixinbo/phaseField/tree/next/applications/dendriticGrowth">这里</a></p>
<h1 id="扩展过程"><a href="#扩展过程" class="headerlink" title="扩展过程"></a>扩展过程</h1><h2 id="定义要使用解的个数"><a href="#定义要使用解的个数" class="headerlink" title="定义要使用解的个数"></a>定义要使用解的个数</h2><p>在parameter.h中新增宏定义numSolution，其决定方程中用到几步解，比如在枝晶生长的模拟中用到两步解，其就等于2，之前的所有模拟中都等于1。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> numSolution 2</span></span><br></pre></td></tr></table></figure>
<p>这里涉及头文件的包含顺序，放在后面定义的话，会不认识。</p>
<h2 id="新增前一步解和临界解的存储对象"><a href="#新增前一步解和临界解的存储对象" class="headerlink" title="新增前一步解和临界解的存储对象"></a>新增前一步解和临界解的存储对象</h2><p>仿照solutionSet的定义，在相同位置(具体就是MatrixFreePDE类声明)增加oldSolutionSet和tempSolutionSet，同时初始化空间，并且根据初始条件初始化值。<br>注意这个地方初始化时不要跟当前解使用同一个地址，否则它们自动跟着当前解变化，应该另外开辟内存地址：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vectorType *U,*oldU, *tempU, *R;</span><br><span class="line"><span class="keyword">if</span> (iter==<span class="number">0</span>)&#123;</span><br><span class="line">  U=<span class="keyword">new</span> vectorType; R=<span class="keyword">new</span> vectorType;</span><br><span class="line">  oldU=<span class="keyword">new</span> vectorType; tempU = <span class="keyword">new</span> vectorType;</span><br><span class="line">  solutionSet.<span class="built_in">push_back</span>(U); residualSet.<span class="built_in">push_back</span>(R); </span><br><span class="line">  oldSolutionSet.<span class="built_in">push_back</span>(oldU);</span><br><span class="line">  tempSolutionSet.<span class="built_in">push_back</span>(tempU);</span><br><span class="line">  matrixFreeObject.<span class="built_in">initialize_dof_vector</span>(*R,  fieldIndex); *R=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  U=solutionSet.<span class="built_in">at</span>(fieldIndex); </span><br><span class="line">  oldU=oldSolutionSet.<span class="built_in">at</span>(fieldIndex); </span><br><span class="line">  tempU=tempSolutionSet.<span class="built_in">at</span>(fieldIndex); </span><br><span class="line">&#125;</span><br><span class="line">matrixFreeObject.<span class="built_in">initialize_dof_vector</span>(*U,  fieldIndex); *U=<span class="number">0</span>;</span><br><span class="line">matrixFreeObject.<span class="built_in">initialize_dof_vector</span>(*oldU,  fieldIndex); *oldU=<span class="number">0</span>;</span><br><span class="line">matrixFreeObject.<span class="built_in">initialize_dof_vector</span>(*tempU,  fieldIndex); *tempU=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="更新解"><a href="#更新解" class="headerlink" title="更新解"></a>更新解</h2><p>每次计算开始前，将solutionSet暂存在tempSolutionSet中，计算完毕后，使用tempSolutionSet对oldSolutionSet赋值(可以在基类中增加这么一个更新解的成员函数)。<br>注意，用当前步的解给上步解赋值时，不能直接使用等号，像这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oldSolutionSet = solutionSet;</span><br></pre></td></tr></table></figure>
<p>这样会将当前解的地址直接赋给上步解，导致两个解完全同步。<br>需要只是传递值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> fieldIndex=<span class="number">0</span>; fieldIndex&lt;fields.<span class="built_in">size</span>(); fieldIndex++)&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> dof=<span class="number">0</span>; dof&lt;solutionSet[fieldIndex]-&gt;<span class="built_in">local_size</span>(); ++dof)&#123;</span><br><span class="line">oldSolutionSet[fieldIndex]-&gt;<span class="built_in">local_element</span>(dof) = solutionSet[fieldIndex]-&gt;<span class="built_in">local_element</span>(dof);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="将计算右端项的输入改为盛放两步解的容器并赋值"><a href="#将计算右端项的输入改为盛放两步解的容器并赋值" class="headerlink" title="将计算右端项的输入改为盛放两步解的容器并赋值"></a>将计算右端项的输入改为盛放两步解的容器并赋值</h2><p>(1)将computeRHS和getRHS以及residualRHS的输入参数src改为容器，注意需要在多个地方修改：matrixFreePDE原型修改、coupled的函数定义实现、coupled_function中函数实现修改<br>(2)需要在计算右端项之前，对src容器赋值：通过numSolution判断读入多少个解<br>这个将原来盛放一步解的变量改成盛放此变量的容器，涉及多个函数及多个地方的修改，一定要仔细。<br>在getRHS中添加能读取上一步解的功能时，注意学习step48。两者对应关系就是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scalar_vars  VS   current</span><br><span class="line">old_scalar_vars  VS  old</span><br></pre></td></tr></table></figure>
<p>在residualRHS中将输入变成容器时，注意将容器中的元素设置为存储指针，这样就直接指向原来的两个解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::vector&lt;modelVariable&lt;dim&gt;&gt;*&gt; modelVarListList;</span><br><span class="line">modelVarListList.<span class="built_in">push_back</span>(&amp;modelVarList);</span><br><span class="line"><span class="keyword">if</span>(numSolution == <span class="number">2</span>)</span><br><span class="line">  modelVarListList.<span class="built_in">push_back</span>(&amp;oldModelVarList);</span><br></pre></td></tr></table></figure>
<h1 id="计算结果"><a href="#计算结果" class="headerlink" title="计算结果"></a>计算结果</h1><p>二维结果：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvji141btng30hs0f2dra.gif"><br>三维结果<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvji1ln258g30hs0f2n4t.gif"></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>(1)书写方程各项时一定注意，将其弱形式仔细写下来，尤其是分部积分时对拉普拉斯算子分解时的符号变化。<br>(2)学会使用天山折梅手，化简为繁；学会使用奥卡姆剃刀，化繁为简。<br>(3)时间步长和网格间距会导致收敛性<br>(4)求解精度也会影响枝晶形貌<br>(5)有限单元的插值方式会直接决定hessian矩阵的计算</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2016/12/16/prisms-pf-v1-CHAC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Be interesting!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亓欣波">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/16/prisms-pf-v1-CHAC/" class="post-title-link" itemprop="url">PRISMS-PF v1.0 学习手册——Cahn-Hilliard和Allen-Cahn方程耦合求解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-12-16 00:00:00" itemprop="dateCreated datePublished" datetime="2016-12-16T00:00:00+08:00">2016-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 15:20:30" itemprop="dateModified" datetime="2021-03-25T15:20:30+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computational-material-science/" itemprop="url" rel="index"><span itemprop="name">computational material science</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2016/12/16/prisms-pf-v1-CHAC/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/12/16/prisms-pf-v1-CHAC/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>PRISMS-PF的1.0版本相对于最开始的0.8版本，进行了较大的重构，更加模块化，更加容易扩展。同时引入了更加多的功能，比如施加各种边界条件，引入自适应网格等。但带来的一个问题是：文件数量增多，且互相调用，刚开始很容易在文件跳转之间绕晕，所以需要理清整个文件结构和程序运行脉络。</p>
<h1 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h1><h2 id="基础头文件"><a href="#基础头文件" class="headerlink" title="基础头文件"></a>基础头文件</h2><p>首先是deal.II的各种头文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include/dealIIheaders.h</span><br></pre></td></tr></table></figure>
<p>PDE的无矩阵解法的模板类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include/matrixFreePDE.h</span><br></pre></td></tr></table></figure>
<p>包含各种属性的物理场的模板类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include/fields.h</span><br></pre></td></tr></table></figure>
<p>模型中用到的变量的模板类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include/model_variables.h</span><br></pre></td></tr></table></figure>
<p>默认的模拟参数设置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include/defaultValues.h</span><br></pre></td></tr></table></figure>
<h2 id="无矩阵解的模板类的实现头文件"><a href="#无矩阵解的模板类的实现头文件" class="headerlink" title="无矩阵解的模板类的实现头文件"></a>无矩阵解的模板类的实现头文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">src/matrixfree/matrixFreePDE.cc<span class="string">&quot;</span></span><br><span class="line"><span class="string">src/matrixfree/init.cc&quot;</span></span><br><span class="line">src/matrixfree/initForTests.cc<span class="string">&quot;</span></span><br><span class="line"><span class="string">src/matrixfree/refine.cc&quot;</span></span><br><span class="line">src/matrixfree/invM.cc<span class="string">&quot;</span></span><br><span class="line"><span class="string">src/matrixfree/computeLHS.cc&quot;</span></span><br><span class="line">src/matrixfree/computeRHS.cc<span class="string">&quot;</span></span><br><span class="line"><span class="string">src/matrixfree/modifyFields.cc&quot;</span></span><br><span class="line">src/matrixfree/solve.cc<span class="string">&quot;</span></span><br><span class="line"><span class="string">src/matrixfree/solveIncrement.cc&quot;</span></span><br><span class="line">src/matrixfree/outputResults.cc<span class="string">&quot;</span></span><br><span class="line"><span class="string">src/matrixfree/markBoundaries.cc&quot;</span></span><br><span class="line">src/matrixfree/boundaryConditions.cc<span class="string">&quot;</span></span><br><span class="line"><span class="string">src/matrixfree/initialConditions.cc&quot;</span></span><br><span class="line">src/matrixfree/utilities.cc<span class="string">&quot;</span></span><br><span class="line"><span class="string">src/matrixfree/calcFreeEnergy.cc&quot;</span></span><br><span class="line">src/matrixfree/integrate_and_shift_field.cc<span class="string">&quot;</span></span><br><span class="line"><span class="string">src/matrixfree/getOutputTimeSteps.cc&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="求解模型"><a href="#求解模型" class="headerlink" title="求解模型"></a>求解模型</h2><p>不同的问题对应不同的模型。目前提供三种模型供选择：<br>(1)扩散模型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">src/models/diffusion/AC.h</span><br><span class="line">src/models/diffusion/CH.h</span><br><span class="line">src/models/diffusion/coupledCHAC.h</span><br><span class="line">src/models/diffusion/coupledCHAC2.h</span><br><span class="line">src/models/diffusion/Fickian.h</span><br></pre></td></tr></table></figure>
<p>(2)连续力学模型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src/models/mechanics/anisotropy.h</span><br><span class="line">src/models/mechanics/computeStress.h</span><br><span class="line">src/models/mechanics/mechanics.h</span><br></pre></td></tr></table></figure>
<p>(3)两者耦合模型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">src/models/coupled/coupledCHMechanics.h</span><br><span class="line">src/models/coupled/coupledCHACMechanics.h</span><br><span class="line">src/models/coupled/generalized_model.h</span><br><span class="line">src/models/coupled/generalized_model_functions.h</span><br></pre></td></tr></table></figure>
<h2 id="具体问题"><a href="#具体问题" class="headerlink" title="具体问题"></a>具体问题</h2><p>每个具体问题都包含四个文件，分别设定自己所需的：<br>(1)模拟参数，包括计算域大小、网格大小、时间步、输出间距等</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parameters.h</span><br></pre></td></tr></table></figure>
<p>(2)控制方程，这个是需要重要修改的文件，里面包含方程构建过程以及右端项的计算过程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">equations.h</span><br></pre></td></tr></table></figure>
<p>其中包含一系列变量，用“列表+宏定义”的形式方便将这些变量赋值给之前的通用模型中的一系列容器。<br>(3)初始条件和边界条件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ICs_and_BCs.h</span><br></pre></td></tr></table></figure>
<p>(4)入口函数，这个文件非常简单，但其是整个程序的总调度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.cc</span><br></pre></td></tr></table></figure>
<h1 id="求解流程"><a href="#求解流程" class="headerlink" title="求解流程"></a>求解流程</h1><p>分析源码时一定注意各个类之间及类的成员函数之间传递的参数的类型及结构。</p>
<p>具体求解问题时的步骤：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">generalizedProblem&lt;problemDIM&gt; problem;</span><br><span class="line"></span><br><span class="line">problem.<span class="built_in">setBCs</span>();</span><br><span class="line">problem.<span class="built_in">buildFields</span>();</span><br><span class="line">problem.<span class="built_in">init</span>(); </span><br><span class="line">problem.<span class="built_in">solve</span>();</span><br></pre></td></tr></table></figure>
<h2 id="构造函数初始化"><a href="#构造函数初始化" class="headerlink" title="构造函数初始化"></a>构造函数初始化</h2><p>在创建问题类的具体对象时，会调用其构造函数，此时就把手动提供的输入文件中的变量(其用宏定义)传递给类的数据成员上，包括变量名、变量类型、变量所在的控制方程的类型、是否计算值及其梯度和二阶导数的旗标等。<br>比如，在输入条件中设置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> variable_name &#123;<span class="meta-string">&quot;c&quot;</span>, <span class="meta-string">&quot;n&quot;</span>,<span class="meta-string">&quot;biharm&quot;</span>&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> variable_type &#123;<span class="meta-string">&quot;SCALAR&quot;</span>,<span class="meta-string">&quot;SCALAR&quot;</span>,<span class="meta-string">&quot;SCALAR&quot;</span>&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> variable_eq_type &#123;<span class="meta-string">&quot;PARABOLIC&quot;</span>,<span class="meta-string">&quot;PARABOLIC&quot;</span>,<span class="meta-string">&quot;PARABOLIC&quot;</span>&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> need_val &#123;true, true, false&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> need_grad &#123;true, true, true&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> need_hess &#123;false, false, false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> need_val_residual &#123;true, true, false&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> need_grad_residual &#123;true, true, true&#125;</span></span><br></pre></td></tr></table></figure>
<p>那么，在初始化时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var_name = variable_name;</span><br><span class="line">var_type = variable_type;</span><br><span class="line">var_eq_type = variable_eq_type;</span><br><span class="line"></span><br><span class="line">need_value = need_val;</span><br><span class="line">need_gradient = need_grad;</span><br><span class="line">need_hessian = need_hess;</span><br><span class="line">value_residual = need_val_residual;</span><br><span class="line">gradient_residual = need_grad_residual;</span><br></pre></td></tr></table></figure>
<h2 id="设定边界条件"><a href="#设定边界条件" class="headerlink" title="设定边界条件"></a>设定边界条件</h2><p>如上，设定边界条件的函数是setBCs，它需要在ICs_and_BCs.h中手工编写，调用的是另一个成员函数inputBCs，它根据参数不同有多个重载，可以统一设定边界(参数为4个)，也可以分开设定(参数为2+(2+2)*dim)。这一步的目的就是对BC_list赋值，它是一个容器，里面的元素是varBCs的类，每个varBC包含边界条件的类型和边界条件的值。</p>
<h2 id="构建场变量"><a href="#构建场变量" class="headerlink" title="构建场变量"></a>构建场变量</h2><p>判断之前读入的各种变量和方程类型，构建出要求解的场变量的类型，这个场就是在基础头文件中定义的场，其需要三个模板参数：变量类型、方程类型、变量名。这里将方程类型分成了两类：抛物型方程和椭圆型方程，前者用于求解与时间有关的方程，即瞬态方程，后者用于求解与时间无关的方程，即稳态方程。<br>这里就引出来一个非常重要的变量：fields。每个MatrixFreePDE都有一个数据成员fields，它是一个容器，里面盛放的是Field类对象，该类模板在前面提到的基础头文件fields.h中定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Field</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Field</span>(fieldType _type, PDEType _pdetype, std::string _name);</span><br><span class="line">  fieldType type;</span><br><span class="line">  PDEType   pdetype;</span><br><span class="line">  std::string name;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> index;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> startIndex;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> numComponents;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> fieldCount;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> indexCount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为场分为标量场和矢量场，所以fields里面的场变量索引及每个场分量个数都要依情况而定：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (type)&#123;</span><br><span class="line"><span class="keyword">case</span> SCALAR:&#123;</span><br><span class="line">  <span class="comment">//increment index count by one</span></span><br><span class="line">  indexCount+=<span class="number">1</span>;</span><br><span class="line">  numComponents=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> VECTOR:&#123;</span><br><span class="line">  <span class="comment">//increment index count by dim</span></span><br><span class="line">  indexCount+=dim;</span><br><span class="line">  numComponents=dim;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>调用MatrixFreePDE类的init函数，做以下事情(注意：这里默认接收的参数是0，意味着都是进行初始化工作，如果非0，则可以读取已计算的所有值，比如用于断点续算等，未详细考察)：<br>(1)初始化网格<br>根据输入文件，确定计算域大小、初始网格大小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GridGenerator::<span class="built_in">subdivided_hyper_rectangle</span> (triangulation, subdivisions, Point&lt;dim&gt;(), Point&lt;dim&gt;(spanX,spanY,spanZ));</span><br></pre></td></tr></table></figure>
<p>(2)设置边界标识<br>这里根据面的中心必须是计算域顶点才设置边界标识，这里自然全是0。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> face_number=<span class="number">0</span>; face_number&lt;GeometryInfo&lt;dim&gt;::faces_per_cell;++face_number)&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dim; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> ( std::<span class="built_in">fabs</span>(cell-&gt;<span class="built_in">face</span>(face_number)-&gt;<span class="built_in">center</span>()(i) - (<span class="number">0</span>)) &lt; <span class="number">1e-12</span> )&#123;</span><br><span class="line">      cell-&gt;<span class="built_in">face</span>(face_number)-&gt;<span class="built_in">set_boundary_id</span> (<span class="number">2</span>*i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (std::<span class="built_in">fabs</span>(cell-&gt;<span class="built_in">face</span>(face_number)-&gt;<span class="built_in">center</span>()(i) - (domain_size[i])) &lt; <span class="number">1e-12</span>)&#123;</span><br><span class="line">      cell-&gt;<span class="built_in">face</span>(face_number)-&gt;<span class="built_in">set_boundary_id</span> (<span class="number">2</span>*i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3-7)初始化无矩阵对象<br>这几步是对MatrixFreePDE的属性进行初始化，注意这几步操作都是在对每个场都操作，所以刚开始要对所有的场进行循环：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">typename</span> std::vector&lt;Field&lt;dim&gt; &gt;::iterator it = fields.<span class="built_in">begin</span>(); it != fields.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>(3)设定方程类型及索引<br>根据方程类型设定是否是时间相关的，索引数是多少：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">currentFieldIndex=it-&gt;index;</span><br><span class="line"></span><br><span class="line"><span class="comment">//check if any time dependent fields present</span></span><br><span class="line"><span class="keyword">if</span> (it-&gt;pdetype==PARABOLIC)&#123;</span><br><span class="line">isTimeDependentBVP=<span class="literal">true</span>;</span><br><span class="line">parabolicFieldIndex=it-&gt;index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (it-&gt;pdetype==ELLIPTIC)&#123;</span><br><span class="line">isEllipticBVP=<span class="literal">true</span>;</span><br><span class="line">ellipticFieldIndex=it-&gt;index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(4)创建有限单元<br>这里指定有限单元类型，即创建无矩阵对象的FESet属性，它是一个容器，里面的元素是FESystem，之所以用FESystem，也是为了能够处理矢量情形：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (it-&gt;type==SCALAR)&#123;</span><br><span class="line">fe=<span class="keyword">new</span> FESystem&lt;dim&gt;(FE_Q&lt;dim&gt;(QGaussLobatto&lt;<span class="number">1</span>&gt;(finiteElementDegree+<span class="number">1</span>)),<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (it-&gt;type==VECTOR)&#123;</span><br><span class="line">fe=<span class="keyword">new</span> FESystem&lt;dim&gt;(FE_Q&lt;dim&gt;(QGaussLobatto&lt;<span class="number">1</span>&gt;(finiteElementDegree+<span class="number">1</span>)),dim);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">pcout &lt;&lt; <span class="string">&quot;\nmatrixFreePDE.h: unknown field type\n&quot;</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">FESet.<span class="built_in">push_back</span>(fe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(5)分配自由度<br>上一步创建了有限单元，这一步就要对它们分配自由度，当然先根据网格创建自由度管理器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DoFHandler&lt;dim&gt;* dof_handler;</span><br><span class="line"><span class="keyword">if</span> (iter==<span class="number">0</span>)&#123;</span><br><span class="line">  dof_handler=<span class="keyword">new</span> DoFHandler&lt;dim&gt;(triangulation);</span><br><span class="line">  dofHandlersSet.<span class="built_in">push_back</span>(dof_handler);</span><br><span class="line">  dofHandlersSet_nonconst.<span class="built_in">push_back</span>(dof_handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  dof_handler=dofHandlersSet_nonconst.<span class="built_in">at</span>(it-&gt;index);</span><br><span class="line">&#125;</span><br><span class="line">dof_handler-&gt;<span class="built_in">distribute_dofs</span> (*fe);</span><br><span class="line">totalDOFs+=dof_handler-&gt;<span class="built_in">n_dofs</span>();</span><br></pre></td></tr></table></figure>
<p>(6)对零通量和周期性边界条件施加限制<br>(7)施加Dirichlet边界条件，并存储其对应的自由度标识<br>(8)初始化MatrixFree对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> MatrixFree&lt;dim,<span class="keyword">double</span>&gt;::AdditionalData additional_data;</span><br><span class="line">additional_data.mpi_communicator = MPI_COMM_WORLD;</span><br><span class="line">additional_data.tasks_parallel_scheme = MatrixFree&lt;dim,<span class="keyword">double</span>&gt;::AdditionalData::partition_partition;</span><br><span class="line">additional_data.mapping_update_flags = (update_values | update_gradients | update_JxW_values | update_quadrature_points);</span><br><span class="line"><span class="function">QGaussLobatto&lt;1&gt; <span class="title">quadrature</span> <span class="params">(finiteElementDegree+<span class="number">1</span>)</span></span>;</span><br><span class="line">num_quadrature_points=std::<span class="built_in">pow</span>(quadrature.<span class="built_in">size</span>(),dim);</span><br><span class="line">matrixFreeObject.<span class="built_in">clear</span>();</span><br><span class="line">matrixFreeObject.<span class="built_in">reinit</span> (dofHandlersSet, constraintsOtherSet, quadrature, additional_data);</span><br></pre></td></tr></table></figure>
<p>(9)初始化该问题的残差向量和解向量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> fieldIndex=<span class="number">0</span>; fieldIndex&lt;fields.<span class="built_in">size</span>(); fieldIndex++)&#123;</span><br><span class="line">  vectorType *U, *R;</span><br><span class="line">  <span class="keyword">if</span> (iter==<span class="number">0</span>)&#123;</span><br><span class="line">    U=<span class="keyword">new</span> vectorType; R=<span class="keyword">new</span> vectorType;</span><br><span class="line">    solutionSet.<span class="built_in">push_back</span>(U); residualSet.<span class="built_in">push_back</span>(R); </span><br><span class="line">    matrixFreeObject.<span class="built_in">initialize_dof_vector</span>(*R,  fieldIndex); *R=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    U=solutionSet.<span class="built_in">at</span>(fieldIndex); </span><br><span class="line">  &#125;</span><br><span class="line">  matrixFreeObject.<span class="built_in">initialize_dof_vector</span>(*U,  fieldIndex); *U=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>这里就引出了两个很重要的量：残差向量和解向量。两个都是容器，里面的元素是指向向量的指针。这两个向量的大小是问题包含的场的个数，具体到里面的每个元素，即每个场，其大小等于自由度的个数。注意：元素是个指针。<br>解向量和残差向量参与运算，是在computeRHS函数中进行,它们传入getRHS中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matrixFreeObject.<span class="built_in">cell_loop</span> (&amp;MatrixFreePDE&lt;dim&gt;::getRHS, <span class="keyword">this</span>, residualSet, solutionSet);</span><br></pre></td></tr></table></figure>
<p>computeRHS相当于step48中的apply函数，getRHS函数相当于step48中的local_apply函数。<br>(10)根据方程类型不同，初始化一些额外量<br>比如，针对椭圆型方程，计算dU值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fields[fieldIndex].pdetype==ELLIPTIC)&#123;</span><br><span class="line">	 matrixFreeObject.<span class="built_in">initialize_dof_vector</span>(dU,  fieldIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为这里的dU不是一个容器，所以仅能允许问题中有一个椭圆型方程。<br>针对抛物型方程，计算质量矩阵的倒数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isTimeDependentBVP)&#123;</span><br><span class="line">  <span class="built_in">computeInvM</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(11)施加初始条件<br>根据输入文件中的初始条件进行设置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> var_index=<span class="number">0</span>; var_index &lt; num_var; var_index++)&#123;</span><br><span class="line">  <span class="keyword">if</span> (var_type[var_index] == <span class="string">&quot;SCALAR&quot;</span>)&#123;</span><br><span class="line">    VectorTools::<span class="built_in">interpolate</span> (*<span class="keyword">this</span>-&gt;dofHandlersSet[fieldIndex], InitialCondition&lt;dim&gt;(var_index), *<span class="keyword">this</span>-&gt;solutionSet[fieldIndex]);</span><br><span class="line">    fieldIndex++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    VectorTools::<span class="built_in">interpolate</span> (*<span class="keyword">this</span>-&gt;dofHandlersSet[fieldIndex], InitialConditionVec&lt;dim&gt;(var_index), *<span class="keyword">this</span>-&gt;solutionSet[fieldIndex]);</span><br><span class="line">    fieldIndex += dim;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先区分了标量场和矢量场，然后又因为同一种类型的场中会有多个场，所以还通过指标区分了浓度场、相场。结果就是将初始条件的函数场赋给了解向量。</p>
<h2 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h2><p>求解过程也分了两种情形：时间相关的边值问题求解和时间无关的边值问题求解。<br>在计算时可以实现如下功能：<br>(1)输出计算结果</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">outputResults</span>();</span><br></pre></td></tr></table></figure>
<p>(2)计算并输出自由能</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">computeEnergy</span>();                                            </span><br><span class="line"><span class="built_in">outputFreeEnergy</span>(freeEnergyValues);</span><br></pre></td></tr></table></figure>
<p>(3)自适应网格</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">adaptiveRefine</span>(currentIncrement);</span><br></pre></td></tr></table></figure>
<p>(4)逐步求解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">solveIncrement</span>();</span><br></pre></td></tr></table></figure>
<p>这步中包含计算右端项:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">computeRHS</span>();</span><br></pre></td></tr></table></figure>
<p>这里面的右端项的构建还是在输入文件中，该文件中的函数值及其偏导的命名与本身这个变量的表达式很相近，比如偏导或下标直接就写上，理解了这样的书写方式就很好读写了。注意这些表达式力的变量名要与文件开头定义的变量名对应。开头是r表示是剩余项，即residual。另外，这里用到了一个带参数的宏定义，用来将变量向量化，用于后续计算。<br>然后再与质量矩阵的倒数相乘得到最终结果。如果是椭圆型方程，是换用另一种方法直接求解。</p>
<h1 id="计算结果"><a href="#计算结果" class="headerlink" title="计算结果"></a>计算结果</h1><p>如图：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjhzxkp8ig30hs0f2n3y.gif"></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>(1) make debug 比 make release 严格很多，同时计算也更加慢，因为其要检查很多东西。<br>(2)prisms-pf的计算右端项时，将residualSet作为了dst，而deal.II的step48中是将solution作为dst，这个地方有些反直觉，但最终顺序没错，因为它在与质量矩阵的倒数相乘时用的是residualSet。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2016/12/01/prisms-phasefield-allencahn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Be interesting!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亓欣波">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/12/01/prisms-phasefield-allencahn/" class="post-title-link" itemprop="url">PRISMS-PF学习手册——AllenCahn方程求解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-12-01 00:00:00" itemprop="dateCreated datePublished" datetime="2016-12-01T00:00:00+08:00">2016-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 15:20:30" itemprop="dateModified" datetime="2021-03-25T15:20:30+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computational-material-science/" itemprop="url" rel="index"><span itemprop="name">computational material science</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2016/12/01/prisms-phasefield-allencahn/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/12/01/prisms-phasefield-allencahn/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><a target="_blank" rel="noopener" href="http://www.prisms-center.org/">PRISMS</a>是“PRedictive Integrated Structural Materials Science”的缩写，是美国能源部旗下的一个软件创新中心，致力于开发用于多尺度结构材料模拟的开源计算工具。该中心目前已释放出多个开源软件，基于包括相场模型、晶体塑性模型等。这里是对PhaseField的学习。源码在<a target="_blank" rel="noopener" href="https://github.com/prisms-center/phaseField">这里</a>。</p>
<p>几点说明：</p>
<ul>
<li>最好是从最早的v0.8学起，v0.8是最早公开的代码，程序结构简单，耦合程度低，便于学习。</li>
<li>PRISMS-PF的版本与其所基于的deal.II版本需要对应，v0.8基于deal.II的v8.2.1，v1.0基于v8.4.1。这是因为deal.II跨版本升级时会弃用某些类，比如8.2.1中的FEEvaluationGL类在8.3中就不再支持。</li>
<li>目前测试gcc版本不能低于4.8.0，如4.6.3就会出现编译错误。</li>
</ul>
<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p>v0.8主要包括三个文件：</p>
<ul>
<li>CMakeLists.txt: cmake所需的编译文件，用于产生makefile文件</li>
<li>main.cc: 包含初始条件和程序入口main函数 (v0.8中的边界条件都是no-flux，v1.0中加入了多种条件)</li>
<li>parameters.h: 用于输入各种参数<h2 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h2>parameter.h中输入的参数包含两大类：适用于所有模型的通用参数和与模型相关的参数。<br>参数都使用#define来定义。<h3 id="通用参数"><a href="#通用参数" class="headerlink" title="通用参数"></a>通用参数</h3></li>
<li>维数：problemDIM</li>
<li>x方向长度：spanX</li>
<li>y方向长度：spanY (如果维数小于2,则不使用)</li>
<li>z方向长度：spanZ (如果维数小于3,则不使用)</li>
<li>网格细化次数：refineFactor。每个方向上有2的refineFactor次方个单元</li>
<li>有限元空间的插值次数：finiteElementDegree。此时都设为1,即使用Lagrange单元</li>
<li>时间步长：dt</li>
<li>模拟步数：numIncrements。最终时刻则等于dt乘以numIncrements</li>
<li>是否输出：writeOutput。设定布尔值true则为输出</li>
<li>每隔多少步输出：skipOutputSteps。如果writeOutput为真时，初始条件先输出。<h3 id="与模型相关的参数"><a href="#与模型相关的参数" class="headerlink" title="与模型相关的参数"></a>与模型相关的参数</h3>这些参数包括常系数、体积自由能和余量。其中，体积自由能及其导数是相场变量(在代码中通常用n或c表示)的函数，v0.8中都是多项式自由能，非多项式的自由能也能添加，但v0.8不支持。<br>这里以Allen-Cahn方程为例：</li>
<li>迁移率系数：Mn</li>
<li>梯度能系数的平方：Kn</li>
<li>体积自由能的一阶导数：fnV</li>
<li>余量：rnV和rnxV</li>
</ul>
<h2 id="初始条件"><a href="#初始条件" class="headerlink" title="初始条件"></a>初始条件</h2><p>如前所述，初始条件放在main.cc文件中设置。v0.8使用了两种类型的初始条件：在平均值附近的随机噪声(比如初始浓度的微小起伏)或位置的解析函数(比如相场的双曲正切分布)。</p>
<h1 id="程序解析"><a href="#程序解析" class="headerlink" title="程序解析"></a>程序解析</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>包含三种头文件：所用的deal.II的头文件、参数头文件和方程求解方法的头文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../../include/dealIIheaders.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;parameters.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../../src/AC.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="初始条件-1"><a href="#初始条件-1" class="headerlink" title="初始条件"></a>初始条件</h2><p>以下使用的是在初始浓度基础上加一个随机噪声小量，实际就是对InitialConditionN类的virtual函数value进行了函数实现。InitialConditionN类在AC.h中定义，是对Function类的Public继承，它的构造函数用srand函数对下面的rand函数撒种子，这个srand函数这里设置成不同进程有不同的seed值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">double</span> InitialConditionN&lt;dim&gt;::<span class="built_in">value</span> (<span class="keyword">const</span> Point&lt;dim&gt; &amp;p, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="comment">/* component */</span>) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//return the value of the initial order parameter field at point p </span></span><br><span class="line">  <span class="keyword">return</span>  <span class="number">0.5</span>+ <span class="number">0.2</span>*(<span class="number">0.5</span> - (<span class="keyword">double</span>)(std::<span class="built_in">rand</span>() % <span class="number">100</span> )/<span class="number">100.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h2><p>生成AllenCahnProblem类的一个对象，并执行run函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AllenCahnProblem&lt;problemDIM&gt; problem;</span><br><span class="line">problem.<span class="built_in">run</span> ();</span><br></pre></td></tr></table></figure>
<p>AllenCahnProblem类Public继承自Subscriptor类。</p>
<h3 id="创建网格"><a href="#创建网格" class="headerlink" title="创建网格"></a>创建网格</h3><p>首先根据不同的维度创建初始网格，网格大小就是从原点到之前参数中给的位置点。然后使用triangulation全局细化，细化次数是之前参数中的refineFactor，所以每个方向上的网格个数是2的refineFactor次方。</p>
<h3 id="构建系统"><a href="#构建系统" class="headerlink" title="构建系统"></a>构建系统</h3><p>调用该类的setup_system()成员函数：<br>先是自由度分配，因为这里还牵扯到多进程的自由度的分配，使用了很多高级语句，具体可以参考Step-40的用法。<br>再调用该类的setup_matrixfree()成员函数，创建该问题所依赖的数据体data，并初始化，然后建立质量矩阵，因为这里使用了GL单元，所以该矩阵其实是对角的，它的类型是一个存储对角元素的容器。<br>然后施加初始条件。</p>
<h3 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h3><p>先是调用updateRHS()函数更新右端项，其调用ComputeRHS来计算右端项。<br>这块是程序的主要部分，也是主要修改部分，涉及AC方程的分解：<br>(1)右端项中涉及试探函数的函数值的部分：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valN.<span class="built_in">submit_value</span>(rnV,q);</span><br></pre></td></tr></table></figure>
<p>(2)右端项中涉及试探函数的梯度的部分：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valN.<span class="built_in">submit_gradient</span>(constNx*rnxV,q);</span><br></pre></td></tr></table></figure>

<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>结果如图：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjhy2xnszg30o40kgkjn.gif"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Xin-Bo Qi(亓欣波)"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Xin-Bo Qi(亓欣波)</p>
  <div class="site-description" itemprop="description">Be interesting!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">120</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/qixinbo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;qixinbo" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:qixinbo@gmail.com" title="E-Mail → mailto:qixinbo@gmail.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.tsinghua.edu.cn/" title="https:&#x2F;&#x2F;www.tsinghua.edu.cn" rel="noopener" target="_blank">THU</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.imr.cas.cn/" title="http:&#x2F;&#x2F;www.imr.cas.cn" rel="noopener" target="_blank">IMR</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.sdu.edu.cn/" title="http:&#x2F;&#x2F;www.sdu.edu.cn" rel="noopener" target="_blank">SDU</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://liam0205.me/" title="http:&#x2F;&#x2F;liam0205.me&#x2F;" rel="noopener" target="_blank">黄晨成</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xin-Bo Qi(亓欣波)</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://qixinbo.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
