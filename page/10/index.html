<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"qixinbo.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Be interesting!">
<meta property="og:type" content="website">
<meta property="og:title" content="亓欣波">
<meta property="og:url" content="http://qixinbo.github.io/page/10/index.html">
<meta property="og:site_name" content="亓欣波">
<meta property="og:description" content="Be interesting!">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Xin-Bo Qi(亓欣波)">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://qixinbo.github.io/page/10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>亓欣波</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">亓欣波</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Hi, I am Xin-Bo Qi (亓欣波)</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-scholar">

    <a href="/scholar/" rel="section"><i class="bar-chart fa-fw"></i>scholar</a>

  </li>
        <li class="menu-item menu-item-sources">

    <a href="/sources/" rel="section"><i class="rss fa-fw"></i>sources</a>

  </li>
        <li class="menu-item menu-item-gallery">

    <a href="/gallery/" rel="section"><i class="file-image-o fa-fw"></i>gallery</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404.html" rel="section"><i class="heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2016/08/30/dealii-learn-step6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Be interesting!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亓欣波">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/08/30/dealii-learn-step6/" class="post-title-link" itemprop="url">求解偏微分方程开源有限元软件deal.II学习--Step 6</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-08-30 00:00:00" itemprop="dateCreated datePublished" datetime="2016-08-30T00:00:00+08:00">2016-08-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 15:20:30" itemprop="dateModified" datetime="2021-03-25T15:20:30+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computational-material-science/" itemprop="url" rel="index"><span itemprop="name">computational material science</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2016/08/30/dealii-learn-step6/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/08/30/dealii-learn-step6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>本例主要着眼于处理局部细化的网格。如果临近单元细化多次以后，单元界面上的格点可能在另一边就不平衡，称为“悬点”。为了保证全局解在这些格点上也是连续的，必须对这些节点上的解的值施加一些限制，相应的核心的类是ConstraintMatrix。</p>
<h1 id="程序解析"><a href="#程序解析" class="headerlink" title="程序解析"></a>程序解析</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/quadrature_lib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/function.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/logstream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/vector.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/full_matrix.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/sparse_matrix.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/solver_cg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/precondition.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_handler.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/grid_generator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria_accessor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria_iterator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/manifold_lib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_accessor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_tools.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/fe/fe_values.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/vector_tools.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/matrix_tools.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/data_out.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/fe/fe_q.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>以上头文件之前用过，不解释。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/grid_out.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>本例中不从文件中读取网格，而是使用一个库函数来直接生成。但是需要输出网格(仅输出网格，不包括解，就像step1一样)，所以需要上述头文件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/constraint_matrix.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>当局部细化网格时，就会产生悬点，但是，标准的有限元方法假定离散解空间是连续的，所以我们也得在悬点上的自由度加一些限制，使得全局解是连续的。这些限制条件就由ConstraintMatrix实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/grid_refinement.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>这个头文件提供函数来确定哪个单元来细化或粗化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/error_estimator.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>该头文件提供细化指示子的计算，其根据一些误差估计方法。通常来说自适应是跟所研究的问题密切相关的，不过该文件中的误差指示子对很多问题都具有很好的适用性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> dealii;</span><br></pre></td></tr></table></figure>
<p>最后是使用dealii命名空间。</p>
<p>step6的类模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Step6</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Step6</span> ();</span><br><span class="line">        ~<span class="built_in">Step6</span> ();</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setup_system</span> <span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">assemble_system</span> <span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">refine_grid</span> <span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">output_results</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> cycle)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        Triangulation&lt;dim&gt; triangulation;</span><br><span class="line">        DoFHandler&lt;dim&gt; dof_handler;</span><br><span class="line">        FE_Q&lt;dim&gt; fe;</span><br><span class="line">        ConstraintMatrix constraints;</span><br><span class="line">        SparsityPattern sparsity_pattern;</span><br><span class="line">        SparseMatrix&lt;<span class="keyword">double</span>&gt; system_matrix;</span><br><span class="line">        Vector&lt;<span class="keyword">double</span>&gt; solution;</span><br><span class="line">        Vector&lt;<span class="keyword">double</span>&gt; system_rhs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>基本跟之前的类模板相同，但多了几个新东西：refine_grid函数用来自适应地细化网格，这跟之前的全局细化不同;constraints对象来存储限制条件;还有一个析构函数。<br>变系数的引入是完全复制step5的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coefficient</span> :</span> <span class="keyword">public</span> Function&lt;dim&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Coefficient</span> () : Function&lt;dim&gt;() &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">value</span> <span class="params">(<span class="keyword">const</span> Point&lt;dim&gt; &amp;p,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">value_list</span> <span class="params">(<span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt; &gt; &amp;points,</span></span></span><br><span class="line"><span class="function"><span class="params">                std::vector&lt;<span class="keyword">double</span>&gt; &amp;values,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">double</span> Coefficient&lt;dim&gt;::<span class="built_in">value</span> (<span class="keyword">const</span> Point&lt;dim&gt; &amp;p,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p.<span class="built_in">square</span>() &lt; <span class="number">0.5</span>*<span class="number">0.5</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> Coefficient&lt;dim&gt;::<span class="built_in">value_list</span> (<span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt; &gt; &amp;points,</span><br><span class="line">        std::vector&lt;<span class="keyword">double</span>&gt; &amp;values,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> n_points = points.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">Assert</span> (values.<span class="built_in">size</span>() == n_points,</span><br><span class="line">            <span class="built_in">ExcDimensionMismatch</span> (values.<span class="built_in">size</span>(), n_points));</span><br><span class="line">    <span class="built_in">Assert</span> (component == <span class="number">0</span>,</span><br><span class="line">            <span class="built_in">ExcIndexRange</span> (component, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n_points; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (points[i].<span class="built_in">square</span>() &lt; <span class="number">0.5</span>*<span class="number">0.5</span>)</span><br><span class="line">            values[i] = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            values[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">Step6&lt;dim&gt;::<span class="built_in">Step6</span> ()</span><br><span class="line">    :</span><br><span class="line">        <span class="built_in">dof_handler</span> (triangulation),</span><br><span class="line">        <span class="built_in">fe</span> (<span class="number">2</span>)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>注意：这里因为要使用的单元是二次的，所以fe的参数是2。还要注意初始化器列表中的两个的位置顺序，这里是dof_handler在fe的前面，之前都是在fe的后面。这里的顺序变动将会产生一个很坏的副作用：<br>当我们使用dof_handler.distribute_dofs()分配自由度时，dof_handler也存储了一个指向正在使用的有限单元的指针，因为此指针一直在使用，直到使用另一个fe重新分配自由度或dof_handler被销毁掉。这样如果允许在dof_handler之前删除fe的话就会产生很大隐患。为了防止这个误操作，dof_handler在fe对象内部为一个计数器增值，这个计数器统计有多少对象使用这个有限元。如果该计数器大于0，那么这个fe对象就拒绝被销毁，因为有其他对象依赖于它。如果试图销毁它，一个异常就会被抛出，程序就会停止。<br>现在构造函数的初始化器列表这样写的话，如果不写析构函数，那么就会发生如上错误，因为销毁顺序是与之前的建立顺序相反的。在析构函数中应当做的就是告诉dof_handler释放它对fe的锁，当然这必须在它确实不再需要fe之后才行，即当所有的有限元相关的数据都被删除。DoFHandler有一个函数clear能够删除所有的自由度，同时释放对fe的锁。clear以后fe内部的计数器就变为0，然后就可以安全地删除fe了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">Step6&lt;dim&gt;::~<span class="built_in">Step6</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    dof_handler.<span class="built_in">clear</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一步就是要建立线性有限元系统的有关变量，如：自由度、矩阵、向量等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> Step6&lt;dim&gt;::<span class="built_in">setup_system</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    dof_handler.<span class="built_in">distribute_dofs</span> (fe);</span><br><span class="line">    solution.<span class="built_in">reinit</span> (dof_handler.<span class="built_in">n_dofs</span>());</span><br><span class="line">    system_rhs.<span class="built_in">reinit</span> (dof_handler.<span class="built_in">n_dofs</span>());</span><br></pre></td></tr></table></figure>
<p>这一部分代码跟step5相同，下面就不同了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constraints.<span class="built_in">clear</span> ();</span><br><span class="line">DoFTools::<span class="built_in">make_hanging_node_constraints</span> (dof_handler,</span><br><span class="line">        constraints);</span><br></pre></td></tr></table></figure>
<p>上述就是对悬点的限制条件。clear就是清除其中可能残留的信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VectorTools::<span class="built_in">interpolate_boundary_values</span> (dof_handler,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        ZeroFunction&lt;dim&gt;(),</span><br><span class="line">        constraints);</span><br></pre></td></tr></table></figure>
<p>这里将0值边界条件施加进去，将结果保存进constraints。注意：之前施加边界条件都是在组装完毕之后，这里却是在其之前。消除系统方程的边界节点，应该发生在消除悬点之后，这个是很重要的(感谢adadobe的指正)。所以在建立悬点限制后就将边界条件放进去。<br>下一步就是关闭该对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constraints.<span class="built_in">close</span> ();</span><br></pre></td></tr></table></figure>
<p>接着就是创建稀疏矩阵：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DynamicSparsityPattern <span class="title">dsp</span><span class="params">(dof_handler.n_dofs())</span></span>;</span><br><span class="line">DoFTools::<span class="built_in">make_sparsity_pattern</span>(dof_handler,</span><br><span class="line">        dsp,</span><br><span class="line">        constraints,</span><br><span class="line">        / *keep_constrained_dofs = * / <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>注意，这里没有立即把pattern复制到最终的里面，而是又做了一步，至于是啥意思，没看明白。<br>然后就是真正创建矩阵：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sparsity_pattern.<span class="built_in">copy_from</span>(dsp);</span><br><span class="line">system_matrix.<span class="built_in">reinit</span> (sparsity_pattern);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再然后就是组装系统。跟之前的step5有两点不同：一是因为有限元形函数的多项式次数变大了，相应的积分公式的次数也要提高，这点很好实现，QGauss类接收每个方向上积分点的个数作为参数，之前双线性单元是2个积分点，对双二次单元则是3个。二是在组装总刚时，不再使用手写的循环，而是用ConstraintMatrix::distribute_local_to_global实现，它内置那个循环，并删除所有的限制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> Step6&lt;dim&gt;::<span class="built_in">assemble_system</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> QGauss&lt;dim&gt; <span class="title">quadrature_formula</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">FEValues&lt;dim&gt; <span class="title">fe_values</span> <span class="params">(fe, quadrature_formula,</span></span></span><br><span class="line"><span class="function"><span class="params">            update_values | update_gradients |</span></span></span><br><span class="line"><span class="function"><span class="params">            update_quadrature_points | update_JxW_values)</span></span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> dofs_per_cell = fe.dofs_per_cell;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> n_q_points = quadrature_formula.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">FullMatrix&lt;<span class="keyword">double</span>&gt; <span class="title">cell_matrix</span> <span class="params">(dofs_per_cell, dofs_per_cell)</span></span>;</span><br><span class="line">    <span class="function">Vector&lt;<span class="keyword">double</span>&gt; <span class="title">cell_rhs</span> <span class="params">(dofs_per_cell)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;types::global_dof_index&gt; <span class="title">local_dof_indices</span> <span class="params">(dofs_per_cell)</span></span>;</span><br><span class="line">    <span class="keyword">const</span> Coefficient&lt;dim&gt; coefficient;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">double</span>&gt; <span class="title">coefficient_values</span> <span class="params">(n_q_points)</span></span>;</span><br><span class="line">    <span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator</span><br><span class="line">        cell = dof_handler.<span class="built_in">begin_active</span>(),</span><br><span class="line">             endc = dof_handler.<span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">for</span> (; cell!=endc; ++cell)</span><br><span class="line">    &#123;</span><br><span class="line">        cell_matrix = <span class="number">0</span>;</span><br><span class="line">        cell_rhs = <span class="number">0</span>;</span><br><span class="line">        fe_values.<span class="built_in">reinit</span> (cell);</span><br><span class="line">        coefficient.<span class="built_in">value_list</span> (fe_values.<span class="built_in">get_quadrature_points</span>(),</span><br><span class="line">                coefficient_values);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> q_index=<span class="number">0</span>; q_index&lt;n_q_points; ++q_index)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dofs_per_cell; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j=<span class="number">0</span>; j&lt;dofs_per_cell; ++j)</span><br><span class="line">                    <span class="built_in">cell_matrix</span>(i,j) += (coefficient_values[q_index] *</span><br><span class="line">                            fe_values.<span class="built_in">shape_grad</span>(i,q_index) *</span><br><span class="line">                            fe_values.<span class="built_in">shape_grad</span>(j,q_index) *</span><br><span class="line">                            fe_values.<span class="built_in">JxW</span>(q_index));</span><br><span class="line">                <span class="built_in">cell_rhs</span>(i) += (fe_values.<span class="built_in">shape_value</span>(i,q_index) *</span><br><span class="line">                        <span class="number">1.0</span> *</span><br><span class="line">                        fe_values.<span class="built_in">JxW</span>(q_index));</span><br><span class="line">            &#125;</span><br><span class="line">        cell-&gt;<span class="built_in">get_dof_indices</span> (local_dof_indices);</span><br><span class="line">        constraints.<span class="built_in">distribute_local_to_global</span> (cell_matrix,</span><br><span class="line">                cell_rhs,</span><br><span class="line">                local_dof_indices,</span><br><span class="line">                system_matrix,</span><br><span class="line">                system_rhs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总套路跟之前差不多，但实际上隐藏的变化还是挺多的，只不过对用户不可见。<br>求解步如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> Step6&lt;dim&gt;::<span class="built_in">solve</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">SolverControl <span class="title">solver_control</span> <span class="params">(<span class="number">1000</span>, <span class="number">1e-12</span>)</span></span>;</span><br><span class="line">    SolverCG&lt;&gt; <span class="built_in">solver</span> (solver_control);</span><br><span class="line">    PreconditionSSOR&lt;&gt; preconditioner;</span><br><span class="line">    preconditioner.<span class="built_in">initialize</span>(system_matrix, <span class="number">1.2</span>);</span><br><span class="line">    solver.<span class="built_in">solve</span> (system_matrix, solution, system_rhs,</span><br><span class="line">            preconditioner);</span><br><span class="line">    constraints.<span class="built_in">distribute</span> (solution);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里在最后也加入了限制。<br>下面是重头戏：局部细化。这里使用的是KellyErrorEstimator，顾名思义，该方法是由Kelly等人提出的。尽管该方法起初是用于拉普拉斯方程，但证明其对很多问题都能快速地产生局部细化的网格。原理上来讲，它着眼于单元之间的解的梯度阶跃(即是二阶导数的计算)，然后与单元尺寸比例一下，物理上来讲，它代表解在该单元的局部光滑度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> Step6&lt;dim&gt;::<span class="built_in">refine_grid</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Vector&lt;<span class="keyword">float</span>&gt; <span class="title">estimated_error_per_cell</span> <span class="params">(triangulation.n_active_cells())</span></span>;</span><br><span class="line">    KellyErrorEstimator&lt;dim&gt;::<span class="built_in">estimate</span> (dof_handler,</span><br><span class="line">            QGauss&lt;dim<span class="number">-1</span>&gt;(<span class="number">3</span>),</span><br><span class="line">            <span class="keyword">typename</span> FunctionMap&lt;dim&gt;::<span class="built_in">type</span>(),</span><br><span class="line">            solution,</span><br><span class="line">            estimated_error_per_cell);</span><br></pre></td></tr></table></figure>
<p>接收的参数分别为：一个DofHandler对象，描述自由度和每个自由度上的值，边界上的积分公式QGauss<dim-1>，Neumann边界对应的边界指示子FunctionMap<dim>::type()，这里因为没有施加Neumann边界条件，所以为空，解solution，还有返回的每个单元上的误差值estimated_error_per_cell。细化过程则为：对有最大误差值的30%的单元细化，而对有最小误差值的3%的单元粗化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GridRefinement::<span class="built_in">refine_and_coarsen_fixed_number</span> (triangulation,</span><br><span class="line">        estimated_error_per_cell,</span><br><span class="line">        <span class="number">0.3</span>, <span class="number">0.03</span>);</span><br><span class="line">triangulation.<span class="built_in">execute_coarsening_and_refinement</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仅输出网格：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> Step6&lt;dim&gt;::<span class="built_in">output_results</span> (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> cycle) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Assert</span> (cycle &lt; <span class="number">10</span>, <span class="built_in">ExcNotImplemented</span>());</span><br><span class="line">    std::string filename = <span class="string">&quot;grid-&quot;</span>;</span><br><span class="line">    filename += (<span class="string">&#x27;0&#x27;</span> + cycle);</span><br><span class="line">    filename += <span class="string">&quot;.eps&quot;</span>;</span><br><span class="line">    <span class="function">std::ofstream <span class="title">output</span> <span class="params">(filename.c_str())</span></span>;</span><br><span class="line">    GridOut grid_out;</span><br><span class="line">    grid_out.<span class="built_in">write_eps</span> (triangulation, output);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>run函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> Step6&lt;dim&gt;::<span class="built_in">run</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> cycle=<span class="number">0</span>; cycle&lt;<span class="number">8</span>; ++cycle)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="string">&#x27;:&#x27;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (cycle == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GridGenerator::<span class="built_in">hyper_ball</span> (triangulation);</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">const</span> SphericalManifold&lt;dim&gt; boundary;</span><br><span class="line">            triangulation.<span class="built_in">set_all_manifold_ids_on_boundary</span>(<span class="number">0</span>);</span><br><span class="line">            triangulation.<span class="built_in">set_manifold</span> (<span class="number">0</span>, boundary);</span><br><span class="line">            triangulation.<span class="built_in">refine_global</span> (<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">refine_grid</span> ();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; Number of active cells: &quot;</span></span><br><span class="line">            &lt;&lt; triangulation.<span class="built_in">n_active_cells</span>()</span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">setup_system</span> ();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; Number of degrees of freedom: &quot;</span></span><br><span class="line">            &lt;&lt; dof_handler.<span class="built_in">n_dofs</span>()</span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">assemble_system</span> ();</span><br><span class="line">        <span class="built_in">solve</span> ();</span><br><span class="line">        <span class="built_in">output_results</span> (cycle);</span><br><span class="line">    &#125;</span><br><span class="line">DataOutBase::EpsFlags eps_flags;</span><br><span class="line">eps_flags.z_scaling = <span class="number">4</span>;</span><br><span class="line">DataOut&lt;dim&gt; data_out;</span><br><span class="line">data_out.<span class="built_in">set_flags</span> (eps_flags);</span><br><span class="line">data_out.<span class="built_in">attach_dof_handler</span> (dof_handler);</span><br><span class="line">data_out.<span class="built_in">add_data_vector</span> (solution, <span class="string">&quot;solution&quot;</span>);</span><br><span class="line">data_out.<span class="built_in">build_patches</span> ();</span><br><span class="line"><span class="function">std::ofstream <span class="title">output</span> <span class="params">(<span class="string">&quot;final-solution.eps&quot;</span>)</span></span>;</span><br><span class="line">data_out.<span class="built_in">write_eps</span> (output);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，每次循环都输出一下细化后的网格，同时在最后也输出一下解。<br>最后是main函数，它比之前的都高级，因为加入了异常捕获机制。有时候，程序只有在运行时才会出问题，比如没有足够的硬盘空间用于输出文件，没有足够的内存来分配矢量或矩阵，或者没有权限读写文件等。这里的代码具有一定的通用性，可以用于其他大型程序中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        Step6&lt;<span class="number">2</span>&gt; laplace_problem_2d;</span><br><span class="line">        laplace_problem_2d.<span class="built_in">run</span> ();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先try运行一下我们的程序，如果失败了，就要尽可能多地收集信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (std::exception &amp;exc)</span><br><span class="line">&#123;</span><br><span class="line">    std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">        &lt;&lt; std::endl;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; exc.<span class="built_in">what</span>() &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">        &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果抛出的异常属于C++标准类exception，那么就可以调用what这一成员函数来显示具体出错信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (...)</span><br><span class="line">&#123;</span><br><span class="line">    std::cerr &lt;&lt; std::endl &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">        &lt;&lt; std::endl;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;----------------------------------------------------&quot;</span></span><br><span class="line">        &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不是一个来自标准exception类的异常，那么就无力作什么事情，只能打印一些提示字符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有异常，就顺序退出。</p>
<h1 id="计算结果："><a href="#计算结果：" class="headerlink" title="计算结果："></a>计算结果：</h1><p>最终输出的解为：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjkc5872dj308d05umzs.jpg"><br>每步循环得到的网格为：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjkcgcd26j308d08d0st.jpg"><br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjkcrecpej308d08d0t0.jpg"><br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjkd3x4cyj308d08dgm2.jpg"><br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjke3uyanj308d08daan.jpg"><br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjkefkmexj308d08daax.jpg"><br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjkerwqhbj308d08dq3y.jpg"><br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjkf3nbh0j308d08ddgw.jpg"><br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjkfexab3j308d08dq41.jpg"></p>
<h1 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h1><h2 id="求解器和预条件子"><a href="#求解器和预条件子" class="headerlink" title="求解器和预条件子"></a>求解器和预条件子</h2><p>deal.II中提供多种求解器和预条件子来求解问题。<br>该例中的线性系统是对称且正定的，所以CG算法挺适合。这里可以更改预条件子来看看，如使用Jacobi(需要包含lac/sparse_ilu.h头文件)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PreconditionJacobi&lt;&gt; preconditioner;</span><br><span class="line">preconditioner.<span class="built_in">initialize</span>(system_matrix);</span><br></pre></td></tr></table></figure>
<p>或LU分解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SparseILU&lt;<span class="keyword">double</span>&gt; preconditioner;</span><br><span class="line">preconditioner.<span class="built_in">initialize</span>(system_matrix);</span><br></pre></td></tr></table></figure>
<p>预条件子的选择需要根据具体问题来，不同类型的问题以及不同的有限单元可能有不一样的结论。</p>
<h2 id="更好的网格"><a href="#更好的网格" class="headerlink" title="更好的网格"></a>更好的网格</h2><p>之前生成的网格可以看出来不是很能显示出圆形这一特征，Triangulation类仅能着眼于粗网格的集合，但是不知道它们组合起来应该怎么样。这可以通过更复杂的程序来调节，使之better represent the desired geometry。具体不说了，看帮助文档。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2016/08/28/dealii-learn-step5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Be interesting!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亓欣波">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/08/28/dealii-learn-step5/" class="post-title-link" itemprop="url">求解偏微分方程开源有限元软件deal.II学习--Step 5</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-08-28 00:00:00" itemprop="dateCreated datePublished" datetime="2016-08-28T00:00:00+08:00">2016-08-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 15:20:30" itemprop="dateModified" datetime="2021-03-25T15:20:30+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computational-material-science/" itemprop="url" rel="index"><span itemprop="name">computational material science</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2016/08/28/dealii-learn-step5/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/08/28/dealii-learn-step5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>此例没有介绍革命性的功能，但有很多对前面例子的“微创新”，包括：</p>
<ul>
<li>在不断细化的网格上的计算。数值计算通常要在不同的网格上进行，这样才能感受到精度。而且deal.II支持自适应网格，虽然这个例子中没有用到，但基础在这</li>
<li>读入非规则网格数据</li>
<li>计算优化</li>
<li>debug模式，使用Assert宏</li>
<li>变系数Possion方程，使用预条件迭代求解器</li>
</ul>
<p>这里要求解的方程是：<br>$$<br>\begin{equation}<br>\begin{split}<br>-\nabla\cdot a(x)\nabla u(x) &amp;=1  \qquad in \Omega, \<br>u &amp;=0 \qquad on \partial\Omega<br>\end{split}<br>\end{equation}<br>$$<br>如果$a(x)$是常系数，那么就成了Possion方程，如果它是空间相关的变系数，方程就复杂一些了。<br>还是得先写出方程的弱形式：<br>$$<br>(a \nabla \phi, \nabla u) = (\phi, 1) \qquad \forall \phi<br>$$</p>
<h1 id="程序解析"><a href="#程序解析" class="headerlink" title="程序解析"></a>程序解析</h1><p>以下是头文件们：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/quadrature_lib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/function.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/logstream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/vector.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/full_matrix.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/sparse_matrix.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/solver_cg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/precondition.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_handler.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria_accessor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria_iterator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_accessor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_tools.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/fe/fe_q.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/fe/fe_values.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/vector_tools.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/matrix_tools.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/data_out.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/grid_in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/manifold_lib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> dealii;</span><br></pre></td></tr></table></figure>
<p>新增的是grid_in.h，是为了从硬盘中读入一个网格文件。manifold_lib.h是为了描述环形边界上的对象。</p>
<p>step5类模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Step5</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Step5</span> ();</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setup_system</span> <span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">assemble_system</span> <span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">output_results</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> cycle)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        Triangulation&lt;dim&gt; triangulation;</span><br><span class="line">        FE_Q&lt;dim&gt; fe;</span><br><span class="line">        DoFHandler&lt;dim&gt; dof_handler;</span><br><span class="line">        SparsityPattern sparsity_pattern;</span><br><span class="line">        SparseMatrix&lt;<span class="keyword">double</span>&gt; system_matrix;</span><br><span class="line">        Vector&lt;<span class="keyword">double</span>&gt; solution;</span><br><span class="line">        Vector&lt;<span class="keyword">double</span>&gt; system_rhs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为这里处理的是变系数椭圆问题，使用的对象类型还是Function，不过这里没用value，而是用的value_list，它不再接收单个点，而是接收一系列的点，然后返回这些点上的函数值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coefficient</span> :</span> <span class="keyword">public</span> Function&lt;dim&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Coefficient</span> () : Function&lt;dim&gt;() &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">value</span> <span class="params">(<span class="keyword">const</span> Point&lt;dim&gt; &amp;p,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">value_list</span> <span class="params">(<span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt; &gt; &amp;points,</span></span></span><br><span class="line"><span class="function"><span class="params">                std::vector&lt;<span class="keyword">double</span>&gt; &amp;values,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面是单个点上的函数值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">double</span> Coefficient&lt;dim&gt;::<span class="built_in">value</span> (<span class="keyword">const</span> Point&lt;dim&gt; &amp;p,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> / *component* /) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (p.<span class="built_in">square</span>() &lt; <span class="number">0.5</span>*<span class="number">0.5</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么下面就是一下计算很多点的函数值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> Coefficient&lt;dim&gt;::<span class="built_in">value_list</span> (<span class="keyword">const</span> std::vector&lt;Point&lt;dim&gt; &gt; &amp;points,</span><br><span class="line">        std::vector&lt;<span class="keyword">double</span>&gt; &amp;values,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Assert</span> (values.<span class="built_in">size</span>() == points.<span class="built_in">size</span>(),</span><br><span class="line">            <span class="built_in">ExcDimensionMismatch</span> (values.<span class="built_in">size</span>(), points.<span class="built_in">size</span>()));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个函数接收三个参数：一个是坐标点的列表，一个是存储这些点上的函数值的列表，一个是矢量component，这里应该是0,因为此处是标量函数。<br>很明显，输出列表values的大小跟输入列表points应该相同，但事实上90%的编程错误都是输入了无效参数，因此应该保证输入参数是valid的。此处，Assert宏是个好方法，因为它保证它的第一个参数，即条件，是有效的，如果无效，就抛出一个exception，即它的第二个参数，通常是终止程序。这将极快地定位错误，方便调试。另一方面，这些检查也不会明显地拖慢程序，而且，Assert宏可仅存在于debug模式，在优化模式中可以将其完全去掉。<br>事实上，如果将deal.II中的所有check都关掉，可以提速4倍，但同时有引入大量调试错误的问题。<br>所以，最好是程序稳定后，再将debug关闭。<br>上面代码就是Assert一下两者的尺寸是否相同，第一个参数是是否相同的条件，第二个参数是调用内置的一个函数来输出两者维度不匹配的信息。该算例的最后就是给出了一个触发这种不匹配的情形，可以发现很快就能定位错误，同时，如果程序是在一个调试器中运行，可以通过调用堆栈直接跳转到出错位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Assert</span> (component == <span class="number">0</span>,</span><br><span class="line">        <span class="built_in">ExcIndexRange</span> (component, <span class="number">0</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>这里还检查了是不是标量函数，因为标量可视为只有一个分量的矢量，所以Assert一下是否component=0,如果越界了，就调用ExcIndexRange函数。<br>下面就是具体赋值代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> n_points = points.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n_points; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (points[i].<span class="built_in">square</span>() &lt; <span class="number">0.5</span>*<span class="number">0.5</span>)</span><br><span class="line">        values[i] = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        values[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">Step5&lt;dim&gt;::<span class="built_in">Step5</span> () :</span><br><span class="line">    <span class="built_in">fe</span> (<span class="number">1</span>),</span><br><span class="line">    <span class="built_in">dof_handler</span> (triangulation)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>建立系统，跟之前不同的是没有生成网格这一步：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> Step5&lt;dim&gt;::<span class="built_in">setup_system</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    dof_handler.<span class="built_in">distribute_dofs</span> (fe);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; Number of degrees of freedom: &quot;</span></span><br><span class="line">        &lt;&lt; dof_handler.<span class="built_in">n_dofs</span>()</span><br><span class="line">        &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">DynamicSparsityPattern <span class="title">dsp</span><span class="params">(dof_handler.n_dofs())</span></span>;</span><br><span class="line">    DoFTools::<span class="built_in">make_sparsity_pattern</span> (dof_handler, dsp);</span><br><span class="line">    sparsity_pattern.<span class="built_in">copy_from</span>(dsp);</span><br><span class="line">    system_matrix.<span class="built_in">reinit</span> (sparsity_pattern);</span><br><span class="line">    solution.<span class="built_in">reinit</span> (dof_handler.<span class="built_in">n_dofs</span>());</span><br><span class="line">    system_rhs.<span class="built_in">reinit</span> (dof_handler.<span class="built_in">n_dofs</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>组装系统：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> Step5&lt;dim&gt;::<span class="built_in">assemble_system</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">QGauss&lt;dim&gt; <span class="title">quadrature_formula</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">FEValues&lt;dim&gt; <span class="title">fe_values</span> <span class="params">(fe, quadrature_formula,</span></span></span><br><span class="line"><span class="function"><span class="params">            update_values | update_gradients |</span></span></span><br><span class="line"><span class="function"><span class="params">            update_quadrature_points | update_JxW_values)</span></span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> dofs_per_cell = fe.dofs_per_cell;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> n_q_points = quadrature_formula.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">FullMatrix&lt;<span class="keyword">double</span>&gt; <span class="title">cell_matrix</span> <span class="params">(dofs_per_cell, dofs_per_cell)</span></span>;</span><br><span class="line">    <span class="function">Vector&lt;<span class="keyword">double</span>&gt; <span class="title">cell_rhs</span> <span class="params">(dofs_per_cell)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;types::global_dof_index&gt; <span class="title">local_dof_indices</span> <span class="params">(dofs_per_cell)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这一步的前面部分跟之前的相同，不解释。<br>下面不同之处在于这里用的是变系数，所以先根据之前的系数模板创建这么一个对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Coefficient&lt;dim&gt; coefficient;</span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">double</span>&gt; <span class="title">coefficient_values</span> <span class="params">(n_q_points)</span></span>;</span><br><span class="line"><span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator</span><br><span class="line">cell = dof_handler.<span class="built_in">begin_active</span>(),</span><br><span class="line">     endc = dof_handler.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">for</span> (; cell!=endc; ++cell)</span><br><span class="line">&#123;</span><br><span class="line">    cell_matrix = <span class="number">0</span>;</span><br><span class="line">    cell_rhs = <span class="number">0</span>;</span><br><span class="line">    fe_values.<span class="built_in">reinit</span> (cell);</span><br><span class="line">    coefficient.<span class="built_in">value_list</span> (fe_values.<span class="built_in">get_quadrature_points</span>(),</span><br><span class="line">            coefficient_values);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> q_index=<span class="number">0</span>; q_index&lt;n_q_points; ++q_index)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dofs_per_cell; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j=<span class="number">0</span>; j&lt;dofs_per_cell; ++j)</span><br><span class="line">                <span class="built_in">cell_matrix</span>(i,j) += (coefficient_values[q_index] *</span><br><span class="line">                        fe_values.<span class="built_in">shape_grad</span>(i,q_index) *</span><br><span class="line">                        fe_values.<span class="built_in">shape_grad</span>(j,q_index) *</span><br><span class="line">                        fe_values.<span class="built_in">JxW</span>(q_index));</span><br><span class="line">            <span class="built_in">cell_rhs</span>(i) += (fe_values.<span class="built_in">shape_value</span>(i,q_index) *</span><br><span class="line">                    <span class="number">1.0</span> *</span><br><span class="line">                    fe_values.<span class="built_in">JxW</span>(q_index));</span><br><span class="line">        &#125;</span><br><span class="line">    cell-&gt;<span class="built_in">get_dof_indices</span> (local_dof_indices);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dofs_per_cell; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j=<span class="number">0</span>; j&lt;dofs_per_cell; ++j)</span><br><span class="line">            system_matrix.<span class="built_in">add</span> (local_dof_indices[i],</span><br><span class="line">                    local_dof_indices[j],</span><br><span class="line">                    <span class="built_in">cell_matrix</span>(i,j));</span><br><span class="line">        <span class="built_in">system_rhs</span>(local_dof_indices[i]) += <span class="built_in">cell_rhs</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">std::map&lt;types::global_dof_index,<span class="keyword">double</span>&gt; boundary_values;</span><br><span class="line">VectorTools::<span class="built_in">interpolate_boundary_values</span> (dof_handler,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        ZeroFunction&lt;dim&gt;(),</span><br><span class="line">        boundary_values);</span><br><span class="line">MatrixTools::<span class="built_in">apply_boundary_values</span> (boundary_values,</span><br><span class="line">        system_matrix,</span><br><span class="line">        solution,</span><br><span class="line">        system_rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比起step4做的优化是：在计算系数函数的值时，是在每个单位上一下计算了所有积分点上的值。因为从step4可以看出，在那里计算右端项时，计算了$dofs_per_cell<em>n_q_points times$次，如果还是这样计算，对应到这里计算系数时，就需要计算$dofs_per_cell</em>dofs_per_cell*n_q_points$次，但实际上相同积分点对应的这些函数值相同，没必要在自由度的循环中重复计算，同时这里还涉及虚函数调用，开销很大。综上，一次性计算完毕，优化了计算效率。<br>求解步如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> Step5&lt;dim&gt;::<span class="built_in">solve</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">SolverControl <span class="title">solver_control</span> <span class="params">(<span class="number">1000</span>, <span class="number">1e-12</span>)</span></span>;</span><br><span class="line">    SolverCG&lt;&gt; <span class="built_in">solver</span> (solver_control);</span><br><span class="line">    PreconditionSSOR&lt;&gt; preconditioner;</span><br><span class="line">    preconditioner.<span class="built_in">initialize</span>(system_matrix, <span class="number">1.2</span>);</span><br><span class="line">    solver.<span class="built_in">solve</span> (system_matrix, solution, system_rhs,</span><br><span class="line">            preconditioner);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; solver_control.<span class="built_in">last_step</span>()</span><br><span class="line">        &lt;&lt; <span class="string">&quot; CG iterations needed to obtain convergence.&quot;</span></span><br><span class="line">        &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用了对称超松弛迭代算法作为预条件子。<br>输出部分如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> Step5&lt;dim&gt;::<span class="built_in">output_results</span> (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> cycle) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    DataOut&lt;dim&gt; data_out;</span><br><span class="line">    data_out.<span class="built_in">attach_dof_handler</span> (dof_handler);</span><br><span class="line">    data_out.<span class="built_in">add_data_vector</span> (solution, <span class="string">&quot;solution&quot;</span>);</span><br><span class="line">    data_out.<span class="built_in">build_patches</span> ();</span><br><span class="line">    DataOutBase::EpsFlags eps_flags;</span><br><span class="line">    eps_flags.z_scaling = <span class="number">4</span>;</span><br><span class="line">    eps_flags.azimut_angle = <span class="number">40</span>;</span><br><span class="line">    eps_flags.turn_angle = <span class="number">10</span>;</span><br><span class="line">    data_out.<span class="built_in">set_flags</span> (eps_flags);</span><br><span class="line">    std::ostringstream filename;</span><br><span class="line">    filename &lt;&lt; <span class="string">&quot;solution-&quot;</span></span><br><span class="line">        &lt;&lt; cycle</span><br><span class="line">        &lt;&lt; <span class="string">&quot;.eps&quot;</span>;</span><br><span class="line">    <span class="function">std::ofstream <span class="title">output</span> <span class="params">(filename.str().c_str())</span></span>;</span><br><span class="line">    data_out.<span class="built_in">write_eps</span> (output);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将输出格式改成了EPS。因为EPS是一个打印格式，它不像其他格式的数据那样能输入到图像工具进行编辑，所以需要事先定义好，源码中就定义了多种flag，不详述。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> Step5&lt;dim&gt;::<span class="built_in">run</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    GridIn&lt;dim&gt; grid_in;</span><br><span class="line">    grid_in.<span class="built_in">attach_triangulation</span> (triangulation);</span><br><span class="line">    <span class="function">std::ifstream <span class="title">input_file</span><span class="params">(<span class="string">&quot;circle-grid.inp&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>run函数中直接读入网格文件，这里是个inp后缀的。因为该网格是二维的，所以Assert一下如果不是二维的，就抛出一个异常：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Assert</span> (dim==<span class="number">2</span>, <span class="built_in">ExcInternalError</span>());</span><br></pre></td></tr></table></figure>
<p>这是一个非规则网格文件UCD：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid_in.<span class="built_in">read_ucd</span> (input_file);</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> SphericalManifold&lt;dim&gt; boundary;</span><br><span class="line">triangulation.<span class="built_in">set_all_manifold_ids_on_boundary</span>(<span class="number">0</span>);</span><br><span class="line">triangulation.<span class="built_in">set_manifold</span> (<span class="number">0</span>, boundary);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> cycle=<span class="number">0</span>; cycle&lt;<span class="number">6</span>; ++cycle)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; <span class="string">&#x27;:&#x27;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (cycle != <span class="number">0</span>)</span><br><span class="line">        triangulation.<span class="built_in">refine_global</span> (<span class="number">1</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; Number of active cells: &quot;</span></span><br><span class="line">        &lt;&lt; triangulation.<span class="built_in">n_active_cells</span>()</span><br><span class="line">        &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot; Total number of cells: &quot;</span></span><br><span class="line">        &lt;&lt; triangulation.<span class="built_in">n_cells</span>()</span><br><span class="line">        &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">setup_system</span> ();</span><br><span class="line">    <span class="built_in">assemble_system</span> ();</span><br><span class="line">    <span class="built_in">solve</span> ();</span><br><span class="line">    <span class="built_in">output_results</span> (cycle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后创建一个流形，来告诉triangulation在网格细化后如何在边界上加点。<br>然后是main函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Step5&lt;<span class="number">2</span>&gt; laplace_problem_2d;</span><br><span class="line">    laplace_problem_2d.<span class="built_in">run</span> ();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       Coefficient&lt;2&gt; coefficient;</span></span><br><span class="line"><span class="comment">       std::vector&lt;Point&lt;2&gt; &gt; points (2);</span></span><br><span class="line"><span class="comment">       std::vector&lt;double&gt; coefficient_values (1);</span></span><br><span class="line"><span class="comment">       coefficient.value_list (points, coefficient_values);</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释起来的代码是为了得到Assert的异常信息。</p>
<h1 id="计算结果"><a href="#计算结果" class="headerlink" title="计算结果"></a>计算结果</h1><p>每次细化结果为：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjkgydl3lj308d06ldgs.jpg"><br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjkh9l2r6j308d06uac6.jpg"><br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjkhu0robj308d06u0vs.jpg"><br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjki7mzf5j308d06u0wd.jpg"><br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjkifcrm6j308d06uadz.jpg"><br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjkisk167j308d06u41z.jpg"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2016/08/27/dealii-learn-step4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Be interesting!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亓欣波">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/08/27/dealii-learn-step4/" class="post-title-link" itemprop="url">求解偏微分方程开源有限元软件deal.II学习--Step 4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-08-27 00:00:00" itemprop="dateCreated datePublished" datetime="2016-08-27T00:00:00+08:00">2016-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 15:20:30" itemprop="dateModified" datetime="2021-03-25T15:20:30+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computational-material-science/" itemprop="url" rel="index"><span itemprop="name">computational material science</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2016/08/27/dealii-learn-step4/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/08/27/dealii-learn-step4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>deal.II有一个特性，叫作”维度无关的编程“。前面的例子中，很多类都有一个尖括号括起的数字的后缀。<br>这意味着该类能作用在不同的维度上，而不同维度的计算代码基本相同，这能显著地减少重复代码。这正是C++的模板template的拿手好戏。<br>在Step4中，将显示程序怎样维度无关的编程，具体是将step3中的Laplace问题同时在二维和三维上求解，以及右端项不再是常量、边界值不再为0。</p>
<h1 id="程序解析"><a href="#程序解析" class="headerlink" title="程序解析"></a>程序解析</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_handler.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/grid_generator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria_accessor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria_iterator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_accessor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/fe/fe_q.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_tools.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/fe/fe_values.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/quadrature_lib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/function.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/vector_tools.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/matrix_tools.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/vector.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/full_matrix.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/sparse_matrix.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/solver_cg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/precondition.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/data_out.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/logstream.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> dealii;</span><br></pre></td></tr></table></figure>
<p>最后一个头文件logstream是为了压缩输出信息。<br>下面就是step4类，它的形式跟step3相同，只不过将之前的2维改成这里的dim，相应地改用了类模板的形式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Step4</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Step4</span> ();</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">make_grid</span> <span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setup_system</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">assemble_system</span> <span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">output_results</span> <span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        Triangulation&lt;dim&gt; triangulation;</span><br><span class="line">        FE_Q&lt;dim&gt; fe;</span><br><span class="line">        DoFHandler&lt;dim&gt; dof_handler;</span><br><span class="line">        SparsityPattern sparsity_pattern;</span><br><span class="line">        SparseMatrix&lt;<span class="keyword">double</span>&gt; system_matrix;</span><br><span class="line">        Vector&lt;<span class="keyword">double</span>&gt; solution;</span><br><span class="line">        Vector&lt;<span class="keyword">double</span>&gt; system_rhs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面的右端项和边界条件也都是类模板的形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RightHandSide</span> :</span> <span class="keyword">public</span> Function&lt;dim&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">RightHandSide</span> () : Function&lt;dim&gt;() &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">value</span> <span class="params">(<span class="keyword">const</span> Point&lt;dim&gt; &amp;p,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundaryValues</span> :</span> <span class="keyword">public</span> Function&lt;dim&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">BoundaryValues</span> () : Function&lt;dim&gt;() &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">value</span> <span class="params">(<span class="keyword">const</span> Point&lt;dim&gt; &amp;p,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> component = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看出，两者都是继承自Function类，其中的value函数是一个虚函数，需要自定义一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">double</span> RightHandSide&lt;dim&gt;::<span class="built_in">value</span> (<span class="keyword">const</span> Point&lt;dim&gt; &amp;p,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> / *component* /) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">double</span> return_value = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dim; ++i)</span><br><span class="line">        return_value += <span class="number">4.0</span> * std::<span class="built_in">pow</span>(<span class="built_in">p</span>(i), <span class="number">4.0</span>);</span><br><span class="line">    <span class="keyword">return</span> return_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，Point<dim>代表n维的点，可以用圆括号来访问它的分量。<br>右端项同理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">double</span> BoundaryValues&lt;dim&gt;::<span class="built_in">value</span> (<span class="keyword">const</span> Point&lt;dim&gt; &amp;p,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> / *component* /) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> p.<span class="built_in">square</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只是这里取的右端项正好是点的平方，所以直接调用平方函数即可。<br>下面是step4的具体应用，它的每个成员函数的具体实现前面也要加template。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line">Step4&lt;dim&gt;::<span class="built_in">Step4</span> ()</span><br><span class="line">    :</span><br><span class="line">        <span class="built_in">fe</span> (<span class="number">1</span>),</span><br><span class="line">        <span class="built_in">dof_handler</span> (triangulation)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> Step4&lt;dim&gt;::<span class="built_in">make_grid</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    GridGenerator::<span class="built_in">hyper_cube</span> (triangulation, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">    triangulation.<span class="built_in">refine_global</span> (<span class="number">4</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; Number of active cells: &quot;</span></span><br><span class="line">        &lt;&lt; triangulation.<span class="built_in">n_active_cells</span>()</span><br><span class="line">        &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot; Total number of cells: &quot;</span></span><br><span class="line">        &lt;&lt; triangulation.<span class="built_in">n_cells</span>()</span><br><span class="line">        &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> Step4&lt;dim&gt;::<span class="built_in">setup_system</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    dof_handler.<span class="built_in">distribute_dofs</span> (fe);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; Number of degrees of freedom: &quot;</span></span><br><span class="line">        &lt;&lt; dof_handler.<span class="built_in">n_dofs</span>()</span><br><span class="line">        &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">DynamicSparsityPattern <span class="title">dsp</span><span class="params">(dof_handler.n_dofs())</span></span>;</span><br><span class="line">    DoFTools::<span class="built_in">make_sparsity_pattern</span> (dof_handler, dsp);</span><br><span class="line">    sparsity_pattern.<span class="built_in">copy_from</span>(dsp);</span><br><span class="line">    system_matrix.<span class="built_in">reinit</span> (sparsity_pattern);</span><br><span class="line">    solution.<span class="built_in">reinit</span> (dof_handler.<span class="built_in">n_dofs</span>());</span><br><span class="line">    system_rhs.<span class="built_in">reinit</span> (dof_handler.<span class="built_in">n_dofs</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是其构造函数、make_grid和setup_system成员函数，跟step3中基本相同，差别就是加入了dim。<br>以下就是跟之前不同了，这里使用的是非常量的右端项和非零边界条件，与前面稍有不同，体现在代码上也是稍有不同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> Step4&lt;dim&gt;::<span class="built_in">assemble_system</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">QGauss&lt;dim&gt; <span class="title">quadrature_formula</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对于非常量的rhs，需要创建它的一个对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RightHandSide&lt;dim&gt; right_hand_side;</span><br></pre></td></tr></table></figure>
<p>为了对每个单元都计算右端项，还得需要单元上的积分点信息，所以得在FEValues说明一下需要更新积分点信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FEValues&lt;dim&gt; <span class="title">fe_values</span> <span class="params">(fe, quadrature_formula,</span></span></span><br><span class="line"><span class="function"><span class="params">        update_values | update_gradients |</span></span></span><br><span class="line"><span class="function"><span class="params">        update_quadrature_points | update_JxW_values)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后就是对单元上的矩阵和右端项的计算：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> dofs_per_cell = fe.dofs_per_cell;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> n_q_points = quadrature_formula.<span class="built_in">size</span>();</span><br><span class="line"><span class="function">FullMatrix&lt;<span class="keyword">double</span>&gt; <span class="title">cell_matrix</span> <span class="params">(dofs_per_cell, dofs_per_cell)</span></span>;</span><br><span class="line"><span class="function">Vector&lt;<span class="keyword">double</span>&gt; <span class="title">cell_rhs</span> <span class="params">(dofs_per_cell)</span></span>;</span><br><span class="line"><span class="function">std::vector&lt;types::global_dof_index&gt; <span class="title">local_dof_indices</span> <span class="params">(dofs_per_cell)</span></span>;</span><br><span class="line"><span class="keyword">typename</span> DoFHandler&lt;dim&gt;::active_cell_iterator</span><br><span class="line">    cell = dof_handler.<span class="built_in">begin_active</span>(),</span><br><span class="line">         endc = dof_handler.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">for</span> (; cell!=endc; ++cell)</span><br><span class="line">&#123;</span><br><span class="line">    fe_values.<span class="built_in">reinit</span> (cell);</span><br><span class="line">    cell_matrix = <span class="number">0</span>;</span><br><span class="line">    cell_rhs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> q_index=<span class="number">0</span>; q_index&lt;n_q_points; ++q_index)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dofs_per_cell; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j=<span class="number">0</span>; j&lt;dofs_per_cell; ++j)</span><br><span class="line">                <span class="built_in">cell_matrix</span>(i,j) += (fe_values.<span class="built_in">shape_grad</span> (i, q_index) *</span><br><span class="line">                        fe_values.<span class="built_in">shape_grad</span> (j, q_index) *</span><br><span class="line">                        fe_values.<span class="built_in">JxW</span> (q_index));</span><br><span class="line">            <span class="built_in">cell_rhs</span>(i) += (fe_values.<span class="built_in">shape_value</span> (i, q_index) *</span><br><span class="line">                    right_hand_side.<span class="built_in">value</span> (fe_values.<span class="built_in">quadrature_point</span> (q_index)) *</span><br><span class="line">                    fe_values.<span class="built_in">JxW</span> (q_index));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这里就将rhs和matrix同时在一个循环中计算。另外，在cell_rhs的计算时，乘以的不再是1，而是函数在积分点上的值。<br>然后再组装整体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cell-&gt;<span class="built_in">get_dof_indices</span> (local_dof_indices);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dofs_per_cell; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j=<span class="number">0</span>; j&lt;dofs_per_cell; ++j)</span><br><span class="line">        system_matrix.<span class="built_in">add</span> (local_dof_indices[i],</span><br><span class="line">                local_dof_indices[j],</span><br><span class="line">                <span class="built_in">cell_matrix</span>(i,j));</span><br><span class="line">    <span class="built_in">system_rhs</span>(local_dof_indices[i]) += <span class="built_in">cell_rhs</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，这里已将两个循环合并。<br>然后就是将不为0的边界条件加入，就是将step3中的ZeroFunction换成上面的BoundaryValues类的对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;types::global_dof_index,<span class="keyword">double</span>&gt; boundary_values;</span><br><span class="line">VectorTools::<span class="built_in">interpolate_boundary_values</span> (dof_handler,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        BoundaryValues&lt;dim&gt;(),</span><br><span class="line">        boundary_values);</span><br><span class="line">MatrixTools::<span class="built_in">apply_boundary_values</span> (boundary_values,</span><br><span class="line">        system_matrix,</span><br><span class="line">        solution,</span><br><span class="line">        system_rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是求解了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> Step4&lt;dim&gt;::<span class="built_in">solve</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">SolverControl <span class="title">solver_control</span> <span class="params">(<span class="number">1000</span>, <span class="number">1e-12</span>)</span></span>;</span><br><span class="line">    SolverCG&lt;&gt; <span class="built_in">solver</span> (solver_control);</span><br><span class="line">    solver.<span class="built_in">solve</span> (system_matrix, solution, system_rhs,</span><br><span class="line">            <span class="built_in">PreconditionIdentity</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; solver_control.<span class="built_in">last_step</span>()</span><br><span class="line">        &lt;&lt; <span class="string">&quot; CG iterations needed to obtain convergence.&quot;</span></span><br><span class="line">        &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟之前差不多，只是这里手动输出迭代步数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> Step4&lt;dim&gt;::<span class="built_in">output_results</span> () <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    DataOut&lt;dim&gt; data_out;</span><br><span class="line">    data_out.<span class="built_in">attach_dof_handler</span> (dof_handler);</span><br><span class="line">    data_out.<span class="built_in">add_data_vector</span> (solution, <span class="string">&quot;solution&quot;</span>);</span><br><span class="line">    data_out.<span class="built_in">build_patches</span> ();</span><br><span class="line">    <span class="function">std::ofstream <span class="title">output</span> <span class="params">(dim == <span class="number">2</span> ?</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">&quot;solution-2d.vtk&quot;</span> :</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">&quot;solution-3d.vtk&quot;</span>)</span></span>;</span><br><span class="line">    data_out.<span class="built_in">write_vtk</span> (output);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出文件的格式也由gnuplot改成了VTK格式。也将2维和3维的数据用不同的文件名区分。<br>run函数无须多说：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> dim&gt;</span><br><span class="line"><span class="keyword">void</span> Step4&lt;dim&gt;::<span class="built_in">run</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Solving problem in &quot;</span> &lt;&lt; dim &lt;&lt; <span class="string">&quot; space dimensions.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">make_grid</span>();</span><br><span class="line">    <span class="built_in">setup_system</span> ();</span><br><span class="line">    <span class="built_in">assemble_system</span> ();</span><br><span class="line">    <span class="built_in">solve</span> ();</span><br><span class="line">    <span class="built_in">output_results</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deallog.<span class="built_in">depth_console</span> (<span class="number">0</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        Step4&lt;<span class="number">2</span>&gt; laplace_problem_2d;</span><br><span class="line">        laplace_problem_2d.<span class="built_in">run</span> ();</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        Step4&lt;<span class="number">3</span>&gt; laplace_problem_3d;</span><br><span class="line">        laplace_problem_3d.<span class="built_in">run</span> ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2d和3d的切换是如此从容，注意：这里用花括号将两者分开，是为了及时销毁变量和释放内存。</p>
<h1 id="计算结果"><a href="#计算结果" class="headerlink" title="计算结果"></a>计算结果</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Solving problem in <span class="number">2</span> space dimensions.</span><br><span class="line">Number of active cells: <span class="number">256</span></span><br><span class="line">Total number of cells: <span class="number">341</span></span><br><span class="line">Number of degrees of freedom: <span class="number">289</span></span><br><span class="line"><span class="number">26</span> CG iterations needed to obtain convergence.</span><br><span class="line">Solving problem in <span class="number">3</span> space dimensions.</span><br><span class="line">Number of active cells: <span class="number">4096</span></span><br><span class="line">Total number of cells: <span class="number">4681</span></span><br><span class="line">Number of degrees of freedom: <span class="number">4913</span></span><br><span class="line"><span class="number">30</span> CG iterations needed to obtain convergence.</span><br></pre></td></tr></table></figure>
<p>可以看出3维时的自由度数要大很多，计算量也相应增大。<br>2维计算结果为：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjkk1jqg9j30qx0k5abx.jpg"><br>3维计算结果为：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjkkbrbhcj30qx0k542b.jpg"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2016/08/25/dealii-learn-step3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Be interesting!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亓欣波">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/08/25/dealii-learn-step3/" class="post-title-link" itemprop="url">求解偏微分方程开源有限元软件deal.II学习--Step 3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-08-25 00:00:00" itemprop="dateCreated datePublished" datetime="2016-08-25T00:00:00+08:00">2016-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 15:20:30" itemprop="dateModified" datetime="2021-03-25T15:20:30+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computational-material-science/" itemprop="url" rel="index"><span itemprop="name">computational material science</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2016/08/25/dealii-learn-step3/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/08/25/dealii-learn-step3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>这是使用有限元法进行具体计算的第一个算例，求解的是一个简化的Possion方程，其在边界上为0，而右端项不为0，即：<br>$$<br>\begin{equation}<br>\begin{split}<br>-\Delta u &amp;=f \qquad in \qquad \Omega; \<br>u &amp;=0 \qquad on \qquad \partial \Omega<br>\end{split}<br>\end{equation}<br>$$<br>求解域是单位正方形$\Omega=[0,1]^2$，其上的网格划分在step1和step2中已经涉及。<br>这里也仅仅计算特例$f(x)=1$，更一般的情形详见step4。</p>
<h1 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h1><p>首先需要得到上述方程的弱形式，即在方程两侧左乘一个测试函数$\phi$并在计算域上积分(注意是左乘，而不是右乘)：<br>$$<br>-\int_{\Omega}\phi\Delta u=\int_{\Omega}\phi f<br>$$<br>然后利用高斯散度公式进行分部积分，可得：<br>$$<br>\int_{\Omega}\nabla\phi\cdot\nabla u-\int_{\partial\Omega}\phi\vec n\cdot\nabla u =<br>\int_\Omega\phi f<br>$$<br>同时，因为测试函数必须满足相同的边界条件，即在边界上$\phi=0$，所以上式变为：<br>$$<br>(\nabla \phi,\nabla u)=(\phi,f)<br>$$<br>这里应用了通常的简写形式：$(a,b)=\int_\Omega ab$。<br>那么问题就变成了找到在所在空间上对于所有的测试函数上式都成立的函数$u$。当然在计算机上我们不能找到这样的函数的一个通用形式，事实上是寻找一个近似表达式$u_h(x)=\sum_jU_j\phi_j(x)$，其中$U_j$是需要确定的未知系数(即自由度)，而$\phi_j(x)$是有限单元的形函数。同样可以对试探函数作这样的处理，其实之前的形式中已经把试探函数取为了形函数。另外，由于可以任意选择试验函数，因此可以将除了j点之外的所有的$\phi_j$设置为0。<br>为了确定形函数，需要作如下工作：</p>
<ul>
<li>形函数所在的网格。在step1和step2中已经有关于产生网格的方法。</li>
<li>描述形函数形式的参考单元。比如二维下的双线性单元。</li>
<li>枚举网格上所有自由度的DofHandler对象。</li>
<li>描述由参考单元的形函数获得真实单元的形函数的映射，默认deal.II使用线性映射。</li>
</ul>
<p>通过上述几步就得到了形函数的集合，那么就可以得到离散形式的弱形式，即：<br>$$<br>(\nabla \phi_i,\nabla u_h)=(\phi_i,f) \qquad i=0…N-1<br>$$<br>对于每个试验函数都可以得到一个方程，所有方程就可以生成一个线性代数系统。将$u_h$的表达式代入，可得：<br>$$<br>(\nabla \phi_i,\nabla \sum_jU_j\phi_j)=(\phi_i,f) \qquad i=0…N-1<br>$$<br>整理得：<br>$$<br>\sum_j(\nabla\phi_i,\nabla\phi_j)U_j=(\phi_i,f) \qquad i=0…N-1<br>$$<br>展开形式为：<br>$$<br>\begin{bmatrix}<br>(\nabla\phi_0,\nabla\phi_0) &amp; (\nabla\phi_0,\nabla\phi_1) &amp; \cdots &amp; (\nabla\phi_0,\nabla\phi_j) \<br>(\nabla\phi_1,\nabla\phi_0) &amp; (\nabla\phi_1,\nabla\phi_1) &amp; \cdots &amp; (\nabla\phi_1,\nabla\phi_j) \<br>. \<br>(\nabla\phi_{N-1},\nabla\phi_0) &amp; (\nabla\phi_{N-1},\nabla\phi_1) &amp; \cdots &amp; (\nabla\phi_{N-1},\nabla\phi_j)<br>\end{bmatrix}<br>\begin{bmatrix}<br>u_0 \<br>u_1 \<br>. \<br>u_{j}<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>(\phi_0,f) \<br>(\phi_1,f) \<br>. \<br>(\phi_j,f)<br>\end{bmatrix}<br>$$</p>
<p>采用矩阵形式：<br>$$<br>AU=F<br>$$<br>所以，矩阵的元素$A_{ij}=(\nabla\phi_i,\nabla\phi_j)$。<br>右端项的元素$F_i=(\phi_i,f)$。$\sum_j$代表矩阵运算中每个方程的相加操作。<br>注意：以上都是对节点的循环，对单元的循环则需要对上述矩阵进行分块，比如如果0号、1号、2号节点在单元0上，那么左上角的九个量就形成一个子矩阵。上述矩阵整体可称为整体刚度矩阵，但单元刚度矩阵则需要是对单元进行循环得到的分块矩阵，即单元刚度矩阵必须建立在单元上。<br>上面两个元素都含有积分，因此还需要求解积分，数学上的积分是连续的，但有限元必须离散到每个单元上来求解。通常使用如下方法：在每个单元上取一系列积分点，积分由函数在这些积分点上的值的和来代替，即：<br>$$<br>\begin{equation}<br>\begin{split}<br>A^K_{ij} &amp;= \int_K \nabla\phi_i \cdot \nabla \phi_j \approx \sum_q \nabla\phi_i(x^K_q) \cdot \nabla \phi_j(x^K_q) w_q^K, \<br>F^K_i &amp;= \int_K \phi_i f \approx \sum_q \phi_i(x^K_q) f(x^K_q) w^K_q<br>\end{split}<br>\end{equation}<br>$$<br>其中，$x^k_q$是单元K上的第q个积分点，$w^k_q$是该积分点的权重。<br>注意：积分必须在单元上进行，所以必须是对单元的循环。<br>再次Attention！！：这样，循环的过程就是这样：先是对单元循环，找到当前的单元，然后对单元上的积分点进行循环，目的就是为了能计算积分，再对自由度循环，找到相互作用的i、j，计算了刚度矩阵后放入合适的位置。</p>
<p>附录：从参考单元向真实单元的映射过程<br>映射就是一个变换$x=F_K(\widehat{x})$，它将参考单元$[0,1]^{dim}$中的点$\widehat{x}$映射到真实网格单元$K\subset R^{spacedim}$中的点$x$。<br>一些复杂映射通常需要这种映射的Jacobian矩阵，即$J(\widehat{x})=\widehat{\nabla}F_K(\widehat{x})$。比如，如果$dim=spacedim=2$，那么：<br>$$<br>J(\widehat{x})<br>\begin{bmatrix}<br>\frac{\partial x}{\partial\widehat{x}} &amp; \frac{\partial x}{\partial\widehat{y}} \<br>\frac{\partial y}{\partial\widehat{x}} &amp; \frac{\partial y}{\partial\widehat{y}}<br>\end{bmatrix}<br>$$</p>
<ol>
<li><p>标量函数的映射<br>形函数是定义在参考单元中，它通过以下映射到真实单元中：<br>$$<br>\phi(x)=\phi(F_K(\widehat{x}))=\widehat{\phi}(\widehat{x})<br>$$</p>
</li>
<li><p>积分的映射<br>积分的映射关系如下：<br>$$<br>\int_K u(x)dx = \int_{\widehat K} \widehat u(\widehat{x}) \left|\text{det}J(\widehat{x})\right| d\widehat x.<br>$$<br>将上述积分由在积分点上的离散形式表示：<br>$$<br>\int_K u(x)dx \approx \sum_{q} \widehat u(\widehat{x}_q) \underbrace{\left|\text{det}J(\widehat{x}_q)\right| w_q}_{=: \text{JxW}_q}.<br>$$<br>其中，$JxW$是一个象形词，代表Jacobian行列式乘以积分权重，数学上来说，积分点上的$Jxw_q$也就承担了原来积分中的$dx$的作用，它们在编程中可以由FEValues::JxW()函数获得。</p>
</li>
<li><p>矢量、微分和矢量的梯度的映射<br>矢量场和微分(即标量场的梯度)统一记为$v$，矢量场的梯度记为$T$，它们的映射形式为：<br>$$<br>v(x)=A(\widehat{x})\widehat{v}(\widehat{x}), \qquad<br>T(x)=A(\widehat{x})\widehat{T}(\widehat{x})B(\widehat{x})<br>$$<br>微分$A$和$B$需要通过要变换的对象来具体确定。</p>
</li>
<li><p>映射的导数<br>某些情况下还需要计算映射的导数，一阶导数就是上面的Jacobian矩阵。更高阶的导数类似，比如Jacobian矩阵的导数，还有Jacobian二阶导数等，具体形式参见帮助文档。</p>
</li>
</ol>
<h1 id="deal-II的程序结构"><a href="#deal-II的程序结构" class="headerlink" title="deal.II的程序结构"></a>deal.II的程序结构</h1><p><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjkliv2w9j30gm0atjru.jpg"><br>deal.II采用面向对象编程，其中包含了很多的Modules，各自实现不同的功能，并有机地结合起来。如上图所示。具体为：</p>
<ol>
<li><p>Triangulation<br>Triangulations是单元及其更低维度的边界的集合。triangulation存储了网格的几何和拓扑性质：单元怎样接触，它们的顶点在哪里。triangulation不知道将要在它上面使用的有限元的任何信息，甚至不知道它自己的单元的形状，它只知道在二维情形下有4条线段和4个顶点，三维下有6个面、12条线段和8个顶点。不过其他所有信息都定义在映射类mapping中，由该类将参考单元的坐标映射到真实单元的坐标上，通常采用线性映射。<br>当需要访问triangulation的性质和数据时，通过使用iterators迭代器对单元进行循环。</p>
</li>
<li><p>Finite Element<br>Finite element类用来描述定义在参考单元上的有限元空间的性质，比如在单元的顶点、线段或内部各有多少自由度，此外还给出节点上的形函数的值及其梯度。</p>
</li>
<li><p>Quadrature<br>跟Finite element相同，Quadrature也定义在单元上，用来描述参考单元上积分点的位置及其权重。</p>
</li>
<li><p>DoFHandler<br>DoFHandler对象是triangulations和finite elements的汇合点：finite element类描述了triangulation单元的点、线或内部需要多少自由度，而DoFHandler分配了这种空间，从而使得点、线或内部都有正确的数目，同时也给这些自由度统一编号。<br>也可以这样理解：triangulation和finite element描述了有限元空间的具体性质(有限元空间就是用来得到离散解的空间)，DoFHandler则枚举了该空间的基本框架，使得我们可以用一系列有序的系数$U_j$来表示离散解$u_h(x)=\sum_jU_j\phi_i(x)$。<br>正如triangulation对象，DoFHandler也可以通过iterators迭代器对单元进行循环，从而得到具体的信息，比如单元的几何和拓扑信息(这些也可以由triangulation迭代获得，其实两个类是派生关系)，以及当前单元上的自由度数目和数值。需要注意的是，跟triangulation一样，DoFHandler也不知道从参考单元到它上面的真实单元的映射，也不知道对应于它所管理的自由度的形函数。</p>
</li>
<li><p>Mapping<br>Mapping类就是建立从参考单元到triangulation的单元的映射，包括形函数、积分点和积分权重，同时提供了这种派生的梯度和Jacobian行列式。</p>
</li>
<li><p>FEValues<br>这一步就是真正地取出某个单元，计算它上面在积分点上的形函数值及其梯度。注意，有限元空间不是连续的，积分都是在特定积分点上计算。</p>
</li>
<li><p>Linear Systems<br>一旦知道了怎样使用FEValues在单个单元上计算形函数值及其梯度，同时知道怎样使用DoFHandler获得自由度的全局标识，那么就可以使用矩阵类和向量类来存储和管理矩阵和向量的元素，从而形成线性系统。</p>
</li>
<li><p>Linear Solvers<br>构建好线性系统后，就可以使用求解器来求解该系统。</p>
</li>
<li><p>Output<br>求解完毕后，就可以输出结果到可视化软件中进行后处理。</p>
</li>
</ol>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_handler.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>这两个头文件分别处理triangulation和自由度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/grid_generator.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>该文件用于生成网格。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria_accessor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria_iterator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_accessor.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>这三个文件用来对单元进行循环并获得单元上的信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/fe/fe_q.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>该文件包含拉格朗日插值的描述。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_tools.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/fe/fe_values.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/quadrature_lib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/base/function.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/vector_tools.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/matrix_tools.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/vector.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/full_matrix.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/sparse_matrix.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/solver_cg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/precondition.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/numerics/data_out.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>以上头文件还需仔细理解。</p>
<h2 id="step3类"><a href="#step3类" class="headerlink" title="step3类"></a>step3类</h2><p>跟之前两个例子不同，这次将信息都封装在了一个类里面。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Step3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Step3</span> ();</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>这是类的public部分，包含一个构造函数和一个run函数，用来说明执行顺序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_grid</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup_system</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assemble_system</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output_results</span> <span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>这是类的private部分的成员函数，函数名说明了其要实现的功能。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Triangulation&lt;<span class="number">2</span>&gt; triangulation;</span><br><span class="line">FE_Q&lt;<span class="number">2</span>&gt; fe;</span><br><span class="line">DoFHandler&lt;<span class="number">2</span>&gt; dof_handler;</span><br><span class="line">SparsityPattern sparsity_pattern;</span><br><span class="line">SparseMatrix&lt;<span class="keyword">double</span>&gt; system_matrix;</span><br><span class="line">Vector&lt;<span class="keyword">double</span>&gt; solution;</span><br><span class="line">Vector&lt;<span class="keyword">double</span>&gt; system_rhs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>还有成员变量，用来存储各种信息。<br>以下是step3类的各个成员函数的详解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Step3::<span class="built_in">Step3</span> ()</span><br><span class="line">    :</span><br><span class="line">    <span class="built_in">fe</span> (<span class="number">1</span>),</span><br><span class="line">    <span class="built_in">dof_handler</span> (triangulation)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这是step3类的构造函数，它没有执行具体操作，只是调用了成员初始器对fe和dof_handler进行了初始化。fe是一个finite element对象，它接收1，1是多项式的次数，表明使用的是双线性插值的形函数。<br>之前的triangulation也被传递给了dof_handler。注意此时triangulation还没有具体建立网格，但dof_handler不介意，它只有在具体分配自由度时才关心网格。<br>下一步必须做的就是对计算域进行剖分，然后对每个顶点分配自由度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Step3::make_grid</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GridGenerator::<span class="built_in">hyper_cube</span> (triangulation, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">    triangulation.<span class="built_in">refine_global</span> (<span class="number">5</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Number of active cells: &quot;</span></span><br><span class="line">        &lt;&lt; triangulation.<span class="built_in">n_active_cells</span>()</span><br><span class="line">        &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数做的是第一步，即对计算域进行剖分，建立网格。计算域是$[-1,1]x[-1,1]$。<br>因为初次建立时只有一个单元，所以细化5次，形成1024个单元，这里用n_active_cells()验证一下个数。注意这里用的不是n_cells()函数，因为其还包涵父单元的概念。<br>下一步就是分配自由度：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Step3::setup_system</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dof_handler.<span class="built_in">distribute_dofs</span> (fe);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Number of degrees of freedom: &quot;</span></span><br><span class="line">        &lt;&lt; dof_handler.<span class="built_in">n_dofs</span>()</span><br><span class="line">        &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>这里使用distribute_dofs()函数，接收的是fe，因为fe是线性插值，所以自由度是每个顶点上有一个。用n_dofs()输出一下，显示是1089。这是因为我们有32x32个网格，那么对应是33x33个节点。<br>然后创建稀疏矩阵</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DynamicSparsityPattern <span class="title">dsp</span><span class="params">(dof_handler.n_dofs())</span></span>;</span><br><span class="line">DoFTools::<span class="built_in">make_sparsity_pattern</span> (dof_handler, dsp);</span><br><span class="line">sparsity_pattern.<span class="built_in">copy_from</span>(dsp);</span><br><span class="line">system_matrix.<span class="built_in">reinit</span> (sparsity_pattern);</span><br></pre></td></tr></table></figure>
<p>注意，SparsityPattern和SparseMatrix不同，前者只存储元素的位置，后者则存储具体的数值。<br>然后建立右端项向量和解向量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">solution.<span class="built_in">reinit</span> (dof_handler.<span class="built_in">n_dofs</span>());</span><br><span class="line">system_rhs.<span class="built_in">reinit</span> (dof_handler.<span class="built_in">n_dofs</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一步就是计算线性系统中的矩阵中的元素以及右端项的元素，这是每个有限元程序的核心部分！<br>组装矩阵和向量通常的方法是对所有单元进行循环，然后在每个单元上进行积分运算，得到该单元对整体的贡献。需要注意的是此时需要知道在每个真实单元上形函数在积分点位置上的值，但是！！形函数和积分点都是仅仅定义在参考单元上的，因此这些东西基本没用。那么关键问题来了，就是怎样将数据从参考单元上映射到真实单元上。这个活是由Mapping类来完成的，更加智能的是通常不需要人为指定它怎么做，它自动按标准双线性映射来操作。<br>现在我们需要处理三类东西：有限元finite element、积分quadrature和映射mapping。这些概念太多了，这里有一个类FEValues来将三者有机地整合起来。给它传进去这三个东西，它就能告诉你在真实单元上的形函数的值和梯度。<br>那么现在就开干吧：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Step3::assemble_system</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QGauss&lt;2&gt; <span class="title">quadrature_formula</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>先确定在单元上的一套积分规则，这里使用的是Gauss数值积分方法，每个方向上选两个积分点。这套积分规则满足现在的问题。然后就可以生成FEValues的对象了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FEValues&lt;2&gt; <span class="title">fe_values</span> <span class="params">(fe, quadrature_formula,</span></span></span><br><span class="line"><span class="function"><span class="params">        update_values | update_gradients | update_JxW_values)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数告诉它参考单元是谁，第二个参数告诉它积分点及其权重(实际是一个Qudrature对象)，还有默认使用了双线性映射。最后告诉它需要在每个单元上计算什么，包括在积分点上的形函数值(为了计算右端项$\phi_i(x^K_q) f(x^K_q)$)、在积分点上的形函数梯度(为了计算矩阵元素$\nabla\phi_i(x^K_q) \cdot \nabla \phi_j(x^K_q)$)、Jacobian行列式。注意：这里都是积分点上的值。因为需要对单元进行循环，所有这些值需要更新，所以加上前缀update。这样显著地跟程序说明需要计算什么，就能加速运算，因为有的软件所有东西不管有用没用都一块计算，比如二阶导数、法向量等。注意最后用了按位或这一运算符，这在c语言中很常见，这里的意思就是我要计算谁“和”谁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> dofs_per_cell = fe.dofs_per_cell;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> n_q_points = quadrature_formula.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>
<p>然后定义两个“快捷名”来称呼常用的两个变量：每个单元上的自由度个数和积分点个数。<br>现在终于开始一个单元一个单元地组装整体刚度矩阵和向量了。一种方法是直接将结果写入整体矩阵中，但这样对于大型矩阵的运算通常是很慢的。所以，这里是先在当前单元上计算该单元的单元刚度矩阵，然后将它的贡献叠加到整体上。计算右端项向量时也是这样的。<br>首先先创建以上两种单元矩阵和单元向量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FullMatrix&lt;<span class="keyword">double</span>&gt; <span class="title">cell_matrix</span> <span class="params">(dofs_per_cell, dofs_per_cell)</span></span>;</span><br><span class="line"><span class="function">Vector&lt;<span class="keyword">double</span>&gt; <span class="title">cell_rhs</span> <span class="params">(dofs_per_cell)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当计算每个单元的贡献时，是对该单元上的自由度的局部标识进行循环，即从0到dofs_per_cell-1。<br>然而，当把结果传递给整体时，需要知道这些自由度的全局标识，这时需要一个临时的量来存储：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;types::global_dof_index&gt; <span class="title">local_dof_indices</span> <span class="params">(dofs_per_cell)</span></span>;</span><br></pre></td></tr></table></figure>
<p>来，现在真的要对单元进行循环：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DoFHandler&lt;<span class="number">2</span>&gt;::active_cell_iterator</span><br><span class="line">cell = dof_handler.<span class="built_in">begin_active</span>(),</span><br><span class="line">     endc = dof_handler.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">for</span> (; cell!=endc; ++cell)</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>现在，我们整个人站在单元上，我们想要知道在积分点上的形函数的值及其梯度以及参考单元和真实单元之间变换的Jacobian行列式。因为这些值与每个单元的几何信息有关，所以必须在每个单元上都需要让FEValues重算一下这些东西：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fe_values.<span class="built_in">reinit</span> (cell);</span><br></pre></td></tr></table></figure>
<p>初始化单元的贡献为0，以便后面的赋值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cell_matrix = <span class="number">0</span>;</span><br><span class="line">cell_rhs = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>然后开始积分，对积分点进行循环：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> q_index=<span class="number">0</span>; q_index&lt;n_q_points; ++q_index)</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>首先是对单元矩阵的计算：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dofs_per_cell; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j=<span class="number">0</span>; j&lt;dofs_per_cell; ++j)</span><br><span class="line">        <span class="built_in">cell_matrix</span>(i,j) += (fe_values.<span class="built_in">shape_grad</span> (i, q_index) *</span><br><span class="line">                fe_values.<span class="built_in">shape_grad</span> (j, q_index) *</span><br><span class="line">                fe_values.<span class="built_in">JxW</span> (q_index));</span><br></pre></td></tr></table></figure>
<p>对于拉普拉斯方程，每个单元上的矩阵是形函数i和j的梯度的积分，程序中用quadrature代替integral，所以变成两个梯度的乘积乘以Jacobian行列式(这是为了从参考单元到真实单元)和权重。这里的计算过程实际是这样的：<br>$fe_values.shape_grad(i,q_index)$是一个dim维(这里是2维)的向量，实际是一个Tensor&lt;1,dim&gt;的对象，后面的dim是维度，前面的1代表dim维的一阶向量，如果是0则代表标量，如果是2则代表dim乘以dim维的二阶张量。星号运算符则将前面的dim维向量跟后面的dim维向量正确地相乘，即两者做点积，结果是个标量，再跟后面的权重这一标量相乘。</p>
<p>然后对单元右端项向量的计算：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dofs_per_cell; ++i)</span><br><span class="line">    <span class="built_in">cell_rhs</span>(i) += (fe_values.<span class="built_in">shape_value</span> (i, q_index) *</span><br><span class="line">            <span class="number">1</span> *</span><br><span class="line">            fe_values.<span class="built_in">JxW</span> (q_index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的积分是形函数的值乘以f乘以JxW。<br>Attention!!:实际上上面两步计算可以将两个循环合并起来，加速计算，见后面的step4。<br>现在有了单元的矩阵，下一步就是把它组装到整体上。我们先得问问这个单元，它的某个局部标号的自由度的全局标识是多少：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cell-&gt;<span class="built_in">get_dof_indices</span> (local_dof_indices);</span><br></pre></td></tr></table></figure>
<p>后面就可以通过local_dof_indices[i]来获取全局标识。<br>然后再作循环叠加：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dofs_per_cell; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j=<span class="number">0</span>; j&lt;dofs_per_cell; ++j)</span><br><span class="line">system_matrix.<span class="built_in">add</span> (local_dof_indices[i],</span><br><span class="line">        local_dof_indices[j],</span><br><span class="line">        <span class="built_in">cell_matrix</span>(i,j));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dofs_per_cell; ++i)</span><br><span class="line"><span class="built_in">system_rhs</span>(local_dof_indices[i]) += <span class="built_in">cell_rhs</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理Attention！，这里也可以这样将两个循环合并。这样线性系统基本全做完了。But！还有一个重要的东西漏了：边界条件。事实上，如果该拉普拉斯方程不加上一个Dirichlet边界条件，它的解就不是惟一的，因为你可以在解上加一个任意的量。显然得解决这个问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;types::global_dof_index,<span class="keyword">double</span>&gt; boundary_values;</span><br><span class="line">VectorTools::<span class="built_in">interpolate_boundary_values</span> (dof_handler,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        ZeroFunction&lt;<span class="number">2</span>&gt;(),</span><br><span class="line">        boundary_values);</span><br></pre></td></tr></table></figure>
<p>这里使用的interpolate_boundary_values函数就是将函数值插入到特定位置的边界上，它需要的参数有：DoFHandler对象来获得边界上的自由度的全局标识;边界的一部分;边界上的值本身;输出对象。<br>”边界的一部分“意思是有时你只想在边界的一部分上赋予边界值，比如流体力学的入流和出流边界、变形体的固定部分等。这时可以对边界进行一部分一部分地标号，不同的标号施加不同的条件。默认条件下所有的边界标号都是0，这里也使用的是0，表明是对整个边界作用。描述边界值的函数这里用的是ZeroFunction，返回的是0，刚好适用现在的零边界条件。最后的输出对象boundary_values是一个列表，里面是成对的边界自由度全局标识及其对应的边界值。<br>知道上述信息后，再实际施加边界条件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MatrixTools::<span class="built_in">apply_boundary_values</span> (boundary_values,</span><br><span class="line">        system_matrix,</span><br><span class="line">        solution,</span><br><span class="line">        system_rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完全建立好线性系统了，终于该求解了。这个问题的变量个数是1089，实际是很小的量，通常的问题一般是10万个变量这个量级。传统的求解线性代数的算法，如Gauss消去或LU分解，对于大型系统不适用，这里用的是共轭梯度算法，即CG算法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Step3::solve</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">SolverControl <span class="title">solver_control</span> <span class="params">(<span class="number">1000</span>, <span class="number">1e-12</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>首先告诉CG算法何时停止计算，这里是创建一个SolverControl对象来控制：最多迭代1000步，精度为1e-12。通常这个精度值是迭代停止的判据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SolverCG&lt;&gt; <span class="built_in">solver</span> (solver_control);</span><br></pre></td></tr></table></figure>
<p>然后创建一个CG的求解器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">solver.<span class="built_in">solve</span> (system_matrix, solution, system_rhs,</span><br><span class="line">        <span class="built_in">PreconditionIdentity</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是开始求解了。第四个参数是一个预条件子。求解完毕后，solution中就存储了解向量的离散值。<br>然后就是输出结果了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Step3::output_results</span> <span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DataOut&lt;<span class="number">2</span>&gt; data_out;</span><br></pre></td></tr></table></figure>
<p>首先让它知道从哪里提取数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data_out.<span class="built_in">attach_dof_handler</span> (dof_handler);</span><br><span class="line">data_out.<span class="built_in">add_data_vector</span> (solution, <span class="string">&quot;solution&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>知道了目标数据后，离后面的可输出数据还隔了一个“中间数据”，因为deal.II是前后端分离的，这个中间数据像是个缓冲层，得到它的语句为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_out.<span class="built_in">build_patches</span> ();</span><br></pre></td></tr></table></figure>
<p>然后再输出成最终的可被可视化软件读取的数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::ofstream <span class="title">output</span> <span class="params">(<span class="string">&quot;solution.gpl&quot;</span>)</span></span>;</span><br><span class="line">data_out.<span class="built_in">write_gnuplot</span> (output);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面一系列的成员函数通过run函数来按次序执行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Step3::run</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">make_grid</span> ();</span><br><span class="line">    <span class="built_in">setup_system</span> ();</span><br><span class="line">    <span class="built_in">assemble_system</span> ();</span><br><span class="line">    <span class="built_in">solve</span> ();</span><br><span class="line">    <span class="built_in">output_results</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序的main函数为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deallog.<span class="built_in">depth_console</span> (<span class="number">2</span>);</span><br><span class="line">    Step3 laplace_problem;</span><br><span class="line">    laplace_problem.<span class="built_in">run</span> ();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个语句是打印log信息到屏幕上，后面就是创建step3对象，然后执行。</p>
<h1 id="计算结果"><a href="#计算结果" class="headerlink" title="计算结果"></a>计算结果</h1><p>输出到屏幕上的信息有：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Number of active cells: <span class="number">1024</span></span><br><span class="line">Number of degrees of freedom: <span class="number">1089</span></span><br><span class="line">DEAL:cg::Starting value <span class="number">0.121094</span></span><br><span class="line">DEAL:cg::Convergence step <span class="number">48</span> value <span class="number">5.33692e-13</span></span><br></pre></td></tr></table></figure>
<p>即，说明了单元个数1024、自由度个数1089，CG算法的起始残差是0.12，经过47步迭代后满足精度要求。<br>图形结果为：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjklvv10zj30hs0dc77g.jpg"><br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjkm5ntoaj30hs0dcjub.jpg"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2016/08/19/mathematica-fem-ch4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Be interesting!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亓欣波">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/08/19/mathematica-fem-ch4/" class="post-title-link" itemprop="url">利用Mathematica进行有限元编程(三)：三角形单元分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-08-19 00:00:00" itemprop="dateCreated datePublished" datetime="2016-08-19T00:00:00+08:00">2016-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 15:20:30" itemprop="dateModified" datetime="2021-03-25T15:20:30+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">programming</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2016/08/19/mathematica-fem-ch4/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/08/19/mathematica-fem-ch4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文是对<a target="_blank" rel="noopener" href="https://www.amazon.cn/Mathematica%E6%9C%89%E9%99%90%E5%85%83%E5%88%86%E6%9E%90%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%BA%94%E7%94%A8-%E9%B2%8D%E5%9B%9B%E5%85%83/dp/B00328IIOC">Mathematica有限元分析与工程应用</a>一书的学习笔记。</p>
<p>三角形单元适用于具有复杂和不规则边界形状的问题，是一种常见的网格离散方式。</p>
<h1 id="双线性三角形单元"><a href="#双线性三角形单元" class="headerlink" title="双线性三角形单元"></a>双线性三角形单元</h1><h2 id="局部坐标系"><a href="#局部坐标系" class="headerlink" title="局部坐标系"></a>局部坐标系</h2><p>之前的杆单元和桁架元的局部坐标系容易建立，即建在其自身上即可。而三角形单元的局部坐标系显然不能这样建立，其常采用一套无量纲的自然坐标系——面积坐标，如下图所示：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjjrmjerxj30c50890su.jpg"><br>三角形123内部有一任意点P，P与顶点1、2、3组成3个子三角形，每个子三角形的面积与总面积之比记为$L_i$，即P点的面积坐标为$(L_1,L_2,L_3)$。<br>因为三个坐标相加为1，所以仅有两个独立的自然坐标，所以可以简记为：<br>$$(\xi,\eta,1-\xi-\eta)$$<br>注意到：面积坐标还有如下特点，在顶点1时，$\xi=1$，其他坐标为0。其他顶点亦同，见上图三个顶点处的坐标值。因此，面积坐标还有形函数的功能。即：<br>$$<br>N_1=L_1=\xi, N_2=L_2=\eta, N_3=L_3=1-\xi-\eta<br>$$<br>写成矩阵形式为:<br>$$<br>ShapeN=<br>\begin{bmatrix}<br>\xi \<br>\eta \<br>1-\xi-\eta<br>\end{bmatrix}<br>$$<br>在局部坐标系下形函数对$\xi,\eta$的偏导数为：<br>$$<br>DeriveN=<br>\begin{bmatrix}<br>\partial ShapeN^T/\partial\xi \<br>\partial ShapeN^T/\partial\eta<br>\end{bmatrix}<br>$$<br>代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ShapeN = &#123;xi, eta, <span class="number">1</span> - xi - eta&#125;;</span><br><span class="line">DeriveN = &#123;D[ShapeN, xi], D[ShapeN, eta]&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>偏导数在不同坐标系下的变换：<br>$$<br>\begin{bmatrix}<br>\partial N_1/\partial\xi \<br>\partial N_1/\partial\eta<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>\partial x/\partial\xi &amp; \partial y/\partial\xi \<br>\partial x/\partial\eta &amp; \partial y/\partial\eta<br>\end{bmatrix}<br>\begin{bmatrix}<br>\partial N_1/\partial x \<br>\partial N_1/\partial y<br>\end{bmatrix}<br>=J<br>\begin{bmatrix}<br>\partial N_1/\partial x \<br>\partial N_1/\partial y<br>\end{bmatrix}<br>$$<br>其中，J为Jacobian矩阵。在上式中，当局部坐标系中明确给定函数$N_1$时，等式的左侧可以求出。同时，当基于局部坐标系给出x和y的显式表达时，基于局部坐标系也可以给出Jacobian矩阵的显式表达。具体过程如下：<br>根据等参元的性质，基于局部坐标给出的标准形函数与整体坐标的形函数完全形同，则：<br>$$<br>\begin{equation}<br>\begin{split}<br>x&amp;=N_1 x_1+N_2 x_2 +N_3 x_3 \<br>y&amp;=N_1 y_1+N_2 y_2 +N_3 y_3<br>\end{split}<br>\end{equation}<br>$$<br>所以，Jacobian矩阵为：<br>$$<br>J=<br>\begin{bmatrix}<br>\partial x/\partial\xi &amp; \partial y/\partial\xi \<br>\partial x/\partial\eta &amp; \partial y/\partial\eta<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>\sum\frac{\partial N_i}{\partial\xi}x_i &amp; \sum\frac{\partial N_i}{\partial\xi}y_i \<br>\sum\frac{\partial N_i}{\partial\eta}x_i &amp; \sum\frac{\partial N_i}{\partial\eta}y_i<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>\frac{\partial N_1}{\partial\xi} &amp; \frac{\partial N_2}{\partial\xi} &amp; \frac{\partial N_3}{\partial\xi} \<br>\frac{\partial N_1}{\partial\eta} &amp; \frac{\partial N_2}{\partial\eta} &amp; \frac{\partial N_3}{\partial\eta}<br>\end{bmatrix}<br>\begin{bmatrix}<br>x_1 &amp; y_1 \<br>x_2 &amp; y_2 \<br>x_3 &amp; y_3<br>\end{bmatrix}<br>$$<br>具体到这里使用的面积坐标，则有：<br>$$<br>\begin{equation}<br>\begin{split}<br>x&amp;=N_1 x_1+N_2 x_2 +N_3 x_3=\xi(x_1-x_3)+\eta(x_2-x_3)+x_3 \<br>y&amp;=N_1 y_1+N_2 y_2 +N_3 y_3=\xi(y_1-y_3)+\eta(y_2-y_3)+y_3<br>\end{split}<br>\end{equation}<br>$$<br>所以：<br>$$<br>J=<br>\begin{bmatrix}<br>x_1-x_3 &amp; y_1-y_3 \<br>x_2-x_3 &amp; y_2-y_3<br>\end{bmatrix}<br>$$</p>
<p>Jacobian矩阵的逆变换为：<br>$$<br>\begin{bmatrix}<br>\partial/\partial x \<br>\partial/\partial y<br>\end{bmatrix}<br>=J^{-1}<br>\begin{bmatrix}<br>\partial/\partial\xi \<br>\partial/\partial\eta<br>\end{bmatrix}<br>$$<br>而Jacobian行列式则为：<br>$$<br>|J|=<br>\begin{vmatrix}<br>\partial x/\partial\xi &amp; \partial y/\partial\xi \<br>\partial x/\partial\eta &amp; \partial y/\partial\eta<br>\end{vmatrix}<br>=\frac{\partial x}{\partial\xi}\frac{\partial y}{\partial\eta}-\frac{\partial y}{\partial\xi}\frac{\partial x}{\partial\eta}<br>$$<br>在求解刚度矩阵时，所对应的积分中要用到此行列式。积分过程中的变量和区域需要进行变换：<br>$$<br>dxdy=|J|d\xi d\eta<br>$$</p>
<p>Jacobian矩阵的逆矩阵和行列式则可以通过Inverse和Det命令求得。</p>
<h2 id="应力应变矩阵"><a href="#应力应变矩阵" class="headerlink" title="应力应变矩阵"></a>应力应变矩阵</h2><p>对平面应力问题，应力应变矩阵D为：<br>$$<br>D=\frac{E}{1-\nu^2}<br>\begin{bmatrix}<br>1 &amp; \nu &amp; 0 \<br>\nu &amp; 1 &amp; 0 \<br>0 &amp; 0 &amp; (1-\nu)/2<br>\end{bmatrix}<br>$$<br>对平面应变问题，应力应变矩阵D为：<br>$$<br>D=\frac{E}{(1+\nu)(1-2\nu)}<br>\begin{bmatrix}<br>1-\nu &amp; \nu &amp; 0 \<br>\nu &amp; 1-\nu &amp; 0 \<br>0 &amp; 0 &amp; (1-2\nu)/2<br>\end{bmatrix}<br>$$</p>
<h2 id="应变位移矩阵"><a href="#应变位移矩阵" class="headerlink" title="应变位移矩阵"></a>应变位移矩阵</h2><p>应变、位移的关系为：<br>$$<br>\epsilon=<br>\begin{bmatrix}<br>\frac{\partial}{\partial x} &amp; 0 \<br>0 &amp; \frac{\partial}{\partial y} \<br>\frac{\partial}{\partial y} &amp; \frac{\partial}{\partial x}<br>\end{bmatrix}<br>\begin{bmatrix}<br>u \<br>v<br>\end{bmatrix}<br>$$<br>代入位移函数表达式，可得：<br>$$<br>\epsilon=Ba=<br>\begin{bmatrix}<br>B_1 &amp; B_2 &amp; B_3<br>\end{bmatrix}<br>\begin{bmatrix}<br>a_1 \<br>a_2 \<br>a_3<br>\end{bmatrix}<br>$$<br>其中应变位移矩阵的一部分为：<br>$$<br>B1=<br>\begin{bmatrix}<br>\frac{\partial N_1}{\partial x} &amp; 0 \<br>0 &amp; \frac{\partial N_1}{\partial y} \<br>\frac{\partial N_1}{\partial y} &amp; \frac{\partial N_1}{\partial x}<br>\end{bmatrix}<br>$$</p>
<h2 id="单元刚度矩阵"><a href="#单元刚度矩阵" class="headerlink" title="单元刚度矩阵"></a>单元刚度矩阵</h2><p>根据最小势能原理，求得单元刚度矩阵表达式：<br>$$<br>K=\int_0^1\int_0^{1-\eta}B^TDBt|J|d\xi d\eta<br>$$</p>
<h2 id="模块分析"><a href="#模块分析" class="headerlink" title="模块分析"></a>模块分析</h2><h3 id="建立单元刚度矩阵"><a href="#建立单元刚度矩阵" class="headerlink" title="建立单元刚度矩阵"></a>建立单元刚度矩阵</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GenerateLinearTriangKm[cord_] := Module[&#123;Bmatrix, DeriveN, J, km&#125;,</span><br><span class="line">      n1 = xi; n2 = eta; n3 = <span class="number">1</span> - xi - eta;</span><br><span class="line">  bdv = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;&#125;;(*这里是局部坐标系下的偏导数*)</span><br><span class="line">  J = bdv.cord;(*求解Jacobian矩阵*)</span><br><span class="line">  bdv = Simplify[Inverse[J].bdv];(*转换成整体坐标系下的偏导数*)</span><br><span class="line">  Bmatrix = &#123;&#123;bdv[[<span class="number">1</span>, <span class="number">1</span>]], <span class="number">0</span>, bdv[[<span class="number">1</span>, <span class="number">2</span>]], <span class="number">0</span>, bdv[[<span class="number">1</span>, <span class="number">3</span>]], <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, </span><br><span class="line">              bdv[[<span class="number">2</span>, <span class="number">1</span>]], <span class="number">0</span>, bdv[[<span class="number">2</span>, <span class="number">2</span>]], <span class="number">0</span>, bdv[[<span class="number">2</span>, <span class="number">3</span>]]&#125;, &#123;bdv[[<span class="number">2</span>, <span class="number">1</span>]], </span><br><span class="line">              bdv[[<span class="number">1</span>, <span class="number">1</span>]], bdv[[<span class="number">2</span>, <span class="number">2</span>]], bdv[[<span class="number">1</span>, <span class="number">2</span>]], bdv[[<span class="number">2</span>, <span class="number">3</span>]], bdv[[<span class="number">1</span>, <span class="number">3</span>]]&#125;&#125;;</span><br><span class="line">  Dmatrix = </span><br><span class="line">     ee/(<span class="number">1</span> - nu*nu) &#123;&#123;<span class="number">1</span>, nu, <span class="number">0</span>&#125;, &#123;nu, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, (<span class="number">1</span> - nu)/<span class="number">2</span>&#125;&#125;;</span><br><span class="line">  km = h Integrate[</span><br><span class="line">       Det[J] (Transpose[Bmatrix].Dmatrix.Bmatrix), &#123;xi, <span class="number">0</span>, <span class="number">1</span>&#125;, &#123;eta, <span class="number">0</span>,</span><br><span class="line">                  <span class="number">1</span> - xi&#125;]</span><br><span class="line">                    ]</span><br></pre></td></tr></table></figure>
<h3 id="组装刚度矩阵"><a href="#组装刚度矩阵" class="headerlink" title="组装刚度矩阵"></a>组装刚度矩阵</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AssembleLinearTriangKm[p1_, p2_, p3_, m_] := </span><br><span class="line"> Module[&#123;f&#125;, f = &#123;p1, p2, p3&#125;;</span><br><span class="line">  For[j = <span class="number">1</span>, j &lt;= <span class="number">3</span>, j++, For[k = <span class="number">1</span>, k &lt;= <span class="number">3</span>, k++,</span><br><span class="line">      GlobalK[[<span class="number">2</span> f[[j]], <span class="number">2</span> f[[k]]]] += m[[<span class="number">2</span> j, <span class="number">2</span> k]];</span><br><span class="line">      GlobalK[[<span class="number">2</span> f[[j]] - <span class="number">1</span>, <span class="number">2</span> f[[k]]]] += m[[<span class="number">2</span> j - <span class="number">1</span>, <span class="number">2</span> k]];</span><br><span class="line">      GlobalK[[<span class="number">2</span> f[[j]], <span class="number">2</span> f[[k]] - <span class="number">1</span>]] += m[[<span class="number">2</span> j, <span class="number">2</span> k - <span class="number">1</span>]];</span><br><span class="line">      GlobalK[[<span class="number">2</span> f[[j]] - <span class="number">1</span>, <span class="number">2</span> f[[k]] - <span class="number">1</span>]] += m[[<span class="number">2</span> j - <span class="number">1</span>, <span class="number">2</span> k - <span class="number">1</span>]];</span><br><span class="line">      ]];</span><br><span class="line">  GlobalK]</span><br></pre></td></tr></table></figure>
<p>这里注意矩阵带不带Matrixform在计算时有很大区别。<br>注意这里的循环次数为3,是因为每个单元有3个节点。</p>
<h1 id="二次三角形单元"><a href="#二次三角形单元" class="headerlink" title="二次三角形单元"></a>二次三角形单元</h1><p>二次三角形单元就是在每条边上还各有一个节点，如图：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjjryk2i9j30fa0a774i.jpg"><br>具体分析过程跟双线性三角形单元相同，只不过形函数更加复杂。且在组装总刚时循环系数为6。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2016/08/18/mathematica-fem-ch3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Be interesting!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亓欣波">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/08/18/mathematica-fem-ch3/" class="post-title-link" itemprop="url">利用Mathematica进行有限元编程(二)：桁架元分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-08-18 00:00:00" itemprop="dateCreated datePublished" datetime="2016-08-18T00:00:00+08:00">2016-08-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 15:20:30" itemprop="dateModified" datetime="2021-03-25T15:20:30+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">programming</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2016/08/18/mathematica-fem-ch3/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/08/18/mathematica-fem-ch3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文是对<a target="_blank" rel="noopener" href="https://www.amazon.cn/Mathematica%E6%9C%89%E9%99%90%E5%85%83%E5%88%86%E6%9E%90%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%BA%94%E7%94%A8-%E9%B2%8D%E5%9B%9B%E5%85%83/dp/B00328IIOC">Mathematica有限元分析与工程应用</a>一书的学习笔记。</p>
<h1 id="桁架元的特点"><a href="#桁架元的特点" class="headerlink" title="桁架元的特点"></a>桁架元的特点</h1><p>平面桁架元是既有局部坐标又有整体坐标的二维有限元，因此比起之前的杆单元，需要多一步坐标变换。<br>桁架元示意图如下：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjjq6vt55j30l0098t8w.jpg"><br>指定整体坐标系为X-Y，局部坐标系为x-y。则两者之间的转换关系为：<br>$$<br>\begin{equation}<br>\begin{split}<br>U_{Xi}&amp;=u_{xi}cos\theta,U_{Yi}=u_{xi}sin\theta \<br>U_{Xj}&amp;=u_{xj}cos\theta,U_{Yj}=u_{xj}sin\theta<br>\end{split}<br>\end{equation}<br>$$<br>即：<br>$$<br>U=Tu<br>$$<br>其中：<br>$$<br>U=<br>\begin{bmatrix}<br>U_{Xi} \<br>U_{Yi} \<br>U_{Xj} \<br>U_{Yj}<br>\end{bmatrix}<br>,T=<br>\begin{bmatrix}<br>cos\theta &amp; 0 \<br>sin\theta &amp; 0 \<br>0 &amp; cos\theta \<br>0 &amp; sin\theta<br>\end{bmatrix}<br>,u=<br>\begin{bmatrix}<br>u_{xi} \<br>u_{xj}<br>\end{bmatrix}<br>$$<br>局部坐标系下的有限元方程为：<br>$$<br>f=Ku<br>$$<br>为了把有限元方程从局部坐标系变换到整体坐标系，可通过转换矩阵：<br>$$<br>u=T^{-1}U, f=T^{-1}F<br>$$<br>所以：<br>$$<br>F=TKT^{-1}U<br>$$<br>又因为转换矩阵T满足如下关系(可实际计算验证一下)：<br>$$<br>T^{T}T=I<br>$$<br>所以：<br>$$<br>F=TKT^TU=\overline{K}U<br>$$<br>所以整体坐标系的刚度矩阵与局部坐标系的刚度矩阵关系为：<br>$$<br>\overline{K}=TKT^T<br>$$<br>由于局部坐标系下的单元刚度矩阵为：<br>$$<br>K=<br>\begin{bmatrix}<br>k &amp; -k \<br>-k &amp; k<br>\end{bmatrix}<br>$$<br>其中$k=\frac{EA}{L}$。那么整体坐标系下的单刚为：<br>$$<br>\overline{K}=\frac{EA}{L}<br>\begin{bmatrix}<br>C^2 &amp; CS &amp; -C^2 &amp; -CS \<br>CS &amp; S^2 &amp; -CS &amp; -S^2 \<br>-C^2 &amp; -CS &amp; C^2 &amp; CS \<br>-CS &amp; -S^2 &amp; CS &amp; S^2<br>\end{bmatrix}<br>$$<br>其中$C=cos\theta,S=sin\theta$。</p>
<h1 id="模块分析："><a href="#模块分析：" class="headerlink" title="模块分析："></a>模块分析：</h1><h2 id="建立单元刚度矩阵-经过了坐标变换"><a href="#建立单元刚度矩阵-经过了坐标变换" class="headerlink" title="建立单元刚度矩阵(经过了坐标变换)"></a>建立单元刚度矩阵(经过了坐标变换)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TrussElementKm[EE_, AA_, LL_, theta_] := Module[&#123;&#125;,</span><br><span class="line">      x = theta*Pi/<span class="number">180</span>;</span><br><span class="line">  w1 = Cos[x]^<span class="number">2</span>;</span><br><span class="line">    w2 = Sin[x]^<span class="number">2</span>;</span><br><span class="line">      w3 = Sin[x]*Cos[x];</span><br><span class="line">        y = EE*AA/</span><br><span class="line">             LL*&#123;&#123;w1, w3, -w1, -w3&#125;, &#123;w3, w2, -w3, -w2&#125;, &#123;-w1, -w3, w1, </span><br><span class="line">                       w3&#125;, &#123;-w3, -w2, w3, w2&#125;&#125;;</span><br><span class="line">  y]</span><br></pre></td></tr></table></figure>
<h2 id="组装整体刚度矩阵"><a href="#组装整体刚度矩阵" class="headerlink" title="组装整体刚度矩阵"></a>组装整体刚度矩阵</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AssembleSpringKm[p1_, p2_, m_] := Module[&#123;j, k&#125;, f = &#123;p1, p2&#125;;</span><br><span class="line">  For[j = <span class="number">1</span>, j &lt;= <span class="number">2</span>, j++, For[k = <span class="number">1</span>, k &lt;= <span class="number">2</span>, k++,</span><br><span class="line">      GlobalK[[<span class="number">2</span> f[[j]], <span class="number">2</span> f[[k]]]] += m[[<span class="number">2</span> j, <span class="number">2</span> k]];</span><br><span class="line">    GlobalK[[<span class="number">2</span> f[[j]] - <span class="number">1</span>, <span class="number">2</span> f[[k]]]] += m[[<span class="number">2</span> j - <span class="number">1</span>, <span class="number">2</span> k]];</span><br><span class="line">        GlobalK[[<span class="number">2</span> f[[j]], <span class="number">2</span> f[[k]] - <span class="number">1</span>]] += m[[<span class="number">2</span> j, <span class="number">2</span> k - <span class="number">1</span>]];</span><br><span class="line">            GlobalK[[<span class="number">2</span> f[[j]] - <span class="number">1</span>, <span class="number">2</span> f[[k]] - <span class="number">1</span>]] += m[[<span class="number">2</span> j - <span class="number">1</span>, <span class="number">2</span> k - <span class="number">1</span>]];</span><br><span class="line">                ]];</span><br><span class="line">                  GlobalK]</span><br></pre></td></tr></table></figure>
<p>这里的组装与之前的杆单元不同，注意此处每个节点上有两个自由度，但总体原则还是将单刚的每个元素叠加到总刚的对应位置上，只是自由度的多少决定了每个单刚的矩阵块的大小，所以得乘以适当的系数。<br>比如平面刚架元，其既考虑轴向变形，也考虑弯曲变形，每个节点上有三个自由度，其总刚组装时的系数同时变化，如图：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjjqkfym8j30mc0ay3zt.jpg"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2016/08/17/mathematica-fem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Be interesting!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亓欣波">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/08/17/mathematica-fem/" class="post-title-link" itemprop="url">利用Mathematica进行有限元编程(一)：杆单元分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-08-17 00:00:00" itemprop="dateCreated datePublished" datetime="2016-08-17T00:00:00+08:00">2016-08-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 15:20:30" itemprop="dateModified" datetime="2021-03-25T15:20:30+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">programming</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2016/08/17/mathematica-fem/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/08/17/mathematica-fem/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文是对<a target="_blank" rel="noopener" href="https://www.amazon.cn/Mathematica%E6%9C%89%E9%99%90%E5%85%83%E5%88%86%E6%9E%90%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%BA%94%E7%94%A8-%E9%B2%8D%E5%9B%9B%E5%85%83/dp/B00328IIOC">Mathematica有限元分析与工程应用</a>一书的学习笔记。</p>
<p>这里的杆单元是总体坐标与局部坐标一致的一维有限元，因此不需要坐标变换，更易分析。</p>
<h1 id="线性杆单元的形函数"><a href="#线性杆单元的形函数" class="headerlink" title="线性杆单元的形函数"></a>线性杆单元的形函数</h1><p>线性杆单元的位移函数是坐标x的一次函数，可用以下代码求解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Clear[u1, u2];</span><br><span class="line">u = a1 + a2 x;</span><br><span class="line">solut = Solve[&#123;u1 == (u /. x -&gt; <span class="number">0</span>), u2 == (u /. x -&gt; <span class="number">1</span>)&#125;, &#123;a1, a2&#125;];</span><br><span class="line">u = u /. solut[[<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>
<p>其中u1和u2是杆端点x=0和x=1处的位移，结果为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u1 + (-u1 + u2) x</span><br></pre></td></tr></table></figure>
<p>形函数则可以通过取系数函数Coefficient获得：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NShape = &#123;Coefficient[u, u1], Coefficient[u, u2]&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">1</span> - x, x&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二次杆单元的形函数"><a href="#二次杆单元的形函数" class="headerlink" title="二次杆单元的形函数"></a>二次杆单元的形函数</h1><p>二次杆单元的位移函数是坐标x的二次函数，求解代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Clear[u1, u2, u3, a1, a2, a3];</span><br><span class="line">u = a1 + a2 x + a3 x^<span class="number">2</span>;</span><br><span class="line">solut = Solve[&#123;u1 == (u /. x -&gt; <span class="number">0</span>), u2 == (u /. x -&gt; <span class="number">1</span>/<span class="number">2</span>), </span><br><span class="line">        u3 == &#123;u /. x -&gt; <span class="number">1</span>&#125;&#125;, &#123;a1, a2, a3&#125;];</span><br><span class="line">u = u /. solut[[<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u1 + (<span class="number">-3</span> u1 + <span class="number">4</span> u2 - u3) x + <span class="number">2</span> (u1 - <span class="number">2</span> u2 + u3) x^<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>其中u1、u2和u3分别是杆端点x=0、杆中点x=0.5、杆端点x=1处的位移。<br>那么形函数就是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NShape = Coefficient[u, &#123;u1, u2, u3&#125;]</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">1</span> - <span class="number">3</span> x + <span class="number">2</span> x^<span class="number">2</span>, <span class="number">4</span> x - <span class="number">4</span> x^<span class="number">2</span>, -x + <span class="number">2</span> x^<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
<h1 id="单元刚度矩阵"><a href="#单元刚度矩阵" class="headerlink" title="单元刚度矩阵"></a>单元刚度矩阵</h1><p>一次杆单元的刚度矩阵可以类比弹簧元的刚度矩阵。<br>设弹簧的刚度系数为k，节点i，j的位移分别为$u_i$和$u_j$，受到的力分别为$F_i$，$F_j$。易知：<br>$$<br>\begin{equation}<br>\begin{split}<br>F_i &amp;= ku_i-ku_j \<br>F_j &amp;= ku_j-ku_i<br>\end{split}<br>\end{equation}<br>$$<br>写成矩阵形式为：<br>$$<br>\begin{bmatrix}<br>k &amp; -k \<br>-k &amp; k<br>\end{bmatrix}<br>\begin{bmatrix}<br>u_i \<br>u_j<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>F_i \<br>F_j<br>\end{bmatrix}<br>$$<br>所以单元刚度矩阵为：<br>$$<br>k_{ij}=<br>\begin{bmatrix}<br>k &amp; -k \<br>-k &amp; k<br>\end{bmatrix}<br>$$<br>同理，一次杆单元的刚度矩阵为：<br>$$<br>k_{ij}=\frac{EA}{L}<br>\begin{bmatrix}<br>1 &amp; -1 \<br>-1 &amp; 1<br>\end{bmatrix}<br>$$<br>二次杆单元的刚度矩阵可通过能量法求解。应用能量法的示意图：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjj7einyuj30a405wt8q.jpg"><br>应变能为：<br>$$<br>U=\int_\Omega \frac{1}{2}\sigma\epsilon dV=\int_0^L\frac{1}{2}EA\epsilon^2dx<br>=\int_0^L\frac{1}{2}EAa^T\frac{dN^T}{dx}\frac{dN}{dx}adx=\frac{1}{2}a^TKa<br>$$<br>其中：<br>$$<br>\sigma=E\epsilon; \epsilon=\frac{du}{dx}=\frac{dN}{dx}a, a=[u_1,u_2,u_3]^T<br>$$<br>所以单元刚度矩阵为：<br>$$<br>K=EA\int_{0}^L[\frac{dN}{dx}]^T[\frac{dN}{dx}]dx<br>$$<br>代入上面的形函数，那么求解代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dNx = L D[NShape, x];</span><br><span class="line">K = EA Integrate[Transpose[&#123;dNx&#125;].&#123;dNx&#125;, &#123;x, <span class="number">0</span>, <span class="number">1</span>&#125;]/L;</span><br><span class="line">K <span class="comment">// MatrixForm</span></span><br></pre></td></tr></table></figure>
<p>注意：代码中的L这个系数是因为使用了之前位于0到1上的形函数，如果直接采用0到L，则形函数的具体形式会发生改变。<br>输出结果为：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjj7okixoj308y034t8m.jpg"></p>
<h1 id="模块分析"><a href="#模块分析" class="headerlink" title="模块分析"></a>模块分析</h1><h2 id="模块1-建立单元刚度矩阵"><a href="#模块1-建立单元刚度矩阵" class="headerlink" title="模块1:建立单元刚度矩阵"></a>模块1:建立单元刚度矩阵</h2><p>以下分别建立了弹簧元、线性杆单元、二次杆单元的单元刚度矩阵：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GenerateSpringKm[k_] := </span><br><span class="line"> Module[&#123;y&#125;, y = k*&#123;&#123;<span class="number">1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;&#125;; y]</span><br><span class="line">GenerateLinearRodKm[k_] := </span><br><span class="line"> Module[&#123;y&#125;, y = EE*AA/L*&#123;&#123;<span class="number">1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;&#125;; y]</span><br><span class="line">GenerateQuadraticRodKm[k_] := </span><br><span class="line"> Module[&#123;y&#125;, y = EE*AA/L*&#123;&#123;<span class="number">7</span>, <span class="number">1</span>, <span class="number">-8</span>&#125;, &#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">-8</span>&#125;, &#123;<span class="number">-8</span>, <span class="number">-8</span>, <span class="number">16</span>&#125;&#125;; y]</span><br></pre></td></tr></table></figure>
<h2 id="模块2-组装整体刚度矩阵"><a href="#模块2-组装整体刚度矩阵" class="headerlink" title="模块2:组装整体刚度矩阵"></a>模块2:组装整体刚度矩阵</h2><p>以弹簧元为例，单独的一个弹簧元有两个节点，其单元刚度矩阵是2行2列的矩阵。对于含有n个节点的弹簧元系统，则是n行n列的整体刚度矩阵。组装过程为：假设某个弹簧元的节点的整体编号为i和j，其单刚中的四个元素要分别找到其对应的整体编号位置，然后叠加上去，即11对应ii，12对应ij，21对应ji，22对应jj。代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GlobalK = <span class="number">0</span> IdentityMatrix[<span class="number">3</span>];</span><br><span class="line">AssembleSpringKm[p1_, p2_, m_] := Module[&#123;j, k&#125;, f = &#123;p1, p2&#125;;</span><br><span class="line">  For[j = <span class="number">1</span>, j &lt;= <span class="number">2</span>, j++,</span><br><span class="line">     For[k = <span class="number">1</span>, k &lt;= <span class="number">2</span>, k++,</span><br><span class="line">         GlobalK[[f[[j]], f[[k]]]] += m[[j, k]];</span><br><span class="line">    ]];</span><br><span class="line">      GlobalK]</span><br></pre></td></tr></table></figure>
<p>代码中p1和p2是节点的整体编号(输入时要注意节点号的顺序)，m是该单元的单刚，GlobalK是整刚。<br>二次杆单元的整体刚度矩阵则为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AssembleQuadraticRod[p1_, p2_, p3_, m_] := </span><br><span class="line"> Module[&#123;i, j, k&#125;, f = &#123;p1, p2&#125;;</span><br><span class="line">  For[i = <span class="number">1</span>, i &lt;= <span class="number">3</span>, i++,</span><br><span class="line">     For[j = <span class="number">1</span>, j &lt;= <span class="number">3</span>, j++,</span><br><span class="line">         For[k = <span class="number">1</span>, k &lt;= <span class="number">3</span>, k++,</span><br><span class="line">              GlobalK[[f[[j]], f[[k]]]] += m[[j, k]];</span><br><span class="line">     ]]];</span><br><span class="line">       GlobalK]</span><br></pre></td></tr></table></figure>
<p>建立好整体刚度矩阵后，代入边界条件，即可求出位移量，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">U = &#123;u1x, u2x, u3x&#125;;</span><br><span class="line">u1x = u3x = <span class="number">0</span>;</span><br><span class="line">F2x = <span class="number">17.5</span>;</span><br><span class="line">Load = &#123;F1x, F2x, F3x&#125;;</span><br><span class="line">tmp = Sort[Join[U, Load]];</span><br><span class="line">unknown = Drop[tmp, <span class="number">3</span>];</span><br><span class="line">solut = Solve[GlobalK.U == Load, unknown]</span><br></pre></td></tr></table></figure>
<p>这里使用的边界条件是编号1和3上的位移为0,2上的力为17.5，然后利用Solve求解。</p>
<h2 id="模块3-得到单元应力"><a href="#模块3-得到单元应力" class="headerlink" title="模块3:得到单元应力"></a>模块3:得到单元应力</h2><p>已知单元的位移向量u(在整体坐标系下的值)，求单元上的力：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SpringElementForce[k_, u_, i_] := Module[&#123;force&#125;,</span><br><span class="line">      force = k.u;</span><br><span class="line">  Print[<span class="string">&quot;The spring force of the ele&quot;</span>, i, <span class="string">&quot; is &quot;</span>, force, <span class="string">&quot;kN&quot;</span>];</span><br><span class="line">    ];</span><br><span class="line">RodElementForce[k_, u_, AA_, i_] := Module[&#123;force&#125;,</span><br><span class="line">      force = k.u;</span><br><span class="line">  sigma = force/AA;</span><br><span class="line">    Print[<span class="string">&quot;The force of the ele&quot;</span>, i, <span class="string">&quot; is &quot;</span>, force, <span class="string">&quot;kN, &quot;</span>, </span><br><span class="line">       <span class="string">&quot;the stress is &quot;</span>, sigma, <span class="string">&quot; Pa.&quot;</span>];</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>
<p>i是单元编号，u是位移向量，k是单刚。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2016/08/04/dealii-learn-step2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Be interesting!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亓欣波">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/08/04/dealii-learn-step2/" class="post-title-link" itemprop="url">求解偏微分方程开源有限元软件deal.II学习--Step 2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-08-04 00:00:00" itemprop="dateCreated datePublished" datetime="2016-08-04T00:00:00+08:00">2016-08-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 15:20:30" itemprop="dateModified" datetime="2021-03-25T15:20:30+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computational-material-science/" itemprop="url" rel="index"><span itemprop="name">computational material science</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2016/08/04/dealii-learn-step2/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/08/04/dealii-learn-step2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>在step1中创建了网格，下面就是在网格上定义自由度。此例中使用一阶线性有限元，其自由度的个数与网格的顶点数相关。后面的例子将展示更高次的单元，其上面的自由度与顶点、边、面及cell都有关。<br>自由度可以理解为形函数中的系数个数，因为它们是未知的，所以称之为未知量或自由度。<br>定义网格上的自由度很简单，因为deal.II已经内置该功能了，唯一要做的是创建有限元空间。</p>
<h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_handler.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>该头文件将自由度与顶点、线、cell联系起来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/fe/fe_q.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>该头文件包含双线性有限元的描述，即只在顶点上有自由度，在边上和cell内部无自由度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_tools.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>该头文件包含对自由度的操作工具。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/sparse_matrix.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/lac/dynamic_sparsity_pattern.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/dofs/dof_renumbering.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h1 id="产生网格"><a href="#产生网格" class="headerlink" title="产生网格"></a>产生网格</h1><p>这里用了step-1中的方法，只不过这里将网格triangulation作为参数返回，同时将manifold object声明为static，防止其过早销毁：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_grid</span> <span class="params">(Triangulation&lt;<span class="number">2</span>&gt; &amp;triangulation)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Point&lt;2&gt; <span class="title">center</span> <span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> inner_radius = <span class="number">0.5</span>,</span><br><span class="line">          outer_radius = <span class="number">1.0</span>;</span><br><span class="line">    GridGenerator::<span class="built_in">hyper_shell</span> (triangulation,</span><br><span class="line">            center, inner_radius, outer_radius,</span><br><span class="line">            <span class="number">5</span> );</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> SphericalManifold&lt;2&gt; <span class="title">manifold_description</span><span class="params">(center)</span></span>;</span><br><span class="line">    triangulation.<span class="built_in">set_all_manifold_ids</span>(<span class="number">0</span>);</span><br><span class="line">    triangulation.<span class="built_in">set_manifold</span> (<span class="number">0</span>, manifold_description);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> step=<span class="number">0</span>; step&lt;<span class="number">3</span>; ++step)</span><br><span class="line">    &#123;</span><br><span class="line">        Triangulation&lt;<span class="number">2</span>&gt;::active_cell_iterator</span><br><span class="line">            cell = triangulation.<span class="built_in">begin_active</span>(),</span><br><span class="line">                 endc = triangulation.<span class="built_in">end</span>();</span><br><span class="line">        <span class="keyword">for</span> (; cell!=endc; ++cell)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> v=<span class="number">0</span>;</span><br><span class="line">                    v &lt; GeometryInfo&lt;<span class="number">2</span>&gt;::vertices_per_cell;</span><br><span class="line">                    ++v)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">double</span> distance_from_center</span><br><span class="line">                    = center.<span class="built_in">distance</span> (cell-&gt;<span class="built_in">vertex</span>(v));</span><br><span class="line">                <span class="keyword">if</span> (std::<span class="built_in">fabs</span>(distance_from_center - inner_radius) &lt; <span class="number">1e-10</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    cell-&gt;<span class="built_in">set_refine_flag</span> ();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        triangulation.<span class="built_in">execute_coarsening_and_refinement</span> ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="创建DoFHandler"><a href="#创建DoFHandler" class="headerlink" title="创建DoFHandler"></a>创建DoFHandler</h1><p>目前为止，只创建了一个网格，包含几何信息(顶点的位置)和拓扑信息(顶点怎样连成线，线连成cell，cell之间怎样连接)。为了执行数值运算，还需要一些逻辑信息，比如将自由度赋给顶点，创建矩阵和矢量，用来描述网格上的场量。<br>首先描述自由度是如何分布的。这里使用类模板FE_Q来创建拉格朗日单元，它的成员函数需要一个参数来描述单元的多项式次数，此处是1,表明是双线性单元，也就意味着自由度只在顶点上。如果参数是3,那么意味着是双三次单元，自由度分布为：每个顶点上一个，每条边上两个，每个cell内有四个。<br>示意图为：<br>对于Q1单元：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjknj5y7uj30ej0ha0t7.jpg"><br>对于Q2单元：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjknsl84nj30f90jujs4.jpg"><br>对于Q3单元：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjko5pvifj30890833yi.jpg"><br>每种单元上形函数的模样可以参见<a target="_blank" rel="noopener" href="https://dealii.org/8.4.1/doxygen/deal.II/classFE__Q.html">这里</a>。<br>通过创建一个有限元对象，然后用DoFHandler分配自由度：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> FE_Q&lt;2&gt; <span class="title">finite_element</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">dof_handler.<span class="built_in">distribute_dofs</span> (finite_element);</span><br></pre></td></tr></table></figure>
<p>将自由度分配到每个顶点上去后，不是很容易直接可视化来看到它们，但这也不重要，因为一般情况下自由度的标号是随机的。<br>与网格每个顶点对应的还有形函数。注意：形函数仅在它们对应的顶点上为1，在其他顶点上则为0。那么也只相邻顶点形成的矩阵不为0，由于顶点的标号是随机的，那么总矩阵应该是稀碎的。<br>首先创建一个结构来存储非0元素的位置。这个类是SpasityPattern，但它有一些缺点，因为它需要事先估计每排最多有多少个，这会造成不必要的内存浪费。因此这里换用DynamicSparsityPattern这个类，传入的参数是矩阵的大小：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DynamicSparsityPattern <span class="title">dynamic_sparsity_pattern</span><span class="params">(dof_handler.n_dofs(),</span></span></span><br><span class="line"><span class="function"><span class="params">        dof_handler.n_dofs())</span></span>;</span><br></pre></td></tr></table></figure>
<p>然后根据自由度分布给出非零元素的位置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DoFTools::<span class="built_in">make_sparsity_pattern</span> (dof_handler, dynamic_sparsity_pattern);</span><br></pre></td></tr></table></figure>
<p>然后将DynamicSparsityPattern的信息传回SpasityPattern：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SparsityPattern sparsity_pattern;</span><br><span class="line">sparsity_pattern.copy_from (dynamic_sparsity_pattern);</span><br></pre></td></tr></table></figure>
<p>然后存储到文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::ofstream <span class="title">out</span> <span class="params">(<span class="string">&quot;sparsity_pattern1.svg&quot;</span>)</span></span>;</span><br><span class="line">sparsity_pattern.<span class="built_in">print_svg</span> (out);</span><br></pre></td></tr></table></figure>
<p>结果为：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjkqcgh74j30480483yd.jpg"><br>其中每个小红方块都是矩阵中的一个非0元素。</p>
<h1 id="对自由度重新编号"><a href="#对自由度重新编号" class="headerlink" title="对自由度重新编号"></a>对自由度重新编号</h1><p>上面的结果可以看出，非0元素离对角线很远。对于有些算法，如不完全LU分解和Gauss-Seidel预条件子，这样的分布不好，因此需要改进。<br>注意：对于矩阵中非0的元素(i，j)，对应的形函数i和j必须相交，而此时其所在的顶点需要相邻，因此，同一个cell内顶点的编号不能差太多才行。这可以通过一种简单的步进方法实现：首先给定一个顶点标识为0,然后对它的邻居连续标号。这里使用的是Cuthill_Mckee提出的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DoFRenumbering::<span class="built_in">Cuthill_McKee</span> (dof_handler);</span><br><span class="line"><span class="function">DynamicSparsityPattern <span class="title">dynamic_sparsity_pattern</span><span class="params">(dof_handler.n_dofs(),</span></span></span><br><span class="line"><span class="function"><span class="params">        dof_handler.n_dofs())</span></span>;</span><br><span class="line">DoFTools::<span class="built_in">make_sparsity_pattern</span> (dof_handler, dynamic_sparsity_pattern);</span><br><span class="line">SparsityPattern sparsity_pattern;</span><br><span class="line">sparsity_pattern.<span class="built_in">copy_from</span> (dynamic_sparsity_pattern);</span><br></pre></td></tr></table></figure>
<p>结果为：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjkqt98kkj3048048gli.jpg"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2016/08/02/dealii-learn-step1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Be interesting!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亓欣波">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/08/02/dealii-learn-step1/" class="post-title-link" itemprop="url">求解偏微分方程开源有限元软件deal.II学习--Step 1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-08-02 00:00:00" itemprop="dateCreated datePublished" datetime="2016-08-02T00:00:00+08:00">2016-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 15:20:30" itemprop="dateModified" datetime="2021-03-25T15:20:30+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computational-material-science/" itemprop="url" rel="index"><span itemprop="name">computational material science</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2016/08/02/dealii-learn-step1/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/08/02/dealii-learn-step1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="dealii.org">deal.II</a>是一款开源的求解偏微分方程的有限元软件，它有如下几个<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Deal.II">特点</a>：</p>
<ul>
<li>使用C++编写</li>
<li>有多种单元类型</li>
<li>可以大规模并行</li>
<li>可以自适应网格</li>
<li>文档和范例齐全</li>
<li>与其他库有良好的接口</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>deal.II最新版本为8.4.1,可从官网上下载源码，解压后进入源文件目录安装：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -DCMAKE_INSTALL_PREFIX=/path/to/install/dir ../deal.II</span><br><span class="line">make install</span><br><span class="line">make test</span><br></pre></td></tr></table></figure>
<p>如果期间需要其他依赖如cmake、doxygen等，自行安装好即可。</p>
<h1 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h1><p>deal.II的文档和example特别完备，刚开始接触可以它多达54个例子进行。<br>具体入口在<a target="_blank" rel="noopener" href="https://dealii.org/8.4.1/doxygen/deal.II/Tutorial.html">这里</a>。<br>编译运行命令为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake .</span><br><span class="line">make</span><br><span class="line">make run</span><br></pre></td></tr></table></figure>
<p>第一条命令用来创建Makefile文件，指明程序所依赖的文件、怎样编译和运行。此命令应该能找到之前安装deal.II后的库文件，如果不能找到，需要人为指定路径：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -DDEAL_II_DIR=/path/to/installed/deal.II .</span><br></pre></td></tr></table></figure>
<p>第二条命令将源文件编译成可执行文件，第三条是运行该可执行文件。其实可以省略第二条命令。后面的example遵循同样的命令。</p>
<h1 id="第一个教学实例——step-1"><a href="#第一个教学实例——step-1" class="headerlink" title="第一个教学实例——step-1"></a>第一个教学实例——step-1</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>此头文件声明了Triangulation类模板，其用途是生成各种单元。如Triangulation&lt;1,1&gt;表示一维线段，Triangulation&lt;1,2&gt;或&lt;2,3&gt;表示二维中的曲线和三维中的面，通常用于边界单元中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria_accessor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/tria_iterator.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>这两个头文件一个是存取器，一个是迭代器，用于对单元的循环遍历。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/grid_generator.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>该头文件声明了GridGenerator命名空间，用于生成标准网格</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/manifold_lib.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>本例中用到了非直线的边以及双线性四边形，所以还要导入一些类来预先描述流形，比如描述球、圆柱等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deal.II/grid/grid_out.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>该头文件声明了GridOut类，用于生成多种格式的数据，如dx、gnuplot、msh、eps、svg、vtk等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>以上是c++的一些标准库，用于字符和文件的输入输出，以及作开方、取绝对值等数学库。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> dealii;</span><br></pre></td></tr></table></figure>
<p>为了防止命名冲突，该包的函数和类都包含在dealii这个命名空间中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">first_grid</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Triangulation&lt;<span class="number">2</span>&gt; triangulation;</span><br><span class="line">  GridGenerator::<span class="built_in">hyper_cube</span> (triangulation);</span><br><span class="line">  triangulation.<span class="built_in">refine_global</span> (<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>首先创建一个Triangulation类的对象，这里只有一个参数是2，表明该对象是作用在二维上。然后用超立方体形状的一个单元来填充给定的triangulation。这里因为是二维，就是一个正方形。正方形的大小是默认的从0到1的边长，可以在参数中人为设定。还有一个参数colorize是设定边界标识，这里默认都是0。<br>此时整个网格只有一个单元，然后将网格加密4次。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::ofstream <span class="title">out</span> <span class="params">(<span class="string">&quot;grid-1.eps&quot;</span>)</span></span>;</span><br><span class="line">GridOut grid_out;</span><br><span class="line">grid_out.<span class="built_in">write_eps</span> (triangulation, out);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Grid written to grid-1.eps&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后输出，这里使用的是eps格式。</p>
<p>第一个函数first_grid生成一个由一个单元网格加密四次后生成的4的4次方=256个正方形单元的网格。<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjkunipr2j30i60i4myi.jpg"></p>
<p>然后是第二个函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GridGenerator::<span class="built_in">hyper_shell</span> (triangulation,center,inner_radius,outer_radius,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>生成一个三维的壳体或二维的环。注意：这里的边界是弯曲的，而默认情形下边界都是直线。这时需要指定“manifold indicator”来指明边界，告诉在哪个地方细化。<br>如果不指明manifold indicator，那么就只会得到在周向为10个cell，然后加密3次：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Triangulation&lt;<span class="number">2</span>&gt; triangulation;</span><br><span class="line"><span class="function"><span class="keyword">const</span> Point&lt;2&gt; <span class="title">center</span> <span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inner_radius = <span class="number">0.5</span>,</span><br><span class="line">outer_radius = <span class="number">1.0</span>;</span><br><span class="line">GridGenerator::<span class="built_in">hyper_shell</span> (triangulation,</span><br><span class="line">center, inner_radius, outer_radius,</span><br><span class="line"><span class="number">10</span>);</span><br><span class="line">triangulation.<span class="built_in">refine_global</span> (<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>结果如图：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjkv8lgfkj308d07yq39.jpg"><br>对边界进行特定标识后，效果会好一些：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Triangulation&lt;<span class="number">2</span>&gt; triangulation;</span><br><span class="line"><span class="function"><span class="keyword">const</span> Point&lt;2&gt; <span class="title">center</span> <span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inner_radius = <span class="number">0.5</span>,</span><br><span class="line">outer_radius = <span class="number">1.0</span>;</span><br><span class="line">GridGenerator::<span class="built_in">hyper_shell</span> (triangulation,</span><br><span class="line">center, inner_radius, outer_radius,</span><br><span class="line"><span class="number">10</span>);</span><br><span class="line"><span class="function"><span class="keyword">const</span> HyperShellBoundary&lt;2&gt; <span class="title">boundary_description</span><span class="params">(center)</span></span>;</span><br><span class="line">triangulation.<span class="built_in">set_boundary</span> (<span class="number">0</span>, boundary_description);</span><br><span class="line">triangulation.<span class="built_in">refine_global</span> (<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>结果如图：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjkvs65zlj308d08d74o.jpg"><br>可以看出此时能较好地表现出内外边界的圆形特征，但仍然能从切线上的弯折分辨出最初的10个cell。这可以通过不光对边界上的线，而是对所有的线都指定indicator来优化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Triangulation&lt;<span class="number">2</span>&gt; triangulation;</span><br><span class="line"><span class="function"><span class="keyword">const</span> Point&lt;2&gt; <span class="title">center</span> <span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inner_radius = <span class="number">0.5</span>,</span><br><span class="line">outer_radius = <span class="number">1.0</span>;</span><br><span class="line">GridGenerator::<span class="built_in">hyper_shell</span> (triangulation,</span><br><span class="line">center, inner_radius, outer_radius,</span><br><span class="line"><span class="number">10</span>);</span><br><span class="line"><span class="function"><span class="keyword">const</span> SphericalManifold&lt;2&gt; <span class="title">boundary_description</span><span class="params">(center)</span></span>;</span><br><span class="line">triangulation.<span class="built_in">set_manifold</span> (<span class="number">0</span>, boundary_description);</span><br><span class="line">Triangulation&lt;<span class="number">2</span>&gt;::active_cell_iterator</span><br><span class="line">cell = triangulation.<span class="built_in">begin_active</span>(),</span><br><span class="line">endc = triangulation.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">for</span> (; cell!=endc; ++cell)</span><br><span class="line">cell-&gt;<span class="built_in">set_all_manifold_ids</span> (<span class="number">0</span>);</span><br><span class="line">triangulation.<span class="built_in">refine_global</span> (<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>效果如图：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjkw5vj6zj308d08ddg7.jpg"></p>
<p>之前设定的hyper_shell初始周向网格为10个cell，如果设置为3,且只对边界上的cell设定indicator：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Triangulation&lt;<span class="number">2</span>&gt; triangulation;</span><br><span class="line"><span class="function"><span class="keyword">const</span> Point&lt;2&gt; <span class="title">center</span> <span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inner_radius = <span class="number">0.5</span>,</span><br><span class="line">outer_radius = <span class="number">1.0</span>;</span><br><span class="line">GridGenerator::<span class="built_in">hyper_shell</span> (triangulation,</span><br><span class="line">center, inner_radius, outer_radius,</span><br><span class="line"><span class="number">3</span>); <span class="comment">// four circumferential cells</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> HyperShellBoundary&lt;2&gt; <span class="title">boundary_description</span><span class="params">(center)</span></span>;</span><br><span class="line">triangulation.<span class="built_in">set_boundary</span> (<span class="number">0</span>, boundary_description);</span><br><span class="line">triangulation.<span class="built_in">refine_global</span> (<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>结果为：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjkz3xiwyj308d08d0sx.jpg"><br>可以看出细化效果很差，但即使初始为3,也可以通过对全部的cell设定indicator来优化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Triangulation&lt;<span class="number">2</span>&gt; triangulation;</span><br><span class="line"><span class="function"><span class="keyword">const</span> Point&lt;2&gt; <span class="title">center</span> <span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> inner_radius = <span class="number">0.5</span>,</span><br><span class="line">outer_radius = <span class="number">1.0</span>;</span><br><span class="line">GridGenerator::<span class="built_in">hyper_shell</span> (triangulation,</span><br><span class="line">center, inner_radius, outer_radius,</span><br><span class="line"><span class="number">3</span>); <span class="comment">// three circumferential cells</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> SphericalManifold&lt;2&gt; <span class="title">boundary_description</span><span class="params">(center)</span></span>;</span><br><span class="line">triangulation.<span class="built_in">set_manifold</span> (<span class="number">0</span>, boundary_description);</span><br><span class="line">Triangulation&lt;<span class="number">2</span>&gt;::active_cell_iterator</span><br><span class="line">cell = triangulation.<span class="built_in">begin_active</span>(),</span><br><span class="line">endc = triangulation.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">for</span> (; cell!=endc; ++cell)</span><br><span class="line">cell-&gt;<span class="built_in">set_all_manifold_ids</span> (<span class="number">0</span>);</span><br><span class="line">triangulation.<span class="built_in">refine_global</span> (<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>结果为：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjkzr11lfj308d08d74f.jpg"></p>
<p>以上分析过程见<a target="_blank" rel="noopener" href="https://dealii.org/8.4.1/doxygen/deal.II/group__manifold.html">这里</a>。</p>
<p>在step-1的second_grid函数中，将上述细化更进一步，不再是全局细化，而是局部细化，因此首先是要得到能指向每个cell的指针，可以想象一个triangulation是所有cell的集合，而cell在其中并不是一个序列，因此这里不能直接用指针，而是用迭代器iterator，从第一个cell开始，遍历所有cell。不过这里没有使用遍历所有cell的迭代器，而是使用只遍历active cell的迭代器active_cell_iterator，active cell是没有children的cell，其后来将被细化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Triangulation&lt;<span class="number">2</span>&gt;::active_cell_iterator</span><br><span class="line">cell = triangulation.<span class="built_in">begin_active</span>(),</span><br><span class="line">endc = triangulation.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">for</span> (; cell!=endc; ++cell)</span><br></pre></td></tr></table></figure>
<p>然后在这个for循环中再遍历每个cell的所有顶点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> v=<span class="number">0</span>;</span><br><span class="line">v &lt; GeometryInfo&lt;<span class="number">2</span>&gt;::vertices_per_cell;</span><br><span class="line">++v)</span><br></pre></td></tr></table></figure>
<p>然后从这些顶点中通过判断该顶点与圆心的距离找到属于内边界的顶点，从而标记该顶点所在的cell，用于后续的细化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> distance_from_center</span><br><span class="line">= center.<span class="built_in">distance</span> (cell-&gt;<span class="built_in">vertex</span>(v));</span><br><span class="line"><span class="keyword">if</span> (std::<span class="built_in">fabs</span>(distance_from_center - inner_radius) &lt; <span class="number">1e-10</span>)</span><br><span class="line">&#123;</span><br><span class="line">cell-&gt;<span class="built_in">set_refine_flag</span> ();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后开始执行细化操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">triangulation.<span class="built_in">execute_coarsening_and_refinement</span> ();</span><br></pre></td></tr></table></figure>
<p>结果为：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjl0si8vzj308b08c0t0.jpg"></p>
<p>注意：当函数结束，开始销毁所创建的对象时，按相反顺序进行，因为定义的manifold object是在triangulation之后，所以manifold object先销毁，此时将会报错，因此必须先释放它：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">triangulation.<span class="built_in">set_manifold</span> (<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>另一种简单的方法是在triangulation之前定义manifold object。</p>
<p>second_grid给了我们提示，可以设定不同的细化条件，比如设定当cell的中心的y坐标大于0时才加密：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; cell!=endc; ++cell)</span><br><span class="line"><span class="keyword">if</span> (cell-&gt;<span class="built_in">center</span>()[<span class="number">1</span>] &gt; <span class="number">0</span>)</span><br><span class="line">cell-&gt;<span class="built_in">set_refine_flag</span> ();</span><br></pre></td></tr></table></figure>
<p>结果为：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjl1612r5j30lv0l9td6.jpg"></p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>deal.II的作者建议尽早学会使用一个debugger！</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="产生的信息"><a href="#产生的信息" class="headerlink" title="产生的信息"></a>产生的信息</h2><p>此例最简化的版本是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">first_grid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Triangulation&lt;<span class="number">2</span>&gt; triangulation;</span><br><span class="line">  GridGenerator::<span class="built_in">hyper_cube</span>(triangulation);</span><br><span class="line">  triangulation.<span class="built_in">refine_global</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function">std::ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;grid-1.vtk&quot;</span>)</span></span>;</span><br><span class="line">  GridOut grid_out;</span><br><span class="line">  grid_out.<span class="built_in">write_vtk</span>(triangulation,out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>产生的vtk文件是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># vtk DataFile Version 3.0</span></span><br><span class="line">#This file was generated by the deal.II library on <span class="number">2016</span>/<span class="number">11</span>/<span class="number">7</span> at <span class="number">15</span>:<span class="number">38</span>:<span class="number">30</span></span><br><span class="line">ASCII</span><br><span class="line">DATASET UNSTRUCTURED_GRID</span><br><span class="line"></span><br><span class="line">POINTS <span class="number">4</span> <span class="keyword">double</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">CELLS <span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span>	<span class="number">0</span>	<span class="number">1</span>	<span class="number">3</span>	<span class="number">2</span></span><br><span class="line"></span><br><span class="line">CELL_TYPES <span class="number">1</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"></span><br><span class="line">POINT_DATA <span class="number">4</span></span><br><span class="line">SCALARS level <span class="keyword">double</span> <span class="number">1</span></span><br><span class="line">LOOKUP_TABLE <span class="keyword">default</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">SCALARS manifold <span class="keyword">double</span> <span class="number">1</span></span><br><span class="line">LOOKUP_TABLE <span class="keyword">default</span></span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> </span><br><span class="line">SCALARS material <span class="keyword">double</span> <span class="number">1</span></span><br><span class="line">LOOKUP_TABLE <span class="keyword">default</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">SCALARS subdomain <span class="keyword">double</span> <span class="number">1</span></span><br><span class="line">LOOKUP_TABLE <span class="keyword">default</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">SCALARS level_subdomain <span class="keyword">double</span> <span class="number">1</span></span><br><span class="line">LOOKUP_TABLE <span class="keyword">default</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br></pre></td></tr></table></figure>
<p>说明生成的数据的特点是：<br>(1)拓扑结构：只有四个点，且其构成四边形<br>(2)属性：该网格上有五个属性值，包括level、manifold、material、subdomain和level_subdomain。<br>具体的样子可以通过ParaView查看。</p>
<p>注意，如果将全局优化次数改为1，那么节点个数就变成16个，点的编号也相应变化，虽然点变成了16个，但实际只有9个，因为有些是同一个坐标点有多个编号，相应的上面的每个属性值的个数也变成了16个，单元个数还是实际个数，不存在重合现象，即此时是4个。改为全局细化两次后，节点有64个，单元有16个。</p>
<h2 id="cell和vertex分布"><a href="#cell和vertex分布" class="headerlink" title="cell和vertex分布"></a>cell和vertex分布</h2><p>deal.II对cell的个数计数有两种：一种是active_cells，它们就是网格中呈现的单元，表示不能再继续细化的单元;另一种是cells，它们不仅包含active_cells，还包含之前细化过的单元。<br>对单元作循环，统计个数，可以看出两者的区别：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Triangulation&lt;<span class="number">2</span>&gt;::cell_iterator</span><br><span class="line">  cell = triangulation.<span class="built_in">begin</span>(),</span><br><span class="line">  endc = triangulation.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">Triangulation&lt;<span class="number">2</span>&gt;::active_cell_iterator</span><br><span class="line">  active_cell = triangulation.<span class="built_in">begin_active</span>(),</span><br><span class="line">  active_endc = triangulation.<span class="built_in">end</span>();</span><br></pre></td></tr></table></figure>
<p>以全局细化两次为例，active_cells共有16个，而cells共有21个。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;cell!=endc;cell++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> v=<span class="number">0</span>; v &lt; GeometryInfo&lt;<span class="number">2</span>&gt;::vertices_per_cell; v++)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;the point at &quot;</span> &lt;&lt; cell-&gt;<span class="built_in">vertex</span>(v)[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;and &quot;</span>          &lt;&lt; cell-&gt;<span class="built_in">vertex</span>(v)[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是将顶点的坐标输出，其结果跟vtk文件是相同的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://qixinbo.github.io/2016/06/12/mathematica-pickPointData/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Xin-Bo Qi(亓欣波)">
      <meta itemprop="description" content="Be interesting!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亓欣波">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016/06/12/mathematica-pickPointData/" class="post-title-link" itemprop="url">Mathematica版GetData——用Mathematica提取图片中的数据点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-06-12 00:00:00" itemprop="dateCreated datePublished" datetime="2016-06-12T00:00:00+08:00">2016-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-25 15:20:30" itemprop="dateModified" datetime="2021-03-25T15:20:30+08:00">2021-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">programming</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2016/06/12/mathematica-pickPointData/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/06/12/mathematica-pickPointData/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>阅读文献时常常会遇到只给图像却没有原始数据的情形，此时如果想要提取数据，就得借助相应软件，目测用的最多的就是<a target="_blank" rel="noopener" href="http://www.getdata-graph-digitizer.com/">GetData</a>，这个是个商业软件，还有个好用的基于web的开源软件<a target="_blank" rel="noopener" href="http://arohatgi.info/WebPlotDigitizer/app/">WebPlotDigitizer</a>。这里我们基于Mathematica写一套能用于提取图片中数据点的代码。<br>参考文献(基本思路参考SE上的这个问题，但具体取点和去点方式不同)：<br><a target="_blank" rel="noopener" href="http://mathematica.stackexchange.com/questions/1524/recovering-data-points-from-an-image">Recovering data points from an image</a></p>
<p>Attention：这里的版本强烈依赖于Mathematica的版本，此处使用的是10.4版本，目测应该使用10以上版本，因为低版本中不会出现工具提示条。</p>
<h1 id="实际坐标系与图像坐标系的对应"><a href="#实际坐标系与图像坐标系的对应" class="headerlink" title="实际坐标系与图像坐标系的对应"></a>实际坐标系与图像坐标系的对应</h1><p>首先使用工具提示条中的“坐标工具”提取已知点的图像坐标，然后选择“复制坐标”并保存(注意保存的数据中的点的先后顺序)。<br>如图：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjj3b3vslj30ku0m1jt6.jpg"><br>利用这些图像中的坐标与实际坐标建立对应关系：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trans = FindGeometricTransform[&#123;&#123;<span class="number">0</span>, <span class="number">1.2</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1.1</span>&#125;, &#123;<span class="number">4</span>, <span class="number">0.82</span>&#125;, &#123;<span class="number">2</span>, <span class="number">0.82</span>&#125;&#125;,</span><br><span class="line">      &#123;&#123;<span class="number">20.630372492836678</span>`, <span class="number">146.88825214899714</span>`&#125;, &#123;<span class="number">20.630372492836678</span>`, <span class="number">111.8166189111748</span>`&#125;, </span><br><span class="line">       &#123;<span class="number">153.1805157593123</span>`, <span class="number">14.33810888252151</span>`&#125;, &#123;<span class="number">86.1318051575931</span>`, <span class="number">14.33810888252151</span>`&#125;&#125;,TransformationClass-&gt;<span class="string">&quot;Affine&quot;</span>][[<span class="number">2</span>]];</span><br></pre></td></tr></table></figure>
<p>注意是实际坐标在前，图像坐标在后。此次提取后注意找一个未知点验证一下，防止选择的变换方式出错。</p>
<h1 id="提取曲线颜色"><a href="#提取曲线颜色" class="headerlink" title="提取曲线颜色"></a>提取曲线颜色</h1><p>要正确识别出图像中要提取的曲线，必须先让程序知道该曲线的颜色，即RGB值。这里依然使用工具提示条的“坐标工具”，提取曲线上一点后，选择“复制颜色值”。这里仅提取了一个点的RGB值，很难覆盖整条曲线，所以再设置一个忍量，使得与此RGB值相近的点都可以被识别：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">objRGB = &#123;&#123;<span class="number">103</span>, <span class="number">125</span>, <span class="number">174</span>&#125;&#125;;</span><br><span class="line">tolRGB = <span class="number">40</span>;</span><br><span class="line">rangeRGB = Flatten[&#123;objRGB - tolRGB, objRGB + tolRGB&#125;, <span class="number">1</span>]/<span class="number">255.0</span>;</span><br><span class="line">img1 = ImageApply[</span><br><span class="line">  If[#[[<span class="number">1</span>]] &gt; rangeRGB[[<span class="number">1</span>, <span class="number">1</span>]] &amp;&amp; #[[<span class="number">1</span>]] &lt; </span><br><span class="line">      rangeRGB[[<span class="number">2</span>, <span class="number">1</span>]] &amp;&amp; #[[<span class="number">2</span>]] &gt; rangeRGB[[<span class="number">1</span>, <span class="number">2</span>]] &amp;&amp; #[[<span class="number">2</span>]] &lt; </span><br><span class="line">      rangeRGB[[<span class="number">2</span>, <span class="number">2</span>]] &amp;&amp; #[[<span class="number">3</span>]] &gt; rangeRGB[[<span class="number">1</span>, <span class="number">3</span>]] &amp;&amp; #[[<span class="number">3</span>]] &lt; </span><br><span class="line">      rangeRGB[[<span class="number">2</span>, <span class="number">3</span>]], &#123;<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>&#125;, &#123;<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>&#125;] &amp;, img]</span><br></pre></td></tr></table></figure>
<p>此忍量的值可视情形调节。以上策略就是当某点的RGB值在忍量之内时，就变为(0.0,0.0,0.0)，即黑色，否则则为白色(1.0,1.0,1.0)。<br>效果如图：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjj3sqt1rj30a0060t8h.jpg"></p>
<h1 id="选区和去噪点"><a href="#选区和去噪点" class="headerlink" title="选区和去噪点"></a>选区和去噪点</h1><p>从上图可以看出，识别出的曲线中含有一些噪点，如果不处理掉就会影响结果。此时需要对图片进行精修，使其干净无污染。具体方法是采用工具提示条的“掩模工具”(话说10版本的MMA工具提示条真是逆天的存在)，将要选择的区域勾勒出来，然后选择“逆掩模为一个图”，之所以是“逆掩模”，是因为要将这部分选出来而不是去除，也不选择“逆掩模为一个图像”，经测试选择“图”而不是“图像”，分辨率要更高。<br>逆掩模如图：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjj47z069j309w05y3yc.jpg"><br>将此逆掩模的图放入下面代码中的Masking参数中即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curve = ImageApply[&#123;<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>&#125; &amp;, img1, Masking -&gt; 此处是那个选区]</span><br></pre></td></tr></table></figure>
<p>结果为：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjj4m1nkcj30a0060mwx.jpg"><br>可以看出噪点已经被去除。</p>
<h1 id="提取数据点的位置"><a href="#提取数据点的位置" class="headerlink" title="提取数据点的位置"></a>提取数据点的位置</h1><p>这一步就是提取上面曲线中的黑点的位置，代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curvLoc = Reverse /@ Position[ImageData[curve, DataReversed -&gt; True], &#123;<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>&#125;];</span><br></pre></td></tr></table></figure>
<p>注意这里需要注意Position取得的位置是(1,1)在左上角，而图像坐标则是(1,1)在左下角，所以需要进行一系列变换，具体的变换规则如示意图：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjj4zmetsj30qo0zk3zn.jpg"></p>
<h1 id="作图并与解析解作对比"><a href="#作图并与解析解作对比" class="headerlink" title="作图并与解析解作对比"></a>作图并与解析解作对比</h1><p>实际要提取的曲线是有具体的表达式的，此处将提取出的数据与解析表达式对比：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Show[ListPlot[trans@curvLoc],Plot[x^((x<span class="number">-2</span>)^<span class="number">2</span> E^-x)+E^-x, &#123;x, <span class="number">0</span>, <span class="number">10</span>&#125;, PlotStyle-&gt;Red]]</span><br></pre></td></tr></table></figure>
<p>结果为：<br><img src="https://ws1.sinaimg.cn/large/0072Lfvtly1fvjj5k5eefj30a006caa3.jpg"><br>可以看出效果还不错。</p>
<p>目前还是以代码的形式操作，以后没准能有图形界面？<br>以上。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Xin-Bo Qi(亓欣波)"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Xin-Bo Qi(亓欣波)</p>
  <div class="site-description" itemprop="description">Be interesting!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">120</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/qixinbo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;qixinbo" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:qixinbo@gmail.com" title="E-Mail → mailto:qixinbo@gmail.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.tsinghua.edu.cn/" title="https:&#x2F;&#x2F;www.tsinghua.edu.cn" rel="noopener" target="_blank">THU</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.imr.cas.cn/" title="http:&#x2F;&#x2F;www.imr.cas.cn" rel="noopener" target="_blank">IMR</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.sdu.edu.cn/" title="http:&#x2F;&#x2F;www.sdu.edu.cn" rel="noopener" target="_blank">SDU</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://liam0205.me/" title="http:&#x2F;&#x2F;liam0205.me&#x2F;" rel="noopener" target="_blank">黄晨成</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xin-Bo Qi(亓欣波)</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://qixinbo.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
